var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a3, b) => (typeof require !== "undefined" ? require : a3)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/.pnpm/registry.npmmirror.com+mersenne-twister@1.1.0/node_modules/mersenne-twister/src/mersenne-twister.js
var require_mersenne_twister = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mersenne-twister@1.1.0/node_modules/mersenne-twister/src/mersenne-twister.js"(exports, module) {
    var MersenneTwister2 = function(seed) {
      if (seed == void 0) {
        seed = new Date().getTime();
      }
      this.N = 624;
      this.M = 397;
      this.MATRIX_A = 2567483615;
      this.UPPER_MASK = 2147483648;
      this.LOWER_MASK = 2147483647;
      this.mt = new Array(this.N);
      this.mti = this.N + 1;
      if (seed.constructor == Array) {
        this.init_by_array(seed, seed.length);
      } else {
        this.init_seed(seed);
      }
    };
    MersenneTwister2.prototype.init_seed = function(s) {
      this.mt[0] = s >>> 0;
      for (this.mti = 1; this.mti < this.N; this.mti++) {
        var s = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (((s & 4294901760) >>> 16) * 1812433253 << 16) + (s & 65535) * 1812433253 + this.mti;
        this.mt[this.mti] >>>= 0;
      }
    };
    MersenneTwister2.prototype.init_by_array = function(init_key, key_length) {
      var i, j, k;
      this.init_seed(19650218);
      i = 1;
      j = 0;
      k = this.N > key_length ? this.N : key_length;
      for (; k; k--) {
        var s = this.mt[i - 1] ^ this.mt[i - 1] >>> 30;
        this.mt[i] = (this.mt[i] ^ (((s & 4294901760) >>> 16) * 1664525 << 16) + (s & 65535) * 1664525) + init_key[j] + j;
        this.mt[i] >>>= 0;
        i++;
        j++;
        if (i >= this.N) {
          this.mt[0] = this.mt[this.N - 1];
          i = 1;
        }
        if (j >= key_length)
          j = 0;
      }
      for (k = this.N - 1; k; k--) {
        var s = this.mt[i - 1] ^ this.mt[i - 1] >>> 30;
        this.mt[i] = (this.mt[i] ^ (((s & 4294901760) >>> 16) * 1566083941 << 16) + (s & 65535) * 1566083941) - i;
        this.mt[i] >>>= 0;
        i++;
        if (i >= this.N) {
          this.mt[0] = this.mt[this.N - 1];
          i = 1;
        }
      }
      this.mt[0] = 2147483648;
    };
    MersenneTwister2.prototype.random_int = function() {
      var y;
      var mag01 = new Array(0, this.MATRIX_A);
      if (this.mti >= this.N) {
        var kk;
        if (this.mti == this.N + 1)
          this.init_seed(5489);
        for (kk = 0; kk < this.N - this.M; kk++) {
          y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ mag01[y & 1];
        }
        for (; kk < this.N - 1; kk++) {
          y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ mag01[y & 1];
        }
        y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
        this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ mag01[y & 1];
        this.mti = 0;
      }
      y = this.mt[this.mti++];
      y ^= y >>> 11;
      y ^= y << 7 & 2636928640;
      y ^= y << 15 & 4022730752;
      y ^= y >>> 18;
      return y >>> 0;
    };
    MersenneTwister2.prototype.random_int31 = function() {
      return this.random_int() >>> 1;
    };
    MersenneTwister2.prototype.random_incl = function() {
      return this.random_int() * (1 / 4294967295);
    };
    MersenneTwister2.prototype.random = function() {
      return this.random_int() * (1 / 4294967296);
    };
    MersenneTwister2.prototype.random_excl = function() {
      return (this.random_int() + 0.5) * (1 / 4294967296);
    };
    MersenneTwister2.prototype.random_long = function() {
      var a3 = this.random_int() >>> 5, b = this.random_int() >>> 6;
      return (a3 * 67108864 + b) * (1 / 9007199254740992);
    };
    module.exports = MersenneTwister2;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/punycode.js
var require_punycode = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type2) {
        throw new RangeError(errors[type2]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        "version": "1.3.2",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/IPv6.js
var require_IPv6 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/IPv6.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.IPv6 = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _IPv6 = root && root.IPv6;
      function bestPresentation(address) {
        var _address = address.toLowerCase();
        var segments = _address.split(":");
        var length = segments.length;
        var total = 8;
        if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
          segments.shift();
          segments.shift();
        } else if (segments[0] === "" && segments[1] === "") {
          segments.shift();
        } else if (segments[length - 1] === "" && segments[length - 2] === "") {
          segments.pop();
        }
        length = segments.length;
        if (segments[length - 1].indexOf(".") !== -1) {
          total = 7;
        }
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (segments[pos] === "") {
            break;
          }
        }
        if (pos < total) {
          segments.splice(pos, 1, "0000");
          while (segments.length < total) {
            segments.splice(pos, 0, "0000");
          }
        }
        var _segments;
        for (var i = 0; i < total; i++) {
          _segments = segments[i].split("");
          for (var j = 0; j < 3; j++) {
            if (_segments[0] === "0" && _segments.length > 1) {
              _segments.splice(0, 1);
            } else {
              break;
            }
          }
          segments[i] = _segments.join("");
        }
        var best = -1;
        var _best = 0;
        var _current = 0;
        var current = -1;
        var inzeroes = false;
        for (i = 0; i < total; i++) {
          if (inzeroes) {
            if (segments[i] === "0") {
              _current += 1;
            } else {
              inzeroes = false;
              if (_current > _best) {
                best = current;
                _best = _current;
              }
            }
          } else {
            if (segments[i] === "0") {
              inzeroes = true;
              current = i;
              _current = 1;
            }
          }
        }
        if (_current > _best) {
          best = current;
          _best = _current;
        }
        if (_best > 1) {
          segments.splice(best, _best, "");
        }
        length = segments.length;
        var result = "";
        if (segments[0] === "") {
          result = ":";
        }
        for (i = 0; i < length; i++) {
          result += segments[i];
          if (i === length - 1) {
            break;
          }
          result += ":";
        }
        if (segments[length - 1] === "") {
          result += ":";
        }
        return result;
      }
      function noConflict() {
        if (root.IPv6 === this) {
          root.IPv6 = _IPv6;
        }
        return this;
      }
      return {
        best: bestPresentation,
        noConflict
      };
    });
  }
});

// node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/SecondLevelDomains.js
var require_SecondLevelDomains = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/SecondLevelDomains.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.SecondLevelDomains = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _SecondLevelDomains = root && root.SecondLevelDomains;
      var SLD = {
        list: {
          "ac": " com gov mil net org ",
          "ae": " ac co gov mil name net org pro sch ",
          "af": " com edu gov net org ",
          "al": " com edu gov mil net org ",
          "ao": " co ed gv it og pb ",
          "ar": " com edu gob gov int mil net org tur ",
          "at": " ac co gv or ",
          "au": " asn com csiro edu gov id net org ",
          "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          "bb": " biz co com edu gov info net org store tv ",
          "bh": " biz cc com edu gov info net org ",
          "bn": " com edu gov net org ",
          "bo": " com edu gob gov int mil net org tv ",
          "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          "bs": " com edu gov net org ",
          "bz": " du et om ov rg ",
          "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          "ck": " biz co edu gen gov info net org ",
          "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          "co": " com edu gov mil net nom org ",
          "cr": " ac c co ed fi go or sa ",
          "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          "do": " art com edu gob gov mil net org sld web ",
          "dz": " art asso com edu gov net org pol ",
          "ec": " com edu fin gov info med mil net org pro ",
          "eg": " com edu eun gov mil name net org sci ",
          "er": " com edu gov ind mil net org rochest w ",
          "es": " com edu gob nom org ",
          "et": " biz com edu gov info name net org ",
          "fj": " ac biz com info mil name net org pro ",
          "fk": " ac co gov net nom org ",
          "fr": " asso com f gouv nom prd presse tm ",
          "gg": " co net org ",
          "gh": " com edu gov mil org ",
          "gn": " ac com gov net org ",
          "gr": " com edu gov mil net org ",
          "gt": " com edu gob ind mil net org ",
          "gu": " com edu gov net org ",
          "hk": " com edu gov idv net org ",
          "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          "id": " ac co go mil net or sch web ",
          "il": " ac co gov idf k12 muni net org ",
          "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
          "iq": " com edu gov i mil net org ",
          "ir": " ac co dnssec gov i id net org sch ",
          "it": " edu gov ",
          "je": " co net org ",
          "jo": " com edu gov mil name net org sch ",
          "jp": " ac ad co ed go gr lg ne or ",
          "ke": " ac co go info me mobi ne or sc ",
          "kh": " com edu gov mil net org per ",
          "ki": " biz com de edu gov info mob net org tel ",
          "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          "kn": " edu gov net org ",
          "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          "kw": " com edu gov net org ",
          "ky": " com edu gov net org ",
          "kz": " com edu gov mil net org ",
          "lb": " com edu gov net org ",
          "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          "lr": " com edu gov net org ",
          "lv": " asn com conf edu gov id mil net org ",
          "ly": " com edu gov id med net org plc sch ",
          "ma": " ac co gov m net org press ",
          "mc": " asso tm ",
          "me": " ac co edu gov its net org priv ",
          "mg": " com edu gov mil nom org prd tm ",
          "mk": " com edu gov inf name net org pro ",
          "ml": " com edu gov net org presse ",
          "mn": " edu gov org ",
          "mo": " com edu gov net org ",
          "mt": " com edu gov net org ",
          "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
          "mw": " ac co com coop edu gov int museum net org ",
          "mx": " com edu gob net org ",
          "my": " com edu gov mil name net org sch ",
          "nf": " arts com firm info net other per rec store web ",
          "ng": " biz com edu gov mil mobi name net org sch ",
          "ni": " ac co com edu gob mil net nom org ",
          "np": " com edu gov mil net org ",
          "nr": " biz com edu gov info net org ",
          "om": " ac biz co com edu gov med mil museum net org pro sch ",
          "pe": " com edu gob mil net nom org sld ",
          "ph": " com edu gov i mil net ngo org ",
          "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
          "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          "pr": " ac biz com edu est gov info isla name net org pro prof ",
          "ps": " com edu gov net org plo sec ",
          "pw": " belau co ed go ne or ",
          "ro": " arts com firm info nom nt org rec store tm www ",
          "rs": " ac co edu gov in org ",
          "sb": " com edu gov net org ",
          "sc": " com edu gov net org ",
          "sh": " co com edu gov net nom org ",
          "sl": " com edu gov net org ",
          "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
          "sv": " com edu gob org red ",
          "sz": " ac co org ",
          "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          "tw": " club com ebiz edu game gov idv mil net org ",
          "mu": " ac co com gov net or org ",
          "mz": " ac co edu gov org ",
          "na": " co com ",
          "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          "pa": " abo ac com edu gob ing med net nom org sld ",
          "pt": " com edu gov int net nome org publ ",
          "py": " com edu gov mil net org ",
          "qa": " com edu gov mil net org ",
          "re": " asso com nom ",
          "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          "rw": " ac co com edu gouv gov int mil net ",
          "sa": " com edu gov med net org pub sch ",
          "sd": " com edu gov info med net org tv ",
          "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          "sg": " com edu gov idn net org per ",
          "sn": " art com edu gouv org perso univ ",
          "sy": " com edu gov mil net news org ",
          "th": " ac co go in mi net or ",
          "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
          "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          "tz": " ac co go ne or ",
          "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          "ug": " ac co go ne or org sc ",
          "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          "us": " dni fed isa kids nsn ",
          "uy": " com edu gub mil net org ",
          "ve": " co com edu gob info mil net org web ",
          "vi": " co com k12 net org ",
          "vn": " ac biz com edu gov health info int name net org pro ",
          "ye": " co com gov ltd me net org plc ",
          "yu": " ac co edu gov org ",
          "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          "zm": " ac co com edu gov net org sch ",
          "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          "net": "gb jp se uk ",
          "org": "ae",
          "de": "com "
        },
        has: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
        },
        is: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset >= 0) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
        },
        get: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return null;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return null;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return null;
          }
          if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
            return null;
          }
          return domain.slice(sldOffset + 1);
        },
        noConflict: function() {
          if (root.SecondLevelDomains === this) {
            root.SecondLevelDomains = _SecondLevelDomains;
          }
          return this;
        }
      };
      return SLD;
    });
  }
});

// node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/URI.js
var require_URI = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+urijs@1.19.11/node_modules/urijs/src/URI.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory(require_punycode(), require_IPv6(), require_SecondLevelDomains());
      } else if (typeof define === "function" && define.amd) {
        define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory);
      } else {
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
      }
    })(exports, function(punycode, IPv6, SLD, root) {
      "use strict";
      var _URI = root && root.URI;
      function URI(url, base) {
        var _urlSupplied = arguments.length >= 1;
        var _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI)) {
          if (_urlSupplied) {
            if (_baseSupplied) {
              return new URI(url, base);
            }
            return new URI(url);
          }
          return new URI();
        }
        if (url === void 0) {
          if (_urlSupplied) {
            throw new TypeError("undefined is not a valid argument for URI");
          }
          if (typeof location !== "undefined") {
            url = location.href + "";
          } else {
            url = "";
          }
        }
        if (url === null) {
          if (_urlSupplied) {
            throw new TypeError("null is not a valid argument for URI");
          }
        }
        this.href(url);
        if (base !== void 0) {
          return this.absoluteTo(base);
        }
        return this;
      }
      function isInteger(value) {
        return /^[0-9]+$/.test(value);
      }
      URI.version = "1.19.11";
      var p = URI.prototype;
      var hasOwn2 = Object.prototype.hasOwnProperty;
      function escapeRegEx(string) {
        return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function getType(value) {
        if (value === void 0) {
          return "Undefined";
        }
        return String(Object.prototype.toString.call(value)).slice(8, -1);
      }
      function isArray2(obj) {
        return getType(obj) === "Array";
      }
      function filterArrayValues(data, value) {
        var lookup = {};
        var i, length;
        if (getType(value) === "RegExp") {
          lookup = null;
        } else if (isArray2(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            lookup[value[i]] = true;
          }
        } else {
          lookup[value] = true;
        }
        for (i = 0, length = data.length; i < length; i++) {
          var _match = lookup && lookup[data[i]] !== void 0 || !lookup && value.test(data[i]);
          if (_match) {
            data.splice(i, 1);
            length--;
            i--;
          }
        }
        return data;
      }
      function arrayContains(list, value) {
        var i, length;
        if (isArray2(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            if (!arrayContains(list, value[i])) {
              return false;
            }
          }
          return true;
        }
        var _type = getType(value);
        for (i = 0, length = list.length; i < length; i++) {
          if (_type === "RegExp") {
            if (typeof list[i] === "string" && list[i].match(value)) {
              return true;
            }
          } else if (list[i] === value) {
            return true;
          }
        }
        return false;
      }
      function arraysEqual(one, two) {
        if (!isArray2(one) || !isArray2(two)) {
          return false;
        }
        if (one.length !== two.length) {
          return false;
        }
        one.sort();
        two.sort();
        for (var i = 0, l = one.length; i < l; i++) {
          if (one[i] !== two[i]) {
            return false;
          }
        }
        return true;
      }
      function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
      }
      URI._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          preventInvalidHostname: URI.preventInvalidHostname,
          duplicateQueryParameters: URI.duplicateQueryParameters,
          escapeQuerySpace: URI.escapeQuerySpace
        };
      };
      URI.preventInvalidHostname = false;
      URI.duplicateQueryParameters = false;
      URI.escapeQuerySpace = true;
      URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
      URI.idn_expression = /[^a-z0-9\._-]/i;
      URI.punycode_expression = /(xn--)/i;
      URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
      URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
      URI.findUri = {
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        end: /[\s\r\n]|$/,
        trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      };
      URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
      URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      };
      URI.hostProtocols = [
        "http",
        "https"
      ];
      URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
      URI.domAttributes = {
        "a": "href",
        "blockquote": "cite",
        "link": "href",
        "base": "href",
        "script": "src",
        "form": "action",
        "img": "src",
        "area": "href",
        "iframe": "src",
        "embed": "src",
        "source": "src",
        "track": "src",
        "input": "src",
        "audio": "src",
        "video": "src"
      };
      URI.getDomAttribute = function(node) {
        if (!node || !node.nodeName) {
          return void 0;
        }
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "input" && node.type !== "image") {
          return void 0;
        }
        return URI.domAttributes[nodeName];
      };
      function escapeForDumbFirefox36(value) {
        return escape(value);
      }
      function strictEncodeURIComponent(string) {
        return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
      }
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
      URI.iso8859 = function() {
        URI.encode = escape;
        URI.decode = unescape;
      };
      URI.unicode = function() {
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
      };
      URI.characters = {
        pathname: {
          encode: {
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      };
      URI.encodeQuery = function(string, escapeQuerySpace) {
        var escaped = URI.encode(string + "");
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
      };
      URI.decodeQuery = function(string, escapeQuerySpace) {
        string += "";
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        try {
          return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
        } catch (e) {
          return string;
        }
      };
      var _parts = { "encode": "encode", "decode": "decode" };
      var _part;
      var generateAccessor = function(_group, _part2) {
        return function(string) {
          try {
            return URI[_part2](string + "").replace(URI.characters[_group][_part2].expression, function(c) {
              return URI.characters[_group][_part2].map[c];
            });
          } catch (e) {
            return string;
          }
        };
      };
      for (_part in _parts) {
        URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
        URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
      }
      var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string) {
          var actualCodingFunc;
          if (!_innerCodingFuncName) {
            actualCodingFunc = URI[_codingFuncName];
          } else {
            actualCodingFunc = function(string2) {
              return URI[_codingFuncName](URI[_innerCodingFuncName](string2));
            };
          }
          var segments = (string + "").split(_sep);
          for (var i = 0, length = segments.length; i < length; i++) {
            segments[i] = actualCodingFunc(segments[i]);
          }
          return segments.join(_sep);
        };
      };
      URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
      URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
      URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
      URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
      URI.encodeReserved = generateAccessor("reserved", "encode");
      URI.parse = function(string, parts) {
        var pos;
        if (!parts) {
          parts = {
            preventInvalidHostname: URI.preventInvalidHostname
          };
        }
        string = string.replace(URI.leading_whitespace_expression, "");
        string = string.replace(URI.ascii_tab_whitespace, "");
        pos = string.indexOf("#");
        if (pos > -1) {
          parts.fragment = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        pos = string.indexOf("?");
        if (pos > -1) {
          parts.query = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
        string = string.replace(/^[/\\]{2,}/i, "//");
        if (string.substring(0, 2) === "//") {
          parts.protocol = null;
          string = string.substring(2);
          string = URI.parseAuthority(string, parts);
        } else {
          pos = string.indexOf(":");
          if (pos > -1) {
            parts.protocol = string.substring(0, pos) || null;
            if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
              parts.protocol = void 0;
            } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
              string = string.substring(pos + 3);
              string = URI.parseAuthority(string, parts);
            } else {
              string = string.substring(pos + 1);
              parts.urn = true;
            }
          }
        }
        parts.path = string;
        return parts;
      };
      URI.parseHost = function(string, parts) {
        if (!string) {
          string = "";
        }
        string = string.replace(/\\/g, "/");
        var pos = string.indexOf("/");
        var bracketPos;
        var t;
        if (pos === -1) {
          pos = string.length;
        }
        if (string.charAt(0) === "[") {
          bracketPos = string.indexOf("]");
          parts.hostname = string.substring(1, bracketPos) || null;
          parts.port = string.substring(bracketPos + 2, pos) || null;
          if (parts.port === "/") {
            parts.port = null;
          }
        } else {
          var firstColon = string.indexOf(":");
          var firstSlash = string.indexOf("/");
          var nextColon = string.indexOf(":", firstColon + 1);
          if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
            parts.hostname = string.substring(0, pos) || null;
            parts.port = null;
          } else {
            t = string.substring(0, pos).split(":");
            parts.hostname = t[0] || null;
            parts.port = t[1] || null;
          }
        }
        if (parts.hostname && string.substring(pos).charAt(0) !== "/") {
          pos++;
          string = "/" + string;
        }
        if (parts.preventInvalidHostname) {
          URI.ensureValidHostname(parts.hostname, parts.protocol);
        }
        if (parts.port) {
          URI.ensureValidPort(parts.port);
        }
        return string.substring(pos) || "/";
      };
      URI.parseAuthority = function(string, parts) {
        string = URI.parseUserinfo(string, parts);
        return URI.parseHost(string, parts);
      };
      URI.parseUserinfo = function(string, parts) {
        var _string = string;
        var firstBackSlash = string.indexOf("\\");
        if (firstBackSlash !== -1) {
          string = string.replace(/\\/g, "/");
        }
        var firstSlash = string.indexOf("/");
        var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
        var t;
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
          t = string.substring(0, pos).split(":");
          parts.username = t[0] ? URI.decode(t[0]) : null;
          t.shift();
          parts.password = t[0] ? URI.decode(t.join(":")) : null;
          string = _string.substring(pos + 1);
        } else {
          parts.username = null;
          parts.password = null;
        }
        return string;
      };
      URI.parseQuery = function(string, escapeQuerySpace) {
        if (!string) {
          return {};
        }
        string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
        if (!string) {
          return {};
        }
        var items = {};
        var splits = string.split("&");
        var length = splits.length;
        var v3, name, value;
        for (var i = 0; i < length; i++) {
          v3 = splits[i].split("=");
          name = URI.decodeQuery(v3.shift(), escapeQuerySpace);
          value = v3.length ? URI.decodeQuery(v3.join("="), escapeQuerySpace) : null;
          if (name === "__proto__") {
            continue;
          } else if (hasOwn2.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
              items[name] = [items[name]];
            }
            items[name].push(value);
          } else {
            items[name] = value;
          }
        }
        return items;
      };
      URI.build = function(parts) {
        var t = "";
        var requireAbsolutePath = false;
        if (parts.protocol) {
          t += parts.protocol + ":";
        }
        if (!parts.urn && (t || parts.hostname)) {
          t += "//";
          requireAbsolutePath = true;
        }
        t += URI.buildAuthority(parts) || "";
        if (typeof parts.path === "string") {
          if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
            t += "/";
          }
          t += parts.path;
        }
        if (typeof parts.query === "string" && parts.query) {
          t += "?" + parts.query;
        }
        if (typeof parts.fragment === "string" && parts.fragment) {
          t += "#" + parts.fragment;
        }
        return t;
      };
      URI.buildHost = function(parts) {
        var t = "";
        if (!parts.hostname) {
          return "";
        } else if (URI.ip6_expression.test(parts.hostname)) {
          t += "[" + parts.hostname + "]";
        } else {
          t += parts.hostname;
        }
        if (parts.port) {
          t += ":" + parts.port;
        }
        return t;
      };
      URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
      };
      URI.buildUserinfo = function(parts) {
        var t = "";
        if (parts.username) {
          t += URI.encode(parts.username);
        }
        if (parts.password) {
          t += ":" + URI.encode(parts.password);
        }
        if (t) {
          t += "@";
        }
        return t;
      };
      URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var t = "";
        var unique, key, i, length;
        for (key in data) {
          if (key === "__proto__") {
            continue;
          } else if (hasOwn2.call(data, key)) {
            if (isArray2(data[key])) {
              unique = {};
              for (i = 0, length = data[key].length; i < length; i++) {
                if (data[key][i] !== void 0 && unique[data[key][i] + ""] === void 0) {
                  t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                  if (duplicateQueryParameters !== true) {
                    unique[data[key][i] + ""] = true;
                  }
                }
              }
            } else if (data[key] !== void 0) {
              t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
            }
          }
        }
        return t.substring(1);
      };
      URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
      };
      URI.addQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn2.call(name, key)) {
              URI.addQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (data[name] === void 0) {
            data[name] = value;
            return;
          } else if (typeof data[name] === "string") {
            data[name] = [data[name]];
          }
          if (!isArray2(value)) {
            value = [value];
          }
          data[name] = (data[name] || []).concat(value);
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
      };
      URI.setQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn2.call(name, key)) {
              URI.setQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          data[name] = value === void 0 ? null : value;
        } else {
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
        }
      };
      URI.removeQuery = function(data, name, value) {
        var i, length, key;
        if (isArray2(name)) {
          for (i = 0, length = name.length; i < length; i++) {
            data[name[i]] = void 0;
          }
        } else if (getType(name) === "RegExp") {
          for (key in data) {
            if (name.test(key)) {
              data[key] = void 0;
            }
          }
        } else if (typeof name === "object") {
          for (key in name) {
            if (hasOwn2.call(name, key)) {
              URI.removeQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (value !== void 0) {
            if (getType(value) === "RegExp") {
              if (!isArray2(data[name]) && value.test(data[name])) {
                data[name] = void 0;
              } else {
                data[name] = filterArrayValues(data[name], value);
              }
            } else if (data[name] === String(value) && (!isArray2(value) || value.length === 1)) {
              data[name] = void 0;
            } else if (isArray2(data[name])) {
              data[name] = filterArrayValues(data[name], value);
            }
          } else {
            data[name] = void 0;
          }
        } else {
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        }
      };
      URI.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;
          case "RegExp":
            for (var key in data) {
              if (hasOwn2.call(data, key)) {
                if (name.test(key) && (value === void 0 || URI.hasQuery(data, key, value))) {
                  return true;
                }
              }
            }
            return false;
          case "Object":
            for (var _key in name) {
              if (hasOwn2.call(name, _key)) {
                if (!URI.hasQuery(data, _key, name[_key])) {
                  return false;
                }
              }
            }
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;
          case "Boolean":
            var _booly = Boolean(isArray2(data[name]) ? data[name].length : data[name]);
            return value === _booly;
          case "Function":
            return !!value(data[name], name, data);
          case "Array":
            if (!isArray2(data[name])) {
              return false;
            }
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);
          case "RegExp":
            if (!isArray2(data[name])) {
              return Boolean(data[name] && data[name].match(value));
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          case "Number":
            value = String(value);
          case "String":
            if (!isArray2(data[name])) {
              return data[name] === value;
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      };
      URI.joinPaths = function() {
        var input = [];
        var segments = [];
        var nonEmptySegments = 0;
        for (var i = 0; i < arguments.length; i++) {
          var url = new URI(arguments[i]);
          input.push(url);
          var _segments = url.segment();
          for (var s = 0; s < _segments.length; s++) {
            if (typeof _segments[s] === "string") {
              segments.push(_segments[s]);
            }
            if (_segments[s]) {
              nonEmptySegments++;
            }
          }
        }
        if (!segments.length || !nonEmptySegments) {
          return new URI("");
        }
        var uri = new URI("").segment(segments);
        if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
          uri.path("/" + uri.path());
        }
        return uri.normalize();
      };
      URI.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length);
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
          }
        }
        if (pos < 1) {
          return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
        }
        if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
          pos = one.substring(0, pos).lastIndexOf("/");
        }
        return one.substring(0, pos + 1);
      };
      URI.withinString = function(string, callback, options) {
        options || (options = {});
        var _start = options.start || URI.findUri.start;
        var _end = options.end || URI.findUri.end;
        var _trim = options.trim || URI.findUri.trim;
        var _parens = options.parens || URI.findUri.parens;
        var _attributeOpen = /[a-z0-9-]=["']?$/i;
        _start.lastIndex = 0;
        while (true) {
          var match = _start.exec(string);
          if (!match) {
            break;
          }
          var start = match.index;
          if (options.ignoreHtml) {
            var attributeOpen = string.slice(Math.max(start - 3, 0), start);
            if (attributeOpen && _attributeOpen.test(attributeOpen)) {
              continue;
            }
          }
          var end = start + string.slice(start).search(_end);
          var slice2 = string.slice(start, end);
          var parensEnd = -1;
          while (true) {
            var parensMatch = _parens.exec(slice2);
            if (!parensMatch) {
              break;
            }
            var parensMatchEnd = parensMatch.index + parensMatch[0].length;
            parensEnd = Math.max(parensEnd, parensMatchEnd);
          }
          if (parensEnd > -1) {
            slice2 = slice2.slice(0, parensEnd) + slice2.slice(parensEnd).replace(_trim, "");
          } else {
            slice2 = slice2.replace(_trim, "");
          }
          if (slice2.length <= match[0].length) {
            continue;
          }
          if (options.ignore && options.ignore.test(slice2)) {
            continue;
          }
          end = start + slice2.length;
          var result = callback(slice2, start, end, string);
          if (result === void 0) {
            _start.lastIndex = end;
            continue;
          }
          result = String(result);
          string = string.slice(0, start) + result + string.slice(end);
          _start.lastIndex = start + result.length;
        }
        _start.lastIndex = 0;
        return string;
      };
      URI.ensureValidHostname = function(v3, protocol) {
        var hasHostname = !!v3;
        var hasProtocol = !!protocol;
        var rejectEmptyHostname = false;
        if (hasProtocol) {
          rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
        }
        if (rejectEmptyHostname && !hasHostname) {
          throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
        } else if (v3 && v3.match(URI.invalid_hostname_characters)) {
          if (!punycode) {
            throw new TypeError('Hostname "' + v3 + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          }
          if (punycode.toASCII(v3).match(URI.invalid_hostname_characters)) {
            throw new TypeError('Hostname "' + v3 + '" contains characters other than [A-Z0-9.-:_]');
          }
        }
      };
      URI.ensureValidPort = function(v3) {
        if (!v3) {
          return;
        }
        var port = Number(v3);
        if (isInteger(port) && port > 0 && port < 65536) {
          return;
        }
        throw new TypeError('Port "' + v3 + '" is not a valid port');
      };
      URI.noConflict = function(removeAll) {
        if (removeAll) {
          var unconflicted = {
            URI: this.noConflict()
          };
          if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
            unconflicted.URITemplate = root.URITemplate.noConflict();
          }
          if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
            unconflicted.IPv6 = root.IPv6.noConflict();
          }
          if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
            unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
          }
          return unconflicted;
        } else if (root.URI === this) {
          root.URI = _URI;
        }
        return this;
      };
      p.build = function(deferBuild) {
        if (deferBuild === true) {
          this._deferred_build = true;
        } else if (deferBuild === void 0 || this._deferred_build) {
          this._string = URI.build(this._parts);
          this._deferred_build = false;
        }
        return this;
      };
      p.clone = function() {
        return new URI(this);
      };
      p.valueOf = p.toString = function() {
        return this.build(false)._string;
      };
      function generateSimpleAccessor(_part2) {
        return function(v3, build) {
          if (v3 === void 0) {
            return this._parts[_part2] || "";
          } else {
            this._parts[_part2] = v3 || null;
            this.build(!build);
            return this;
          }
        };
      }
      function generatePrefixAccessor(_part2, _key) {
        return function(v3, build) {
          if (v3 === void 0) {
            return this._parts[_part2] || "";
          } else {
            if (v3 !== null) {
              v3 = v3 + "";
              if (v3.charAt(0) === _key) {
                v3 = v3.substring(1);
              }
            }
            this._parts[_part2] = v3;
            this.build(!build);
            return this;
          }
        };
      }
      p.protocol = generateSimpleAccessor("protocol");
      p.username = generateSimpleAccessor("username");
      p.password = generateSimpleAccessor("password");
      p.hostname = generateSimpleAccessor("hostname");
      p.port = generateSimpleAccessor("port");
      p.query = generatePrefixAccessor("query", "?");
      p.fragment = generatePrefixAccessor("fragment", "#");
      p.search = function(v3, build) {
        var t = this.query(v3, build);
        return typeof t === "string" && t.length ? "?" + t : t;
      };
      p.hash = function(v3, build) {
        var t = this.fragment(v3, build);
        return typeof t === "string" && t.length ? "#" + t : t;
      };
      p.pathname = function(v3, build) {
        if (v3 === void 0 || v3 === true) {
          var res = this._parts.path || (this._parts.hostname ? "/" : "");
          return v3 ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
        } else {
          if (this._parts.urn) {
            this._parts.path = v3 ? URI.recodeUrnPath(v3) : "";
          } else {
            this._parts.path = v3 ? URI.recodePath(v3) : "/";
          }
          this.build(!build);
          return this;
        }
      };
      p.path = p.pathname;
      p.href = function(href, build) {
        var key;
        if (href === void 0) {
          return this.toString();
        }
        this._string = "";
        this._parts = URI._parts();
        var _URI2 = href instanceof URI;
        var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
          var attribute = URI.getDomAttribute(href);
          href = href[attribute] || "";
          _object = false;
        }
        if (!_URI2 && _object && href.pathname !== void 0) {
          href = href.toString();
        }
        if (typeof href === "string" || href instanceof String) {
          this._parts = URI.parse(String(href), this._parts);
        } else if (_URI2 || _object) {
          var src = _URI2 ? href._parts : href;
          for (key in src) {
            if (key === "query") {
              continue;
            }
            if (hasOwn2.call(this._parts, key)) {
              this._parts[key] = src[key];
            }
          }
          if (src.query) {
            this.query(src.query, false);
          }
        } else {
          throw new TypeError("invalid input");
        }
        this.build(!build);
        return this;
      };
      p.is = function(what) {
        var ip = false;
        var ip4 = false;
        var ip6 = false;
        var name = false;
        var sld = false;
        var idn = false;
        var punycode2 = false;
        var relative = !this._parts.urn;
        if (this._parts.hostname) {
          relative = false;
          ip4 = URI.ip4_expression.test(this._parts.hostname);
          ip6 = URI.ip6_expression.test(this._parts.hostname);
          ip = ip4 || ip6;
          name = !ip;
          sld = name && SLD && SLD.has(this._parts.hostname);
          idn = name && URI.idn_expression.test(this._parts.hostname);
          punycode2 = name && URI.punycode_expression.test(this._parts.hostname);
        }
        switch (what.toLowerCase()) {
          case "relative":
            return relative;
          case "absolute":
            return !relative;
          case "domain":
          case "name":
            return name;
          case "sld":
            return sld;
          case "ip":
            return ip;
          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;
          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;
          case "idn":
            return idn;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return punycode2;
        }
        return null;
      };
      var _protocol = p.protocol;
      var _port = p.port;
      var _hostname = p.hostname;
      p.protocol = function(v3, build) {
        if (v3) {
          v3 = v3.replace(/:(\/\/)?$/, "");
          if (!v3.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v3 + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
          }
        }
        return _protocol.call(this, v3, build);
      };
      p.scheme = p.protocol;
      p.port = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 !== void 0) {
          if (v3 === 0) {
            v3 = null;
          }
          if (v3) {
            v3 += "";
            if (v3.charAt(0) === ":") {
              v3 = v3.substring(1);
            }
            URI.ensureValidPort(v3);
          }
        }
        return _port.call(this, v3, build);
      };
      p.hostname = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 !== void 0) {
          var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
          var res = URI.parseHost(v3, x);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v3 + '" contains characters other than [A-Z0-9.-]');
          }
          v3 = x.hostname;
          if (this._parts.preventInvalidHostname) {
            URI.ensureValidHostname(v3, this._parts.protocol);
          }
        }
        return _hostname.call(this, v3, build);
      };
      p.origin = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 === void 0) {
          var protocol = this.protocol();
          var authority = this.authority();
          if (!authority) {
            return "";
          }
          return (protocol ? protocol + "://" : "") + this.authority();
        } else {
          var origin = URI(v3);
          this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
          return this;
        }
      };
      p.host = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 === void 0) {
          return this._parts.hostname ? URI.buildHost(this._parts) : "";
        } else {
          var res = URI.parseHost(v3, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v3 + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.authority = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 === void 0) {
          return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        } else {
          var res = URI.parseAuthority(v3, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v3 + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.userinfo = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 === void 0) {
          var t = URI.buildUserinfo(this._parts);
          return t ? t.substring(0, t.length - 1) : t;
        } else {
          if (v3[v3.length - 1] !== "@") {
            v3 += "@";
          }
          URI.parseUserinfo(v3, this._parts);
          this.build(!build);
          return this;
        }
      };
      p.resource = function(v3, build) {
        var parts;
        if (v3 === void 0) {
          return this.path() + this.search() + this.hash();
        }
        parts = URI.parse(v3);
        this._parts.path = parts.path;
        this._parts.query = parts.query;
        this._parts.fragment = parts.fragment;
        this.build(!build);
        return this;
      };
      p.subdomain = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var end = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, end) || "";
        } else {
          var e = this._parts.hostname.length - this.domain().length;
          var sub = this._parts.hostname.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(sub));
          if (v3 && v3.charAt(v3.length - 1) !== ".") {
            v3 += ".";
          }
          if (v3.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          if (v3) {
            URI.ensureValidHostname(v3, this._parts.protocol);
          }
          this._parts.hostname = this._parts.hostname.replace(replace, v3);
          this.build(!build);
          return this;
        }
      };
      p.domain = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (typeof v3 === "boolean") {
          build = v3;
          v3 = void 0;
        }
        if (v3 === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var t = this._parts.hostname.match(/\./g);
          if (t && t.length < 2) {
            return this._parts.hostname;
          }
          var end = this._parts.hostname.length - this.tld(build).length - 1;
          end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
          return this._parts.hostname.substring(end) || "";
        } else {
          if (!v3) {
            throw new TypeError("cannot set domain empty");
          }
          if (v3.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          URI.ensureValidHostname(v3, this._parts.protocol);
          if (!this._parts.hostname || this.is("IP")) {
            this._parts.hostname = v3;
          } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v3);
          }
          this.build(!build);
          return this;
        }
      };
      p.tld = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (typeof v3 === "boolean") {
          build = v3;
          v3 = void 0;
        }
        if (v3 === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var pos = this._parts.hostname.lastIndexOf(".");
          var tld = this._parts.hostname.substring(pos + 1);
          if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
          }
          return tld;
        } else {
          var replace;
          if (!v3) {
            throw new TypeError("cannot set TLD empty");
          } else if (v3.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v3)) {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v3);
            } else {
              throw new TypeError('TLD "' + v3 + '" contains characters other than [A-Z0-9]');
            }
          } else if (!this._parts.hostname || this.is("IP")) {
            throw new ReferenceError("cannot set TLD on non-domain host");
          } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v3);
          }
          this.build(!build);
          return this;
        }
      };
      p.directory = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 === void 0 || v3 === true) {
          if (!this._parts.path && !this._parts.hostname) {
            return "";
          }
          if (this._parts.path === "/") {
            return "/";
          }
          var end = this._parts.path.length - this.filename().length - 1;
          var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
          return v3 ? URI.decodePath(res) : res;
        } else {
          var e = this._parts.path.length - this.filename().length;
          var directory = this._parts.path.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(directory));
          if (!this.is("relative")) {
            if (!v3) {
              v3 = "/";
            }
            if (v3.charAt(0) !== "/") {
              v3 = "/" + v3;
            }
          }
          if (v3 && v3.charAt(v3.length - 1) !== "/") {
            v3 += "/";
          }
          v3 = URI.recodePath(v3);
          this._parts.path = this._parts.path.replace(replace, v3);
          this.build(!build);
          return this;
        }
      };
      p.filename = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (typeof v3 !== "string") {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var pos = this._parts.path.lastIndexOf("/");
          var res = this._parts.path.substring(pos + 1);
          return v3 ? URI.decodePathSegment(res) : res;
        } else {
          var mutatedDirectory = false;
          if (v3.charAt(0) === "/") {
            v3 = v3.substring(1);
          }
          if (v3.match(/\.?\//)) {
            mutatedDirectory = true;
          }
          var replace = new RegExp(escapeRegEx(this.filename()) + "$");
          v3 = URI.recodePath(v3);
          this._parts.path = this._parts.path.replace(replace, v3);
          if (mutatedDirectory) {
            this.normalizePath(build);
          } else {
            this.build(!build);
          }
          return this;
        }
      };
      p.suffix = function(v3, build) {
        if (this._parts.urn) {
          return v3 === void 0 ? "" : this;
        }
        if (v3 === void 0 || v3 === true) {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var filename = this.filename();
          var pos = filename.lastIndexOf(".");
          var s, res;
          if (pos === -1) {
            return "";
          }
          s = filename.substring(pos + 1);
          res = /^[a-z0-9%]+$/i.test(s) ? s : "";
          return v3 ? URI.decodePathSegment(res) : res;
        } else {
          if (v3.charAt(0) === ".") {
            v3 = v3.substring(1);
          }
          var suffix = this.suffix();
          var replace;
          if (!suffix) {
            if (!v3) {
              return this;
            }
            this._parts.path += "." + URI.recodePath(v3);
          } else if (!v3) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
          } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
          }
          if (replace) {
            v3 = URI.recodePath(v3);
            this._parts.path = this._parts.path.replace(replace, v3);
          }
          this.build(!build);
          return this;
        }
      };
      p.segment = function(segment, v3, build) {
        var separator = this._parts.urn ? ":" : "/";
        var path = this.path();
        var absolute = path.substring(0, 1) === "/";
        var segments = path.split(separator);
        if (segment !== void 0 && typeof segment !== "number") {
          build = v3;
          v3 = segment;
          segment = void 0;
        }
        if (segment !== void 0 && typeof segment !== "number") {
          throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        }
        if (absolute) {
          segments.shift();
        }
        if (segment < 0) {
          segment = Math.max(segments.length + segment, 0);
        }
        if (v3 === void 0) {
          return segment === void 0 ? segments : segments[segment];
        } else if (segment === null || segments[segment] === void 0) {
          if (isArray2(v3)) {
            segments = [];
            for (var i = 0, l = v3.length; i < l; i++) {
              if (!v3[i].length && (!segments.length || !segments[segments.length - 1].length)) {
                continue;
              }
              if (segments.length && !segments[segments.length - 1].length) {
                segments.pop();
              }
              segments.push(trimSlashes(v3[i]));
            }
          } else if (v3 || typeof v3 === "string") {
            v3 = trimSlashes(v3);
            if (segments[segments.length - 1] === "") {
              segments[segments.length - 1] = v3;
            } else {
              segments.push(v3);
            }
          }
        } else {
          if (v3) {
            segments[segment] = trimSlashes(v3);
          } else {
            segments.splice(segment, 1);
          }
        }
        if (absolute) {
          segments.unshift("");
        }
        return this.path(segments.join(separator), build);
      };
      p.segmentCoded = function(segment, v3, build) {
        var segments, i, l;
        if (typeof segment !== "number") {
          build = v3;
          v3 = segment;
          segment = void 0;
        }
        if (v3 === void 0) {
          segments = this.segment(segment, v3, build);
          if (!isArray2(segments)) {
            segments = segments !== void 0 ? URI.decode(segments) : void 0;
          } else {
            for (i = 0, l = segments.length; i < l; i++) {
              segments[i] = URI.decode(segments[i]);
            }
          }
          return segments;
        }
        if (!isArray2(v3)) {
          v3 = typeof v3 === "string" || v3 instanceof String ? URI.encode(v3) : v3;
        } else {
          for (i = 0, l = v3.length; i < l; i++) {
            v3[i] = URI.encode(v3[i]);
          }
        }
        return this.segment(segment, v3, build);
      };
      var q = p.query;
      p.query = function(v3, build) {
        if (v3 === true) {
          return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        } else if (typeof v3 === "function") {
          var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          var result = v3.call(this, data);
          this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else if (v3 !== void 0 && typeof v3 !== "string") {
          this._parts.query = URI.buildQuery(v3, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else {
          return q.call(this, v3, build);
        }
      };
      p.setQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof name === "string" || name instanceof String) {
          data[name] = value !== void 0 ? value : null;
        } else if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn2.call(name, key)) {
              data[key] = name[key];
            }
          }
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.addQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.addQuery(data, name, value === void 0 ? null : value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.removeQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.removeQuery(data, name, value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.hasQuery = function(name, value, withinArray) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.hasQuery(data, name, value, withinArray);
      };
      p.setSearch = p.setQuery;
      p.addSearch = p.addQuery;
      p.removeSearch = p.removeQuery;
      p.hasSearch = p.hasQuery;
      p.normalize = function() {
        if (this._parts.urn) {
          return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        }
        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      };
      p.normalizeProtocol = function(build) {
        if (typeof this._parts.protocol === "string") {
          this._parts.protocol = this._parts.protocol.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizeHostname = function(build) {
        if (this._parts.hostname) {
          if (this.is("IDN") && punycode) {
            this._parts.hostname = punycode.toASCII(this._parts.hostname);
          } else if (this.is("IPv6") && IPv6) {
            this._parts.hostname = IPv6.best(this._parts.hostname);
          }
          this._parts.hostname = this._parts.hostname.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizePort = function(build) {
        if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
          this._parts.port = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizePath = function(build) {
        var _path = this._parts.path;
        if (!_path) {
          return this;
        }
        if (this._parts.urn) {
          this._parts.path = URI.recodeUrnPath(this._parts.path);
          this.build(!build);
          return this;
        }
        if (this._parts.path === "/") {
          return this;
        }
        _path = URI.recodePath(_path);
        var _was_relative;
        var _leadingParents = "";
        var _parent, _pos;
        if (_path.charAt(0) !== "/") {
          _was_relative = true;
          _path = "/" + _path;
        }
        if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
          _path += "/";
        }
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
        if (_was_relative) {
          _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
          if (_leadingParents) {
            _leadingParents = _leadingParents[0];
          }
        }
        while (true) {
          _parent = _path.search(/\/\.\.(\/|$)/);
          if (_parent === -1) {
            break;
          } else if (_parent === 0) {
            _path = _path.substring(3);
            continue;
          }
          _pos = _path.substring(0, _parent).lastIndexOf("/");
          if (_pos === -1) {
            _pos = _parent;
          }
          _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        if (_was_relative && this.is("relative")) {
          _path = _leadingParents + _path.substring(1);
        }
        this._parts.path = _path;
        this.build(!build);
        return this;
      };
      p.normalizePathname = p.normalizePath;
      p.normalizeQuery = function(build) {
        if (typeof this._parts.query === "string") {
          if (!this._parts.query.length) {
            this._parts.query = null;
          } else {
            this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
          }
          this.build(!build);
        }
        return this;
      };
      p.normalizeFragment = function(build) {
        if (!this._parts.fragment) {
          this._parts.fragment = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizeSearch = p.normalizeQuery;
      p.normalizeHash = p.normalizeFragment;
      p.iso8859 = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = escape;
        URI.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.unicode = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = strictEncodeURIComponent;
        URI.decode = unescape;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.readable = function() {
        var uri = this.clone();
        uri.username("").password("").normalize();
        var t = "";
        if (uri._parts.protocol) {
          t += uri._parts.protocol + "://";
        }
        if (uri._parts.hostname) {
          if (uri.is("punycode") && punycode) {
            t += punycode.toUnicode(uri._parts.hostname);
            if (uri._parts.port) {
              t += ":" + uri._parts.port;
            }
          } else {
            t += uri.host();
          }
        }
        if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
          t += "/";
        }
        t += uri.path(true);
        if (uri._parts.query) {
          var q3 = "";
          for (var i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
            var kv = (qp[i] || "").split("=");
            q3 += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            if (kv[1] !== void 0) {
              q3 += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            }
          }
          t += "?" + q3.substring(1);
        }
        t += URI.decodeQuery(uri.hash(), true);
        return t;
      };
      p.absoluteTo = function(base) {
        var resolved = this.clone();
        var properties = ["protocol", "username", "password", "hostname", "port"];
        var basedir, i, p2;
        if (this._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        if (!(base instanceof URI)) {
          base = new URI(base);
        }
        if (resolved._parts.protocol) {
          return resolved;
        } else {
          resolved._parts.protocol = base._parts.protocol;
        }
        if (this._parts.hostname) {
          return resolved;
        }
        for (i = 0; p2 = properties[i]; i++) {
          resolved._parts[p2] = base._parts[p2];
        }
        if (!resolved._parts.path) {
          resolved._parts.path = base._parts.path;
          if (!resolved._parts.query) {
            resolved._parts.query = base._parts.query;
          }
        } else {
          if (resolved._parts.path.substring(-2) === "..") {
            resolved._parts.path += "/";
          }
          if (resolved.path().charAt(0) !== "/") {
            basedir = base.directory();
            basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
            resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
            resolved.normalizePath();
          }
        }
        resolved.build();
        return resolved;
      };
      p.relativeTo = function(base) {
        var relative = this.clone().normalize();
        var relativeParts, baseParts, common, relativePath, basePath;
        if (relative._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        base = new URI(base).normalize();
        relativeParts = relative._parts;
        baseParts = base._parts;
        relativePath = relative.path();
        basePath = base.path();
        if (relativePath.charAt(0) !== "/") {
          throw new Error("URI is already relative");
        }
        if (basePath.charAt(0) !== "/") {
          throw new Error("Cannot calculate a URI relative to another relative URI");
        }
        if (relativeParts.protocol === baseParts.protocol) {
          relativeParts.protocol = null;
        }
        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
          return relative.build();
        }
        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
          return relative.build();
        }
        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
          relativeParts.hostname = null;
          relativeParts.port = null;
        } else {
          return relative.build();
        }
        if (relativePath === basePath) {
          relativeParts.path = "";
          return relative.build();
        }
        common = URI.commonPath(relativePath, basePath);
        if (!common) {
          return relative.build();
        }
        var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
        return relative.build();
      };
      p.equals = function(uri) {
        var one = this.clone();
        var two = new URI(uri);
        var one_map = {};
        var two_map = {};
        var checked = {};
        var one_query, two_query, key;
        one.normalize();
        two.normalize();
        if (one.toString() === two.toString()) {
          return true;
        }
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");
        if (one.toString() !== two.toString()) {
          return false;
        }
        if (one_query.length !== two_query.length) {
          return false;
        }
        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
        two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key in one_map) {
          if (hasOwn2.call(one_map, key)) {
            if (!isArray2(one_map[key])) {
              if (one_map[key] !== two_map[key]) {
                return false;
              }
            } else if (!arraysEqual(one_map[key], two_map[key])) {
              return false;
            }
            checked[key] = true;
          }
        }
        for (key in two_map) {
          if (hasOwn2.call(two_map, key)) {
            if (!checked[key]) {
              return false;
            }
          }
        }
        return true;
      };
      p.preventInvalidHostname = function(v3) {
        this._parts.preventInvalidHostname = !!v3;
        return this;
      };
      p.duplicateQueryParameters = function(v3) {
        this._parts.duplicateQueryParameters = !!v3;
        return this;
      };
      p.escapeQuerySpace = function(v3) {
        this._parts.escapeQuerySpace = !!v3;
        return this;
      };
      return URI;
    });
  }
});

// node_modules/.pnpm/registry.npmmirror.com+punycode@1.3.2/node_modules/punycode/punycode.js
var require_punycode2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+punycode@1.3.2/node_modules/punycode/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type2) {
        throw RangeError(errors[type2]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        "version": "1.3.2",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/.pnpm/registry.npmmirror.com+url@0.11.0/node_modules/url/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+url@0.11.0/node_modules/url/util.js"(exports, module) {
    "use strict";
    module.exports = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+querystring@0.2.0/node_modules/querystring/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+querystring@0.2.0/node_modules/querystring/decode.js"(exports, module) {
    "use strict";
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v3;
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v3 = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v3;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v3);
        } else {
          obj[k] = [obj[k], v3];
        }
      }
      return obj;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+querystring@0.2.0/node_modules/querystring/encode.js
var require_encode = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+querystring@0.2.0/node_modules/querystring/encode.js"(exports, module) {
    "use strict";
    var stringifyPrimitive = function(v3) {
      switch (typeof v3) {
        case "string":
          return v3;
        case "boolean":
          return v3 ? "true" : "false";
        case "number":
          return isFinite(v3) ? v3 : "";
        default:
          return "";
      }
    };
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v3) {
              return ks + encodeURIComponent(stringifyPrimitive(v3));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+querystring@0.2.0/node_modules/querystring/index.js
var require_querystring = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+querystring@0.2.0/node_modules/querystring/index.js"(exports) {
    "use strict";
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  }
});

// node_modules/.pnpm/registry.npmmirror.com+url@0.11.0/node_modules/url/url.js
var require_url = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+url@0.11.0/node_modules/url/url.js"(exports) {
    "use strict";
    var punycode = require_punycode2();
    var util = require_util();
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    exports.Url = Url;
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_querystring();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url)
        return url;
      var u3 = new Url();
      u3.parse(url, parseQueryString, slashesDenoteHost);
      return u3;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest)
        this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (util.isString(obj))
        obj = urlParse(obj);
      if (!(obj instanceof Url))
        return Url.prototype.format.call(obj);
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source)
        return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys2 = Object.keys(relative);
          for (var v3 = 0; v3 < keys2.length; v3++) {
            var k = keys2[v3];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
  }
});

// packages/draw/polygon.ts
var polygon_exports = {};
__export(polygon_exports, {
  drawPolygon: () => drawPolygon
});

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/defined.js
function defined(value) {
  return value !== void 0 && value !== null;
}
var defined_default = defined;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/DeveloperError.js
function DeveloperError(message) {
  this.name = "DeveloperError";
  this.message = message;
  let stack;
  try {
    throw new Error();
  } catch (e) {
    stack = e.stack;
  }
  this.stack = stack;
}
if (defined_default(Object.create)) {
  DeveloperError.prototype = Object.create(Error.prototype);
  DeveloperError.prototype.constructor = DeveloperError;
}
DeveloperError.prototype.toString = function() {
  let str = `${this.name}: ${this.message}`;
  if (defined_default(this.stack)) {
    str += `
${this.stack.toString()}`;
  }
  return str;
};
DeveloperError.throwInstantiationError = function() {
  throw new DeveloperError(
    "This function defines an interface and should not be called directly."
  );
};
var DeveloperError_default = DeveloperError;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Check.js
var Check = {};
Check.typeOf = {};
function getUndefinedErrorMessage(name) {
  return `${name} is required, actual value was undefined`;
}
function getFailedTypeErrorMessage(actual, expected, name) {
  return `Expected ${name} to be typeof ${expected}, actual typeof was ${actual}`;
}
Check.defined = function(name, test) {
  if (!defined_default(test)) {
    throw new DeveloperError_default(getUndefinedErrorMessage(name));
  }
};
Check.typeOf.func = function(name, test) {
  if (typeof test !== "function") {
    throw new DeveloperError_default(
      getFailedTypeErrorMessage(typeof test, "function", name)
    );
  }
};
Check.typeOf.string = function(name, test) {
  if (typeof test !== "string") {
    throw new DeveloperError_default(
      getFailedTypeErrorMessage(typeof test, "string", name)
    );
  }
};
Check.typeOf.number = function(name, test) {
  if (typeof test !== "number") {
    throw new DeveloperError_default(
      getFailedTypeErrorMessage(typeof test, "number", name)
    );
  }
};
Check.typeOf.number.lessThan = function(name, test, limit) {
  Check.typeOf.number(name, test);
  if (test >= limit) {
    throw new DeveloperError_default(
      `Expected ${name} to be less than ${limit}, actual value was ${test}`
    );
  }
};
Check.typeOf.number.lessThanOrEquals = function(name, test, limit) {
  Check.typeOf.number(name, test);
  if (test > limit) {
    throw new DeveloperError_default(
      `Expected ${name} to be less than or equal to ${limit}, actual value was ${test}`
    );
  }
};
Check.typeOf.number.greaterThan = function(name, test, limit) {
  Check.typeOf.number(name, test);
  if (test <= limit) {
    throw new DeveloperError_default(
      `Expected ${name} to be greater than ${limit}, actual value was ${test}`
    );
  }
};
Check.typeOf.number.greaterThanOrEquals = function(name, test, limit) {
  Check.typeOf.number(name, test);
  if (test < limit) {
    throw new DeveloperError_default(
      `Expected ${name} to be greater than or equal to ${limit}, actual value was ${test}`
    );
  }
};
Check.typeOf.object = function(name, test) {
  if (typeof test !== "object") {
    throw new DeveloperError_default(
      getFailedTypeErrorMessage(typeof test, "object", name)
    );
  }
};
Check.typeOf.bool = function(name, test) {
  if (typeof test !== "boolean") {
    throw new DeveloperError_default(
      getFailedTypeErrorMessage(typeof test, "boolean", name)
    );
  }
};
Check.typeOf.bigint = function(name, test) {
  if (typeof test !== "bigint") {
    throw new DeveloperError_default(
      getFailedTypeErrorMessage(typeof test, "bigint", name)
    );
  }
};
Check.typeOf.number.equals = function(name1, name2, test1, test2) {
  Check.typeOf.number(name1, test1);
  Check.typeOf.number(name2, test2);
  if (test1 !== test2) {
    throw new DeveloperError_default(
      `${name1} must be equal to ${name2}, the actual values are ${test1} and ${test2}`
    );
  }
};
var Check_default = Check;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/defaultValue.js
function defaultValue(a3, b) {
  if (a3 !== void 0 && a3 !== null) {
    return a3;
  }
  return b;
}
defaultValue.EMPTY_OBJECT = Object.freeze({});
var defaultValue_default = defaultValue;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Math.js
var import_mersenne_twister = __toESM(require_mersenne_twister(), 1);
var CesiumMath = {};
CesiumMath.EPSILON1 = 0.1;
CesiumMath.EPSILON2 = 0.01;
CesiumMath.EPSILON3 = 1e-3;
CesiumMath.EPSILON4 = 1e-4;
CesiumMath.EPSILON5 = 1e-5;
CesiumMath.EPSILON6 = 1e-6;
CesiumMath.EPSILON7 = 1e-7;
CesiumMath.EPSILON8 = 1e-8;
CesiumMath.EPSILON9 = 1e-9;
CesiumMath.EPSILON10 = 1e-10;
CesiumMath.EPSILON11 = 1e-11;
CesiumMath.EPSILON12 = 1e-12;
CesiumMath.EPSILON13 = 1e-13;
CesiumMath.EPSILON14 = 1e-14;
CesiumMath.EPSILON15 = 1e-15;
CesiumMath.EPSILON16 = 1e-16;
CesiumMath.EPSILON17 = 1e-17;
CesiumMath.EPSILON18 = 1e-18;
CesiumMath.EPSILON19 = 1e-19;
CesiumMath.EPSILON20 = 1e-20;
CesiumMath.EPSILON21 = 1e-21;
CesiumMath.GRAVITATIONALPARAMETER = 3986004418e5;
CesiumMath.SOLAR_RADIUS = 6955e5;
CesiumMath.LUNAR_RADIUS = 1737400;
CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;
CesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;
CesiumMath.sign = defaultValue_default(Math.sign, function sign(value) {
  value = +value;
  if (value === 0 || value !== value) {
    return value;
  }
  return value > 0 ? 1 : -1;
});
CesiumMath.signNotZero = function(value) {
  return value < 0 ? -1 : 1;
};
CesiumMath.toSNorm = function(value, rangeMaximum) {
  rangeMaximum = defaultValue_default(rangeMaximum, 255);
  return Math.round(
    (CesiumMath.clamp(value, -1, 1) * 0.5 + 0.5) * rangeMaximum
  );
};
CesiumMath.fromSNorm = function(value, rangeMaximum) {
  rangeMaximum = defaultValue_default(rangeMaximum, 255);
  return CesiumMath.clamp(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
};
CesiumMath.normalize = function(value, rangeMinimum, rangeMaximum) {
  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0);
  return rangeMaximum === 0 ? 0 : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0, 1);
};
CesiumMath.sinh = defaultValue_default(Math.sinh, function sinh(value) {
  return (Math.exp(value) - Math.exp(-value)) / 2;
});
CesiumMath.cosh = defaultValue_default(Math.cosh, function cosh(value) {
  return (Math.exp(value) + Math.exp(-value)) / 2;
});
CesiumMath.lerp = function(p, q, time) {
  return (1 - time) * p + time * q;
};
CesiumMath.PI = Math.PI;
CesiumMath.ONE_OVER_PI = 1 / Math.PI;
CesiumMath.PI_OVER_TWO = Math.PI / 2;
CesiumMath.PI_OVER_THREE = Math.PI / 3;
CesiumMath.PI_OVER_FOUR = Math.PI / 4;
CesiumMath.PI_OVER_SIX = Math.PI / 6;
CesiumMath.THREE_PI_OVER_TWO = 3 * Math.PI / 2;
CesiumMath.TWO_PI = 2 * Math.PI;
CesiumMath.ONE_OVER_TWO_PI = 1 / (2 * Math.PI);
CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180;
CesiumMath.DEGREES_PER_RADIAN = 180 / Math.PI;
CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600;
CesiumMath.toRadians = function(degrees) {
  if (!defined_default(degrees)) {
    throw new DeveloperError_default("degrees is required.");
  }
  return degrees * CesiumMath.RADIANS_PER_DEGREE;
};
CesiumMath.toDegrees = function(radians) {
  if (!defined_default(radians)) {
    throw new DeveloperError_default("radians is required.");
  }
  return radians * CesiumMath.DEGREES_PER_RADIAN;
};
CesiumMath.convertLongitudeRange = function(angle) {
  if (!defined_default(angle)) {
    throw new DeveloperError_default("angle is required.");
  }
  const twoPi = CesiumMath.TWO_PI;
  const simplified = angle - Math.floor(angle / twoPi) * twoPi;
  if (simplified < -Math.PI) {
    return simplified + twoPi;
  }
  if (simplified >= Math.PI) {
    return simplified - twoPi;
  }
  return simplified;
};
CesiumMath.clampToLatitudeRange = function(angle) {
  if (!defined_default(angle)) {
    throw new DeveloperError_default("angle is required.");
  }
  return CesiumMath.clamp(
    angle,
    -1 * CesiumMath.PI_OVER_TWO,
    CesiumMath.PI_OVER_TWO
  );
};
CesiumMath.negativePiToPi = function(angle) {
  if (!defined_default(angle)) {
    throw new DeveloperError_default("angle is required.");
  }
  if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {
    return angle;
  }
  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;
};
CesiumMath.zeroToTwoPi = function(angle) {
  if (!defined_default(angle)) {
    throw new DeveloperError_default("angle is required.");
  }
  if (angle >= 0 && angle <= CesiumMath.TWO_PI) {
    return angle;
  }
  const mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);
  if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(angle) > CesiumMath.EPSILON14) {
    return CesiumMath.TWO_PI;
  }
  return mod;
};
CesiumMath.mod = function(m, n) {
  if (!defined_default(m)) {
    throw new DeveloperError_default("m is required.");
  }
  if (!defined_default(n)) {
    throw new DeveloperError_default("n is required.");
  }
  if (n === 0) {
    throw new DeveloperError_default("divisor cannot be 0.");
  }
  if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {
    return m;
  }
  return (m % n + n) % n;
};
CesiumMath.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("left is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("right is required.");
  }
  relativeEpsilon = defaultValue_default(relativeEpsilon, 0);
  absoluteEpsilon = defaultValue_default(absoluteEpsilon, relativeEpsilon);
  const absDiff = Math.abs(left - right);
  return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));
};
CesiumMath.lessThan = function(left, right, absoluteEpsilon) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("first is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("second is required.");
  }
  if (!defined_default(absoluteEpsilon)) {
    throw new DeveloperError_default("absoluteEpsilon is required.");
  }
  return left - right < -absoluteEpsilon;
};
CesiumMath.lessThanOrEquals = function(left, right, absoluteEpsilon) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("first is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("second is required.");
  }
  if (!defined_default(absoluteEpsilon)) {
    throw new DeveloperError_default("absoluteEpsilon is required.");
  }
  return left - right < absoluteEpsilon;
};
CesiumMath.greaterThan = function(left, right, absoluteEpsilon) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("first is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("second is required.");
  }
  if (!defined_default(absoluteEpsilon)) {
    throw new DeveloperError_default("absoluteEpsilon is required.");
  }
  return left - right > absoluteEpsilon;
};
CesiumMath.greaterThanOrEquals = function(left, right, absoluteEpsilon) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("first is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("second is required.");
  }
  if (!defined_default(absoluteEpsilon)) {
    throw new DeveloperError_default("absoluteEpsilon is required.");
  }
  return left - right > -absoluteEpsilon;
};
var factorials = [1];
CesiumMath.factorial = function(n) {
  if (typeof n !== "number" || n < 0) {
    throw new DeveloperError_default(
      "A number greater than or equal to 0 is required."
    );
  }
  const length = factorials.length;
  if (n >= length) {
    let sum = factorials[length - 1];
    for (let i = length; i <= n; i++) {
      const next = sum * i;
      factorials.push(next);
      sum = next;
    }
  }
  return factorials[n];
};
CesiumMath.incrementWrap = function(n, maximumValue, minimumValue) {
  minimumValue = defaultValue_default(minimumValue, 0);
  if (!defined_default(n)) {
    throw new DeveloperError_default("n is required.");
  }
  if (maximumValue <= minimumValue) {
    throw new DeveloperError_default("maximumValue must be greater than minimumValue.");
  }
  ++n;
  if (n > maximumValue) {
    n = minimumValue;
  }
  return n;
};
CesiumMath.isPowerOfTwo = function(n) {
  if (typeof n !== "number" || n < 0 || n > 4294967295) {
    throw new DeveloperError_default("A number between 0 and (2^32)-1 is required.");
  }
  return n !== 0 && (n & n - 1) === 0;
};
CesiumMath.nextPowerOfTwo = function(n) {
  if (typeof n !== "number" || n < 0 || n > 2147483648) {
    throw new DeveloperError_default("A number between 0 and 2^31 is required.");
  }
  --n;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  ++n;
  return n;
};
CesiumMath.previousPowerOfTwo = function(n) {
  if (typeof n !== "number" || n < 0 || n > 4294967295) {
    throw new DeveloperError_default("A number between 0 and (2^32)-1 is required.");
  }
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  n = (n >>> 0) - (n >>> 1);
  return n;
};
CesiumMath.clamp = function(value, min, max) {
  Check_default.typeOf.number("value", value);
  Check_default.typeOf.number("min", min);
  Check_default.typeOf.number("max", max);
  return value < min ? min : value > max ? max : value;
};
var randomNumberGenerator = new import_mersenne_twister.default();
CesiumMath.setRandomNumberSeed = function(seed) {
  if (!defined_default(seed)) {
    throw new DeveloperError_default("seed is required.");
  }
  randomNumberGenerator = new import_mersenne_twister.default(seed);
};
CesiumMath.nextRandomNumber = function() {
  return randomNumberGenerator.random();
};
CesiumMath.randomBetween = function(min, max) {
  return CesiumMath.nextRandomNumber() * (max - min) + min;
};
CesiumMath.acosClamped = function(value) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required.");
  }
  return Math.acos(CesiumMath.clamp(value, -1, 1));
};
CesiumMath.asinClamped = function(value) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required.");
  }
  return Math.asin(CesiumMath.clamp(value, -1, 1));
};
CesiumMath.chordLength = function(angle, radius) {
  if (!defined_default(angle)) {
    throw new DeveloperError_default("angle is required.");
  }
  if (!defined_default(radius)) {
    throw new DeveloperError_default("radius is required.");
  }
  return 2 * radius * Math.sin(angle * 0.5);
};
CesiumMath.logBase = function(number, base) {
  if (!defined_default(number)) {
    throw new DeveloperError_default("number is required.");
  }
  if (!defined_default(base)) {
    throw new DeveloperError_default("base is required.");
  }
  return Math.log(number) / Math.log(base);
};
CesiumMath.cbrt = defaultValue_default(Math.cbrt, function cbrt(number) {
  const result = Math.pow(Math.abs(number), 1 / 3);
  return number < 0 ? -result : result;
});
CesiumMath.log2 = defaultValue_default(Math.log2, function log2(number) {
  return Math.log(number) * Math.LOG2E;
});
CesiumMath.fog = function(distanceToCamera, density) {
  const scalar = distanceToCamera * density;
  return 1 - Math.exp(-(scalar * scalar));
};
CesiumMath.fastApproximateAtan = function(x) {
  Check_default.typeOf.number("x", x);
  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);
};
CesiumMath.fastApproximateAtan2 = function(x, y) {
  Check_default.typeOf.number("x", x);
  Check_default.typeOf.number("y", y);
  let opposite;
  let t = Math.abs(x);
  opposite = Math.abs(y);
  const adjacent = Math.max(t, opposite);
  opposite = Math.min(t, opposite);
  const oppositeOverAdjacent = opposite / adjacent;
  if (isNaN(oppositeOverAdjacent)) {
    throw new DeveloperError_default("either x or y must be nonzero");
  }
  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);
  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;
  t = x < 0 ? CesiumMath.PI - t : t;
  t = y < 0 ? -t : t;
  return t;
};
var Math_default = CesiumMath;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Cartesian3.js
function Cartesian3(x, y, z) {
  this.x = defaultValue_default(x, 0);
  this.y = defaultValue_default(y, 0);
  this.z = defaultValue_default(z, 0);
}
Cartesian3.fromSpherical = function(spherical, result) {
  Check_default.typeOf.object("spherical", spherical);
  if (!defined_default(result)) {
    result = new Cartesian3();
  }
  const clock = spherical.clock;
  const cone = spherical.cone;
  const magnitude = defaultValue_default(spherical.magnitude, 1);
  const radial = magnitude * Math.sin(cone);
  result.x = radial * Math.cos(clock);
  result.y = radial * Math.sin(clock);
  result.z = magnitude * Math.cos(cone);
  return result;
};
Cartesian3.fromElements = function(x, y, z, result) {
  if (!defined_default(result)) {
    return new Cartesian3(x, y, z);
  }
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Cartesian3.clone = function(cartesian, result) {
  if (!defined_default(cartesian)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
  }
  result.x = cartesian.x;
  result.y = cartesian.y;
  result.z = cartesian.z;
  return result;
};
Cartesian3.fromCartesian4 = Cartesian3.clone;
Cartesian3.packedLength = 3;
Cartesian3.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.x;
  array[startingIndex++] = value.y;
  array[startingIndex] = value.z;
  return array;
};
Cartesian3.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Cartesian3();
  }
  result.x = array[startingIndex++];
  result.y = array[startingIndex++];
  result.z = array[startingIndex];
  return result;
};
Cartesian3.packArray = function(array, result) {
  Check_default.defined("array", array);
  const length = array.length;
  const resultLength = length * 3;
  if (!defined_default(result)) {
    result = new Array(resultLength);
  } else if (!Array.isArray(result) && result.length !== resultLength) {
    throw new DeveloperError_default(
      "If result is a typed array, it must have exactly array.length * 3 elements"
    );
  } else if (result.length !== resultLength) {
    result.length = resultLength;
  }
  for (let i = 0; i < length; ++i) {
    Cartesian3.pack(array[i], result, i * 3);
  }
  return result;
};
Cartesian3.unpackArray = function(array, result) {
  Check_default.defined("array", array);
  Check_default.typeOf.number.greaterThanOrEquals("array.length", array.length, 3);
  if (array.length % 3 !== 0) {
    throw new DeveloperError_default("array length must be a multiple of 3.");
  }
  const length = array.length;
  if (!defined_default(result)) {
    result = new Array(length / 3);
  } else {
    result.length = length / 3;
  }
  for (let i = 0; i < length; i += 3) {
    const index = i / 3;
    result[index] = Cartesian3.unpack(array, i, result[index]);
  }
  return result;
};
Cartesian3.fromArray = Cartesian3.unpack;
Cartesian3.maximumComponent = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return Math.max(cartesian.x, cartesian.y, cartesian.z);
};
Cartesian3.minimumComponent = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return Math.min(cartesian.x, cartesian.y, cartesian.z);
};
Cartesian3.minimumByComponent = function(first, second, result) {
  Check_default.typeOf.object("first", first);
  Check_default.typeOf.object("second", second);
  Check_default.typeOf.object("result", result);
  result.x = Math.min(first.x, second.x);
  result.y = Math.min(first.y, second.y);
  result.z = Math.min(first.z, second.z);
  return result;
};
Cartesian3.maximumByComponent = function(first, second, result) {
  Check_default.typeOf.object("first", first);
  Check_default.typeOf.object("second", second);
  Check_default.typeOf.object("result", result);
  result.x = Math.max(first.x, second.x);
  result.y = Math.max(first.y, second.y);
  result.z = Math.max(first.z, second.z);
  return result;
};
Cartesian3.clamp = function(value, min, max, result) {
  Check_default.typeOf.object("value", value);
  Check_default.typeOf.object("min", min);
  Check_default.typeOf.object("max", max);
  Check_default.typeOf.object("result", result);
  const x = Math_default.clamp(value.x, min.x, max.x);
  const y = Math_default.clamp(value.y, min.y, max.y);
  const z = Math_default.clamp(value.z, min.z, max.z);
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Cartesian3.magnitudeSquared = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
};
Cartesian3.magnitude = function(cartesian) {
  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
};
var distanceScratch = new Cartesian3();
Cartesian3.distance = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian3.subtract(left, right, distanceScratch);
  return Cartesian3.magnitude(distanceScratch);
};
Cartesian3.distanceSquared = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian3.subtract(left, right, distanceScratch);
  return Cartesian3.magnitudeSquared(distanceScratch);
};
Cartesian3.normalize = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const magnitude = Cartesian3.magnitude(cartesian);
  result.x = cartesian.x / magnitude;
  result.y = cartesian.y / magnitude;
  result.z = cartesian.z / magnitude;
  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {
    throw new DeveloperError_default("normalized result is not a number");
  }
  return result;
};
Cartesian3.dot = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  return left.x * right.x + left.y * right.y + left.z * right.z;
};
Cartesian3.multiplyComponents = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x * right.x;
  result.y = left.y * right.y;
  result.z = left.z * right.z;
  return result;
};
Cartesian3.divideComponents = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x / right.x;
  result.y = left.y / right.y;
  result.z = left.z / right.z;
  return result;
};
Cartesian3.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x + right.x;
  result.y = left.y + right.y;
  result.z = left.z + right.z;
  return result;
};
Cartesian3.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x - right.x;
  result.y = left.y - right.y;
  result.z = left.z - right.z;
  return result;
};
Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = cartesian.x * scalar;
  result.y = cartesian.y * scalar;
  result.z = cartesian.z * scalar;
  return result;
};
Cartesian3.divideByScalar = function(cartesian, scalar, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = cartesian.x / scalar;
  result.y = cartesian.y / scalar;
  result.z = cartesian.z / scalar;
  return result;
};
Cartesian3.negate = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result.x = -cartesian.x;
  result.y = -cartesian.y;
  result.z = -cartesian.z;
  return result;
};
Cartesian3.abs = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result.x = Math.abs(cartesian.x);
  result.y = Math.abs(cartesian.y);
  result.z = Math.abs(cartesian.z);
  return result;
};
var lerpScratch = new Cartesian3();
Cartesian3.lerp = function(start, end, t, result) {
  Check_default.typeOf.object("start", start);
  Check_default.typeOf.object("end", end);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  Cartesian3.multiplyByScalar(end, t, lerpScratch);
  result = Cartesian3.multiplyByScalar(start, 1 - t, result);
  return Cartesian3.add(lerpScratch, result, result);
};
var angleBetweenScratch = new Cartesian3();
var angleBetweenScratch2 = new Cartesian3();
Cartesian3.angleBetween = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian3.normalize(left, angleBetweenScratch);
  Cartesian3.normalize(right, angleBetweenScratch2);
  const cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
  const sine = Cartesian3.magnitude(
    Cartesian3.cross(
      angleBetweenScratch,
      angleBetweenScratch2,
      angleBetweenScratch
    )
  );
  return Math.atan2(sine, cosine);
};
var mostOrthogonalAxisScratch = new Cartesian3();
Cartesian3.mostOrthogonalAxis = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);
  Cartesian3.abs(f, f);
  if (f.x <= f.y) {
    if (f.x <= f.z) {
      result = Cartesian3.clone(Cartesian3.UNIT_X, result);
    } else {
      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
    }
  } else if (f.y <= f.z) {
    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
  } else {
    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
  }
  return result;
};
Cartesian3.projectVector = function(a3, b, result) {
  Check_default.defined("a", a3);
  Check_default.defined("b", b);
  Check_default.defined("result", result);
  const scalar = Cartesian3.dot(a3, b) / Cartesian3.dot(b, b);
  return Cartesian3.multiplyByScalar(b, scalar, result);
};
Cartesian3.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.x === right.x && left.y === right.y && left.z === right.z;
};
Cartesian3.equalsArray = function(cartesian, array, offset) {
  return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];
};
Cartesian3.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
  return left === right || defined_default(left) && defined_default(right) && Math_default.equalsEpsilon(
    left.x,
    right.x,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.y,
    right.y,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.z,
    right.z,
    relativeEpsilon,
    absoluteEpsilon
  );
};
Cartesian3.cross = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  const leftX = left.x;
  const leftY = left.y;
  const leftZ = left.z;
  const rightX = right.x;
  const rightY = right.y;
  const rightZ = right.z;
  const x = leftY * rightZ - leftZ * rightY;
  const y = leftZ * rightX - leftX * rightZ;
  const z = leftX * rightY - leftY * rightX;
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Cartesian3.midpoint = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = (left.x + right.x) * 0.5;
  result.y = (left.y + right.y) * 0.5;
  result.z = (left.z + right.z) * 0.5;
  return result;
};
Cartesian3.fromDegrees = function(longitude, latitude, height, ellipsoid, result) {
  Check_default.typeOf.number("longitude", longitude);
  Check_default.typeOf.number("latitude", latitude);
  longitude = Math_default.toRadians(longitude);
  latitude = Math_default.toRadians(latitude);
  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);
};
var scratchN = new Cartesian3();
var scratchK = new Cartesian3();
var wgs84RadiiSquared = new Cartesian3(
  6378137 * 6378137,
  6378137 * 6378137,
  6356752314245179e-9 * 6356752314245179e-9
);
Cartesian3.fromRadians = function(longitude, latitude, height, ellipsoid, result) {
  Check_default.typeOf.number("longitude", longitude);
  Check_default.typeOf.number("latitude", latitude);
  height = defaultValue_default(height, 0);
  const radiiSquared = defined_default(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;
  const cosLatitude = Math.cos(latitude);
  scratchN.x = cosLatitude * Math.cos(longitude);
  scratchN.y = cosLatitude * Math.sin(longitude);
  scratchN.z = Math.sin(latitude);
  scratchN = Cartesian3.normalize(scratchN, scratchN);
  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);
  if (!defined_default(result)) {
    result = new Cartesian3();
  }
  return Cartesian3.add(scratchK, scratchN, result);
};
Cartesian3.fromDegreesArray = function(coordinates, ellipsoid, result) {
  Check_default.defined("coordinates", coordinates);
  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
    throw new DeveloperError_default(
      "the number of coordinates must be a multiple of 2 and at least 2"
    );
  }
  const length = coordinates.length;
  if (!defined_default(result)) {
    result = new Array(length / 2);
  } else {
    result.length = length / 2;
  }
  for (let i = 0; i < length; i += 2) {
    const longitude = coordinates[i];
    const latitude = coordinates[i + 1];
    const index = i / 2;
    result[index] = Cartesian3.fromDegrees(
      longitude,
      latitude,
      0,
      ellipsoid,
      result[index]
    );
  }
  return result;
};
Cartesian3.fromRadiansArray = function(coordinates, ellipsoid, result) {
  Check_default.defined("coordinates", coordinates);
  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
    throw new DeveloperError_default(
      "the number of coordinates must be a multiple of 2 and at least 2"
    );
  }
  const length = coordinates.length;
  if (!defined_default(result)) {
    result = new Array(length / 2);
  } else {
    result.length = length / 2;
  }
  for (let i = 0; i < length; i += 2) {
    const longitude = coordinates[i];
    const latitude = coordinates[i + 1];
    const index = i / 2;
    result[index] = Cartesian3.fromRadians(
      longitude,
      latitude,
      0,
      ellipsoid,
      result[index]
    );
  }
  return result;
};
Cartesian3.fromDegreesArrayHeights = function(coordinates, ellipsoid, result) {
  Check_default.defined("coordinates", coordinates);
  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
    throw new DeveloperError_default(
      "the number of coordinates must be a multiple of 3 and at least 3"
    );
  }
  const length = coordinates.length;
  if (!defined_default(result)) {
    result = new Array(length / 3);
  } else {
    result.length = length / 3;
  }
  for (let i = 0; i < length; i += 3) {
    const longitude = coordinates[i];
    const latitude = coordinates[i + 1];
    const height = coordinates[i + 2];
    const index = i / 3;
    result[index] = Cartesian3.fromDegrees(
      longitude,
      latitude,
      height,
      ellipsoid,
      result[index]
    );
  }
  return result;
};
Cartesian3.fromRadiansArrayHeights = function(coordinates, ellipsoid, result) {
  Check_default.defined("coordinates", coordinates);
  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
    throw new DeveloperError_default(
      "the number of coordinates must be a multiple of 3 and at least 3"
    );
  }
  const length = coordinates.length;
  if (!defined_default(result)) {
    result = new Array(length / 3);
  } else {
    result.length = length / 3;
  }
  for (let i = 0; i < length; i += 3) {
    const longitude = coordinates[i];
    const latitude = coordinates[i + 1];
    const height = coordinates[i + 2];
    const index = i / 3;
    result[index] = Cartesian3.fromRadians(
      longitude,
      latitude,
      height,
      ellipsoid,
      result[index]
    );
  }
  return result;
};
Cartesian3.ZERO = Object.freeze(new Cartesian3(0, 0, 0));
Cartesian3.ONE = Object.freeze(new Cartesian3(1, 1, 1));
Cartesian3.UNIT_X = Object.freeze(new Cartesian3(1, 0, 0));
Cartesian3.UNIT_Y = Object.freeze(new Cartesian3(0, 1, 0));
Cartesian3.UNIT_Z = Object.freeze(new Cartesian3(0, 0, 1));
Cartesian3.prototype.clone = function(result) {
  return Cartesian3.clone(this, result);
};
Cartesian3.prototype.equals = function(right) {
  return Cartesian3.equals(this, right);
};
Cartesian3.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
  return Cartesian3.equalsEpsilon(
    this,
    right,
    relativeEpsilon,
    absoluteEpsilon
  );
};
Cartesian3.prototype.toString = function() {
  return `(${this.x}, ${this.y}, ${this.z})`;
};
var Cartesian3_default = Cartesian3;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Cartesian4.js
function Cartesian4(x, y, z, w) {
  this.x = defaultValue_default(x, 0);
  this.y = defaultValue_default(y, 0);
  this.z = defaultValue_default(z, 0);
  this.w = defaultValue_default(w, 0);
}
Cartesian4.fromElements = function(x, y, z, w, result) {
  if (!defined_default(result)) {
    return new Cartesian4(x, y, z, w);
  }
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
Cartesian4.fromColor = function(color, result) {
  Check_default.typeOf.object("color", color);
  if (!defined_default(result)) {
    return new Cartesian4(color.red, color.green, color.blue, color.alpha);
  }
  result.x = color.red;
  result.y = color.green;
  result.z = color.blue;
  result.w = color.alpha;
  return result;
};
Cartesian4.clone = function(cartesian, result) {
  if (!defined_default(cartesian)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
  }
  result.x = cartesian.x;
  result.y = cartesian.y;
  result.z = cartesian.z;
  result.w = cartesian.w;
  return result;
};
Cartesian4.packedLength = 4;
Cartesian4.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.x;
  array[startingIndex++] = value.y;
  array[startingIndex++] = value.z;
  array[startingIndex] = value.w;
  return array;
};
Cartesian4.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Cartesian4();
  }
  result.x = array[startingIndex++];
  result.y = array[startingIndex++];
  result.z = array[startingIndex++];
  result.w = array[startingIndex];
  return result;
};
Cartesian4.packArray = function(array, result) {
  Check_default.defined("array", array);
  const length = array.length;
  const resultLength = length * 4;
  if (!defined_default(result)) {
    result = new Array(resultLength);
  } else if (!Array.isArray(result) && result.length !== resultLength) {
    throw new DeveloperError_default(
      "If result is a typed array, it must have exactly array.length * 4 elements"
    );
  } else if (result.length !== resultLength) {
    result.length = resultLength;
  }
  for (let i = 0; i < length; ++i) {
    Cartesian4.pack(array[i], result, i * 4);
  }
  return result;
};
Cartesian4.unpackArray = function(array, result) {
  Check_default.defined("array", array);
  Check_default.typeOf.number.greaterThanOrEquals("array.length", array.length, 4);
  if (array.length % 4 !== 0) {
    throw new DeveloperError_default("array length must be a multiple of 4.");
  }
  const length = array.length;
  if (!defined_default(result)) {
    result = new Array(length / 4);
  } else {
    result.length = length / 4;
  }
  for (let i = 0; i < length; i += 4) {
    const index = i / 4;
    result[index] = Cartesian4.unpack(array, i, result[index]);
  }
  return result;
};
Cartesian4.fromArray = Cartesian4.unpack;
Cartesian4.maximumComponent = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
};
Cartesian4.minimumComponent = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
};
Cartesian4.minimumByComponent = function(first, second, result) {
  Check_default.typeOf.object("first", first);
  Check_default.typeOf.object("second", second);
  Check_default.typeOf.object("result", result);
  result.x = Math.min(first.x, second.x);
  result.y = Math.min(first.y, second.y);
  result.z = Math.min(first.z, second.z);
  result.w = Math.min(first.w, second.w);
  return result;
};
Cartesian4.maximumByComponent = function(first, second, result) {
  Check_default.typeOf.object("first", first);
  Check_default.typeOf.object("second", second);
  Check_default.typeOf.object("result", result);
  result.x = Math.max(first.x, second.x);
  result.y = Math.max(first.y, second.y);
  result.z = Math.max(first.z, second.z);
  result.w = Math.max(first.w, second.w);
  return result;
};
Cartesian4.clamp = function(value, min, max, result) {
  Check_default.typeOf.object("value", value);
  Check_default.typeOf.object("min", min);
  Check_default.typeOf.object("max", max);
  Check_default.typeOf.object("result", result);
  const x = Math_default.clamp(value.x, min.x, max.x);
  const y = Math_default.clamp(value.y, min.y, max.y);
  const z = Math_default.clamp(value.z, min.z, max.z);
  const w = Math_default.clamp(value.w, min.w, max.w);
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
Cartesian4.magnitudeSquared = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
};
Cartesian4.magnitude = function(cartesian) {
  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
};
var distanceScratch2 = new Cartesian4();
Cartesian4.distance = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian4.subtract(left, right, distanceScratch2);
  return Cartesian4.magnitude(distanceScratch2);
};
Cartesian4.distanceSquared = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian4.subtract(left, right, distanceScratch2);
  return Cartesian4.magnitudeSquared(distanceScratch2);
};
Cartesian4.normalize = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const magnitude = Cartesian4.magnitude(cartesian);
  result.x = cartesian.x / magnitude;
  result.y = cartesian.y / magnitude;
  result.z = cartesian.z / magnitude;
  result.w = cartesian.w / magnitude;
  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z) || isNaN(result.w)) {
    throw new DeveloperError_default("normalized result is not a number");
  }
  return result;
};
Cartesian4.dot = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
};
Cartesian4.multiplyComponents = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x * right.x;
  result.y = left.y * right.y;
  result.z = left.z * right.z;
  result.w = left.w * right.w;
  return result;
};
Cartesian4.divideComponents = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x / right.x;
  result.y = left.y / right.y;
  result.z = left.z / right.z;
  result.w = left.w / right.w;
  return result;
};
Cartesian4.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x + right.x;
  result.y = left.y + right.y;
  result.z = left.z + right.z;
  result.w = left.w + right.w;
  return result;
};
Cartesian4.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x - right.x;
  result.y = left.y - right.y;
  result.z = left.z - right.z;
  result.w = left.w - right.w;
  return result;
};
Cartesian4.multiplyByScalar = function(cartesian, scalar, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = cartesian.x * scalar;
  result.y = cartesian.y * scalar;
  result.z = cartesian.z * scalar;
  result.w = cartesian.w * scalar;
  return result;
};
Cartesian4.divideByScalar = function(cartesian, scalar, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = cartesian.x / scalar;
  result.y = cartesian.y / scalar;
  result.z = cartesian.z / scalar;
  result.w = cartesian.w / scalar;
  return result;
};
Cartesian4.negate = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result.x = -cartesian.x;
  result.y = -cartesian.y;
  result.z = -cartesian.z;
  result.w = -cartesian.w;
  return result;
};
Cartesian4.abs = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result.x = Math.abs(cartesian.x);
  result.y = Math.abs(cartesian.y);
  result.z = Math.abs(cartesian.z);
  result.w = Math.abs(cartesian.w);
  return result;
};
var lerpScratch2 = new Cartesian4();
Cartesian4.lerp = function(start, end, t, result) {
  Check_default.typeOf.object("start", start);
  Check_default.typeOf.object("end", end);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  Cartesian4.multiplyByScalar(end, t, lerpScratch2);
  result = Cartesian4.multiplyByScalar(start, 1 - t, result);
  return Cartesian4.add(lerpScratch2, result, result);
};
var mostOrthogonalAxisScratch2 = new Cartesian4();
Cartesian4.mostOrthogonalAxis = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch2);
  Cartesian4.abs(f, f);
  if (f.x <= f.y) {
    if (f.x <= f.z) {
      if (f.x <= f.w) {
        result = Cartesian4.clone(Cartesian4.UNIT_X, result);
      } else {
        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
      }
    } else if (f.z <= f.w) {
      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
    } else {
      result = Cartesian4.clone(Cartesian4.UNIT_W, result);
    }
  } else if (f.y <= f.z) {
    if (f.y <= f.w) {
      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
    } else {
      result = Cartesian4.clone(Cartesian4.UNIT_W, result);
    }
  } else if (f.z <= f.w) {
    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
  } else {
    result = Cartesian4.clone(Cartesian4.UNIT_W, result);
  }
  return result;
};
Cartesian4.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;
};
Cartesian4.equalsArray = function(cartesian, array, offset) {
  return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];
};
Cartesian4.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
  return left === right || defined_default(left) && defined_default(right) && Math_default.equalsEpsilon(
    left.x,
    right.x,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.y,
    right.y,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.z,
    right.z,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.w,
    right.w,
    relativeEpsilon,
    absoluteEpsilon
  );
};
Cartesian4.ZERO = Object.freeze(new Cartesian4(0, 0, 0, 0));
Cartesian4.ONE = Object.freeze(new Cartesian4(1, 1, 1, 1));
Cartesian4.UNIT_X = Object.freeze(new Cartesian4(1, 0, 0, 0));
Cartesian4.UNIT_Y = Object.freeze(new Cartesian4(0, 1, 0, 0));
Cartesian4.UNIT_Z = Object.freeze(new Cartesian4(0, 0, 1, 0));
Cartesian4.UNIT_W = Object.freeze(new Cartesian4(0, 0, 0, 1));
Cartesian4.prototype.clone = function(result) {
  return Cartesian4.clone(this, result);
};
Cartesian4.prototype.equals = function(right) {
  return Cartesian4.equals(this, right);
};
Cartesian4.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
  return Cartesian4.equalsEpsilon(
    this,
    right,
    relativeEpsilon,
    absoluteEpsilon
  );
};
Cartesian4.prototype.toString = function() {
  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;
};
var scratchF32Array = new Float32Array(1);
var scratchU8Array = new Uint8Array(scratchF32Array.buffer);
var testU32 = new Uint32Array([287454020]);
var testU8 = new Uint8Array(testU32.buffer);
var littleEndian = testU8[0] === 68;
Cartesian4.packFloat = function(value, result) {
  Check_default.typeOf.number("value", value);
  if (!defined_default(result)) {
    result = new Cartesian4();
  }
  scratchF32Array[0] = value;
  if (littleEndian) {
    result.x = scratchU8Array[0];
    result.y = scratchU8Array[1];
    result.z = scratchU8Array[2];
    result.w = scratchU8Array[3];
  } else {
    result.x = scratchU8Array[3];
    result.y = scratchU8Array[2];
    result.z = scratchU8Array[1];
    result.w = scratchU8Array[0];
  }
  return result;
};
Cartesian4.unpackFloat = function(packedFloat) {
  Check_default.typeOf.object("packedFloat", packedFloat);
  if (littleEndian) {
    scratchU8Array[0] = packedFloat.x;
    scratchU8Array[1] = packedFloat.y;
    scratchU8Array[2] = packedFloat.z;
    scratchU8Array[3] = packedFloat.w;
  } else {
    scratchU8Array[0] = packedFloat.w;
    scratchU8Array[1] = packedFloat.z;
    scratchU8Array[2] = packedFloat.y;
    scratchU8Array[3] = packedFloat.x;
  }
  return scratchF32Array[0];
};
var Cartesian4_default = Cartesian4;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Matrix3.js
function Matrix3(column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {
  this[0] = defaultValue_default(column0Row0, 0);
  this[1] = defaultValue_default(column0Row1, 0);
  this[2] = defaultValue_default(column0Row2, 0);
  this[3] = defaultValue_default(column1Row0, 0);
  this[4] = defaultValue_default(column1Row1, 0);
  this[5] = defaultValue_default(column1Row2, 0);
  this[6] = defaultValue_default(column2Row0, 0);
  this[7] = defaultValue_default(column2Row1, 0);
  this[8] = defaultValue_default(column2Row2, 0);
}
Matrix3.packedLength = 9;
Matrix3.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value[0];
  array[startingIndex++] = value[1];
  array[startingIndex++] = value[2];
  array[startingIndex++] = value[3];
  array[startingIndex++] = value[4];
  array[startingIndex++] = value[5];
  array[startingIndex++] = value[6];
  array[startingIndex++] = value[7];
  array[startingIndex++] = value[8];
  return array;
};
Matrix3.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Matrix3();
  }
  result[0] = array[startingIndex++];
  result[1] = array[startingIndex++];
  result[2] = array[startingIndex++];
  result[3] = array[startingIndex++];
  result[4] = array[startingIndex++];
  result[5] = array[startingIndex++];
  result[6] = array[startingIndex++];
  result[7] = array[startingIndex++];
  result[8] = array[startingIndex++];
  return result;
};
Matrix3.packArray = function(array, result) {
  Check_default.defined("array", array);
  const length = array.length;
  const resultLength = length * 9;
  if (!defined_default(result)) {
    result = new Array(resultLength);
  } else if (!Array.isArray(result) && result.length !== resultLength) {
    throw new DeveloperError_default(
      "If result is a typed array, it must have exactly array.length * 9 elements"
    );
  } else if (result.length !== resultLength) {
    result.length = resultLength;
  }
  for (let i = 0; i < length; ++i) {
    Matrix3.pack(array[i], result, i * 9);
  }
  return result;
};
Matrix3.unpackArray = function(array, result) {
  Check_default.defined("array", array);
  Check_default.typeOf.number.greaterThanOrEquals("array.length", array.length, 9);
  if (array.length % 9 !== 0) {
    throw new DeveloperError_default("array length must be a multiple of 9.");
  }
  const length = array.length;
  if (!defined_default(result)) {
    result = new Array(length / 9);
  } else {
    result.length = length / 9;
  }
  for (let i = 0; i < length; i += 9) {
    const index = i / 9;
    result[index] = Matrix3.unpack(array, i, result[index]);
  }
  return result;
};
Matrix3.clone = function(matrix, result) {
  if (!defined_default(matrix)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Matrix3(
      matrix[0],
      matrix[3],
      matrix[6],
      matrix[1],
      matrix[4],
      matrix[7],
      matrix[2],
      matrix[5],
      matrix[8]
    );
  }
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  result[4] = matrix[4];
  result[5] = matrix[5];
  result[6] = matrix[6];
  result[7] = matrix[7];
  result[8] = matrix[8];
  return result;
};
Matrix3.fromArray = Matrix3.unpack;
Matrix3.fromColumnMajorArray = function(values, result) {
  Check_default.defined("values", values);
  return Matrix3.clone(values, result);
};
Matrix3.fromRowMajorArray = function(values, result) {
  Check_default.defined("values", values);
  if (!defined_default(result)) {
    return new Matrix3(
      values[0],
      values[1],
      values[2],
      values[3],
      values[4],
      values[5],
      values[6],
      values[7],
      values[8]
    );
  }
  result[0] = values[0];
  result[1] = values[3];
  result[2] = values[6];
  result[3] = values[1];
  result[4] = values[4];
  result[5] = values[7];
  result[6] = values[2];
  result[7] = values[5];
  result[8] = values[8];
  return result;
};
Matrix3.fromQuaternion = function(quaternion, result) {
  Check_default.typeOf.object("quaternion", quaternion);
  const x2 = quaternion.x * quaternion.x;
  const xy = quaternion.x * quaternion.y;
  const xz = quaternion.x * quaternion.z;
  const xw = quaternion.x * quaternion.w;
  const y2 = quaternion.y * quaternion.y;
  const yz = quaternion.y * quaternion.z;
  const yw = quaternion.y * quaternion.w;
  const z2 = quaternion.z * quaternion.z;
  const zw = quaternion.z * quaternion.w;
  const w2 = quaternion.w * quaternion.w;
  const m00 = x2 - y2 - z2 + w2;
  const m01 = 2 * (xy - zw);
  const m02 = 2 * (xz + yw);
  const m10 = 2 * (xy + zw);
  const m11 = -x2 + y2 - z2 + w2;
  const m12 = 2 * (yz - xw);
  const m20 = 2 * (xz - yw);
  const m21 = 2 * (yz + xw);
  const m22 = -x2 - y2 + z2 + w2;
  if (!defined_default(result)) {
    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
  }
  result[0] = m00;
  result[1] = m10;
  result[2] = m20;
  result[3] = m01;
  result[4] = m11;
  result[5] = m21;
  result[6] = m02;
  result[7] = m12;
  result[8] = m22;
  return result;
};
Matrix3.fromHeadingPitchRoll = function(headingPitchRoll, result) {
  Check_default.typeOf.object("headingPitchRoll", headingPitchRoll);
  const cosTheta = Math.cos(-headingPitchRoll.pitch);
  const cosPsi = Math.cos(-headingPitchRoll.heading);
  const cosPhi = Math.cos(headingPitchRoll.roll);
  const sinTheta = Math.sin(-headingPitchRoll.pitch);
  const sinPsi = Math.sin(-headingPitchRoll.heading);
  const sinPhi = Math.sin(headingPitchRoll.roll);
  const m00 = cosTheta * cosPsi;
  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;
  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;
  const m10 = cosTheta * sinPsi;
  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;
  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;
  const m20 = -sinTheta;
  const m21 = sinPhi * cosTheta;
  const m22 = cosPhi * cosTheta;
  if (!defined_default(result)) {
    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
  }
  result[0] = m00;
  result[1] = m10;
  result[2] = m20;
  result[3] = m01;
  result[4] = m11;
  result[5] = m21;
  result[6] = m02;
  result[7] = m12;
  result[8] = m22;
  return result;
};
Matrix3.fromScale = function(scale, result) {
  Check_default.typeOf.object("scale", scale);
  if (!defined_default(result)) {
    return new Matrix3(scale.x, 0, 0, 0, scale.y, 0, 0, 0, scale.z);
  }
  result[0] = scale.x;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = scale.y;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = scale.z;
  return result;
};
Matrix3.fromUniformScale = function(scale, result) {
  Check_default.typeOf.number("scale", scale);
  if (!defined_default(result)) {
    return new Matrix3(scale, 0, 0, 0, scale, 0, 0, 0, scale);
  }
  result[0] = scale;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = scale;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = scale;
  return result;
};
Matrix3.fromCrossProduct = function(vector, result) {
  Check_default.typeOf.object("vector", vector);
  if (!defined_default(result)) {
    return new Matrix3(
      0,
      -vector.z,
      vector.y,
      vector.z,
      0,
      -vector.x,
      -vector.y,
      vector.x,
      0
    );
  }
  result[0] = 0;
  result[1] = vector.z;
  result[2] = -vector.y;
  result[3] = -vector.z;
  result[4] = 0;
  result[5] = vector.x;
  result[6] = vector.y;
  result[7] = -vector.x;
  result[8] = 0;
  return result;
};
Matrix3.fromRotationX = function(angle, result) {
  Check_default.typeOf.number("angle", angle);
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  if (!defined_default(result)) {
    return new Matrix3(
      1,
      0,
      0,
      0,
      cosAngle,
      -sinAngle,
      0,
      sinAngle,
      cosAngle
    );
  }
  result[0] = 1;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = cosAngle;
  result[5] = sinAngle;
  result[6] = 0;
  result[7] = -sinAngle;
  result[8] = cosAngle;
  return result;
};
Matrix3.fromRotationY = function(angle, result) {
  Check_default.typeOf.number("angle", angle);
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  if (!defined_default(result)) {
    return new Matrix3(
      cosAngle,
      0,
      sinAngle,
      0,
      1,
      0,
      -sinAngle,
      0,
      cosAngle
    );
  }
  result[0] = cosAngle;
  result[1] = 0;
  result[2] = -sinAngle;
  result[3] = 0;
  result[4] = 1;
  result[5] = 0;
  result[6] = sinAngle;
  result[7] = 0;
  result[8] = cosAngle;
  return result;
};
Matrix3.fromRotationZ = function(angle, result) {
  Check_default.typeOf.number("angle", angle);
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  if (!defined_default(result)) {
    return new Matrix3(
      cosAngle,
      -sinAngle,
      0,
      sinAngle,
      cosAngle,
      0,
      0,
      0,
      1
    );
  }
  result[0] = cosAngle;
  result[1] = sinAngle;
  result[2] = 0;
  result[3] = -sinAngle;
  result[4] = cosAngle;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 1;
  return result;
};
Matrix3.toArray = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  if (!defined_default(result)) {
    return [
      matrix[0],
      matrix[1],
      matrix[2],
      matrix[3],
      matrix[4],
      matrix[5],
      matrix[6],
      matrix[7],
      matrix[8]
    ];
  }
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  result[4] = matrix[4];
  result[5] = matrix[5];
  result[6] = matrix[6];
  result[7] = matrix[7];
  result[8] = matrix[8];
  return result;
};
Matrix3.getElementIndex = function(column, row) {
  Check_default.typeOf.number.greaterThanOrEquals("row", row, 0);
  Check_default.typeOf.number.lessThanOrEquals("row", row, 2);
  Check_default.typeOf.number.greaterThanOrEquals("column", column, 0);
  Check_default.typeOf.number.lessThanOrEquals("column", column, 2);
  return column * 3 + row;
};
Matrix3.getColumn = function(matrix, index, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 2);
  Check_default.typeOf.object("result", result);
  const startIndex = index * 3;
  const x = matrix[startIndex];
  const y = matrix[startIndex + 1];
  const z = matrix[startIndex + 2];
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Matrix3.setColumn = function(matrix, index, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 2);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result = Matrix3.clone(matrix, result);
  const startIndex = index * 3;
  result[startIndex] = cartesian.x;
  result[startIndex + 1] = cartesian.y;
  result[startIndex + 2] = cartesian.z;
  return result;
};
Matrix3.getRow = function(matrix, index, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 2);
  Check_default.typeOf.object("result", result);
  const x = matrix[index];
  const y = matrix[index + 3];
  const z = matrix[index + 6];
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Matrix3.setRow = function(matrix, index, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 2);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result = Matrix3.clone(matrix, result);
  result[index] = cartesian.x;
  result[index + 3] = cartesian.y;
  result[index + 6] = cartesian.z;
  return result;
};
var scaleScratch1 = new Cartesian3_default();
Matrix3.setScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("scale", scale);
  Check_default.typeOf.object("result", result);
  const existingScale = Matrix3.getScale(matrix, scaleScratch1);
  const scaleRatioX = scale.x / existingScale.x;
  const scaleRatioY = scale.y / existingScale.y;
  const scaleRatioZ = scale.z / existingScale.z;
  result[0] = matrix[0] * scaleRatioX;
  result[1] = matrix[1] * scaleRatioX;
  result[2] = matrix[2] * scaleRatioX;
  result[3] = matrix[3] * scaleRatioY;
  result[4] = matrix[4] * scaleRatioY;
  result[5] = matrix[5] * scaleRatioY;
  result[6] = matrix[6] * scaleRatioZ;
  result[7] = matrix[7] * scaleRatioZ;
  result[8] = matrix[8] * scaleRatioZ;
  return result;
};
var scaleScratch2 = new Cartesian3_default();
Matrix3.setUniformScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scale", scale);
  Check_default.typeOf.object("result", result);
  const existingScale = Matrix3.getScale(matrix, scaleScratch2);
  const scaleRatioX = scale / existingScale.x;
  const scaleRatioY = scale / existingScale.y;
  const scaleRatioZ = scale / existingScale.z;
  result[0] = matrix[0] * scaleRatioX;
  result[1] = matrix[1] * scaleRatioX;
  result[2] = matrix[2] * scaleRatioX;
  result[3] = matrix[3] * scaleRatioY;
  result[4] = matrix[4] * scaleRatioY;
  result[5] = matrix[5] * scaleRatioY;
  result[6] = matrix[6] * scaleRatioZ;
  result[7] = matrix[7] * scaleRatioZ;
  result[8] = matrix[8] * scaleRatioZ;
  return result;
};
var scratchColumn = new Cartesian3_default();
Matrix3.getScale = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result.x = Cartesian3_default.magnitude(
    Cartesian3_default.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)
  );
  result.y = Cartesian3_default.magnitude(
    Cartesian3_default.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn)
  );
  result.z = Cartesian3_default.magnitude(
    Cartesian3_default.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn)
  );
  return result;
};
var scaleScratch3 = new Cartesian3_default();
Matrix3.getMaximumScale = function(matrix) {
  Matrix3.getScale(matrix, scaleScratch3);
  return Cartesian3_default.maximumComponent(scaleScratch3);
};
var scaleScratch4 = new Cartesian3_default();
Matrix3.setRotation = function(matrix, rotation, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const scale = Matrix3.getScale(matrix, scaleScratch4);
  result[0] = rotation[0] * scale.x;
  result[1] = rotation[1] * scale.x;
  result[2] = rotation[2] * scale.x;
  result[3] = rotation[3] * scale.y;
  result[4] = rotation[4] * scale.y;
  result[5] = rotation[5] * scale.y;
  result[6] = rotation[6] * scale.z;
  result[7] = rotation[7] * scale.z;
  result[8] = rotation[8] * scale.z;
  return result;
};
var scaleScratch5 = new Cartesian3_default();
Matrix3.getRotation = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const scale = Matrix3.getScale(matrix, scaleScratch5);
  result[0] = matrix[0] / scale.x;
  result[1] = matrix[1] / scale.x;
  result[2] = matrix[2] / scale.x;
  result[3] = matrix[3] / scale.y;
  result[4] = matrix[4] / scale.y;
  result[5] = matrix[5] / scale.y;
  result[6] = matrix[6] / scale.z;
  result[7] = matrix[7] / scale.z;
  result[8] = matrix[8] / scale.z;
  return result;
};
Matrix3.multiply = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  const column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
  const column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
  const column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];
  const column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
  const column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
  const column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];
  const column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
  const column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
  const column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];
  result[0] = column0Row0;
  result[1] = column0Row1;
  result[2] = column0Row2;
  result[3] = column1Row0;
  result[4] = column1Row1;
  result[5] = column1Row2;
  result[6] = column2Row0;
  result[7] = column2Row1;
  result[8] = column2Row2;
  return result;
};
Matrix3.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result[0] = left[0] + right[0];
  result[1] = left[1] + right[1];
  result[2] = left[2] + right[2];
  result[3] = left[3] + right[3];
  result[4] = left[4] + right[4];
  result[5] = left[5] + right[5];
  result[6] = left[6] + right[6];
  result[7] = left[7] + right[7];
  result[8] = left[8] + right[8];
  return result;
};
Matrix3.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result[0] = left[0] - right[0];
  result[1] = left[1] - right[1];
  result[2] = left[2] - right[2];
  result[3] = left[3] - right[3];
  result[4] = left[4] - right[4];
  result[5] = left[5] - right[5];
  result[6] = left[6] - right[6];
  result[7] = left[7] - right[7];
  result[8] = left[8] - right[8];
  return result;
};
Matrix3.multiplyByVector = function(matrix, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const vX = cartesian.x;
  const vY = cartesian.y;
  const vZ = cartesian.z;
  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Matrix3.multiplyByScalar = function(matrix, scalar, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scalar;
  result[1] = matrix[1] * scalar;
  result[2] = matrix[2] * scalar;
  result[3] = matrix[3] * scalar;
  result[4] = matrix[4] * scalar;
  result[5] = matrix[5] * scalar;
  result[6] = matrix[6] * scalar;
  result[7] = matrix[7] * scalar;
  result[8] = matrix[8] * scalar;
  return result;
};
Matrix3.multiplyByScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("scale", scale);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scale.x;
  result[1] = matrix[1] * scale.x;
  result[2] = matrix[2] * scale.x;
  result[3] = matrix[3] * scale.y;
  result[4] = matrix[4] * scale.y;
  result[5] = matrix[5] * scale.y;
  result[6] = matrix[6] * scale.z;
  result[7] = matrix[7] * scale.z;
  result[8] = matrix[8] * scale.z;
  return result;
};
Matrix3.multiplyByUniformScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scale", scale);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scale;
  result[1] = matrix[1] * scale;
  result[2] = matrix[2] * scale;
  result[3] = matrix[3] * scale;
  result[4] = matrix[4] * scale;
  result[5] = matrix[5] * scale;
  result[6] = matrix[6] * scale;
  result[7] = matrix[7] * scale;
  result[8] = matrix[8] * scale;
  return result;
};
Matrix3.negate = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result[0] = -matrix[0];
  result[1] = -matrix[1];
  result[2] = -matrix[2];
  result[3] = -matrix[3];
  result[4] = -matrix[4];
  result[5] = -matrix[5];
  result[6] = -matrix[6];
  result[7] = -matrix[7];
  result[8] = -matrix[8];
  return result;
};
Matrix3.transpose = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const column0Row0 = matrix[0];
  const column0Row1 = matrix[3];
  const column0Row2 = matrix[6];
  const column1Row0 = matrix[1];
  const column1Row1 = matrix[4];
  const column1Row2 = matrix[7];
  const column2Row0 = matrix[2];
  const column2Row1 = matrix[5];
  const column2Row2 = matrix[8];
  result[0] = column0Row0;
  result[1] = column0Row1;
  result[2] = column0Row2;
  result[3] = column1Row0;
  result[4] = column1Row1;
  result[5] = column1Row2;
  result[6] = column2Row0;
  result[7] = column2Row1;
  result[8] = column2Row2;
  return result;
};
function computeFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i = 0; i < 9; ++i) {
    const temp = matrix[i];
    norm += temp * temp;
  }
  return Math.sqrt(norm);
}
var rowVal = [1, 0, 0];
var colVal = [2, 2, 1];
function offDiagonalFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i = 0; i < 3; ++i) {
    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
    norm += 2 * temp * temp;
  }
  return Math.sqrt(norm);
}
function shurDecomposition(matrix, result) {
  const tolerance = Math_default.EPSILON15;
  let maxDiagonal = 0;
  let rotAxis = 1;
  for (let i = 0; i < 3; ++i) {
    const temp = Math.abs(
      matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]
    );
    if (temp > maxDiagonal) {
      rotAxis = i;
      maxDiagonal = temp;
    }
  }
  let c = 1;
  let s = 0;
  const p = rowVal[rotAxis];
  const q = colVal[rotAxis];
  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
    const qq = matrix[Matrix3.getElementIndex(q, q)];
    const pp = matrix[Matrix3.getElementIndex(p, p)];
    const qp = matrix[Matrix3.getElementIndex(q, p)];
    const tau = (qq - pp) / 2 / qp;
    let t;
    if (tau < 0) {
      t = -1 / (-tau + Math.sqrt(1 + tau * tau));
    } else {
      t = 1 / (tau + Math.sqrt(1 + tau * tau));
    }
    c = 1 / Math.sqrt(1 + t * t);
    s = t * c;
  }
  result = Matrix3.clone(Matrix3.IDENTITY, result);
  result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;
  result[Matrix3.getElementIndex(q, p)] = s;
  result[Matrix3.getElementIndex(p, q)] = -s;
  return result;
}
var jMatrix = new Matrix3();
var jMatrixTranspose = new Matrix3();
Matrix3.computeEigenDecomposition = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  const tolerance = Math_default.EPSILON20;
  const maxSweeps = 10;
  let count = 0;
  let sweep = 0;
  if (!defined_default(result)) {
    result = {};
  }
  const unitaryMatrix = result.unitary = Matrix3.clone(
    Matrix3.IDENTITY,
    result.unitary
  );
  const diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);
  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);
  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
    shurDecomposition(diagMatrix, jMatrix);
    Matrix3.transpose(jMatrix, jMatrixTranspose);
    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);
    if (++count > 2) {
      ++sweep;
      count = 0;
    }
  }
  return result;
};
Matrix3.abs = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result[0] = Math.abs(matrix[0]);
  result[1] = Math.abs(matrix[1]);
  result[2] = Math.abs(matrix[2]);
  result[3] = Math.abs(matrix[3]);
  result[4] = Math.abs(matrix[4]);
  result[5] = Math.abs(matrix[5]);
  result[6] = Math.abs(matrix[6]);
  result[7] = Math.abs(matrix[7]);
  result[8] = Math.abs(matrix[8]);
  return result;
};
Matrix3.determinant = function(matrix) {
  Check_default.typeOf.object("matrix", matrix);
  const m11 = matrix[0];
  const m21 = matrix[3];
  const m31 = matrix[6];
  const m12 = matrix[1];
  const m22 = matrix[4];
  const m32 = matrix[7];
  const m13 = matrix[2];
  const m23 = matrix[5];
  const m33 = matrix[8];
  return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
};
Matrix3.inverse = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const m11 = matrix[0];
  const m21 = matrix[1];
  const m31 = matrix[2];
  const m12 = matrix[3];
  const m22 = matrix[4];
  const m32 = matrix[5];
  const m13 = matrix[6];
  const m23 = matrix[7];
  const m33 = matrix[8];
  const determinant = Matrix3.determinant(matrix);
  if (Math.abs(determinant) <= Math_default.EPSILON15) {
    throw new DeveloperError_default("matrix is not invertible");
  }
  result[0] = m22 * m33 - m23 * m32;
  result[1] = m23 * m31 - m21 * m33;
  result[2] = m21 * m32 - m22 * m31;
  result[3] = m13 * m32 - m12 * m33;
  result[4] = m11 * m33 - m13 * m31;
  result[5] = m12 * m31 - m11 * m32;
  result[6] = m12 * m23 - m13 * m22;
  result[7] = m13 * m21 - m11 * m23;
  result[8] = m11 * m22 - m12 * m21;
  const scale = 1 / determinant;
  return Matrix3.multiplyByScalar(result, scale, result);
};
var scratchTransposeMatrix = new Matrix3();
Matrix3.inverseTranspose = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  return Matrix3.inverse(
    Matrix3.transpose(matrix, scratchTransposeMatrix),
    result
  );
};
Matrix3.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8];
};
Matrix3.equalsEpsilon = function(left, right, epsilon) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon;
};
Matrix3.IDENTITY = Object.freeze(
  new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1)
);
Matrix3.ZERO = Object.freeze(
  new Matrix3(0, 0, 0, 0, 0, 0, 0, 0, 0)
);
Matrix3.COLUMN0ROW0 = 0;
Matrix3.COLUMN0ROW1 = 1;
Matrix3.COLUMN0ROW2 = 2;
Matrix3.COLUMN1ROW0 = 3;
Matrix3.COLUMN1ROW1 = 4;
Matrix3.COLUMN1ROW2 = 5;
Matrix3.COLUMN2ROW0 = 6;
Matrix3.COLUMN2ROW1 = 7;
Matrix3.COLUMN2ROW2 = 8;
Object.defineProperties(Matrix3.prototype, {
  length: {
    get: function() {
      return Matrix3.packedLength;
    }
  }
});
Matrix3.prototype.clone = function(result) {
  return Matrix3.clone(this, result);
};
Matrix3.prototype.equals = function(right) {
  return Matrix3.equals(this, right);
};
Matrix3.equalsArray = function(matrix, array, offset) {
  return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8];
};
Matrix3.prototype.equalsEpsilon = function(right, epsilon) {
  return Matrix3.equalsEpsilon(this, right, epsilon);
};
Matrix3.prototype.toString = function() {
  return `(${this[0]}, ${this[3]}, ${this[6]})
(${this[1]}, ${this[4]}, ${this[7]})
(${this[2]}, ${this[5]}, ${this[8]})`;
};
var Matrix3_default = Matrix3;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/RuntimeError.js
function RuntimeError(message) {
  this.name = "RuntimeError";
  this.message = message;
  let stack;
  try {
    throw new Error();
  } catch (e) {
    stack = e.stack;
  }
  this.stack = stack;
}
if (defined_default(Object.create)) {
  RuntimeError.prototype = Object.create(Error.prototype);
  RuntimeError.prototype.constructor = RuntimeError;
}
RuntimeError.prototype.toString = function() {
  let str = `${this.name}: ${this.message}`;
  if (defined_default(this.stack)) {
    str += `
${this.stack.toString()}`;
  }
  return str;
};
var RuntimeError_default = RuntimeError;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Matrix4.js
function Matrix4(column0Row0, column1Row0, column2Row0, column3Row0, column0Row1, column1Row1, column2Row1, column3Row1, column0Row2, column1Row2, column2Row2, column3Row2, column0Row3, column1Row3, column2Row3, column3Row3) {
  this[0] = defaultValue_default(column0Row0, 0);
  this[1] = defaultValue_default(column0Row1, 0);
  this[2] = defaultValue_default(column0Row2, 0);
  this[3] = defaultValue_default(column0Row3, 0);
  this[4] = defaultValue_default(column1Row0, 0);
  this[5] = defaultValue_default(column1Row1, 0);
  this[6] = defaultValue_default(column1Row2, 0);
  this[7] = defaultValue_default(column1Row3, 0);
  this[8] = defaultValue_default(column2Row0, 0);
  this[9] = defaultValue_default(column2Row1, 0);
  this[10] = defaultValue_default(column2Row2, 0);
  this[11] = defaultValue_default(column2Row3, 0);
  this[12] = defaultValue_default(column3Row0, 0);
  this[13] = defaultValue_default(column3Row1, 0);
  this[14] = defaultValue_default(column3Row2, 0);
  this[15] = defaultValue_default(column3Row3, 0);
}
Matrix4.packedLength = 16;
Matrix4.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value[0];
  array[startingIndex++] = value[1];
  array[startingIndex++] = value[2];
  array[startingIndex++] = value[3];
  array[startingIndex++] = value[4];
  array[startingIndex++] = value[5];
  array[startingIndex++] = value[6];
  array[startingIndex++] = value[7];
  array[startingIndex++] = value[8];
  array[startingIndex++] = value[9];
  array[startingIndex++] = value[10];
  array[startingIndex++] = value[11];
  array[startingIndex++] = value[12];
  array[startingIndex++] = value[13];
  array[startingIndex++] = value[14];
  array[startingIndex] = value[15];
  return array;
};
Matrix4.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Matrix4();
  }
  result[0] = array[startingIndex++];
  result[1] = array[startingIndex++];
  result[2] = array[startingIndex++];
  result[3] = array[startingIndex++];
  result[4] = array[startingIndex++];
  result[5] = array[startingIndex++];
  result[6] = array[startingIndex++];
  result[7] = array[startingIndex++];
  result[8] = array[startingIndex++];
  result[9] = array[startingIndex++];
  result[10] = array[startingIndex++];
  result[11] = array[startingIndex++];
  result[12] = array[startingIndex++];
  result[13] = array[startingIndex++];
  result[14] = array[startingIndex++];
  result[15] = array[startingIndex];
  return result;
};
Matrix4.packArray = function(array, result) {
  Check_default.defined("array", array);
  const length = array.length;
  const resultLength = length * 16;
  if (!defined_default(result)) {
    result = new Array(resultLength);
  } else if (!Array.isArray(result) && result.length !== resultLength) {
    throw new DeveloperError_default(
      "If result is a typed array, it must have exactly array.length * 16 elements"
    );
  } else if (result.length !== resultLength) {
    result.length = resultLength;
  }
  for (let i = 0; i < length; ++i) {
    Matrix4.pack(array[i], result, i * 16);
  }
  return result;
};
Matrix4.unpackArray = function(array, result) {
  Check_default.defined("array", array);
  Check_default.typeOf.number.greaterThanOrEquals("array.length", array.length, 16);
  if (array.length % 16 !== 0) {
    throw new DeveloperError_default("array length must be a multiple of 16.");
  }
  const length = array.length;
  if (!defined_default(result)) {
    result = new Array(length / 16);
  } else {
    result.length = length / 16;
  }
  for (let i = 0; i < length; i += 16) {
    const index = i / 16;
    result[index] = Matrix4.unpack(array, i, result[index]);
  }
  return result;
};
Matrix4.clone = function(matrix, result) {
  if (!defined_default(matrix)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Matrix4(
      matrix[0],
      matrix[4],
      matrix[8],
      matrix[12],
      matrix[1],
      matrix[5],
      matrix[9],
      matrix[13],
      matrix[2],
      matrix[6],
      matrix[10],
      matrix[14],
      matrix[3],
      matrix[7],
      matrix[11],
      matrix[15]
    );
  }
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  result[4] = matrix[4];
  result[5] = matrix[5];
  result[6] = matrix[6];
  result[7] = matrix[7];
  result[8] = matrix[8];
  result[9] = matrix[9];
  result[10] = matrix[10];
  result[11] = matrix[11];
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
Matrix4.fromArray = Matrix4.unpack;
Matrix4.fromColumnMajorArray = function(values, result) {
  Check_default.defined("values", values);
  return Matrix4.clone(values, result);
};
Matrix4.fromRowMajorArray = function(values, result) {
  Check_default.defined("values", values);
  if (!defined_default(result)) {
    return new Matrix4(
      values[0],
      values[1],
      values[2],
      values[3],
      values[4],
      values[5],
      values[6],
      values[7],
      values[8],
      values[9],
      values[10],
      values[11],
      values[12],
      values[13],
      values[14],
      values[15]
    );
  }
  result[0] = values[0];
  result[1] = values[4];
  result[2] = values[8];
  result[3] = values[12];
  result[4] = values[1];
  result[5] = values[5];
  result[6] = values[9];
  result[7] = values[13];
  result[8] = values[2];
  result[9] = values[6];
  result[10] = values[10];
  result[11] = values[14];
  result[12] = values[3];
  result[13] = values[7];
  result[14] = values[11];
  result[15] = values[15];
  return result;
};
Matrix4.fromRotationTranslation = function(rotation, translation, result) {
  Check_default.typeOf.object("rotation", rotation);
  translation = defaultValue_default(translation, Cartesian3_default.ZERO);
  if (!defined_default(result)) {
    return new Matrix4(
      rotation[0],
      rotation[3],
      rotation[6],
      translation.x,
      rotation[1],
      rotation[4],
      rotation[7],
      translation.y,
      rotation[2],
      rotation[5],
      rotation[8],
      translation.z,
      0,
      0,
      0,
      1
    );
  }
  result[0] = rotation[0];
  result[1] = rotation[1];
  result[2] = rotation[2];
  result[3] = 0;
  result[4] = rotation[3];
  result[5] = rotation[4];
  result[6] = rotation[5];
  result[7] = 0;
  result[8] = rotation[6];
  result[9] = rotation[7];
  result[10] = rotation[8];
  result[11] = 0;
  result[12] = translation.x;
  result[13] = translation.y;
  result[14] = translation.z;
  result[15] = 1;
  return result;
};
Matrix4.fromTranslationQuaternionRotationScale = function(translation, rotation, scale, result) {
  Check_default.typeOf.object("translation", translation);
  Check_default.typeOf.object("rotation", rotation);
  Check_default.typeOf.object("scale", scale);
  if (!defined_default(result)) {
    result = new Matrix4();
  }
  const scaleX = scale.x;
  const scaleY = scale.y;
  const scaleZ = scale.z;
  const x2 = rotation.x * rotation.x;
  const xy = rotation.x * rotation.y;
  const xz = rotation.x * rotation.z;
  const xw = rotation.x * rotation.w;
  const y2 = rotation.y * rotation.y;
  const yz = rotation.y * rotation.z;
  const yw = rotation.y * rotation.w;
  const z2 = rotation.z * rotation.z;
  const zw = rotation.z * rotation.w;
  const w2 = rotation.w * rotation.w;
  const m00 = x2 - y2 - z2 + w2;
  const m01 = 2 * (xy - zw);
  const m02 = 2 * (xz + yw);
  const m10 = 2 * (xy + zw);
  const m11 = -x2 + y2 - z2 + w2;
  const m12 = 2 * (yz - xw);
  const m20 = 2 * (xz - yw);
  const m21 = 2 * (yz + xw);
  const m22 = -x2 - y2 + z2 + w2;
  result[0] = m00 * scaleX;
  result[1] = m10 * scaleX;
  result[2] = m20 * scaleX;
  result[3] = 0;
  result[4] = m01 * scaleY;
  result[5] = m11 * scaleY;
  result[6] = m21 * scaleY;
  result[7] = 0;
  result[8] = m02 * scaleZ;
  result[9] = m12 * scaleZ;
  result[10] = m22 * scaleZ;
  result[11] = 0;
  result[12] = translation.x;
  result[13] = translation.y;
  result[14] = translation.z;
  result[15] = 1;
  return result;
};
Matrix4.fromTranslationRotationScale = function(translationRotationScale, result) {
  Check_default.typeOf.object("translationRotationScale", translationRotationScale);
  return Matrix4.fromTranslationQuaternionRotationScale(
    translationRotationScale.translation,
    translationRotationScale.rotation,
    translationRotationScale.scale,
    result
  );
};
Matrix4.fromTranslation = function(translation, result) {
  Check_default.typeOf.object("translation", translation);
  return Matrix4.fromRotationTranslation(Matrix3_default.IDENTITY, translation, result);
};
Matrix4.fromScale = function(scale, result) {
  Check_default.typeOf.object("scale", scale);
  if (!defined_default(result)) {
    return new Matrix4(
      scale.x,
      0,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      0,
      scale.z,
      0,
      0,
      0,
      0,
      1
    );
  }
  result[0] = scale.x;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = scale.y;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = scale.z;
  result[11] = 0;
  result[12] = 0;
  result[13] = 0;
  result[14] = 0;
  result[15] = 1;
  return result;
};
Matrix4.fromUniformScale = function(scale, result) {
  Check_default.typeOf.number("scale", scale);
  if (!defined_default(result)) {
    return new Matrix4(
      scale,
      0,
      0,
      0,
      0,
      scale,
      0,
      0,
      0,
      0,
      scale,
      0,
      0,
      0,
      0,
      1
    );
  }
  result[0] = scale;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = scale;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = scale;
  result[11] = 0;
  result[12] = 0;
  result[13] = 0;
  result[14] = 0;
  result[15] = 1;
  return result;
};
Matrix4.fromRotation = function(rotation, result) {
  Check_default.typeOf.object("rotation", rotation);
  if (!defined_default(result)) {
    result = new Matrix4();
  }
  result[0] = rotation[0];
  result[1] = rotation[1];
  result[2] = rotation[2];
  result[3] = 0;
  result[4] = rotation[3];
  result[5] = rotation[4];
  result[6] = rotation[5];
  result[7] = 0;
  result[8] = rotation[6];
  result[9] = rotation[7];
  result[10] = rotation[8];
  result[11] = 0;
  result[12] = 0;
  result[13] = 0;
  result[14] = 0;
  result[15] = 1;
  return result;
};
var fromCameraF = new Cartesian3_default();
var fromCameraR = new Cartesian3_default();
var fromCameraU = new Cartesian3_default();
Matrix4.fromCamera = function(camera, result) {
  Check_default.typeOf.object("camera", camera);
  const position = camera.position;
  const direction2 = camera.direction;
  const up = camera.up;
  Check_default.typeOf.object("camera.position", position);
  Check_default.typeOf.object("camera.direction", direction2);
  Check_default.typeOf.object("camera.up", up);
  Cartesian3_default.normalize(direction2, fromCameraF);
  Cartesian3_default.normalize(
    Cartesian3_default.cross(fromCameraF, up, fromCameraR),
    fromCameraR
  );
  Cartesian3_default.normalize(
    Cartesian3_default.cross(fromCameraR, fromCameraF, fromCameraU),
    fromCameraU
  );
  const sX = fromCameraR.x;
  const sY = fromCameraR.y;
  const sZ = fromCameraR.z;
  const fX = fromCameraF.x;
  const fY = fromCameraF.y;
  const fZ = fromCameraF.z;
  const uX = fromCameraU.x;
  const uY = fromCameraU.y;
  const uZ = fromCameraU.z;
  const positionX = position.x;
  const positionY = position.y;
  const positionZ = position.z;
  const t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;
  const t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;
  const t2 = fX * positionX + fY * positionY + fZ * positionZ;
  if (!defined_default(result)) {
    return new Matrix4(
      sX,
      sY,
      sZ,
      t0,
      uX,
      uY,
      uZ,
      t1,
      -fX,
      -fY,
      -fZ,
      t2,
      0,
      0,
      0,
      1
    );
  }
  result[0] = sX;
  result[1] = uX;
  result[2] = -fX;
  result[3] = 0;
  result[4] = sY;
  result[5] = uY;
  result[6] = -fY;
  result[7] = 0;
  result[8] = sZ;
  result[9] = uZ;
  result[10] = -fZ;
  result[11] = 0;
  result[12] = t0;
  result[13] = t1;
  result[14] = t2;
  result[15] = 1;
  return result;
};
Matrix4.computePerspectiveFieldOfView = function(fovY, aspectRatio, near, far, result) {
  Check_default.typeOf.number.greaterThan("fovY", fovY, 0);
  Check_default.typeOf.number.lessThan("fovY", fovY, Math.PI);
  Check_default.typeOf.number.greaterThan("near", near, 0);
  Check_default.typeOf.number.greaterThan("far", far, 0);
  Check_default.typeOf.object("result", result);
  const bottom = Math.tan(fovY * 0.5);
  const column1Row1 = 1 / bottom;
  const column0Row0 = column1Row1 / aspectRatio;
  const column2Row2 = (far + near) / (near - far);
  const column3Row2 = 2 * far * near / (near - far);
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = column2Row2;
  result[11] = -1;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
};
Matrix4.computeOrthographicOffCenter = function(left, right, bottom, top, near, far, result) {
  Check_default.typeOf.number("left", left);
  Check_default.typeOf.number("right", right);
  Check_default.typeOf.number("bottom", bottom);
  Check_default.typeOf.number("top", top);
  Check_default.typeOf.number("near", near);
  Check_default.typeOf.number("far", far);
  Check_default.typeOf.object("result", result);
  let a3 = 1 / (right - left);
  let b = 1 / (top - bottom);
  let c = 1 / (far - near);
  const tx = -(right + left) * a3;
  const ty = -(top + bottom) * b;
  const tz = -(far + near) * c;
  a3 *= 2;
  b *= 2;
  c *= -2;
  result[0] = a3;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = b;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = c;
  result[11] = 0;
  result[12] = tx;
  result[13] = ty;
  result[14] = tz;
  result[15] = 1;
  return result;
};
Matrix4.computePerspectiveOffCenter = function(left, right, bottom, top, near, far, result) {
  Check_default.typeOf.number("left", left);
  Check_default.typeOf.number("right", right);
  Check_default.typeOf.number("bottom", bottom);
  Check_default.typeOf.number("top", top);
  Check_default.typeOf.number("near", near);
  Check_default.typeOf.number("far", far);
  Check_default.typeOf.object("result", result);
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -(far + near) / (far - near);
  const column2Row3 = -1;
  const column3Row2 = -2 * far * near / (far - near);
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
};
Matrix4.computeInfinitePerspectiveOffCenter = function(left, right, bottom, top, near, result) {
  Check_default.typeOf.number("left", left);
  Check_default.typeOf.number("right", right);
  Check_default.typeOf.number("bottom", bottom);
  Check_default.typeOf.number("top", top);
  Check_default.typeOf.number("near", near);
  Check_default.typeOf.object("result", result);
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
};
Matrix4.computeViewportTransformation = function(viewport, nearDepthRange, farDepthRange, result) {
  if (!defined_default(result)) {
    result = new Matrix4();
  }
  viewport = defaultValue_default(viewport, defaultValue_default.EMPTY_OBJECT);
  const x = defaultValue_default(viewport.x, 0);
  const y = defaultValue_default(viewport.y, 0);
  const width = defaultValue_default(viewport.width, 0);
  const height = defaultValue_default(viewport.height, 0);
  nearDepthRange = defaultValue_default(nearDepthRange, 0);
  farDepthRange = defaultValue_default(farDepthRange, 1);
  const halfWidth = width * 0.5;
  const halfHeight = height * 0.5;
  const halfDepth = (farDepthRange - nearDepthRange) * 0.5;
  const column0Row0 = halfWidth;
  const column1Row1 = halfHeight;
  const column2Row2 = halfDepth;
  const column3Row0 = x + halfWidth;
  const column3Row1 = y + halfHeight;
  const column3Row2 = nearDepthRange + halfDepth;
  const column3Row3 = 1;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = column2Row2;
  result[11] = 0;
  result[12] = column3Row0;
  result[13] = column3Row1;
  result[14] = column3Row2;
  result[15] = column3Row3;
  return result;
};
Matrix4.computeView = function(position, direction2, up, right, result) {
  Check_default.typeOf.object("position", position);
  Check_default.typeOf.object("direction", direction2);
  Check_default.typeOf.object("up", up);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result[0] = right.x;
  result[1] = up.x;
  result[2] = -direction2.x;
  result[3] = 0;
  result[4] = right.y;
  result[5] = up.y;
  result[6] = -direction2.y;
  result[7] = 0;
  result[8] = right.z;
  result[9] = up.z;
  result[10] = -direction2.z;
  result[11] = 0;
  result[12] = -Cartesian3_default.dot(right, position);
  result[13] = -Cartesian3_default.dot(up, position);
  result[14] = Cartesian3_default.dot(direction2, position);
  result[15] = 1;
  return result;
};
Matrix4.toArray = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  if (!defined_default(result)) {
    return [
      matrix[0],
      matrix[1],
      matrix[2],
      matrix[3],
      matrix[4],
      matrix[5],
      matrix[6],
      matrix[7],
      matrix[8],
      matrix[9],
      matrix[10],
      matrix[11],
      matrix[12],
      matrix[13],
      matrix[14],
      matrix[15]
    ];
  }
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  result[4] = matrix[4];
  result[5] = matrix[5];
  result[6] = matrix[6];
  result[7] = matrix[7];
  result[8] = matrix[8];
  result[9] = matrix[9];
  result[10] = matrix[10];
  result[11] = matrix[11];
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
Matrix4.getElementIndex = function(column, row) {
  Check_default.typeOf.number.greaterThanOrEquals("row", row, 0);
  Check_default.typeOf.number.lessThanOrEquals("row", row, 3);
  Check_default.typeOf.number.greaterThanOrEquals("column", column, 0);
  Check_default.typeOf.number.lessThanOrEquals("column", column, 3);
  return column * 4 + row;
};
Matrix4.getColumn = function(matrix, index, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 3);
  Check_default.typeOf.object("result", result);
  const startIndex = index * 4;
  const x = matrix[startIndex];
  const y = matrix[startIndex + 1];
  const z = matrix[startIndex + 2];
  const w = matrix[startIndex + 3];
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
Matrix4.setColumn = function(matrix, index, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 3);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result = Matrix4.clone(matrix, result);
  const startIndex = index * 4;
  result[startIndex] = cartesian.x;
  result[startIndex + 1] = cartesian.y;
  result[startIndex + 2] = cartesian.z;
  result[startIndex + 3] = cartesian.w;
  return result;
};
Matrix4.getRow = function(matrix, index, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 3);
  Check_default.typeOf.object("result", result);
  const x = matrix[index];
  const y = matrix[index + 4];
  const z = matrix[index + 8];
  const w = matrix[index + 12];
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
Matrix4.setRow = function(matrix, index, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 3);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result = Matrix4.clone(matrix, result);
  result[index] = cartesian.x;
  result[index + 4] = cartesian.y;
  result[index + 8] = cartesian.z;
  result[index + 12] = cartesian.w;
  return result;
};
Matrix4.setTranslation = function(matrix, translation, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("translation", translation);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  result[4] = matrix[4];
  result[5] = matrix[5];
  result[6] = matrix[6];
  result[7] = matrix[7];
  result[8] = matrix[8];
  result[9] = matrix[9];
  result[10] = matrix[10];
  result[11] = matrix[11];
  result[12] = translation.x;
  result[13] = translation.y;
  result[14] = translation.z;
  result[15] = matrix[15];
  return result;
};
var scaleScratch12 = new Cartesian3_default();
Matrix4.setScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("scale", scale);
  Check_default.typeOf.object("result", result);
  const existingScale = Matrix4.getScale(matrix, scaleScratch12);
  const scaleRatioX = scale.x / existingScale.x;
  const scaleRatioY = scale.y / existingScale.y;
  const scaleRatioZ = scale.z / existingScale.z;
  result[0] = matrix[0] * scaleRatioX;
  result[1] = matrix[1] * scaleRatioX;
  result[2] = matrix[2] * scaleRatioX;
  result[3] = matrix[3];
  result[4] = matrix[4] * scaleRatioY;
  result[5] = matrix[5] * scaleRatioY;
  result[6] = matrix[6] * scaleRatioY;
  result[7] = matrix[7];
  result[8] = matrix[8] * scaleRatioZ;
  result[9] = matrix[9] * scaleRatioZ;
  result[10] = matrix[10] * scaleRatioZ;
  result[11] = matrix[11];
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
var scaleScratch22 = new Cartesian3_default();
Matrix4.setUniformScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scale", scale);
  Check_default.typeOf.object("result", result);
  const existingScale = Matrix4.getScale(matrix, scaleScratch22);
  const scaleRatioX = scale / existingScale.x;
  const scaleRatioY = scale / existingScale.y;
  const scaleRatioZ = scale / existingScale.z;
  result[0] = matrix[0] * scaleRatioX;
  result[1] = matrix[1] * scaleRatioX;
  result[2] = matrix[2] * scaleRatioX;
  result[3] = matrix[3];
  result[4] = matrix[4] * scaleRatioY;
  result[5] = matrix[5] * scaleRatioY;
  result[6] = matrix[6] * scaleRatioY;
  result[7] = matrix[7];
  result[8] = matrix[8] * scaleRatioZ;
  result[9] = matrix[9] * scaleRatioZ;
  result[10] = matrix[10] * scaleRatioZ;
  result[11] = matrix[11];
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
var scratchColumn2 = new Cartesian3_default();
Matrix4.getScale = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result.x = Cartesian3_default.magnitude(
    Cartesian3_default.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn2)
  );
  result.y = Cartesian3_default.magnitude(
    Cartesian3_default.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn2)
  );
  result.z = Cartesian3_default.magnitude(
    Cartesian3_default.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn2)
  );
  return result;
};
var scaleScratch32 = new Cartesian3_default();
Matrix4.getMaximumScale = function(matrix) {
  Matrix4.getScale(matrix, scaleScratch32);
  return Cartesian3_default.maximumComponent(scaleScratch32);
};
var scaleScratch42 = new Cartesian3_default();
Matrix4.setRotation = function(matrix, rotation, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const scale = Matrix4.getScale(matrix, scaleScratch42);
  result[0] = rotation[0] * scale.x;
  result[1] = rotation[1] * scale.x;
  result[2] = rotation[2] * scale.x;
  result[3] = matrix[3];
  result[4] = rotation[3] * scale.y;
  result[5] = rotation[4] * scale.y;
  result[6] = rotation[5] * scale.y;
  result[7] = matrix[7];
  result[8] = rotation[6] * scale.z;
  result[9] = rotation[7] * scale.z;
  result[10] = rotation[8] * scale.z;
  result[11] = matrix[11];
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
var scaleScratch52 = new Cartesian3_default();
Matrix4.getRotation = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const scale = Matrix4.getScale(matrix, scaleScratch52);
  result[0] = matrix[0] / scale.x;
  result[1] = matrix[1] / scale.x;
  result[2] = matrix[2] / scale.x;
  result[3] = matrix[4] / scale.y;
  result[4] = matrix[5] / scale.y;
  result[5] = matrix[6] / scale.y;
  result[6] = matrix[8] / scale.z;
  result[7] = matrix[9] / scale.z;
  result[8] = matrix[10] / scale.z;
  return result;
};
Matrix4.multiply = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  const left0 = left[0];
  const left1 = left[1];
  const left2 = left[2];
  const left3 = left[3];
  const left4 = left[4];
  const left5 = left[5];
  const left6 = left[6];
  const left7 = left[7];
  const left8 = left[8];
  const left9 = left[9];
  const left10 = left[10];
  const left11 = left[11];
  const left12 = left[12];
  const left13 = left[13];
  const left14 = left[14];
  const left15 = left[15];
  const right0 = right[0];
  const right1 = right[1];
  const right2 = right[2];
  const right3 = right[3];
  const right4 = right[4];
  const right5 = right[5];
  const right6 = right[6];
  const right7 = right[7];
  const right8 = right[8];
  const right9 = right[9];
  const right10 = right[10];
  const right11 = right[11];
  const right12 = right[12];
  const right13 = right[13];
  const right14 = right[14];
  const right15 = right[15];
  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
  const column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;
  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
  const column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;
  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
  const column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;
  const column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
  const column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
  const column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
  const column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;
  result[0] = column0Row0;
  result[1] = column0Row1;
  result[2] = column0Row2;
  result[3] = column0Row3;
  result[4] = column1Row0;
  result[5] = column1Row1;
  result[6] = column1Row2;
  result[7] = column1Row3;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = column3Row0;
  result[13] = column3Row1;
  result[14] = column3Row2;
  result[15] = column3Row3;
  return result;
};
Matrix4.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result[0] = left[0] + right[0];
  result[1] = left[1] + right[1];
  result[2] = left[2] + right[2];
  result[3] = left[3] + right[3];
  result[4] = left[4] + right[4];
  result[5] = left[5] + right[5];
  result[6] = left[6] + right[6];
  result[7] = left[7] + right[7];
  result[8] = left[8] + right[8];
  result[9] = left[9] + right[9];
  result[10] = left[10] + right[10];
  result[11] = left[11] + right[11];
  result[12] = left[12] + right[12];
  result[13] = left[13] + right[13];
  result[14] = left[14] + right[14];
  result[15] = left[15] + right[15];
  return result;
};
Matrix4.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result[0] = left[0] - right[0];
  result[1] = left[1] - right[1];
  result[2] = left[2] - right[2];
  result[3] = left[3] - right[3];
  result[4] = left[4] - right[4];
  result[5] = left[5] - right[5];
  result[6] = left[6] - right[6];
  result[7] = left[7] - right[7];
  result[8] = left[8] - right[8];
  result[9] = left[9] - right[9];
  result[10] = left[10] - right[10];
  result[11] = left[11] - right[11];
  result[12] = left[12] - right[12];
  result[13] = left[13] - right[13];
  result[14] = left[14] - right[14];
  result[15] = left[15] - right[15];
  return result;
};
Matrix4.multiplyTransformation = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  const left0 = left[0];
  const left1 = left[1];
  const left2 = left[2];
  const left4 = left[4];
  const left5 = left[5];
  const left6 = left[6];
  const left8 = left[8];
  const left9 = left[9];
  const left10 = left[10];
  const left12 = left[12];
  const left13 = left[13];
  const left14 = left[14];
  const right0 = right[0];
  const right1 = right[1];
  const right2 = right[2];
  const right4 = right[4];
  const right5 = right[5];
  const right6 = right[6];
  const right8 = right[8];
  const right9 = right[9];
  const right10 = right[10];
  const right12 = right[12];
  const right13 = right[13];
  const right14 = right[14];
  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
  const column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;
  const column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;
  const column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;
  result[0] = column0Row0;
  result[1] = column0Row1;
  result[2] = column0Row2;
  result[3] = 0;
  result[4] = column1Row0;
  result[5] = column1Row1;
  result[6] = column1Row2;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = 0;
  result[12] = column3Row0;
  result[13] = column3Row1;
  result[14] = column3Row2;
  result[15] = 1;
  return result;
};
Matrix4.multiplyByMatrix3 = function(matrix, rotation, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("rotation", rotation);
  Check_default.typeOf.object("result", result);
  const left0 = matrix[0];
  const left1 = matrix[1];
  const left2 = matrix[2];
  const left4 = matrix[4];
  const left5 = matrix[5];
  const left6 = matrix[6];
  const left8 = matrix[8];
  const left9 = matrix[9];
  const left10 = matrix[10];
  const right0 = rotation[0];
  const right1 = rotation[1];
  const right2 = rotation[2];
  const right4 = rotation[3];
  const right5 = rotation[4];
  const right6 = rotation[5];
  const right8 = rotation[6];
  const right9 = rotation[7];
  const right10 = rotation[8];
  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
  result[0] = column0Row0;
  result[1] = column0Row1;
  result[2] = column0Row2;
  result[3] = 0;
  result[4] = column1Row0;
  result[5] = column1Row1;
  result[6] = column1Row2;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = 0;
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
Matrix4.multiplyByTranslation = function(matrix, translation, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("translation", translation);
  Check_default.typeOf.object("result", result);
  const x = translation.x;
  const y = translation.y;
  const z = translation.z;
  const tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];
  const ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];
  const tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  result[4] = matrix[4];
  result[5] = matrix[5];
  result[6] = matrix[6];
  result[7] = matrix[7];
  result[8] = matrix[8];
  result[9] = matrix[9];
  result[10] = matrix[10];
  result[11] = matrix[11];
  result[12] = tx;
  result[13] = ty;
  result[14] = tz;
  result[15] = matrix[15];
  return result;
};
Matrix4.multiplyByScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("scale", scale);
  Check_default.typeOf.object("result", result);
  const scaleX = scale.x;
  const scaleY = scale.y;
  const scaleZ = scale.z;
  if (scaleX === 1 && scaleY === 1 && scaleZ === 1) {
    return Matrix4.clone(matrix, result);
  }
  result[0] = scaleX * matrix[0];
  result[1] = scaleX * matrix[1];
  result[2] = scaleX * matrix[2];
  result[3] = matrix[3];
  result[4] = scaleY * matrix[4];
  result[5] = scaleY * matrix[5];
  result[6] = scaleY * matrix[6];
  result[7] = matrix[7];
  result[8] = scaleZ * matrix[8];
  result[9] = scaleZ * matrix[9];
  result[10] = scaleZ * matrix[10];
  result[11] = matrix[11];
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
Matrix4.multiplyByUniformScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scale", scale);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scale;
  result[1] = matrix[1] * scale;
  result[2] = matrix[2] * scale;
  result[3] = matrix[3];
  result[4] = matrix[4] * scale;
  result[5] = matrix[5] * scale;
  result[6] = matrix[6] * scale;
  result[7] = matrix[7];
  result[8] = matrix[8] * scale;
  result[9] = matrix[9] * scale;
  result[10] = matrix[10] * scale;
  result[11] = matrix[11];
  result[12] = matrix[12];
  result[13] = matrix[13];
  result[14] = matrix[14];
  result[15] = matrix[15];
  return result;
};
Matrix4.multiplyByVector = function(matrix, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const vX = cartesian.x;
  const vY = cartesian.y;
  const vZ = cartesian.z;
  const vW = cartesian.w;
  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
  const w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
Matrix4.multiplyByPointAsVector = function(matrix, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const vX = cartesian.x;
  const vY = cartesian.y;
  const vZ = cartesian.z;
  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Matrix4.multiplyByPoint = function(matrix, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const vX = cartesian.x;
  const vY = cartesian.y;
  const vZ = cartesian.z;
  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
Matrix4.multiplyByScalar = function(matrix, scalar, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scalar;
  result[1] = matrix[1] * scalar;
  result[2] = matrix[2] * scalar;
  result[3] = matrix[3] * scalar;
  result[4] = matrix[4] * scalar;
  result[5] = matrix[5] * scalar;
  result[6] = matrix[6] * scalar;
  result[7] = matrix[7] * scalar;
  result[8] = matrix[8] * scalar;
  result[9] = matrix[9] * scalar;
  result[10] = matrix[10] * scalar;
  result[11] = matrix[11] * scalar;
  result[12] = matrix[12] * scalar;
  result[13] = matrix[13] * scalar;
  result[14] = matrix[14] * scalar;
  result[15] = matrix[15] * scalar;
  return result;
};
Matrix4.negate = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result[0] = -matrix[0];
  result[1] = -matrix[1];
  result[2] = -matrix[2];
  result[3] = -matrix[3];
  result[4] = -matrix[4];
  result[5] = -matrix[5];
  result[6] = -matrix[6];
  result[7] = -matrix[7];
  result[8] = -matrix[8];
  result[9] = -matrix[9];
  result[10] = -matrix[10];
  result[11] = -matrix[11];
  result[12] = -matrix[12];
  result[13] = -matrix[13];
  result[14] = -matrix[14];
  result[15] = -matrix[15];
  return result;
};
Matrix4.transpose = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const matrix1 = matrix[1];
  const matrix2 = matrix[2];
  const matrix3 = matrix[3];
  const matrix6 = matrix[6];
  const matrix7 = matrix[7];
  const matrix11 = matrix[11];
  result[0] = matrix[0];
  result[1] = matrix[4];
  result[2] = matrix[8];
  result[3] = matrix[12];
  result[4] = matrix1;
  result[5] = matrix[5];
  result[6] = matrix[9];
  result[7] = matrix[13];
  result[8] = matrix2;
  result[9] = matrix6;
  result[10] = matrix[10];
  result[11] = matrix[14];
  result[12] = matrix3;
  result[13] = matrix7;
  result[14] = matrix11;
  result[15] = matrix[15];
  return result;
};
Matrix4.abs = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result[0] = Math.abs(matrix[0]);
  result[1] = Math.abs(matrix[1]);
  result[2] = Math.abs(matrix[2]);
  result[3] = Math.abs(matrix[3]);
  result[4] = Math.abs(matrix[4]);
  result[5] = Math.abs(matrix[5]);
  result[6] = Math.abs(matrix[6]);
  result[7] = Math.abs(matrix[7]);
  result[8] = Math.abs(matrix[8]);
  result[9] = Math.abs(matrix[9]);
  result[10] = Math.abs(matrix[10]);
  result[11] = Math.abs(matrix[11]);
  result[12] = Math.abs(matrix[12]);
  result[13] = Math.abs(matrix[13]);
  result[14] = Math.abs(matrix[14]);
  result[15] = Math.abs(matrix[15]);
  return result;
};
Matrix4.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left[12] === right[12] && left[13] === right[13] && left[14] === right[14] && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[8] === right[8] && left[9] === right[9] && left[10] === right[10] && left[3] === right[3] && left[7] === right[7] && left[11] === right[11] && left[15] === right[15];
};
Matrix4.equalsEpsilon = function(left, right, epsilon) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon && Math.abs(left[9] - right[9]) <= epsilon && Math.abs(left[10] - right[10]) <= epsilon && Math.abs(left[11] - right[11]) <= epsilon && Math.abs(left[12] - right[12]) <= epsilon && Math.abs(left[13] - right[13]) <= epsilon && Math.abs(left[14] - right[14]) <= epsilon && Math.abs(left[15] - right[15]) <= epsilon;
};
Matrix4.getTranslation = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result.x = matrix[12];
  result.y = matrix[13];
  result.z = matrix[14];
  return result;
};
Matrix4.getMatrix3 = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[4];
  result[4] = matrix[5];
  result[5] = matrix[6];
  result[6] = matrix[8];
  result[7] = matrix[9];
  result[8] = matrix[10];
  return result;
};
var scratchInverseRotation = new Matrix3_default();
var scratchMatrix3Zero = new Matrix3_default();
var scratchBottomRow = new Cartesian4_default();
var scratchExpectedBottomRow = new Cartesian4_default(0, 0, 0, 1);
Matrix4.inverse = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const src0 = matrix[0];
  const src1 = matrix[4];
  const src2 = matrix[8];
  const src3 = matrix[12];
  const src4 = matrix[1];
  const src5 = matrix[5];
  const src6 = matrix[9];
  const src7 = matrix[13];
  const src8 = matrix[2];
  const src9 = matrix[6];
  const src10 = matrix[10];
  const src11 = matrix[14];
  const src12 = matrix[3];
  const src13 = matrix[7];
  const src14 = matrix[11];
  const src15 = matrix[15];
  let tmp0 = src10 * src15;
  let tmp1 = src11 * src14;
  let tmp2 = src9 * src15;
  let tmp3 = src11 * src13;
  let tmp4 = src9 * src14;
  let tmp5 = src10 * src13;
  let tmp6 = src8 * src15;
  let tmp7 = src11 * src12;
  let tmp8 = src8 * src14;
  let tmp9 = src10 * src12;
  let tmp10 = src8 * src13;
  let tmp11 = src9 * src12;
  const dst0 = tmp0 * src5 + tmp3 * src6 + tmp4 * src7 - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
  const dst1 = tmp1 * src4 + tmp6 * src6 + tmp9 * src7 - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
  const dst2 = tmp2 * src4 + tmp7 * src5 + tmp10 * src7 - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
  const dst3 = tmp5 * src4 + tmp8 * src5 + tmp11 * src6 - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
  const dst4 = tmp1 * src1 + tmp2 * src2 + tmp5 * src3 - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
  const dst5 = tmp0 * src0 + tmp7 * src2 + tmp8 * src3 - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
  const dst6 = tmp3 * src0 + tmp6 * src1 + tmp11 * src3 - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
  const dst7 = tmp4 * src0 + tmp9 * src1 + tmp10 * src2 - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);
  tmp0 = src2 * src7;
  tmp1 = src3 * src6;
  tmp2 = src1 * src7;
  tmp3 = src3 * src5;
  tmp4 = src1 * src6;
  tmp5 = src2 * src5;
  tmp6 = src0 * src7;
  tmp7 = src3 * src4;
  tmp8 = src0 * src6;
  tmp9 = src2 * src4;
  tmp10 = src0 * src5;
  tmp11 = src1 * src4;
  const dst8 = tmp0 * src13 + tmp3 * src14 + tmp4 * src15 - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
  const dst9 = tmp1 * src12 + tmp6 * src14 + tmp9 * src15 - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
  const dst10 = tmp2 * src12 + tmp7 * src13 + tmp10 * src15 - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
  const dst11 = tmp5 * src12 + tmp8 * src13 + tmp11 * src14 - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
  const dst12 = tmp2 * src10 + tmp5 * src11 + tmp1 * src9 - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
  const dst13 = tmp8 * src11 + tmp0 * src8 + tmp7 * src10 - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
  const dst14 = tmp6 * src9 + tmp11 * src11 + tmp3 * src8 - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
  const dst15 = tmp10 * src10 + tmp4 * src8 + tmp9 * src9 - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);
  let det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;
  if (Math.abs(det) < Math_default.EPSILON21) {
    if (Matrix3_default.equalsEpsilon(
      Matrix4.getMatrix3(matrix, scratchInverseRotation),
      scratchMatrix3Zero,
      Math_default.EPSILON7
    ) && Cartesian4_default.equals(
      Matrix4.getRow(matrix, 3, scratchBottomRow),
      scratchExpectedBottomRow
    )) {
      result[0] = 0;
      result[1] = 0;
      result[2] = 0;
      result[3] = 0;
      result[4] = 0;
      result[5] = 0;
      result[6] = 0;
      result[7] = 0;
      result[8] = 0;
      result[9] = 0;
      result[10] = 0;
      result[11] = 0;
      result[12] = -matrix[12];
      result[13] = -matrix[13];
      result[14] = -matrix[14];
      result[15] = 1;
      return result;
    }
    throw new RuntimeError_default(
      "matrix is not invertible because its determinate is zero."
    );
  }
  det = 1 / det;
  result[0] = dst0 * det;
  result[1] = dst1 * det;
  result[2] = dst2 * det;
  result[3] = dst3 * det;
  result[4] = dst4 * det;
  result[5] = dst5 * det;
  result[6] = dst6 * det;
  result[7] = dst7 * det;
  result[8] = dst8 * det;
  result[9] = dst9 * det;
  result[10] = dst10 * det;
  result[11] = dst11 * det;
  result[12] = dst12 * det;
  result[13] = dst13 * det;
  result[14] = dst14 * det;
  result[15] = dst15 * det;
  return result;
};
Matrix4.inverseTransformation = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const matrix0 = matrix[0];
  const matrix1 = matrix[1];
  const matrix2 = matrix[2];
  const matrix4 = matrix[4];
  const matrix5 = matrix[5];
  const matrix6 = matrix[6];
  const matrix8 = matrix[8];
  const matrix9 = matrix[9];
  const matrix10 = matrix[10];
  const vX = matrix[12];
  const vY = matrix[13];
  const vZ = matrix[14];
  const x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
  const y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
  const z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;
  result[0] = matrix0;
  result[1] = matrix4;
  result[2] = matrix8;
  result[3] = 0;
  result[4] = matrix1;
  result[5] = matrix5;
  result[6] = matrix9;
  result[7] = 0;
  result[8] = matrix2;
  result[9] = matrix6;
  result[10] = matrix10;
  result[11] = 0;
  result[12] = x;
  result[13] = y;
  result[14] = z;
  result[15] = 1;
  return result;
};
var scratchTransposeMatrix2 = new Matrix4();
Matrix4.inverseTranspose = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  return Matrix4.inverse(
    Matrix4.transpose(matrix, scratchTransposeMatrix2),
    result
  );
};
Matrix4.IDENTITY = Object.freeze(
  new Matrix4(
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  )
);
Matrix4.ZERO = Object.freeze(
  new Matrix4(
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  )
);
Matrix4.COLUMN0ROW0 = 0;
Matrix4.COLUMN0ROW1 = 1;
Matrix4.COLUMN0ROW2 = 2;
Matrix4.COLUMN0ROW3 = 3;
Matrix4.COLUMN1ROW0 = 4;
Matrix4.COLUMN1ROW1 = 5;
Matrix4.COLUMN1ROW2 = 6;
Matrix4.COLUMN1ROW3 = 7;
Matrix4.COLUMN2ROW0 = 8;
Matrix4.COLUMN2ROW1 = 9;
Matrix4.COLUMN2ROW2 = 10;
Matrix4.COLUMN2ROW3 = 11;
Matrix4.COLUMN3ROW0 = 12;
Matrix4.COLUMN3ROW1 = 13;
Matrix4.COLUMN3ROW2 = 14;
Matrix4.COLUMN3ROW3 = 15;
Object.defineProperties(Matrix4.prototype, {
  length: {
    get: function() {
      return Matrix4.packedLength;
    }
  }
});
Matrix4.prototype.clone = function(result) {
  return Matrix4.clone(this, result);
};
Matrix4.prototype.equals = function(right) {
  return Matrix4.equals(this, right);
};
Matrix4.equalsArray = function(matrix, array, offset) {
  return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8] && matrix[9] === array[offset + 9] && matrix[10] === array[offset + 10] && matrix[11] === array[offset + 11] && matrix[12] === array[offset + 12] && matrix[13] === array[offset + 13] && matrix[14] === array[offset + 14] && matrix[15] === array[offset + 15];
};
Matrix4.prototype.equalsEpsilon = function(right, epsilon) {
  return Matrix4.equalsEpsilon(this, right, epsilon);
};
Matrix4.prototype.toString = function() {
  return `(${this[0]}, ${this[4]}, ${this[8]}, ${this[12]})
(${this[1]}, ${this[5]}, ${this[9]}, ${this[13]})
(${this[2]}, ${this[6]}, ${this[10]}, ${this[14]})
(${this[3]}, ${this[7]}, ${this[11]}, ${this[15]})`;
};
var Matrix4_default = Matrix4;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/WebGLConstants.js
var WebGLConstants = {
  DEPTH_BUFFER_BIT: 256,
  STENCIL_BUFFER_BIT: 1024,
  COLOR_BUFFER_BIT: 16384,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  ZERO: 0,
  ONE: 1,
  SRC_COLOR: 768,
  ONE_MINUS_SRC_COLOR: 769,
  SRC_ALPHA: 770,
  ONE_MINUS_SRC_ALPHA: 771,
  DST_ALPHA: 772,
  ONE_MINUS_DST_ALPHA: 773,
  DST_COLOR: 774,
  ONE_MINUS_DST_COLOR: 775,
  SRC_ALPHA_SATURATE: 776,
  FUNC_ADD: 32774,
  BLEND_EQUATION: 32777,
  BLEND_EQUATION_RGB: 32777,
  BLEND_EQUATION_ALPHA: 34877,
  FUNC_SUBTRACT: 32778,
  FUNC_REVERSE_SUBTRACT: 32779,
  BLEND_DST_RGB: 32968,
  BLEND_SRC_RGB: 32969,
  BLEND_DST_ALPHA: 32970,
  BLEND_SRC_ALPHA: 32971,
  CONSTANT_COLOR: 32769,
  ONE_MINUS_CONSTANT_COLOR: 32770,
  CONSTANT_ALPHA: 32771,
  ONE_MINUS_CONSTANT_ALPHA: 32772,
  BLEND_COLOR: 32773,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  ARRAY_BUFFER_BINDING: 34964,
  ELEMENT_ARRAY_BUFFER_BINDING: 34965,
  STREAM_DRAW: 35040,
  STATIC_DRAW: 35044,
  DYNAMIC_DRAW: 35048,
  BUFFER_SIZE: 34660,
  BUFFER_USAGE: 34661,
  CURRENT_VERTEX_ATTRIB: 34342,
  FRONT: 1028,
  BACK: 1029,
  FRONT_AND_BACK: 1032,
  CULL_FACE: 2884,
  BLEND: 3042,
  DITHER: 3024,
  STENCIL_TEST: 2960,
  DEPTH_TEST: 2929,
  SCISSOR_TEST: 3089,
  POLYGON_OFFSET_FILL: 32823,
  SAMPLE_ALPHA_TO_COVERAGE: 32926,
  SAMPLE_COVERAGE: 32928,
  NO_ERROR: 0,
  INVALID_ENUM: 1280,
  INVALID_VALUE: 1281,
  INVALID_OPERATION: 1282,
  OUT_OF_MEMORY: 1285,
  CW: 2304,
  CCW: 2305,
  LINE_WIDTH: 2849,
  ALIASED_POINT_SIZE_RANGE: 33901,
  ALIASED_LINE_WIDTH_RANGE: 33902,
  CULL_FACE_MODE: 2885,
  FRONT_FACE: 2886,
  DEPTH_RANGE: 2928,
  DEPTH_WRITEMASK: 2930,
  DEPTH_CLEAR_VALUE: 2931,
  DEPTH_FUNC: 2932,
  STENCIL_CLEAR_VALUE: 2961,
  STENCIL_FUNC: 2962,
  STENCIL_FAIL: 2964,
  STENCIL_PASS_DEPTH_FAIL: 2965,
  STENCIL_PASS_DEPTH_PASS: 2966,
  STENCIL_REF: 2967,
  STENCIL_VALUE_MASK: 2963,
  STENCIL_WRITEMASK: 2968,
  STENCIL_BACK_FUNC: 34816,
  STENCIL_BACK_FAIL: 34817,
  STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
  STENCIL_BACK_PASS_DEPTH_PASS: 34819,
  STENCIL_BACK_REF: 36003,
  STENCIL_BACK_VALUE_MASK: 36004,
  STENCIL_BACK_WRITEMASK: 36005,
  VIEWPORT: 2978,
  SCISSOR_BOX: 3088,
  COLOR_CLEAR_VALUE: 3106,
  COLOR_WRITEMASK: 3107,
  UNPACK_ALIGNMENT: 3317,
  PACK_ALIGNMENT: 3333,
  MAX_TEXTURE_SIZE: 3379,
  MAX_VIEWPORT_DIMS: 3386,
  SUBPIXEL_BITS: 3408,
  RED_BITS: 3410,
  GREEN_BITS: 3411,
  BLUE_BITS: 3412,
  ALPHA_BITS: 3413,
  DEPTH_BITS: 3414,
  STENCIL_BITS: 3415,
  POLYGON_OFFSET_UNITS: 10752,
  POLYGON_OFFSET_FACTOR: 32824,
  TEXTURE_BINDING_2D: 32873,
  SAMPLE_BUFFERS: 32936,
  SAMPLES: 32937,
  SAMPLE_COVERAGE_VALUE: 32938,
  SAMPLE_COVERAGE_INVERT: 32939,
  COMPRESSED_TEXTURE_FORMATS: 34467,
  DONT_CARE: 4352,
  FASTEST: 4353,
  NICEST: 4354,
  GENERATE_MIPMAP_HINT: 33170,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DEPTH_COMPONENT: 6402,
  ALPHA: 6406,
  RGB: 6407,
  RGBA: 6408,
  LUMINANCE: 6409,
  LUMINANCE_ALPHA: 6410,
  UNSIGNED_SHORT_4_4_4_4: 32819,
  UNSIGNED_SHORT_5_5_5_1: 32820,
  UNSIGNED_SHORT_5_6_5: 33635,
  FRAGMENT_SHADER: 35632,
  VERTEX_SHADER: 35633,
  MAX_VERTEX_ATTRIBS: 34921,
  MAX_VERTEX_UNIFORM_VECTORS: 36347,
  MAX_VARYING_VECTORS: 36348,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
  MAX_TEXTURE_IMAGE_UNITS: 34930,
  MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
  SHADER_TYPE: 35663,
  DELETE_STATUS: 35712,
  LINK_STATUS: 35714,
  VALIDATE_STATUS: 35715,
  ATTACHED_SHADERS: 35717,
  ACTIVE_UNIFORMS: 35718,
  ACTIVE_ATTRIBUTES: 35721,
  SHADING_LANGUAGE_VERSION: 35724,
  CURRENT_PROGRAM: 35725,
  NEVER: 512,
  LESS: 513,
  EQUAL: 514,
  LEQUAL: 515,
  GREATER: 516,
  NOTEQUAL: 517,
  GEQUAL: 518,
  ALWAYS: 519,
  KEEP: 7680,
  REPLACE: 7681,
  INCR: 7682,
  DECR: 7683,
  INVERT: 5386,
  INCR_WRAP: 34055,
  DECR_WRAP: 34056,
  VENDOR: 7936,
  RENDERER: 7937,
  VERSION: 7938,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  TEXTURE_2D: 3553,
  TEXTURE: 5890,
  TEXTURE_CUBE_MAP: 34067,
  TEXTURE_BINDING_CUBE_MAP: 34068,
  TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
  MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
  TEXTURE0: 33984,
  TEXTURE1: 33985,
  TEXTURE2: 33986,
  TEXTURE3: 33987,
  TEXTURE4: 33988,
  TEXTURE5: 33989,
  TEXTURE6: 33990,
  TEXTURE7: 33991,
  TEXTURE8: 33992,
  TEXTURE9: 33993,
  TEXTURE10: 33994,
  TEXTURE11: 33995,
  TEXTURE12: 33996,
  TEXTURE13: 33997,
  TEXTURE14: 33998,
  TEXTURE15: 33999,
  TEXTURE16: 34e3,
  TEXTURE17: 34001,
  TEXTURE18: 34002,
  TEXTURE19: 34003,
  TEXTURE20: 34004,
  TEXTURE21: 34005,
  TEXTURE22: 34006,
  TEXTURE23: 34007,
  TEXTURE24: 34008,
  TEXTURE25: 34009,
  TEXTURE26: 34010,
  TEXTURE27: 34011,
  TEXTURE28: 34012,
  TEXTURE29: 34013,
  TEXTURE30: 34014,
  TEXTURE31: 34015,
  ACTIVE_TEXTURE: 34016,
  REPEAT: 10497,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  INT_VEC2: 35667,
  INT_VEC3: 35668,
  INT_VEC4: 35669,
  BOOL: 35670,
  BOOL_VEC2: 35671,
  BOOL_VEC3: 35672,
  BOOL_VEC4: 35673,
  FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  SAMPLER_2D: 35678,
  SAMPLER_CUBE: 35680,
  VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
  VERTEX_ATTRIB_ARRAY_SIZE: 34339,
  VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
  VERTEX_ATTRIB_ARRAY_TYPE: 34341,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
  VERTEX_ATTRIB_ARRAY_POINTER: 34373,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
  IMPLEMENTATION_COLOR_READ_TYPE: 35738,
  IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
  COMPILE_STATUS: 35713,
  LOW_FLOAT: 36336,
  MEDIUM_FLOAT: 36337,
  HIGH_FLOAT: 36338,
  LOW_INT: 36339,
  MEDIUM_INT: 36340,
  HIGH_INT: 36341,
  FRAMEBUFFER: 36160,
  RENDERBUFFER: 36161,
  RGBA4: 32854,
  RGB5_A1: 32855,
  RGB565: 36194,
  DEPTH_COMPONENT16: 33189,
  STENCIL_INDEX: 6401,
  STENCIL_INDEX8: 36168,
  DEPTH_STENCIL: 34041,
  RENDERBUFFER_WIDTH: 36162,
  RENDERBUFFER_HEIGHT: 36163,
  RENDERBUFFER_INTERNAL_FORMAT: 36164,
  RENDERBUFFER_RED_SIZE: 36176,
  RENDERBUFFER_GREEN_SIZE: 36177,
  RENDERBUFFER_BLUE_SIZE: 36178,
  RENDERBUFFER_ALPHA_SIZE: 36179,
  RENDERBUFFER_DEPTH_SIZE: 36180,
  RENDERBUFFER_STENCIL_SIZE: 36181,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
  COLOR_ATTACHMENT0: 36064,
  DEPTH_ATTACHMENT: 36096,
  STENCIL_ATTACHMENT: 36128,
  DEPTH_STENCIL_ATTACHMENT: 33306,
  NONE: 0,
  FRAMEBUFFER_COMPLETE: 36053,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
  FRAMEBUFFER_UNSUPPORTED: 36061,
  FRAMEBUFFER_BINDING: 36006,
  RENDERBUFFER_BINDING: 36007,
  MAX_RENDERBUFFER_SIZE: 34024,
  INVALID_FRAMEBUFFER_OPERATION: 1286,
  UNPACK_FLIP_Y_WEBGL: 37440,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
  CONTEXT_LOST_WEBGL: 37442,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
  BROWSER_DEFAULT_WEBGL: 37444,
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  COMPRESSED_RGBA_ASTC_4x4_WEBGL: 37808,
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  COMPRESSED_RGBA_BPTC_UNORM: 36492,
  HALF_FLOAT_OES: 36193,
  DOUBLE: 5130,
  READ_BUFFER: 3074,
  UNPACK_ROW_LENGTH: 3314,
  UNPACK_SKIP_ROWS: 3315,
  UNPACK_SKIP_PIXELS: 3316,
  PACK_ROW_LENGTH: 3330,
  PACK_SKIP_ROWS: 3331,
  PACK_SKIP_PIXELS: 3332,
  COLOR: 6144,
  DEPTH: 6145,
  STENCIL: 6146,
  RED: 6403,
  RGB8: 32849,
  RGBA8: 32856,
  RGB10_A2: 32857,
  TEXTURE_BINDING_3D: 32874,
  UNPACK_SKIP_IMAGES: 32877,
  UNPACK_IMAGE_HEIGHT: 32878,
  TEXTURE_3D: 32879,
  TEXTURE_WRAP_R: 32882,
  MAX_3D_TEXTURE_SIZE: 32883,
  UNSIGNED_INT_2_10_10_10_REV: 33640,
  MAX_ELEMENTS_VERTICES: 33e3,
  MAX_ELEMENTS_INDICES: 33001,
  TEXTURE_MIN_LOD: 33082,
  TEXTURE_MAX_LOD: 33083,
  TEXTURE_BASE_LEVEL: 33084,
  TEXTURE_MAX_LEVEL: 33085,
  MIN: 32775,
  MAX: 32776,
  DEPTH_COMPONENT24: 33190,
  MAX_TEXTURE_LOD_BIAS: 34045,
  TEXTURE_COMPARE_MODE: 34892,
  TEXTURE_COMPARE_FUNC: 34893,
  CURRENT_QUERY: 34917,
  QUERY_RESULT: 34918,
  QUERY_RESULT_AVAILABLE: 34919,
  STREAM_READ: 35041,
  STREAM_COPY: 35042,
  STATIC_READ: 35045,
  STATIC_COPY: 35046,
  DYNAMIC_READ: 35049,
  DYNAMIC_COPY: 35050,
  MAX_DRAW_BUFFERS: 34852,
  DRAW_BUFFER0: 34853,
  DRAW_BUFFER1: 34854,
  DRAW_BUFFER2: 34855,
  DRAW_BUFFER3: 34856,
  DRAW_BUFFER4: 34857,
  DRAW_BUFFER5: 34858,
  DRAW_BUFFER6: 34859,
  DRAW_BUFFER7: 34860,
  DRAW_BUFFER8: 34861,
  DRAW_BUFFER9: 34862,
  DRAW_BUFFER10: 34863,
  DRAW_BUFFER11: 34864,
  DRAW_BUFFER12: 34865,
  DRAW_BUFFER13: 34866,
  DRAW_BUFFER14: 34867,
  DRAW_BUFFER15: 34868,
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
  MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
  SAMPLER_3D: 35679,
  SAMPLER_2D_SHADOW: 35682,
  FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
  PIXEL_PACK_BUFFER: 35051,
  PIXEL_UNPACK_BUFFER: 35052,
  PIXEL_PACK_BUFFER_BINDING: 35053,
  PIXEL_UNPACK_BUFFER_BINDING: 35055,
  FLOAT_MAT2x3: 35685,
  FLOAT_MAT2x4: 35686,
  FLOAT_MAT3x2: 35687,
  FLOAT_MAT3x4: 35688,
  FLOAT_MAT4x2: 35689,
  FLOAT_MAT4x3: 35690,
  SRGB: 35904,
  SRGB8: 35905,
  SRGB8_ALPHA8: 35907,
  COMPARE_REF_TO_TEXTURE: 34894,
  RGBA32F: 34836,
  RGB32F: 34837,
  RGBA16F: 34842,
  RGB16F: 34843,
  VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
  MAX_ARRAY_TEXTURE_LAYERS: 35071,
  MIN_PROGRAM_TEXEL_OFFSET: 35076,
  MAX_PROGRAM_TEXEL_OFFSET: 35077,
  MAX_VARYING_COMPONENTS: 35659,
  TEXTURE_2D_ARRAY: 35866,
  TEXTURE_BINDING_2D_ARRAY: 35869,
  R11F_G11F_B10F: 35898,
  UNSIGNED_INT_10F_11F_11F_REV: 35899,
  RGB9_E5: 35901,
  UNSIGNED_INT_5_9_9_9_REV: 35902,
  TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
  TRANSFORM_FEEDBACK_VARYINGS: 35971,
  TRANSFORM_FEEDBACK_BUFFER_START: 35972,
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
  RASTERIZER_DISCARD: 35977,
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
  INTERLEAVED_ATTRIBS: 35980,
  SEPARATE_ATTRIBS: 35981,
  TRANSFORM_FEEDBACK_BUFFER: 35982,
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
  RGBA32UI: 36208,
  RGB32UI: 36209,
  RGBA16UI: 36214,
  RGB16UI: 36215,
  RGBA8UI: 36220,
  RGB8UI: 36221,
  RGBA32I: 36226,
  RGB32I: 36227,
  RGBA16I: 36232,
  RGB16I: 36233,
  RGBA8I: 36238,
  RGB8I: 36239,
  RED_INTEGER: 36244,
  RGB_INTEGER: 36248,
  RGBA_INTEGER: 36249,
  SAMPLER_2D_ARRAY: 36289,
  SAMPLER_2D_ARRAY_SHADOW: 36292,
  SAMPLER_CUBE_SHADOW: 36293,
  UNSIGNED_INT_VEC2: 36294,
  UNSIGNED_INT_VEC3: 36295,
  UNSIGNED_INT_VEC4: 36296,
  INT_SAMPLER_2D: 36298,
  INT_SAMPLER_3D: 36299,
  INT_SAMPLER_CUBE: 36300,
  INT_SAMPLER_2D_ARRAY: 36303,
  UNSIGNED_INT_SAMPLER_2D: 36306,
  UNSIGNED_INT_SAMPLER_3D: 36307,
  UNSIGNED_INT_SAMPLER_CUBE: 36308,
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
  DEPTH_COMPONENT32F: 36012,
  DEPTH32F_STENCIL8: 36013,
  FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
  FRAMEBUFFER_DEFAULT: 33304,
  UNSIGNED_INT_24_8: 34042,
  DEPTH24_STENCIL8: 35056,
  UNSIGNED_NORMALIZED: 35863,
  DRAW_FRAMEBUFFER_BINDING: 36006,
  READ_FRAMEBUFFER: 36008,
  DRAW_FRAMEBUFFER: 36009,
  READ_FRAMEBUFFER_BINDING: 36010,
  RENDERBUFFER_SAMPLES: 36011,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
  MAX_COLOR_ATTACHMENTS: 36063,
  COLOR_ATTACHMENT1: 36065,
  COLOR_ATTACHMENT2: 36066,
  COLOR_ATTACHMENT3: 36067,
  COLOR_ATTACHMENT4: 36068,
  COLOR_ATTACHMENT5: 36069,
  COLOR_ATTACHMENT6: 36070,
  COLOR_ATTACHMENT7: 36071,
  COLOR_ATTACHMENT8: 36072,
  COLOR_ATTACHMENT9: 36073,
  COLOR_ATTACHMENT10: 36074,
  COLOR_ATTACHMENT11: 36075,
  COLOR_ATTACHMENT12: 36076,
  COLOR_ATTACHMENT13: 36077,
  COLOR_ATTACHMENT14: 36078,
  COLOR_ATTACHMENT15: 36079,
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
  MAX_SAMPLES: 36183,
  HALF_FLOAT: 5131,
  RG: 33319,
  RG_INTEGER: 33320,
  R8: 33321,
  RG8: 33323,
  R16F: 33325,
  R32F: 33326,
  RG16F: 33327,
  RG32F: 33328,
  R8I: 33329,
  R8UI: 33330,
  R16I: 33331,
  R16UI: 33332,
  R32I: 33333,
  R32UI: 33334,
  RG8I: 33335,
  RG8UI: 33336,
  RG16I: 33337,
  RG16UI: 33338,
  RG32I: 33339,
  RG32UI: 33340,
  VERTEX_ARRAY_BINDING: 34229,
  R8_SNORM: 36756,
  RG8_SNORM: 36757,
  RGB8_SNORM: 36758,
  RGBA8_SNORM: 36759,
  SIGNED_NORMALIZED: 36764,
  COPY_READ_BUFFER: 36662,
  COPY_WRITE_BUFFER: 36663,
  COPY_READ_BUFFER_BINDING: 36662,
  COPY_WRITE_BUFFER_BINDING: 36663,
  UNIFORM_BUFFER: 35345,
  UNIFORM_BUFFER_BINDING: 35368,
  UNIFORM_BUFFER_START: 35369,
  UNIFORM_BUFFER_SIZE: 35370,
  MAX_VERTEX_UNIFORM_BLOCKS: 35371,
  MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
  MAX_COMBINED_UNIFORM_BLOCKS: 35374,
  MAX_UNIFORM_BUFFER_BINDINGS: 35375,
  MAX_UNIFORM_BLOCK_SIZE: 35376,
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
  ACTIVE_UNIFORM_BLOCKS: 35382,
  UNIFORM_TYPE: 35383,
  UNIFORM_SIZE: 35384,
  UNIFORM_BLOCK_INDEX: 35386,
  UNIFORM_OFFSET: 35387,
  UNIFORM_ARRAY_STRIDE: 35388,
  UNIFORM_MATRIX_STRIDE: 35389,
  UNIFORM_IS_ROW_MAJOR: 35390,
  UNIFORM_BLOCK_BINDING: 35391,
  UNIFORM_BLOCK_DATA_SIZE: 35392,
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
  INVALID_INDEX: 4294967295,
  MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
  MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
  MAX_SERVER_WAIT_TIMEOUT: 37137,
  OBJECT_TYPE: 37138,
  SYNC_CONDITION: 37139,
  SYNC_STATUS: 37140,
  SYNC_FLAGS: 37141,
  SYNC_FENCE: 37142,
  SYNC_GPU_COMMANDS_COMPLETE: 37143,
  UNSIGNALED: 37144,
  SIGNALED: 37145,
  ALREADY_SIGNALED: 37146,
  TIMEOUT_EXPIRED: 37147,
  CONDITION_SATISFIED: 37148,
  WAIT_FAILED: 37149,
  SYNC_FLUSH_COMMANDS_BIT: 1,
  VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
  ANY_SAMPLES_PASSED: 35887,
  ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
  SAMPLER_BINDING: 35097,
  RGB10_A2UI: 36975,
  INT_2_10_10_10_REV: 36255,
  TRANSFORM_FEEDBACK: 36386,
  TRANSFORM_FEEDBACK_PAUSED: 36387,
  TRANSFORM_FEEDBACK_ACTIVE: 36388,
  TRANSFORM_FEEDBACK_BINDING: 36389,
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_SRGB8_ETC2: 37493,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37494,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37495,
  COMPRESSED_RGBA8_ETC2_EAC: 37496,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37497,
  TEXTURE_IMMUTABLE_FORMAT: 37167,
  MAX_ELEMENT_INDEX: 36203,
  TEXTURE_IMMUTABLE_LEVELS: 33503,
  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047
};
var WebGLConstants_default = Object.freeze(WebGLConstants);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/AutomaticUniforms.js
var viewerPositionWCScratch = new Cartesian3_default();
function AutomaticUniform(options) {
  this._size = options.size;
  this._datatype = options.datatype;
  this.getValue = options.getValue;
}
var datatypeToGlsl = {};
datatypeToGlsl[WebGLConstants_default.FLOAT] = "float";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC2] = "vec2";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC3] = "vec3";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC4] = "vec4";
datatypeToGlsl[WebGLConstants_default.INT] = "int";
datatypeToGlsl[WebGLConstants_default.INT_VEC2] = "ivec2";
datatypeToGlsl[WebGLConstants_default.INT_VEC3] = "ivec3";
datatypeToGlsl[WebGLConstants_default.INT_VEC4] = "ivec4";
datatypeToGlsl[WebGLConstants_default.BOOL] = "bool";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC2] = "bvec2";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC3] = "bvec3";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC4] = "bvec4";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT2] = "mat2";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT3] = "mat3";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT4] = "mat4";
datatypeToGlsl[WebGLConstants_default.SAMPLER_2D] = "sampler2D";
datatypeToGlsl[WebGLConstants_default.SAMPLER_CUBE] = "samplerCube";
AutomaticUniform.prototype.getDeclaration = function(name) {
  let declaration = `uniform ${datatypeToGlsl[this._datatype]} ${name}`;
  const size = this._size;
  if (size === 1) {
    declaration += ";";
  } else {
    declaration += `[${size.toString()}];`;
  }
  return declaration;
};
var AutomaticUniforms = {
  czm_viewport: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.viewportCartesian4;
    }
  }),
  czm_viewportOrthographic: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewportOrthographic;
    }
  }),
  czm_viewportTransformation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewportTransformation;
    }
  }),
  czm_globeDepthTexture: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.globeDepthTexture;
    }
  }),
  czm_model: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.model;
    }
  }),
  czm_inverseModel: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModel;
    }
  }),
  czm_view: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.view;
    }
  }),
  czm_view3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.view3D;
    }
  }),
  czm_viewRotation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.viewRotation;
    }
  }),
  czm_viewRotation3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.viewRotation3D;
    }
  }),
  czm_inverseView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseView;
    }
  }),
  czm_inverseView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseView3D;
    }
  }),
  czm_inverseViewRotation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseViewRotation;
    }
  }),
  czm_inverseViewRotation3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseViewRotation3D;
    }
  }),
  czm_projection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.projection;
    }
  }),
  czm_inverseProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseProjection;
    }
  }),
  czm_infiniteProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.infiniteProjection;
    }
  }),
  czm_modelView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelView;
    }
  }),
  czm_modelView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelView3D;
    }
  }),
  czm_modelViewRelativeToEye: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewRelativeToEye;
    }
  }),
  czm_inverseModelView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelView;
    }
  }),
  czm_inverseModelView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelView3D;
    }
  }),
  czm_viewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewProjection;
    }
  }),
  czm_inverseViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseViewProjection;
    }
  }),
  czm_modelViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewProjection;
    }
  }),
  czm_inverseModelViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelViewProjection;
    }
  }),
  czm_modelViewProjectionRelativeToEye: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewProjectionRelativeToEye;
    }
  }),
  czm_modelViewInfiniteProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewInfiniteProjection;
    }
  }),
  czm_orthographicIn3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.orthographicIn3D ? 1 : 0;
    }
  }),
  czm_normal: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.normal;
    }
  }),
  czm_normal3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.normal3D;
    }
  }),
  czm_inverseNormal: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseNormal;
    }
  }),
  czm_inverseNormal3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseNormal3D;
    }
  }),
  czm_eyeHeight: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.eyeHeight;
    }
  }),
  czm_eyeHeight2D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.eyeHeight2D;
    }
  }),
  czm_entireFrustum: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.entireFrustum;
    }
  }),
  czm_currentFrustum: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.currentFrustum;
    }
  }),
  czm_frustumPlanes: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.frustumPlanes;
    }
  }),
  czm_farDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.farDepthFromNearPlusOne;
    }
  }),
  czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.log2FarDepthFromNearPlusOne;
    }
  }),
  czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.oneOverLog2FarDepthFromNearPlusOne;
    }
  }),
  czm_sunPositionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunPositionWC;
    }
  }),
  czm_sunPositionColumbusView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunPositionColumbusView;
    }
  }),
  czm_sunDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunDirectionEC;
    }
  }),
  czm_sunDirectionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunDirectionWC;
    }
  }),
  czm_moonDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.moonDirectionEC;
    }
  }),
  czm_lightDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightDirectionEC;
    }
  }),
  czm_lightDirectionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightDirectionWC;
    }
  }),
  czm_lightColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightColor;
    }
  }),
  czm_lightColorHdr: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightColorHdr;
    }
  }),
  czm_encodedCameraPositionMCHigh: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.encodedCameraPositionMCHigh;
    }
  }),
  czm_encodedCameraPositionMCLow: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.encodedCameraPositionMCLow;
    }
  }),
  czm_viewerPositionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return Matrix4_default.getTranslation(
        uniformState.inverseView,
        viewerPositionWCScratch
      );
    }
  }),
  czm_frameNumber: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.frameNumber;
    }
  }),
  czm_morphTime: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.morphTime;
    }
  }),
  czm_sceneMode: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.mode;
    }
  }),
  czm_pass: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.pass;
    }
  }),
  czm_backgroundColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.backgroundColor;
    }
  }),
  czm_brdfLut: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.brdfLut;
    }
  }),
  czm_environmentMap: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_CUBE,
    getValue: function(uniformState) {
      return uniformState.environmentMap;
    }
  }),
  czm_specularEnvironmentMaps: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMaps;
    }
  }),
  czm_specularEnvironmentMapSize: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMapsDimensions;
    }
  }),
  czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMapsMaximumLOD;
    }
  }),
  czm_sphericalHarmonicCoefficients: new AutomaticUniform({
    size: 9,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sphericalHarmonicCoefficients;
    }
  }),
  czm_temeToPseudoFixed: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.temeToPseudoFixedMatrix;
    }
  }),
  czm_pixelRatio: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.pixelRatio;
    }
  }),
  czm_fogDensity: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.fogDensity;
    }
  }),
  czm_splitPosition: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.splitPosition;
    }
  }),
  czm_geometricToleranceOverMeter: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.geometricToleranceOverMeter;
    }
  }),
  czm_minimumDisableDepthTestDistance: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.minimumDisableDepthTestDistance;
    }
  }),
  czm_invertClassificationColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.invertClassificationColor;
    }
  }),
  czm_gamma: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.gamma;
    }
  }),
  czm_ellipsoidRadii: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.ellipsoid.radii;
    }
  }),
  czm_ellipsoidInverseRadii: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.ellipsoid.oneOverRadii;
    }
  })
};
var AutomaticUniforms_default = AutomaticUniforms;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/createGuid.js
function createGuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v3 = c === "x" ? r : r & 3 | 8;
    return v3.toString(16);
  });
}
var createGuid_default = createGuid;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/destroyObject.js
function returnTrue() {
  return true;
}
function destroyObject(object, message) {
  message = defaultValue_default(
    message,
    "This object was destroyed, i.e., destroy() was called."
  );
  function throwOnDestroyed() {
    throw new DeveloperError_default(message);
  }
  for (const key in object) {
    if (typeof object[key] === "function") {
      object[key] = throwOnDestroyed;
    }
  }
  object.isDestroyed = returnTrue;
  return void 0;
}
var destroyObject_default = destroyObject;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/IndexDatatype.js
var IndexDatatype = {
  UNSIGNED_BYTE: WebGLConstants_default.UNSIGNED_BYTE,
  UNSIGNED_SHORT: WebGLConstants_default.UNSIGNED_SHORT,
  UNSIGNED_INT: WebGLConstants_default.UNSIGNED_INT
};
IndexDatatype.getSizeInBytes = function(indexDatatype) {
  switch (indexDatatype) {
    case IndexDatatype.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case IndexDatatype.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case IndexDatatype.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
  }
  throw new DeveloperError_default(
    "indexDatatype is required and must be a valid IndexDatatype constant."
  );
};
IndexDatatype.fromSizeInBytes = function(sizeInBytes) {
  switch (sizeInBytes) {
    case 2:
      return IndexDatatype.UNSIGNED_SHORT;
    case 4:
      return IndexDatatype.UNSIGNED_INT;
    case 1:
      return IndexDatatype.UNSIGNED_BYTE;
    default:
      throw new DeveloperError_default(
        "Size in bytes cannot be mapped to an IndexDatatype"
      );
  }
};
IndexDatatype.validate = function(indexDatatype) {
  return defined_default(indexDatatype) && (indexDatatype === IndexDatatype.UNSIGNED_BYTE || indexDatatype === IndexDatatype.UNSIGNED_SHORT || indexDatatype === IndexDatatype.UNSIGNED_INT);
};
IndexDatatype.createTypedArray = function(numberOfVertices, indicesLengthOrArray) {
  if (!defined_default(numberOfVertices)) {
    throw new DeveloperError_default("numberOfVertices is required.");
  }
  if (numberOfVertices >= Math_default.SIXTY_FOUR_KILOBYTES) {
    return new Uint32Array(indicesLengthOrArray);
  }
  return new Uint16Array(indicesLengthOrArray);
};
IndexDatatype.createTypedArrayFromArrayBuffer = function(numberOfVertices, sourceArray, byteOffset, length) {
  if (!defined_default(numberOfVertices)) {
    throw new DeveloperError_default("numberOfVertices is required.");
  }
  if (!defined_default(sourceArray)) {
    throw new DeveloperError_default("sourceArray is required.");
  }
  if (!defined_default(byteOffset)) {
    throw new DeveloperError_default("byteOffset is required.");
  }
  if (numberOfVertices >= Math_default.SIXTY_FOUR_KILOBYTES) {
    return new Uint32Array(sourceArray, byteOffset, length);
  }
  return new Uint16Array(sourceArray, byteOffset, length);
};
IndexDatatype.fromTypedArray = function(array) {
  if (array instanceof Uint8Array) {
    return IndexDatatype.UNSIGNED_BYTE;
  }
  if (array instanceof Uint16Array) {
    return IndexDatatype.UNSIGNED_SHORT;
  }
  if (array instanceof Uint32Array) {
    return IndexDatatype.UNSIGNED_INT;
  }
  throw new DeveloperError_default(
    "array must be a Uint8Array, Uint16Array, or Uint32Array."
  );
};
var IndexDatatype_default = Object.freeze(IndexDatatype);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/BufferUsage.js
var BufferUsage = {
  STREAM_DRAW: WebGLConstants_default.STREAM_DRAW,
  STATIC_DRAW: WebGLConstants_default.STATIC_DRAW,
  DYNAMIC_DRAW: WebGLConstants_default.DYNAMIC_DRAW,
  validate: function(bufferUsage) {
    return bufferUsage === BufferUsage.STREAM_DRAW || bufferUsage === BufferUsage.STATIC_DRAW || bufferUsage === BufferUsage.DYNAMIC_DRAW;
  }
};
var BufferUsage_default = Object.freeze(BufferUsage);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/Buffer.js
function Buffer2(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  if (!defined_default(options.typedArray) && !defined_default(options.sizeInBytes)) {
    throw new DeveloperError_default(
      "Either options.sizeInBytes or options.typedArray is required."
    );
  }
  if (defined_default(options.typedArray) && defined_default(options.sizeInBytes)) {
    throw new DeveloperError_default(
      "Cannot pass in both options.sizeInBytes and options.typedArray."
    );
  }
  if (defined_default(options.typedArray)) {
    Check_default.typeOf.object("options.typedArray", options.typedArray);
    Check_default.typeOf.number(
      "options.typedArray.byteLength",
      options.typedArray.byteLength
    );
  }
  if (!BufferUsage_default.validate(options.usage)) {
    throw new DeveloperError_default("usage is invalid.");
  }
  const gl = options.context._gl;
  const bufferTarget = options.bufferTarget;
  const typedArray = options.typedArray;
  let sizeInBytes = options.sizeInBytes;
  const usage = options.usage;
  const hasArray = defined_default(typedArray);
  if (hasArray) {
    sizeInBytes = typedArray.byteLength;
  }
  Check_default.typeOf.number.greaterThan("sizeInBytes", sizeInBytes, 0);
  const buffer = gl.createBuffer();
  gl.bindBuffer(bufferTarget, buffer);
  gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);
  gl.bindBuffer(bufferTarget, null);
  this._id = createGuid_default();
  this._gl = gl;
  this._webgl2 = options.context._webgl2;
  this._bufferTarget = bufferTarget;
  this._sizeInBytes = sizeInBytes;
  this._usage = usage;
  this._buffer = buffer;
  this.vertexArrayDestroyable = true;
}
Buffer2.createVertexBuffer = function(options) {
  Check_default.defined("options.context", options.context);
  return new Buffer2({
    context: options.context,
    bufferTarget: WebGLConstants_default.ARRAY_BUFFER,
    typedArray: options.typedArray,
    sizeInBytes: options.sizeInBytes,
    usage: options.usage
  });
};
Buffer2.createIndexBuffer = function(options) {
  Check_default.defined("options.context", options.context);
  if (!IndexDatatype_default.validate(options.indexDatatype)) {
    throw new DeveloperError_default("Invalid indexDatatype.");
  }
  if (options.indexDatatype === IndexDatatype_default.UNSIGNED_INT && !options.context.elementIndexUint) {
    throw new DeveloperError_default(
      "IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint."
    );
  }
  const context = options.context;
  const indexDatatype = options.indexDatatype;
  const bytesPerIndex = IndexDatatype_default.getSizeInBytes(indexDatatype);
  const buffer = new Buffer2({
    context,
    bufferTarget: WebGLConstants_default.ELEMENT_ARRAY_BUFFER,
    typedArray: options.typedArray,
    sizeInBytes: options.sizeInBytes,
    usage: options.usage
  });
  const numberOfIndices = buffer.sizeInBytes / bytesPerIndex;
  Object.defineProperties(buffer, {
    indexDatatype: {
      get: function() {
        return indexDatatype;
      }
    },
    bytesPerIndex: {
      get: function() {
        return bytesPerIndex;
      }
    },
    numberOfIndices: {
      get: function() {
        return numberOfIndices;
      }
    }
  });
  return buffer;
};
Object.defineProperties(Buffer2.prototype, {
  sizeInBytes: {
    get: function() {
      return this._sizeInBytes;
    }
  },
  usage: {
    get: function() {
      return this._usage;
    }
  }
});
Buffer2.prototype._getBuffer = function() {
  return this._buffer;
};
Buffer2.prototype.copyFromArrayView = function(arrayView, offsetInBytes) {
  offsetInBytes = defaultValue_default(offsetInBytes, 0);
  Check_default.defined("arrayView", arrayView);
  Check_default.typeOf.number.lessThanOrEquals(
    "offsetInBytes + arrayView.byteLength",
    offsetInBytes + arrayView.byteLength,
    this._sizeInBytes
  );
  const gl = this._gl;
  const target = this._bufferTarget;
  gl.bindBuffer(target, this._buffer);
  gl.bufferSubData(target, offsetInBytes, arrayView);
  gl.bindBuffer(target, null);
};
Buffer2.prototype.copyFromBuffer = function(readBuffer, readOffset, writeOffset, sizeInBytes) {
  if (!this._webgl2) {
    throw new DeveloperError_default("A WebGL 2 context is required.");
  }
  if (!defined_default(readBuffer)) {
    throw new DeveloperError_default("readBuffer must be defined.");
  }
  if (!defined_default(sizeInBytes) || sizeInBytes <= 0) {
    throw new DeveloperError_default(
      "sizeInBytes must be defined and be greater than zero."
    );
  }
  if (!defined_default(readOffset) || readOffset < 0 || readOffset + sizeInBytes > readBuffer._sizeInBytes) {
    throw new DeveloperError_default(
      "readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes."
    );
  }
  if (!defined_default(writeOffset) || writeOffset < 0 || writeOffset + sizeInBytes > this._sizeInBytes) {
    throw new DeveloperError_default(
      "writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes."
    );
  }
  if (this._buffer === readBuffer._buffer && (writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes || readOffset > writeOffset && readOffset < writeOffset + sizeInBytes)) {
    throw new DeveloperError_default(
      "When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap."
    );
  }
  if (this._bufferTarget === WebGLConstants_default.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget !== WebGLConstants_default.ELEMENT_ARRAY_BUFFER || this._bufferTarget !== WebGLConstants_default.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget === WebGLConstants_default.ELEMENT_ARRAY_BUFFER) {
    throw new DeveloperError_default(
      "Can not copy an index buffer into another buffer type."
    );
  }
  const readTarget = WebGLConstants_default.COPY_READ_BUFFER;
  const writeTarget = WebGLConstants_default.COPY_WRITE_BUFFER;
  const gl = this._gl;
  gl.bindBuffer(writeTarget, this._buffer);
  gl.bindBuffer(readTarget, readBuffer._buffer);
  gl.copyBufferSubData(
    readTarget,
    writeTarget,
    readOffset,
    writeOffset,
    sizeInBytes
  );
  gl.bindBuffer(writeTarget, null);
  gl.bindBuffer(readTarget, null);
};
Buffer2.prototype.getBufferData = function(arrayView, sourceOffset, destinationOffset, length) {
  sourceOffset = defaultValue_default(sourceOffset, 0);
  destinationOffset = defaultValue_default(destinationOffset, 0);
  if (!this._webgl2) {
    throw new DeveloperError_default("A WebGL 2 context is required.");
  }
  if (!defined_default(arrayView)) {
    throw new DeveloperError_default("arrayView is required.");
  }
  let copyLength;
  let elementSize;
  let arrayLength = arrayView.byteLength;
  if (!defined_default(length)) {
    if (defined_default(arrayLength)) {
      copyLength = arrayLength - destinationOffset;
      elementSize = 1;
    } else {
      arrayLength = arrayView.length;
      copyLength = arrayLength - destinationOffset;
      elementSize = arrayView.BYTES_PER_ELEMENT;
    }
  } else {
    copyLength = length;
    if (defined_default(arrayLength)) {
      elementSize = 1;
    } else {
      arrayLength = arrayView.length;
      elementSize = arrayView.BYTES_PER_ELEMENT;
    }
  }
  if (destinationOffset < 0 || destinationOffset > arrayLength) {
    throw new DeveloperError_default(
      "destinationOffset must be greater than zero and less than the arrayView length."
    );
  }
  if (destinationOffset + copyLength > arrayLength) {
    throw new DeveloperError_default(
      "destinationOffset + length must be less than or equal to the arrayViewLength."
    );
  }
  if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {
    throw new DeveloperError_default(
      "sourceOffset must be greater than zero and less than the buffers size."
    );
  }
  if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {
    throw new DeveloperError_default(
      "sourceOffset + length must be less than the buffers size."
    );
  }
  const gl = this._gl;
  const target = WebGLConstants_default.COPY_READ_BUFFER;
  gl.bindBuffer(target, this._buffer);
  gl.getBufferSubData(
    target,
    sourceOffset,
    arrayView,
    destinationOffset,
    length
  );
  gl.bindBuffer(target, null);
};
Buffer2.prototype.isDestroyed = function() {
  return false;
};
Buffer2.prototype.destroy = function() {
  this._gl.deleteBuffer(this._buffer);
  return destroyObject_default(this);
};
var Buffer_default = Buffer2;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Fullscreen.js
var _supportsFullscreen;
var _names = {
  requestFullscreen: void 0,
  exitFullscreen: void 0,
  fullscreenEnabled: void 0,
  fullscreenElement: void 0,
  fullscreenchange: void 0,
  fullscreenerror: void 0
};
var Fullscreen = {};
Object.defineProperties(Fullscreen, {
  element: {
    get: function() {
      if (!Fullscreen.supportsFullscreen()) {
        return void 0;
      }
      return document[_names.fullscreenElement];
    }
  },
  changeEventName: {
    get: function() {
      if (!Fullscreen.supportsFullscreen()) {
        return void 0;
      }
      return _names.fullscreenchange;
    }
  },
  errorEventName: {
    get: function() {
      if (!Fullscreen.supportsFullscreen()) {
        return void 0;
      }
      return _names.fullscreenerror;
    }
  },
  enabled: {
    get: function() {
      if (!Fullscreen.supportsFullscreen()) {
        return void 0;
      }
      return document[_names.fullscreenEnabled];
    }
  },
  fullscreen: {
    get: function() {
      if (!Fullscreen.supportsFullscreen()) {
        return void 0;
      }
      return Fullscreen.element !== null;
    }
  }
});
Fullscreen.supportsFullscreen = function() {
  if (defined_default(_supportsFullscreen)) {
    return _supportsFullscreen;
  }
  _supportsFullscreen = false;
  const body = document.body;
  if (typeof body.requestFullscreen === "function") {
    _names.requestFullscreen = "requestFullscreen";
    _names.exitFullscreen = "exitFullscreen";
    _names.fullscreenEnabled = "fullscreenEnabled";
    _names.fullscreenElement = "fullscreenElement";
    _names.fullscreenchange = "fullscreenchange";
    _names.fullscreenerror = "fullscreenerror";
    _supportsFullscreen = true;
    return _supportsFullscreen;
  }
  const prefixes = ["webkit", "moz", "o", "ms", "khtml"];
  let name;
  for (let i = 0, len = prefixes.length; i < len; ++i) {
    const prefix = prefixes[i];
    name = `${prefix}RequestFullscreen`;
    if (typeof body[name] === "function") {
      _names.requestFullscreen = name;
      _supportsFullscreen = true;
    } else {
      name = `${prefix}RequestFullScreen`;
      if (typeof body[name] === "function") {
        _names.requestFullscreen = name;
        _supportsFullscreen = true;
      }
    }
    name = `${prefix}ExitFullscreen`;
    if (typeof document[name] === "function") {
      _names.exitFullscreen = name;
    } else {
      name = `${prefix}CancelFullScreen`;
      if (typeof document[name] === "function") {
        _names.exitFullscreen = name;
      }
    }
    name = `${prefix}FullscreenEnabled`;
    if (document[name] !== void 0) {
      _names.fullscreenEnabled = name;
    } else {
      name = `${prefix}FullScreenEnabled`;
      if (document[name] !== void 0) {
        _names.fullscreenEnabled = name;
      }
    }
    name = `${prefix}FullscreenElement`;
    if (document[name] !== void 0) {
      _names.fullscreenElement = name;
    } else {
      name = `${prefix}FullScreenElement`;
      if (document[name] !== void 0) {
        _names.fullscreenElement = name;
      }
    }
    name = `${prefix}fullscreenchange`;
    if (document[`on${name}`] !== void 0) {
      if (prefix === "ms") {
        name = "MSFullscreenChange";
      }
      _names.fullscreenchange = name;
    }
    name = `${prefix}fullscreenerror`;
    if (document[`on${name}`] !== void 0) {
      if (prefix === "ms") {
        name = "MSFullscreenError";
      }
      _names.fullscreenerror = name;
    }
  }
  return _supportsFullscreen;
};
Fullscreen.requestFullscreen = function(element, vrDevice) {
  if (!Fullscreen.supportsFullscreen()) {
    return;
  }
  element[_names.requestFullscreen]({ vrDisplay: vrDevice });
};
Fullscreen.exitFullscreen = function() {
  if (!Fullscreen.supportsFullscreen()) {
    return;
  }
  document[_names.exitFullscreen]();
};
Fullscreen._names = _names;
var Fullscreen_default = Fullscreen;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/FeatureDetection.js
var theNavigator;
if (typeof navigator !== "undefined") {
  theNavigator = navigator;
} else {
  theNavigator = {};
}
function extractVersion(versionString) {
  const parts = versionString.split(".");
  for (let i = 0, len = parts.length; i < len; ++i) {
    parts[i] = parseInt(parts[i], 10);
  }
  return parts;
}
var isChromeResult;
var chromeVersionResult;
function isChrome() {
  if (!defined_default(isChromeResult)) {
    isChromeResult = false;
    if (!isEdge()) {
      const fields = / Chrome\/([\.0-9]+)/.exec(theNavigator.userAgent);
      if (fields !== null) {
        isChromeResult = true;
        chromeVersionResult = extractVersion(fields[1]);
      }
    }
  }
  return isChromeResult;
}
function chromeVersion() {
  return isChrome() && chromeVersionResult;
}
var isSafariResult;
var safariVersionResult;
function isSafari() {
  if (!defined_default(isSafariResult)) {
    isSafariResult = false;
    if (!isChrome() && !isEdge() && / Safari\/[\.0-9]+/.test(theNavigator.userAgent)) {
      const fields = / Version\/([\.0-9]+)/.exec(theNavigator.userAgent);
      if (fields !== null) {
        isSafariResult = true;
        safariVersionResult = extractVersion(fields[1]);
      }
    }
  }
  return isSafariResult;
}
function safariVersion() {
  return isSafari() && safariVersionResult;
}
var isWebkitResult;
var webkitVersionResult;
function isWebkit() {
  if (!defined_default(isWebkitResult)) {
    isWebkitResult = false;
    const fields = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(theNavigator.userAgent);
    if (fields !== null) {
      isWebkitResult = true;
      webkitVersionResult = extractVersion(fields[1]);
      webkitVersionResult.isNightly = !!fields[2];
    }
  }
  return isWebkitResult;
}
function webkitVersion() {
  return isWebkit() && webkitVersionResult;
}
var isInternetExplorerResult;
var internetExplorerVersionResult;
function isInternetExplorer() {
  if (!defined_default(isInternetExplorerResult)) {
    isInternetExplorerResult = false;
    let fields;
    if (theNavigator.appName === "Microsoft Internet Explorer") {
      fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
      if (fields !== null) {
        isInternetExplorerResult = true;
        internetExplorerVersionResult = extractVersion(fields[1]);
      }
    } else if (theNavigator.appName === "Netscape") {
      fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(
        theNavigator.userAgent
      );
      if (fields !== null) {
        isInternetExplorerResult = true;
        internetExplorerVersionResult = extractVersion(fields[1]);
      }
    }
  }
  return isInternetExplorerResult;
}
function internetExplorerVersion() {
  return isInternetExplorer() && internetExplorerVersionResult;
}
var isEdgeResult;
var edgeVersionResult;
function isEdge() {
  if (!defined_default(isEdgeResult)) {
    isEdgeResult = false;
    const fields = / Edg\/([\.0-9]+)/.exec(theNavigator.userAgent);
    if (fields !== null) {
      isEdgeResult = true;
      edgeVersionResult = extractVersion(fields[1]);
    }
  }
  return isEdgeResult;
}
function edgeVersion() {
  return isEdge() && edgeVersionResult;
}
var isFirefoxResult;
var firefoxVersionResult;
function isFirefox() {
  if (!defined_default(isFirefoxResult)) {
    isFirefoxResult = false;
    const fields = /Firefox\/([\.0-9]+)/.exec(theNavigator.userAgent);
    if (fields !== null) {
      isFirefoxResult = true;
      firefoxVersionResult = extractVersion(fields[1]);
    }
  }
  return isFirefoxResult;
}
var isWindowsResult;
function isWindows() {
  if (!defined_default(isWindowsResult)) {
    isWindowsResult = /Windows/i.test(theNavigator.appVersion);
  }
  return isWindowsResult;
}
var isIPadOrIOSResult;
function isIPadOrIOS() {
  if (!defined_default(isIPadOrIOSResult)) {
    isIPadOrIOSResult = navigator.platform === "iPhone" || navigator.platform === "iPod" || navigator.platform === "iPad";
  }
  return isIPadOrIOSResult;
}
function firefoxVersion() {
  return isFirefox() && firefoxVersionResult;
}
var hasPointerEvents;
function supportsPointerEvents() {
  if (!defined_default(hasPointerEvents)) {
    hasPointerEvents = !isFirefox() && typeof PointerEvent !== "undefined" && (!defined_default(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);
  }
  return hasPointerEvents;
}
var imageRenderingValueResult;
var supportsImageRenderingPixelatedResult;
function supportsImageRenderingPixelated() {
  if (!defined_default(supportsImageRenderingPixelatedResult)) {
    const canvas = document.createElement("canvas");
    canvas.setAttribute(
      "style",
      "image-rendering: -moz-crisp-edges;image-rendering: pixelated;"
    );
    const tmp2 = canvas.style.imageRendering;
    supportsImageRenderingPixelatedResult = defined_default(tmp2) && tmp2 !== "";
    if (supportsImageRenderingPixelatedResult) {
      imageRenderingValueResult = tmp2;
    }
  }
  return supportsImageRenderingPixelatedResult;
}
function imageRenderingValue() {
  return supportsImageRenderingPixelated() ? imageRenderingValueResult : void 0;
}
function supportsWebP() {
  if (!supportsWebP.initialized) {
    throw new DeveloperError_default(
      "You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP"
    );
  }
  return supportsWebP._result;
}
supportsWebP._promise = void 0;
supportsWebP._result = void 0;
supportsWebP.initialize = function() {
  if (defined_default(supportsWebP._promise)) {
    return supportsWebP._promise;
  }
  supportsWebP._promise = new Promise((resolve) => {
    const image = new Image();
    image.onload = function() {
      supportsWebP._result = image.width > 0 && image.height > 0;
      resolve(supportsWebP._result);
    };
    image.onerror = function() {
      supportsWebP._result = false;
      resolve(supportsWebP._result);
    };
    image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
  });
  return supportsWebP._promise;
};
Object.defineProperties(supportsWebP, {
  initialized: {
    get: function() {
      return defined_default(supportsWebP._result);
    }
  }
});
var typedArrayTypes = [];
if (typeof ArrayBuffer !== "undefined") {
  typedArrayTypes.push(
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  );
  if (typeof Uint8ClampedArray !== "undefined") {
    typedArrayTypes.push(Uint8ClampedArray);
  }
  if (typeof Uint8ClampedArray !== "undefined") {
    typedArrayTypes.push(Uint8ClampedArray);
  }
  if (typeof BigInt64Array !== "undefined") {
    typedArrayTypes.push(BigInt64Array);
  }
  if (typeof BigUint64Array !== "undefined") {
    typedArrayTypes.push(BigUint64Array);
  }
}
var FeatureDetection = {
  isChrome,
  chromeVersion,
  isSafari,
  safariVersion,
  isWebkit,
  webkitVersion,
  isInternetExplorer,
  internetExplorerVersion,
  isEdge,
  edgeVersion,
  isFirefox,
  firefoxVersion,
  isWindows,
  isIPadOrIOS,
  hardwareConcurrency: defaultValue_default(theNavigator.hardwareConcurrency, 3),
  supportsPointerEvents,
  supportsImageRenderingPixelated,
  supportsWebP,
  imageRenderingValue,
  typedArrayTypes
};
FeatureDetection.supportsBasis = function(scene) {
  return FeatureDetection.supportsWebAssembly() && scene.context.supportsBasis;
};
FeatureDetection.supportsFullscreen = function() {
  return Fullscreen_default.supportsFullscreen();
};
FeatureDetection.supportsTypedArrays = function() {
  return typeof ArrayBuffer !== "undefined";
};
FeatureDetection.supportsBigInt64Array = function() {
  return typeof BigInt64Array !== "undefined";
};
FeatureDetection.supportsBigUint64Array = function() {
  return typeof BigUint64Array !== "undefined";
};
FeatureDetection.supportsBigInt = function() {
  return typeof BigInt !== "undefined";
};
FeatureDetection.supportsWebWorkers = function() {
  return typeof Worker !== "undefined";
};
FeatureDetection.supportsWebAssembly = function() {
  return typeof WebAssembly !== "undefined";
};
var FeatureDetection_default = FeatureDetection;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Color.js
function hue2rgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  }
  if (h > 1) {
    h -= 1;
  }
  if (h * 6 < 1) {
    return m1 + (m2 - m1) * 6 * h;
  }
  if (h * 2 < 1) {
    return m2;
  }
  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }
  return m1;
}
function Color(red, green, blue, alpha) {
  this.red = defaultValue_default(red, 1);
  this.green = defaultValue_default(green, 1);
  this.blue = defaultValue_default(blue, 1);
  this.alpha = defaultValue_default(alpha, 1);
}
Color.fromCartesian4 = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  if (!defined_default(result)) {
    return new Color(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
  }
  result.red = cartesian.x;
  result.green = cartesian.y;
  result.blue = cartesian.z;
  result.alpha = cartesian.w;
  return result;
};
Color.fromBytes = function(red, green, blue, alpha, result) {
  red = Color.byteToFloat(defaultValue_default(red, 255));
  green = Color.byteToFloat(defaultValue_default(green, 255));
  blue = Color.byteToFloat(defaultValue_default(blue, 255));
  alpha = Color.byteToFloat(defaultValue_default(alpha, 255));
  if (!defined_default(result)) {
    return new Color(red, green, blue, alpha);
  }
  result.red = red;
  result.green = green;
  result.blue = blue;
  result.alpha = alpha;
  return result;
};
Color.fromAlpha = function(color, alpha, result) {
  Check_default.typeOf.object("color", color);
  Check_default.typeOf.number("alpha", alpha);
  if (!defined_default(result)) {
    return new Color(color.red, color.green, color.blue, alpha);
  }
  result.red = color.red;
  result.green = color.green;
  result.blue = color.blue;
  result.alpha = alpha;
  return result;
};
var scratchArrayBuffer;
var scratchUint32Array;
var scratchUint8Array;
if (FeatureDetection_default.supportsTypedArrays()) {
  scratchArrayBuffer = new ArrayBuffer(4);
  scratchUint32Array = new Uint32Array(scratchArrayBuffer);
  scratchUint8Array = new Uint8Array(scratchArrayBuffer);
}
Color.fromRgba = function(rgba, result) {
  scratchUint32Array[0] = rgba;
  return Color.fromBytes(
    scratchUint8Array[0],
    scratchUint8Array[1],
    scratchUint8Array[2],
    scratchUint8Array[3],
    result
  );
};
Color.fromHsl = function(hue, saturation, lightness, alpha, result) {
  hue = defaultValue_default(hue, 0) % 1;
  saturation = defaultValue_default(saturation, 0);
  lightness = defaultValue_default(lightness, 0);
  alpha = defaultValue_default(alpha, 1);
  let red = lightness;
  let green = lightness;
  let blue = lightness;
  if (saturation !== 0) {
    let m2;
    if (lightness < 0.5) {
      m2 = lightness * (1 + saturation);
    } else {
      m2 = lightness + saturation - lightness * saturation;
    }
    const m1 = 2 * lightness - m2;
    red = hue2rgb(m1, m2, hue + 1 / 3);
    green = hue2rgb(m1, m2, hue);
    blue = hue2rgb(m1, m2, hue - 1 / 3);
  }
  if (!defined_default(result)) {
    return new Color(red, green, blue, alpha);
  }
  result.red = red;
  result.green = green;
  result.blue = blue;
  result.alpha = alpha;
  return result;
};
Color.fromRandom = function(options, result) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  let red = options.red;
  if (!defined_default(red)) {
    const minimumRed = defaultValue_default(options.minimumRed, 0);
    const maximumRed = defaultValue_default(options.maximumRed, 1);
    Check_default.typeOf.number.lessThanOrEquals("minimumRed", minimumRed, maximumRed);
    red = minimumRed + Math_default.nextRandomNumber() * (maximumRed - minimumRed);
  }
  let green = options.green;
  if (!defined_default(green)) {
    const minimumGreen = defaultValue_default(options.minimumGreen, 0);
    const maximumGreen = defaultValue_default(options.maximumGreen, 1);
    Check_default.typeOf.number.lessThanOrEquals(
      "minimumGreen",
      minimumGreen,
      maximumGreen
    );
    green = minimumGreen + Math_default.nextRandomNumber() * (maximumGreen - minimumGreen);
  }
  let blue = options.blue;
  if (!defined_default(blue)) {
    const minimumBlue = defaultValue_default(options.minimumBlue, 0);
    const maximumBlue = defaultValue_default(options.maximumBlue, 1);
    Check_default.typeOf.number.lessThanOrEquals(
      "minimumBlue",
      minimumBlue,
      maximumBlue
    );
    blue = minimumBlue + Math_default.nextRandomNumber() * (maximumBlue - minimumBlue);
  }
  let alpha = options.alpha;
  if (!defined_default(alpha)) {
    const minimumAlpha = defaultValue_default(options.minimumAlpha, 0);
    const maximumAlpha = defaultValue_default(options.maximumAlpha, 1);
    Check_default.typeOf.number.lessThanOrEquals(
      "minumumAlpha",
      minimumAlpha,
      maximumAlpha
    );
    alpha = minimumAlpha + Math_default.nextRandomNumber() * (maximumAlpha - minimumAlpha);
  }
  if (!defined_default(result)) {
    return new Color(red, green, blue, alpha);
  }
  result.red = red;
  result.green = green;
  result.blue = blue;
  result.alpha = alpha;
  return result;
};
var rgbaMatcher = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i;
var rrggbbaaMatcher = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
var rgbParenthesesMatcher = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
var hslParenthesesMatcher = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
Color.fromCssColorString = function(color, result) {
  Check_default.typeOf.string("color", color);
  if (!defined_default(result)) {
    result = new Color();
  }
  color = color.replace(/\s/g, "");
  const namedColor = Color[color.toUpperCase()];
  if (defined_default(namedColor)) {
    Color.clone(namedColor, result);
    return result;
  }
  let matches = rgbaMatcher.exec(color);
  if (matches !== null) {
    result.red = parseInt(matches[1], 16) / 15;
    result.green = parseInt(matches[2], 16) / 15;
    result.blue = parseInt(matches[3], 16) / 15;
    result.alpha = parseInt(defaultValue_default(matches[4], "f"), 16) / 15;
    return result;
  }
  matches = rrggbbaaMatcher.exec(color);
  if (matches !== null) {
    result.red = parseInt(matches[1], 16) / 255;
    result.green = parseInt(matches[2], 16) / 255;
    result.blue = parseInt(matches[3], 16) / 255;
    result.alpha = parseInt(defaultValue_default(matches[4], "ff"), 16) / 255;
    return result;
  }
  matches = rgbParenthesesMatcher.exec(color);
  if (matches !== null) {
    result.red = parseFloat(matches[1]) / ("%" === matches[1].substr(-1) ? 100 : 255);
    result.green = parseFloat(matches[2]) / ("%" === matches[2].substr(-1) ? 100 : 255);
    result.blue = parseFloat(matches[3]) / ("%" === matches[3].substr(-1) ? 100 : 255);
    result.alpha = parseFloat(defaultValue_default(matches[4], "1.0"));
    return result;
  }
  matches = hslParenthesesMatcher.exec(color);
  if (matches !== null) {
    return Color.fromHsl(
      parseFloat(matches[1]) / 360,
      parseFloat(matches[2]) / 100,
      parseFloat(matches[3]) / 100,
      parseFloat(defaultValue_default(matches[4], "1.0")),
      result
    );
  }
  result = void 0;
  return result;
};
Color.packedLength = 4;
Color.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.red;
  array[startingIndex++] = value.green;
  array[startingIndex++] = value.blue;
  array[startingIndex] = value.alpha;
  return array;
};
Color.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Color();
  }
  result.red = array[startingIndex++];
  result.green = array[startingIndex++];
  result.blue = array[startingIndex++];
  result.alpha = array[startingIndex];
  return result;
};
Color.byteToFloat = function(number) {
  return number / 255;
};
Color.floatToByte = function(number) {
  return number === 1 ? 255 : number * 256 | 0;
};
Color.clone = function(color, result) {
  if (!defined_default(color)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Color(color.red, color.green, color.blue, color.alpha);
  }
  result.red = color.red;
  result.green = color.green;
  result.blue = color.blue;
  result.alpha = color.alpha;
  return result;
};
Color.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.red === right.red && left.green === right.green && left.blue === right.blue && left.alpha === right.alpha;
};
Color.equalsArray = function(color, array, offset) {
  return color.red === array[offset] && color.green === array[offset + 1] && color.blue === array[offset + 2] && color.alpha === array[offset + 3];
};
Color.prototype.clone = function(result) {
  return Color.clone(this, result);
};
Color.prototype.equals = function(other) {
  return Color.equals(this, other);
};
Color.prototype.equalsEpsilon = function(other, epsilon) {
  return this === other || defined_default(other) && Math.abs(this.red - other.red) <= epsilon && Math.abs(this.green - other.green) <= epsilon && Math.abs(this.blue - other.blue) <= epsilon && Math.abs(this.alpha - other.alpha) <= epsilon;
};
Color.prototype.toString = function() {
  return `(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
};
Color.prototype.toCssColorString = function() {
  const red = Color.floatToByte(this.red);
  const green = Color.floatToByte(this.green);
  const blue = Color.floatToByte(this.blue);
  if (this.alpha === 1) {
    return `rgb(${red},${green},${blue})`;
  }
  return `rgba(${red},${green},${blue},${this.alpha})`;
};
Color.prototype.toCssHexString = function() {
  let r = Color.floatToByte(this.red).toString(16);
  if (r.length < 2) {
    r = `0${r}`;
  }
  let g = Color.floatToByte(this.green).toString(16);
  if (g.length < 2) {
    g = `0${g}`;
  }
  let b = Color.floatToByte(this.blue).toString(16);
  if (b.length < 2) {
    b = `0${b}`;
  }
  if (this.alpha < 1) {
    let hexAlpha = Color.floatToByte(this.alpha).toString(16);
    if (hexAlpha.length < 2) {
      hexAlpha = `0${hexAlpha}`;
    }
    return `#${r}${g}${b}${hexAlpha}`;
  }
  return `#${r}${g}${b}`;
};
Color.prototype.toBytes = function(result) {
  const red = Color.floatToByte(this.red);
  const green = Color.floatToByte(this.green);
  const blue = Color.floatToByte(this.blue);
  const alpha = Color.floatToByte(this.alpha);
  if (!defined_default(result)) {
    return [red, green, blue, alpha];
  }
  result[0] = red;
  result[1] = green;
  result[2] = blue;
  result[3] = alpha;
  return result;
};
Color.prototype.toRgba = function() {
  scratchUint8Array[0] = Color.floatToByte(this.red);
  scratchUint8Array[1] = Color.floatToByte(this.green);
  scratchUint8Array[2] = Color.floatToByte(this.blue);
  scratchUint8Array[3] = Color.floatToByte(this.alpha);
  return scratchUint32Array[0];
};
Color.prototype.brighten = function(magnitude, result) {
  Check_default.typeOf.number("magnitude", magnitude);
  Check_default.typeOf.number.greaterThanOrEquals("magnitude", magnitude, 0);
  Check_default.typeOf.object("result", result);
  magnitude = 1 - magnitude;
  result.red = 1 - (1 - this.red) * magnitude;
  result.green = 1 - (1 - this.green) * magnitude;
  result.blue = 1 - (1 - this.blue) * magnitude;
  result.alpha = this.alpha;
  return result;
};
Color.prototype.darken = function(magnitude, result) {
  Check_default.typeOf.number("magnitude", magnitude);
  Check_default.typeOf.number.greaterThanOrEquals("magnitude", magnitude, 0);
  Check_default.typeOf.object("result", result);
  magnitude = 1 - magnitude;
  result.red = this.red * magnitude;
  result.green = this.green * magnitude;
  result.blue = this.blue * magnitude;
  result.alpha = this.alpha;
  return result;
};
Color.prototype.withAlpha = function(alpha, result) {
  return Color.fromAlpha(this, alpha, result);
};
Color.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.red = left.red + right.red;
  result.green = left.green + right.green;
  result.blue = left.blue + right.blue;
  result.alpha = left.alpha + right.alpha;
  return result;
};
Color.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.red = left.red - right.red;
  result.green = left.green - right.green;
  result.blue = left.blue - right.blue;
  result.alpha = left.alpha - right.alpha;
  return result;
};
Color.multiply = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.red = left.red * right.red;
  result.green = left.green * right.green;
  result.blue = left.blue * right.blue;
  result.alpha = left.alpha * right.alpha;
  return result;
};
Color.divide = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.red = left.red / right.red;
  result.green = left.green / right.green;
  result.blue = left.blue / right.blue;
  result.alpha = left.alpha / right.alpha;
  return result;
};
Color.mod = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.red = left.red % right.red;
  result.green = left.green % right.green;
  result.blue = left.blue % right.blue;
  result.alpha = left.alpha % right.alpha;
  return result;
};
Color.lerp = function(start, end, t, result) {
  Check_default.typeOf.object("start", start);
  Check_default.typeOf.object("end", end);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  result.red = Math_default.lerp(start.red, end.red, t);
  result.green = Math_default.lerp(start.green, end.green, t);
  result.blue = Math_default.lerp(start.blue, end.blue, t);
  result.alpha = Math_default.lerp(start.alpha, end.alpha, t);
  return result;
};
Color.multiplyByScalar = function(color, scalar, result) {
  Check_default.typeOf.object("color", color);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.red = color.red * scalar;
  result.green = color.green * scalar;
  result.blue = color.blue * scalar;
  result.alpha = color.alpha * scalar;
  return result;
};
Color.divideByScalar = function(color, scalar, result) {
  Check_default.typeOf.object("color", color);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.red = color.red / scalar;
  result.green = color.green / scalar;
  result.blue = color.blue / scalar;
  result.alpha = color.alpha / scalar;
  return result;
};
Color.ALICEBLUE = Object.freeze(Color.fromCssColorString("#F0F8FF"));
Color.ANTIQUEWHITE = Object.freeze(Color.fromCssColorString("#FAEBD7"));
Color.AQUA = Object.freeze(Color.fromCssColorString("#00FFFF"));
Color.AQUAMARINE = Object.freeze(Color.fromCssColorString("#7FFFD4"));
Color.AZURE = Object.freeze(Color.fromCssColorString("#F0FFFF"));
Color.BEIGE = Object.freeze(Color.fromCssColorString("#F5F5DC"));
Color.BISQUE = Object.freeze(Color.fromCssColorString("#FFE4C4"));
Color.BLACK = Object.freeze(Color.fromCssColorString("#000000"));
Color.BLANCHEDALMOND = Object.freeze(Color.fromCssColorString("#FFEBCD"));
Color.BLUE = Object.freeze(Color.fromCssColorString("#0000FF"));
Color.BLUEVIOLET = Object.freeze(Color.fromCssColorString("#8A2BE2"));
Color.BROWN = Object.freeze(Color.fromCssColorString("#A52A2A"));
Color.BURLYWOOD = Object.freeze(Color.fromCssColorString("#DEB887"));
Color.CADETBLUE = Object.freeze(Color.fromCssColorString("#5F9EA0"));
Color.CHARTREUSE = Object.freeze(Color.fromCssColorString("#7FFF00"));
Color.CHOCOLATE = Object.freeze(Color.fromCssColorString("#D2691E"));
Color.CORAL = Object.freeze(Color.fromCssColorString("#FF7F50"));
Color.CORNFLOWERBLUE = Object.freeze(Color.fromCssColorString("#6495ED"));
Color.CORNSILK = Object.freeze(Color.fromCssColorString("#FFF8DC"));
Color.CRIMSON = Object.freeze(Color.fromCssColorString("#DC143C"));
Color.CYAN = Object.freeze(Color.fromCssColorString("#00FFFF"));
Color.DARKBLUE = Object.freeze(Color.fromCssColorString("#00008B"));
Color.DARKCYAN = Object.freeze(Color.fromCssColorString("#008B8B"));
Color.DARKGOLDENROD = Object.freeze(Color.fromCssColorString("#B8860B"));
Color.DARKGRAY = Object.freeze(Color.fromCssColorString("#A9A9A9"));
Color.DARKGREEN = Object.freeze(Color.fromCssColorString("#006400"));
Color.DARKGREY = Color.DARKGRAY;
Color.DARKKHAKI = Object.freeze(Color.fromCssColorString("#BDB76B"));
Color.DARKMAGENTA = Object.freeze(Color.fromCssColorString("#8B008B"));
Color.DARKOLIVEGREEN = Object.freeze(Color.fromCssColorString("#556B2F"));
Color.DARKORANGE = Object.freeze(Color.fromCssColorString("#FF8C00"));
Color.DARKORCHID = Object.freeze(Color.fromCssColorString("#9932CC"));
Color.DARKRED = Object.freeze(Color.fromCssColorString("#8B0000"));
Color.DARKSALMON = Object.freeze(Color.fromCssColorString("#E9967A"));
Color.DARKSEAGREEN = Object.freeze(Color.fromCssColorString("#8FBC8F"));
Color.DARKSLATEBLUE = Object.freeze(Color.fromCssColorString("#483D8B"));
Color.DARKSLATEGRAY = Object.freeze(Color.fromCssColorString("#2F4F4F"));
Color.DARKSLATEGREY = Color.DARKSLATEGRAY;
Color.DARKTURQUOISE = Object.freeze(Color.fromCssColorString("#00CED1"));
Color.DARKVIOLET = Object.freeze(Color.fromCssColorString("#9400D3"));
Color.DEEPPINK = Object.freeze(Color.fromCssColorString("#FF1493"));
Color.DEEPSKYBLUE = Object.freeze(Color.fromCssColorString("#00BFFF"));
Color.DIMGRAY = Object.freeze(Color.fromCssColorString("#696969"));
Color.DIMGREY = Color.DIMGRAY;
Color.DODGERBLUE = Object.freeze(Color.fromCssColorString("#1E90FF"));
Color.FIREBRICK = Object.freeze(Color.fromCssColorString("#B22222"));
Color.FLORALWHITE = Object.freeze(Color.fromCssColorString("#FFFAF0"));
Color.FORESTGREEN = Object.freeze(Color.fromCssColorString("#228B22"));
Color.FUCHSIA = Object.freeze(Color.fromCssColorString("#FF00FF"));
Color.GAINSBORO = Object.freeze(Color.fromCssColorString("#DCDCDC"));
Color.GHOSTWHITE = Object.freeze(Color.fromCssColorString("#F8F8FF"));
Color.GOLD = Object.freeze(Color.fromCssColorString("#FFD700"));
Color.GOLDENROD = Object.freeze(Color.fromCssColorString("#DAA520"));
Color.GRAY = Object.freeze(Color.fromCssColorString("#808080"));
Color.GREEN = Object.freeze(Color.fromCssColorString("#008000"));
Color.GREENYELLOW = Object.freeze(Color.fromCssColorString("#ADFF2F"));
Color.GREY = Color.GRAY;
Color.HONEYDEW = Object.freeze(Color.fromCssColorString("#F0FFF0"));
Color.HOTPINK = Object.freeze(Color.fromCssColorString("#FF69B4"));
Color.INDIANRED = Object.freeze(Color.fromCssColorString("#CD5C5C"));
Color.INDIGO = Object.freeze(Color.fromCssColorString("#4B0082"));
Color.IVORY = Object.freeze(Color.fromCssColorString("#FFFFF0"));
Color.KHAKI = Object.freeze(Color.fromCssColorString("#F0E68C"));
Color.LAVENDER = Object.freeze(Color.fromCssColorString("#E6E6FA"));
Color.LAVENDAR_BLUSH = Object.freeze(Color.fromCssColorString("#FFF0F5"));
Color.LAWNGREEN = Object.freeze(Color.fromCssColorString("#7CFC00"));
Color.LEMONCHIFFON = Object.freeze(Color.fromCssColorString("#FFFACD"));
Color.LIGHTBLUE = Object.freeze(Color.fromCssColorString("#ADD8E6"));
Color.LIGHTCORAL = Object.freeze(Color.fromCssColorString("#F08080"));
Color.LIGHTCYAN = Object.freeze(Color.fromCssColorString("#E0FFFF"));
Color.LIGHTGOLDENRODYELLOW = Object.freeze(Color.fromCssColorString("#FAFAD2"));
Color.LIGHTGRAY = Object.freeze(Color.fromCssColorString("#D3D3D3"));
Color.LIGHTGREEN = Object.freeze(Color.fromCssColorString("#90EE90"));
Color.LIGHTGREY = Color.LIGHTGRAY;
Color.LIGHTPINK = Object.freeze(Color.fromCssColorString("#FFB6C1"));
Color.LIGHTSEAGREEN = Object.freeze(Color.fromCssColorString("#20B2AA"));
Color.LIGHTSKYBLUE = Object.freeze(Color.fromCssColorString("#87CEFA"));
Color.LIGHTSLATEGRAY = Object.freeze(Color.fromCssColorString("#778899"));
Color.LIGHTSLATEGREY = Color.LIGHTSLATEGRAY;
Color.LIGHTSTEELBLUE = Object.freeze(Color.fromCssColorString("#B0C4DE"));
Color.LIGHTYELLOW = Object.freeze(Color.fromCssColorString("#FFFFE0"));
Color.LIME = Object.freeze(Color.fromCssColorString("#00FF00"));
Color.LIMEGREEN = Object.freeze(Color.fromCssColorString("#32CD32"));
Color.LINEN = Object.freeze(Color.fromCssColorString("#FAF0E6"));
Color.MAGENTA = Object.freeze(Color.fromCssColorString("#FF00FF"));
Color.MAROON = Object.freeze(Color.fromCssColorString("#800000"));
Color.MEDIUMAQUAMARINE = Object.freeze(Color.fromCssColorString("#66CDAA"));
Color.MEDIUMBLUE = Object.freeze(Color.fromCssColorString("#0000CD"));
Color.MEDIUMORCHID = Object.freeze(Color.fromCssColorString("#BA55D3"));
Color.MEDIUMPURPLE = Object.freeze(Color.fromCssColorString("#9370DB"));
Color.MEDIUMSEAGREEN = Object.freeze(Color.fromCssColorString("#3CB371"));
Color.MEDIUMSLATEBLUE = Object.freeze(Color.fromCssColorString("#7B68EE"));
Color.MEDIUMSPRINGGREEN = Object.freeze(Color.fromCssColorString("#00FA9A"));
Color.MEDIUMTURQUOISE = Object.freeze(Color.fromCssColorString("#48D1CC"));
Color.MEDIUMVIOLETRED = Object.freeze(Color.fromCssColorString("#C71585"));
Color.MIDNIGHTBLUE = Object.freeze(Color.fromCssColorString("#191970"));
Color.MINTCREAM = Object.freeze(Color.fromCssColorString("#F5FFFA"));
Color.MISTYROSE = Object.freeze(Color.fromCssColorString("#FFE4E1"));
Color.MOCCASIN = Object.freeze(Color.fromCssColorString("#FFE4B5"));
Color.NAVAJOWHITE = Object.freeze(Color.fromCssColorString("#FFDEAD"));
Color.NAVY = Object.freeze(Color.fromCssColorString("#000080"));
Color.OLDLACE = Object.freeze(Color.fromCssColorString("#FDF5E6"));
Color.OLIVE = Object.freeze(Color.fromCssColorString("#808000"));
Color.OLIVEDRAB = Object.freeze(Color.fromCssColorString("#6B8E23"));
Color.ORANGE = Object.freeze(Color.fromCssColorString("#FFA500"));
Color.ORANGERED = Object.freeze(Color.fromCssColorString("#FF4500"));
Color.ORCHID = Object.freeze(Color.fromCssColorString("#DA70D6"));
Color.PALEGOLDENROD = Object.freeze(Color.fromCssColorString("#EEE8AA"));
Color.PALEGREEN = Object.freeze(Color.fromCssColorString("#98FB98"));
Color.PALETURQUOISE = Object.freeze(Color.fromCssColorString("#AFEEEE"));
Color.PALEVIOLETRED = Object.freeze(Color.fromCssColorString("#DB7093"));
Color.PAPAYAWHIP = Object.freeze(Color.fromCssColorString("#FFEFD5"));
Color.PEACHPUFF = Object.freeze(Color.fromCssColorString("#FFDAB9"));
Color.PERU = Object.freeze(Color.fromCssColorString("#CD853F"));
Color.PINK = Object.freeze(Color.fromCssColorString("#FFC0CB"));
Color.PLUM = Object.freeze(Color.fromCssColorString("#DDA0DD"));
Color.POWDERBLUE = Object.freeze(Color.fromCssColorString("#B0E0E6"));
Color.PURPLE = Object.freeze(Color.fromCssColorString("#800080"));
Color.RED = Object.freeze(Color.fromCssColorString("#FF0000"));
Color.ROSYBROWN = Object.freeze(Color.fromCssColorString("#BC8F8F"));
Color.ROYALBLUE = Object.freeze(Color.fromCssColorString("#4169E1"));
Color.SADDLEBROWN = Object.freeze(Color.fromCssColorString("#8B4513"));
Color.SALMON = Object.freeze(Color.fromCssColorString("#FA8072"));
Color.SANDYBROWN = Object.freeze(Color.fromCssColorString("#F4A460"));
Color.SEAGREEN = Object.freeze(Color.fromCssColorString("#2E8B57"));
Color.SEASHELL = Object.freeze(Color.fromCssColorString("#FFF5EE"));
Color.SIENNA = Object.freeze(Color.fromCssColorString("#A0522D"));
Color.SILVER = Object.freeze(Color.fromCssColorString("#C0C0C0"));
Color.SKYBLUE = Object.freeze(Color.fromCssColorString("#87CEEB"));
Color.SLATEBLUE = Object.freeze(Color.fromCssColorString("#6A5ACD"));
Color.SLATEGRAY = Object.freeze(Color.fromCssColorString("#708090"));
Color.SLATEGREY = Color.SLATEGRAY;
Color.SNOW = Object.freeze(Color.fromCssColorString("#FFFAFA"));
Color.SPRINGGREEN = Object.freeze(Color.fromCssColorString("#00FF7F"));
Color.STEELBLUE = Object.freeze(Color.fromCssColorString("#4682B4"));
Color.TAN = Object.freeze(Color.fromCssColorString("#D2B48C"));
Color.TEAL = Object.freeze(Color.fromCssColorString("#008080"));
Color.THISTLE = Object.freeze(Color.fromCssColorString("#D8BFD8"));
Color.TOMATO = Object.freeze(Color.fromCssColorString("#FF6347"));
Color.TURQUOISE = Object.freeze(Color.fromCssColorString("#40E0D0"));
Color.VIOLET = Object.freeze(Color.fromCssColorString("#EE82EE"));
Color.WHEAT = Object.freeze(Color.fromCssColorString("#F5DEB3"));
Color.WHITE = Object.freeze(Color.fromCssColorString("#FFFFFF"));
Color.WHITESMOKE = Object.freeze(Color.fromCssColorString("#F5F5F5"));
Color.YELLOW = Object.freeze(Color.fromCssColorString("#FFFF00"));
Color.YELLOWGREEN = Object.freeze(Color.fromCssColorString("#9ACD32"));
Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0));
var Color_default = Color;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/Pass.js
var Pass = {
  ENVIRONMENT: 0,
  COMPUTE: 1,
  GLOBE: 2,
  TERRAIN_CLASSIFICATION: 3,
  CESIUM_3D_TILE: 4,
  CESIUM_3D_TILE_CLASSIFICATION: 5,
  CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW: 6,
  OPAQUE: 7,
  TRANSLUCENT: 8,
  OVERLAY: 9,
  NUMBER_OF_PASSES: 10
};
var Pass_default = Object.freeze(Pass);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Cartesian2.js
function Cartesian2(x, y) {
  this.x = defaultValue_default(x, 0);
  this.y = defaultValue_default(y, 0);
}
Cartesian2.fromElements = function(x, y, result) {
  if (!defined_default(result)) {
    return new Cartesian2(x, y);
  }
  result.x = x;
  result.y = y;
  return result;
};
Cartesian2.clone = function(cartesian, result) {
  if (!defined_default(cartesian)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Cartesian2(cartesian.x, cartesian.y);
  }
  result.x = cartesian.x;
  result.y = cartesian.y;
  return result;
};
Cartesian2.fromCartesian3 = Cartesian2.clone;
Cartesian2.fromCartesian4 = Cartesian2.clone;
Cartesian2.packedLength = 2;
Cartesian2.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.x;
  array[startingIndex] = value.y;
  return array;
};
Cartesian2.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Cartesian2();
  }
  result.x = array[startingIndex++];
  result.y = array[startingIndex];
  return result;
};
Cartesian2.packArray = function(array, result) {
  Check_default.defined("array", array);
  const length = array.length;
  const resultLength = length * 2;
  if (!defined_default(result)) {
    result = new Array(resultLength);
  } else if (!Array.isArray(result) && result.length !== resultLength) {
    throw new DeveloperError_default(
      "If result is a typed array, it must have exactly array.length * 2 elements"
    );
  } else if (result.length !== resultLength) {
    result.length = resultLength;
  }
  for (let i = 0; i < length; ++i) {
    Cartesian2.pack(array[i], result, i * 2);
  }
  return result;
};
Cartesian2.unpackArray = function(array, result) {
  Check_default.defined("array", array);
  Check_default.typeOf.number.greaterThanOrEquals("array.length", array.length, 2);
  if (array.length % 2 !== 0) {
    throw new DeveloperError_default("array length must be a multiple of 2.");
  }
  const length = array.length;
  if (!defined_default(result)) {
    result = new Array(length / 2);
  } else {
    result.length = length / 2;
  }
  for (let i = 0; i < length; i += 2) {
    const index = i / 2;
    result[index] = Cartesian2.unpack(array, i, result[index]);
  }
  return result;
};
Cartesian2.fromArray = Cartesian2.unpack;
Cartesian2.maximumComponent = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return Math.max(cartesian.x, cartesian.y);
};
Cartesian2.minimumComponent = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return Math.min(cartesian.x, cartesian.y);
};
Cartesian2.minimumByComponent = function(first, second, result) {
  Check_default.typeOf.object("first", first);
  Check_default.typeOf.object("second", second);
  Check_default.typeOf.object("result", result);
  result.x = Math.min(first.x, second.x);
  result.y = Math.min(first.y, second.y);
  return result;
};
Cartesian2.maximumByComponent = function(first, second, result) {
  Check_default.typeOf.object("first", first);
  Check_default.typeOf.object("second", second);
  Check_default.typeOf.object("result", result);
  result.x = Math.max(first.x, second.x);
  result.y = Math.max(first.y, second.y);
  return result;
};
Cartesian2.clamp = function(value, min, max, result) {
  Check_default.typeOf.object("value", value);
  Check_default.typeOf.object("min", min);
  Check_default.typeOf.object("max", max);
  Check_default.typeOf.object("result", result);
  const x = Math_default.clamp(value.x, min.x, max.x);
  const y = Math_default.clamp(value.y, min.y, max.y);
  result.x = x;
  result.y = y;
  return result;
};
Cartesian2.magnitudeSquared = function(cartesian) {
  Check_default.typeOf.object("cartesian", cartesian);
  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
};
Cartesian2.magnitude = function(cartesian) {
  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
};
var distanceScratch3 = new Cartesian2();
Cartesian2.distance = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian2.subtract(left, right, distanceScratch3);
  return Cartesian2.magnitude(distanceScratch3);
};
Cartesian2.distanceSquared = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian2.subtract(left, right, distanceScratch3);
  return Cartesian2.magnitudeSquared(distanceScratch3);
};
Cartesian2.normalize = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const magnitude = Cartesian2.magnitude(cartesian);
  result.x = cartesian.x / magnitude;
  result.y = cartesian.y / magnitude;
  if (isNaN(result.x) || isNaN(result.y)) {
    throw new DeveloperError_default("normalized result is not a number");
  }
  return result;
};
Cartesian2.dot = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  return left.x * right.x + left.y * right.y;
};
Cartesian2.cross = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  return left.x * right.y - left.y * right.x;
};
Cartesian2.multiplyComponents = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x * right.x;
  result.y = left.y * right.y;
  return result;
};
Cartesian2.divideComponents = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x / right.x;
  result.y = left.y / right.y;
  return result;
};
Cartesian2.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x + right.x;
  result.y = left.y + right.y;
  return result;
};
Cartesian2.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x - right.x;
  result.y = left.y - right.y;
  return result;
};
Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = cartesian.x * scalar;
  result.y = cartesian.y * scalar;
  return result;
};
Cartesian2.divideByScalar = function(cartesian, scalar, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = cartesian.x / scalar;
  result.y = cartesian.y / scalar;
  return result;
};
Cartesian2.negate = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result.x = -cartesian.x;
  result.y = -cartesian.y;
  return result;
};
Cartesian2.abs = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result.x = Math.abs(cartesian.x);
  result.y = Math.abs(cartesian.y);
  return result;
};
var lerpScratch3 = new Cartesian2();
Cartesian2.lerp = function(start, end, t, result) {
  Check_default.typeOf.object("start", start);
  Check_default.typeOf.object("end", end);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  Cartesian2.multiplyByScalar(end, t, lerpScratch3);
  result = Cartesian2.multiplyByScalar(start, 1 - t, result);
  return Cartesian2.add(lerpScratch3, result, result);
};
var angleBetweenScratch3 = new Cartesian2();
var angleBetweenScratch22 = new Cartesian2();
Cartesian2.angleBetween = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Cartesian2.normalize(left, angleBetweenScratch3);
  Cartesian2.normalize(right, angleBetweenScratch22);
  return Math_default.acosClamped(
    Cartesian2.dot(angleBetweenScratch3, angleBetweenScratch22)
  );
};
var mostOrthogonalAxisScratch3 = new Cartesian2();
Cartesian2.mostOrthogonalAxis = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch3);
  Cartesian2.abs(f, f);
  if (f.x <= f.y) {
    result = Cartesian2.clone(Cartesian2.UNIT_X, result);
  } else {
    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
  }
  return result;
};
Cartesian2.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.x === right.x && left.y === right.y;
};
Cartesian2.equalsArray = function(cartesian, array, offset) {
  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];
};
Cartesian2.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
  return left === right || defined_default(left) && defined_default(right) && Math_default.equalsEpsilon(
    left.x,
    right.x,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.y,
    right.y,
    relativeEpsilon,
    absoluteEpsilon
  );
};
Cartesian2.ZERO = Object.freeze(new Cartesian2(0, 0));
Cartesian2.ONE = Object.freeze(new Cartesian2(1, 1));
Cartesian2.UNIT_X = Object.freeze(new Cartesian2(1, 0));
Cartesian2.UNIT_Y = Object.freeze(new Cartesian2(0, 1));
Cartesian2.prototype.clone = function(result) {
  return Cartesian2.clone(this, result);
};
Cartesian2.prototype.equals = function(right) {
  return Cartesian2.equals(this, right);
};
Cartesian2.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
  return Cartesian2.equalsEpsilon(
    this,
    right,
    relativeEpsilon,
    absoluteEpsilon
  );
};
Cartesian2.prototype.toString = function() {
  return `(${this.x}, ${this.y})`;
};
var Cartesian2_default = Cartesian2;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/scaleToGeodeticSurface.js
var scaleToGeodeticSurfaceIntersection = new Cartesian3_default();
var scaleToGeodeticSurfaceGradient = new Cartesian3_default();
function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {
  if (!defined_default(cartesian)) {
    throw new DeveloperError_default("cartesian is required.");
  }
  if (!defined_default(oneOverRadii)) {
    throw new DeveloperError_default("oneOverRadii is required.");
  }
  if (!defined_default(oneOverRadiiSquared)) {
    throw new DeveloperError_default("oneOverRadiiSquared is required.");
  }
  if (!defined_default(centerToleranceSquared)) {
    throw new DeveloperError_default("centerToleranceSquared is required.");
  }
  const positionX = cartesian.x;
  const positionY = cartesian.y;
  const positionZ = cartesian.z;
  const oneOverRadiiX = oneOverRadii.x;
  const oneOverRadiiY = oneOverRadii.y;
  const oneOverRadiiZ = oneOverRadii.z;
  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
  const squaredNorm = x2 + y2 + z2;
  const ratio = Math.sqrt(1 / squaredNorm);
  const intersection = Cartesian3_default.multiplyByScalar(
    cartesian,
    ratio,
    scaleToGeodeticSurfaceIntersection
  );
  if (squaredNorm < centerToleranceSquared) {
    return !isFinite(ratio) ? void 0 : Cartesian3_default.clone(intersection, result);
  }
  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
  const gradient = scaleToGeodeticSurfaceGradient;
  gradient.x = intersection.x * oneOverRadiiSquaredX * 2;
  gradient.y = intersection.y * oneOverRadiiSquaredY * 2;
  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2;
  let lambda = (1 - ratio) * Cartesian3_default.magnitude(cartesian) / (0.5 * Cartesian3_default.magnitude(gradient));
  let correction = 0;
  let func;
  let denominator;
  let xMultiplier;
  let yMultiplier;
  let zMultiplier;
  let xMultiplier2;
  let yMultiplier2;
  let zMultiplier2;
  let xMultiplier3;
  let yMultiplier3;
  let zMultiplier3;
  do {
    lambda -= correction;
    xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
    yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
    zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
    xMultiplier2 = xMultiplier * xMultiplier;
    yMultiplier2 = yMultiplier * yMultiplier;
    zMultiplier2 = zMultiplier * zMultiplier;
    xMultiplier3 = xMultiplier2 * xMultiplier;
    yMultiplier3 = yMultiplier2 * yMultiplier;
    zMultiplier3 = zMultiplier2 * zMultiplier;
    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1;
    denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
    const derivative = -2 * denominator;
    correction = func / derivative;
  } while (Math.abs(func) > Math_default.EPSILON12);
  if (!defined_default(result)) {
    return new Cartesian3_default(
      positionX * xMultiplier,
      positionY * yMultiplier,
      positionZ * zMultiplier
    );
  }
  result.x = positionX * xMultiplier;
  result.y = positionY * yMultiplier;
  result.z = positionZ * zMultiplier;
  return result;
}
var scaleToGeodeticSurface_default = scaleToGeodeticSurface;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Cartographic.js
function Cartographic(longitude, latitude, height) {
  this.longitude = defaultValue_default(longitude, 0);
  this.latitude = defaultValue_default(latitude, 0);
  this.height = defaultValue_default(height, 0);
}
Cartographic.fromRadians = function(longitude, latitude, height, result) {
  Check_default.typeOf.number("longitude", longitude);
  Check_default.typeOf.number("latitude", latitude);
  height = defaultValue_default(height, 0);
  if (!defined_default(result)) {
    return new Cartographic(longitude, latitude, height);
  }
  result.longitude = longitude;
  result.latitude = latitude;
  result.height = height;
  return result;
};
Cartographic.fromDegrees = function(longitude, latitude, height, result) {
  Check_default.typeOf.number("longitude", longitude);
  Check_default.typeOf.number("latitude", latitude);
  longitude = Math_default.toRadians(longitude);
  latitude = Math_default.toRadians(latitude);
  return Cartographic.fromRadians(longitude, latitude, height, result);
};
var cartesianToCartographicN = new Cartesian3_default();
var cartesianToCartographicP = new Cartesian3_default();
var cartesianToCartographicH = new Cartesian3_default();
var wgs84OneOverRadii = new Cartesian3_default(
  1 / 6378137,
  1 / 6378137,
  1 / 6356752314245179e-9
);
var wgs84OneOverRadiiSquared = new Cartesian3_default(
  1 / (6378137 * 6378137),
  1 / (6378137 * 6378137),
  1 / (6356752314245179e-9 * 6356752314245179e-9)
);
var wgs84CenterToleranceSquared = Math_default.EPSILON1;
Cartographic.fromCartesian = function(cartesian, ellipsoid, result) {
  const oneOverRadii = defined_default(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;
  const oneOverRadiiSquared = defined_default(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;
  const centerToleranceSquared = defined_default(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared;
  const p = scaleToGeodeticSurface_default(
    cartesian,
    oneOverRadii,
    oneOverRadiiSquared,
    centerToleranceSquared,
    cartesianToCartographicP
  );
  if (!defined_default(p)) {
    return void 0;
  }
  let n = Cartesian3_default.multiplyComponents(
    p,
    oneOverRadiiSquared,
    cartesianToCartographicN
  );
  n = Cartesian3_default.normalize(n, n);
  const h = Cartesian3_default.subtract(cartesian, p, cartesianToCartographicH);
  const longitude = Math.atan2(n.y, n.x);
  const latitude = Math.asin(n.z);
  const height = Math_default.sign(Cartesian3_default.dot(h, cartesian)) * Cartesian3_default.magnitude(h);
  if (!defined_default(result)) {
    return new Cartographic(longitude, latitude, height);
  }
  result.longitude = longitude;
  result.latitude = latitude;
  result.height = height;
  return result;
};
Cartographic.toCartesian = function(cartographic, ellipsoid, result) {
  Check_default.defined("cartographic", cartographic);
  return Cartesian3_default.fromRadians(
    cartographic.longitude,
    cartographic.latitude,
    cartographic.height,
    ellipsoid,
    result
  );
};
Cartographic.clone = function(cartographic, result) {
  if (!defined_default(cartographic)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Cartographic(
      cartographic.longitude,
      cartographic.latitude,
      cartographic.height
    );
  }
  result.longitude = cartographic.longitude;
  result.latitude = cartographic.latitude;
  result.height = cartographic.height;
  return result;
};
Cartographic.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.longitude === right.longitude && left.latitude === right.latitude && left.height === right.height;
};
Cartographic.equalsEpsilon = function(left, right, epsilon) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && Math.abs(left.longitude - right.longitude) <= epsilon && Math.abs(left.latitude - right.latitude) <= epsilon && Math.abs(left.height - right.height) <= epsilon;
};
Cartographic.ZERO = Object.freeze(new Cartographic(0, 0, 0));
Cartographic.prototype.clone = function(result) {
  return Cartographic.clone(this, result);
};
Cartographic.prototype.equals = function(right) {
  return Cartographic.equals(this, right);
};
Cartographic.prototype.equalsEpsilon = function(right, epsilon) {
  return Cartographic.equalsEpsilon(this, right, epsilon);
};
Cartographic.prototype.toString = function() {
  return `(${this.longitude}, ${this.latitude}, ${this.height})`;
};
var Cartographic_default = Cartographic;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Ellipsoid.js
function initialize(ellipsoid, x, y, z) {
  x = defaultValue_default(x, 0);
  y = defaultValue_default(y, 0);
  z = defaultValue_default(z, 0);
  Check_default.typeOf.number.greaterThanOrEquals("x", x, 0);
  Check_default.typeOf.number.greaterThanOrEquals("y", y, 0);
  Check_default.typeOf.number.greaterThanOrEquals("z", z, 0);
  ellipsoid._radii = new Cartesian3_default(x, y, z);
  ellipsoid._radiiSquared = new Cartesian3_default(x * x, y * y, z * z);
  ellipsoid._radiiToTheFourth = new Cartesian3_default(
    x * x * x * x,
    y * y * y * y,
    z * z * z * z
  );
  ellipsoid._oneOverRadii = new Cartesian3_default(
    x === 0 ? 0 : 1 / x,
    y === 0 ? 0 : 1 / y,
    z === 0 ? 0 : 1 / z
  );
  ellipsoid._oneOverRadiiSquared = new Cartesian3_default(
    x === 0 ? 0 : 1 / (x * x),
    y === 0 ? 0 : 1 / (y * y),
    z === 0 ? 0 : 1 / (z * z)
  );
  ellipsoid._minimumRadius = Math.min(x, y, z);
  ellipsoid._maximumRadius = Math.max(x, y, z);
  ellipsoid._centerToleranceSquared = Math_default.EPSILON1;
  if (ellipsoid._radiiSquared.z !== 0) {
    ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;
  }
}
function Ellipsoid(x, y, z) {
  this._radii = void 0;
  this._radiiSquared = void 0;
  this._radiiToTheFourth = void 0;
  this._oneOverRadii = void 0;
  this._oneOverRadiiSquared = void 0;
  this._minimumRadius = void 0;
  this._maximumRadius = void 0;
  this._centerToleranceSquared = void 0;
  this._squaredXOverSquaredZ = void 0;
  initialize(this, x, y, z);
}
Object.defineProperties(Ellipsoid.prototype, {
  radii: {
    get: function() {
      return this._radii;
    }
  },
  radiiSquared: {
    get: function() {
      return this._radiiSquared;
    }
  },
  radiiToTheFourth: {
    get: function() {
      return this._radiiToTheFourth;
    }
  },
  oneOverRadii: {
    get: function() {
      return this._oneOverRadii;
    }
  },
  oneOverRadiiSquared: {
    get: function() {
      return this._oneOverRadiiSquared;
    }
  },
  minimumRadius: {
    get: function() {
      return this._minimumRadius;
    }
  },
  maximumRadius: {
    get: function() {
      return this._maximumRadius;
    }
  }
});
Ellipsoid.clone = function(ellipsoid, result) {
  if (!defined_default(ellipsoid)) {
    return void 0;
  }
  const radii = ellipsoid._radii;
  if (!defined_default(result)) {
    return new Ellipsoid(radii.x, radii.y, radii.z);
  }
  Cartesian3_default.clone(radii, result._radii);
  Cartesian3_default.clone(ellipsoid._radiiSquared, result._radiiSquared);
  Cartesian3_default.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
  Cartesian3_default.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
  Cartesian3_default.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
  result._minimumRadius = ellipsoid._minimumRadius;
  result._maximumRadius = ellipsoid._maximumRadius;
  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;
  return result;
};
Ellipsoid.fromCartesian3 = function(cartesian, result) {
  if (!defined_default(result)) {
    result = new Ellipsoid();
  }
  if (!defined_default(cartesian)) {
    return result;
  }
  initialize(result, cartesian.x, cartesian.y, cartesian.z);
  return result;
};
Ellipsoid.WGS84 = Object.freeze(
  new Ellipsoid(6378137, 6378137, 6356752314245179e-9)
);
Ellipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1, 1, 1));
Ellipsoid.MOON = Object.freeze(
  new Ellipsoid(
    Math_default.LUNAR_RADIUS,
    Math_default.LUNAR_RADIUS,
    Math_default.LUNAR_RADIUS
  )
);
Ellipsoid.prototype.clone = function(result) {
  return Ellipsoid.clone(this, result);
};
Ellipsoid.packedLength = Cartesian3_default.packedLength;
Ellipsoid.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  Cartesian3_default.pack(value._radii, array, startingIndex);
  return array;
};
Ellipsoid.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  const radii = Cartesian3_default.unpack(array, startingIndex);
  return Ellipsoid.fromCartesian3(radii, result);
};
Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3_default.normalize;
Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {
  Check_default.typeOf.object("cartographic", cartographic);
  const longitude = cartographic.longitude;
  const latitude = cartographic.latitude;
  const cosLatitude = Math.cos(latitude);
  const x = cosLatitude * Math.cos(longitude);
  const y = cosLatitude * Math.sin(longitude);
  const z = Math.sin(latitude);
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  result.x = x;
  result.y = y;
  result.z = z;
  return Cartesian3_default.normalize(result, result);
};
Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {
  if (Cartesian3_default.equalsEpsilon(cartesian, Cartesian3_default.ZERO, Math_default.EPSILON14)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  result = Cartesian3_default.multiplyComponents(
    cartesian,
    this._oneOverRadiiSquared,
    result
  );
  return Cartesian3_default.normalize(result, result);
};
var cartographicToCartesianNormal = new Cartesian3_default();
var cartographicToCartesianK = new Cartesian3_default();
Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {
  const n = cartographicToCartesianNormal;
  const k = cartographicToCartesianK;
  this.geodeticSurfaceNormalCartographic(cartographic, n);
  Cartesian3_default.multiplyComponents(this._radiiSquared, n, k);
  const gamma = Math.sqrt(Cartesian3_default.dot(n, k));
  Cartesian3_default.divideByScalar(k, gamma, k);
  Cartesian3_default.multiplyByScalar(n, cartographic.height, n);
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  return Cartesian3_default.add(k, n, result);
};
Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {
  Check_default.defined("cartographics", cartographics);
  const length = cartographics.length;
  if (!defined_default(result)) {
    result = new Array(length);
  } else {
    result.length = length;
  }
  for (let i = 0; i < length; i++) {
    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
  }
  return result;
};
var cartesianToCartographicN2 = new Cartesian3_default();
var cartesianToCartographicP2 = new Cartesian3_default();
var cartesianToCartographicH2 = new Cartesian3_default();
Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {
  const p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP2);
  if (!defined_default(p)) {
    return void 0;
  }
  const n = this.geodeticSurfaceNormal(p, cartesianToCartographicN2);
  const h = Cartesian3_default.subtract(cartesian, p, cartesianToCartographicH2);
  const longitude = Math.atan2(n.y, n.x);
  const latitude = Math.asin(n.z);
  const height = Math_default.sign(Cartesian3_default.dot(h, cartesian)) * Cartesian3_default.magnitude(h);
  if (!defined_default(result)) {
    return new Cartographic_default(longitude, latitude, height);
  }
  result.longitude = longitude;
  result.latitude = latitude;
  result.height = height;
  return result;
};
Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {
  Check_default.defined("cartesians", cartesians);
  const length = cartesians.length;
  if (!defined_default(result)) {
    result = new Array(length);
  } else {
    result.length = length;
  }
  for (let i = 0; i < length; ++i) {
    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
  }
  return result;
};
Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {
  return scaleToGeodeticSurface_default(
    cartesian,
    this._oneOverRadii,
    this._oneOverRadiiSquared,
    this._centerToleranceSquared,
    result
  );
};
Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  const positionX = cartesian.x;
  const positionY = cartesian.y;
  const positionZ = cartesian.z;
  const oneOverRadiiSquared = this._oneOverRadiiSquared;
  const beta = 1 / Math.sqrt(
    positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z
  );
  return Cartesian3_default.multiplyByScalar(cartesian, beta, result);
};
Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  return Cartesian3_default.multiplyComponents(position, this._oneOverRadii, result);
};
Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  return Cartesian3_default.multiplyComponents(position, this._radii, result);
};
Ellipsoid.prototype.equals = function(right) {
  return this === right || defined_default(right) && Cartesian3_default.equals(this._radii, right._radii);
};
Ellipsoid.prototype.toString = function() {
  return this._radii.toString();
};
Ellipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function(position, buffer, result) {
  Check_default.typeOf.object("position", position);
  if (!Math_default.equalsEpsilon(
    this._radii.x,
    this._radii.y,
    Math_default.EPSILON15
  )) {
    throw new DeveloperError_default(
      "Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)"
    );
  }
  Check_default.typeOf.number.greaterThan("Ellipsoid.radii.z", this._radii.z, 0);
  buffer = defaultValue_default(buffer, 0);
  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  result.x = 0;
  result.y = 0;
  result.z = position.z * (1 - squaredXOverSquaredZ);
  if (Math.abs(result.z) >= this._radii.z - buffer) {
    return void 0;
  }
  return result;
};
var abscissas = [
  0.14887433898163,
  0.43339539412925,
  0.67940956829902,
  0.86506336668898,
  0.97390652851717,
  0
];
var weights = [
  0.29552422471475,
  0.26926671930999,
  0.21908636251598,
  0.14945134915058,
  0.066671344308684,
  0
];
function gaussLegendreQuadrature(a3, b, func) {
  Check_default.typeOf.number("a", a3);
  Check_default.typeOf.number("b", b);
  Check_default.typeOf.func("func", func);
  const xMean = 0.5 * (b + a3);
  const xRange = 0.5 * (b - a3);
  let sum = 0;
  for (let i = 0; i < 5; i++) {
    const dx = xRange * abscissas[i];
    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));
  }
  sum *= xRange;
  return sum;
}
Ellipsoid.prototype.surfaceArea = function(rectangle) {
  Check_default.typeOf.object("rectangle", rectangle);
  const minLongitude = rectangle.west;
  let maxLongitude = rectangle.east;
  const minLatitude = rectangle.south;
  const maxLatitude = rectangle.north;
  while (maxLongitude < minLongitude) {
    maxLongitude += Math_default.TWO_PI;
  }
  const radiiSquared = this._radiiSquared;
  const a22 = radiiSquared.x;
  const b2 = radiiSquared.y;
  const c2 = radiiSquared.z;
  const a2b2 = a22 * b2;
  return gaussLegendreQuadrature(minLatitude, maxLatitude, function(lat) {
    const sinPhi = Math.cos(lat);
    const cosPhi = Math.sin(lat);
    return Math.cos(lat) * gaussLegendreQuadrature(minLongitude, maxLongitude, function(lon) {
      const cosTheta = Math.cos(lon);
      const sinTheta = Math.sin(lon);
      return Math.sqrt(
        a2b2 * cosPhi * cosPhi + c2 * (b2 * cosTheta * cosTheta + a22 * sinTheta * sinTheta) * sinPhi * sinPhi
      );
    });
  });
};
var Ellipsoid_default = Ellipsoid;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeographicProjection.js
function GeographicProjection(ellipsoid) {
  this._ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  this._semimajorAxis = this._ellipsoid.maximumRadius;
  this._oneOverSemimajorAxis = 1 / this._semimajorAxis;
}
Object.defineProperties(GeographicProjection.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  }
});
GeographicProjection.prototype.project = function(cartographic, result) {
  const semimajorAxis = this._semimajorAxis;
  const x = cartographic.longitude * semimajorAxis;
  const y = cartographic.latitude * semimajorAxis;
  const z = cartographic.height;
  if (!defined_default(result)) {
    return new Cartesian3_default(x, y, z);
  }
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
GeographicProjection.prototype.unproject = function(cartesian, result) {
  if (!defined_default(cartesian)) {
    throw new DeveloperError_default("cartesian is required");
  }
  const oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
  const longitude = cartesian.x * oneOverEarthSemimajorAxis;
  const latitude = cartesian.y * oneOverEarthSemimajorAxis;
  const height = cartesian.z;
  if (!defined_default(result)) {
    return new Cartographic_default(longitude, latitude, height);
  }
  result.longitude = longitude;
  result.latitude = latitude;
  result.height = height;
  return result;
};
var GeographicProjection_default = GeographicProjection;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Intersect.js
var Intersect = {
  OUTSIDE: -1,
  INTERSECTING: 0,
  INSIDE: 1
};
var Intersect_default = Object.freeze(Intersect);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Rectangle.js
function Rectangle(west, south, east, north) {
  this.west = defaultValue_default(west, 0);
  this.south = defaultValue_default(south, 0);
  this.east = defaultValue_default(east, 0);
  this.north = defaultValue_default(north, 0);
}
Object.defineProperties(Rectangle.prototype, {
  width: {
    get: function() {
      return Rectangle.computeWidth(this);
    }
  },
  height: {
    get: function() {
      return Rectangle.computeHeight(this);
    }
  }
});
Rectangle.packedLength = 4;
Rectangle.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.west;
  array[startingIndex++] = value.south;
  array[startingIndex++] = value.east;
  array[startingIndex] = value.north;
  return array;
};
Rectangle.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Rectangle();
  }
  result.west = array[startingIndex++];
  result.south = array[startingIndex++];
  result.east = array[startingIndex++];
  result.north = array[startingIndex];
  return result;
};
Rectangle.computeWidth = function(rectangle) {
  Check_default.typeOf.object("rectangle", rectangle);
  let east = rectangle.east;
  const west = rectangle.west;
  if (east < west) {
    east += Math_default.TWO_PI;
  }
  return east - west;
};
Rectangle.computeHeight = function(rectangle) {
  Check_default.typeOf.object("rectangle", rectangle);
  return rectangle.north - rectangle.south;
};
Rectangle.fromDegrees = function(west, south, east, north, result) {
  west = Math_default.toRadians(defaultValue_default(west, 0));
  south = Math_default.toRadians(defaultValue_default(south, 0));
  east = Math_default.toRadians(defaultValue_default(east, 0));
  north = Math_default.toRadians(defaultValue_default(north, 0));
  if (!defined_default(result)) {
    return new Rectangle(west, south, east, north);
  }
  result.west = west;
  result.south = south;
  result.east = east;
  result.north = north;
  return result;
};
Rectangle.fromRadians = function(west, south, east, north, result) {
  if (!defined_default(result)) {
    return new Rectangle(west, south, east, north);
  }
  result.west = defaultValue_default(west, 0);
  result.south = defaultValue_default(south, 0);
  result.east = defaultValue_default(east, 0);
  result.north = defaultValue_default(north, 0);
  return result;
};
Rectangle.fromCartographicArray = function(cartographics, result) {
  Check_default.defined("cartographics", cartographics);
  let west = Number.MAX_VALUE;
  let east = -Number.MAX_VALUE;
  let westOverIDL = Number.MAX_VALUE;
  let eastOverIDL = -Number.MAX_VALUE;
  let south = Number.MAX_VALUE;
  let north = -Number.MAX_VALUE;
  for (let i = 0, len = cartographics.length; i < len; i++) {
    const position = cartographics[i];
    west = Math.min(west, position.longitude);
    east = Math.max(east, position.longitude);
    south = Math.min(south, position.latitude);
    north = Math.max(north, position.latitude);
    const lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + Math_default.TWO_PI;
    westOverIDL = Math.min(westOverIDL, lonAdjusted);
    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
  }
  if (east - west > eastOverIDL - westOverIDL) {
    west = westOverIDL;
    east = eastOverIDL;
    if (east > Math_default.PI) {
      east = east - Math_default.TWO_PI;
    }
    if (west > Math_default.PI) {
      west = west - Math_default.TWO_PI;
    }
  }
  if (!defined_default(result)) {
    return new Rectangle(west, south, east, north);
  }
  result.west = west;
  result.south = south;
  result.east = east;
  result.north = north;
  return result;
};
Rectangle.fromCartesianArray = function(cartesians, ellipsoid, result) {
  Check_default.defined("cartesians", cartesians);
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  let west = Number.MAX_VALUE;
  let east = -Number.MAX_VALUE;
  let westOverIDL = Number.MAX_VALUE;
  let eastOverIDL = -Number.MAX_VALUE;
  let south = Number.MAX_VALUE;
  let north = -Number.MAX_VALUE;
  for (let i = 0, len = cartesians.length; i < len; i++) {
    const position = ellipsoid.cartesianToCartographic(cartesians[i]);
    west = Math.min(west, position.longitude);
    east = Math.max(east, position.longitude);
    south = Math.min(south, position.latitude);
    north = Math.max(north, position.latitude);
    const lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + Math_default.TWO_PI;
    westOverIDL = Math.min(westOverIDL, lonAdjusted);
    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
  }
  if (east - west > eastOverIDL - westOverIDL) {
    west = westOverIDL;
    east = eastOverIDL;
    if (east > Math_default.PI) {
      east = east - Math_default.TWO_PI;
    }
    if (west > Math_default.PI) {
      west = west - Math_default.TWO_PI;
    }
  }
  if (!defined_default(result)) {
    return new Rectangle(west, south, east, north);
  }
  result.west = west;
  result.south = south;
  result.east = east;
  result.north = north;
  return result;
};
Rectangle.clone = function(rectangle, result) {
  if (!defined_default(rectangle)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Rectangle(
      rectangle.west,
      rectangle.south,
      rectangle.east,
      rectangle.north
    );
  }
  result.west = rectangle.west;
  result.south = rectangle.south;
  result.east = rectangle.east;
  result.north = rectangle.north;
  return result;
};
Rectangle.equalsEpsilon = function(left, right, absoluteEpsilon) {
  absoluteEpsilon = defaultValue_default(absoluteEpsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && Math.abs(left.west - right.west) <= absoluteEpsilon && Math.abs(left.south - right.south) <= absoluteEpsilon && Math.abs(left.east - right.east) <= absoluteEpsilon && Math.abs(left.north - right.north) <= absoluteEpsilon;
};
Rectangle.prototype.clone = function(result) {
  return Rectangle.clone(this, result);
};
Rectangle.prototype.equals = function(other) {
  return Rectangle.equals(this, other);
};
Rectangle.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.west === right.west && left.south === right.south && left.east === right.east && left.north === right.north;
};
Rectangle.prototype.equalsEpsilon = function(other, epsilon) {
  return Rectangle.equalsEpsilon(this, other, epsilon);
};
Rectangle.validate = function(rectangle) {
  Check_default.typeOf.object("rectangle", rectangle);
  const north = rectangle.north;
  Check_default.typeOf.number.greaterThanOrEquals(
    "north",
    north,
    -Math_default.PI_OVER_TWO
  );
  Check_default.typeOf.number.lessThanOrEquals("north", north, Math_default.PI_OVER_TWO);
  const south = rectangle.south;
  Check_default.typeOf.number.greaterThanOrEquals(
    "south",
    south,
    -Math_default.PI_OVER_TWO
  );
  Check_default.typeOf.number.lessThanOrEquals("south", south, Math_default.PI_OVER_TWO);
  const west = rectangle.west;
  Check_default.typeOf.number.greaterThanOrEquals("west", west, -Math.PI);
  Check_default.typeOf.number.lessThanOrEquals("west", west, Math.PI);
  const east = rectangle.east;
  Check_default.typeOf.number.greaterThanOrEquals("east", east, -Math.PI);
  Check_default.typeOf.number.lessThanOrEquals("east", east, Math.PI);
};
Rectangle.southwest = function(rectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  if (!defined_default(result)) {
    return new Cartographic_default(rectangle.west, rectangle.south);
  }
  result.longitude = rectangle.west;
  result.latitude = rectangle.south;
  result.height = 0;
  return result;
};
Rectangle.northwest = function(rectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  if (!defined_default(result)) {
    return new Cartographic_default(rectangle.west, rectangle.north);
  }
  result.longitude = rectangle.west;
  result.latitude = rectangle.north;
  result.height = 0;
  return result;
};
Rectangle.northeast = function(rectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  if (!defined_default(result)) {
    return new Cartographic_default(rectangle.east, rectangle.north);
  }
  result.longitude = rectangle.east;
  result.latitude = rectangle.north;
  result.height = 0;
  return result;
};
Rectangle.southeast = function(rectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  if (!defined_default(result)) {
    return new Cartographic_default(rectangle.east, rectangle.south);
  }
  result.longitude = rectangle.east;
  result.latitude = rectangle.south;
  result.height = 0;
  return result;
};
Rectangle.center = function(rectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  let east = rectangle.east;
  const west = rectangle.west;
  if (east < west) {
    east += Math_default.TWO_PI;
  }
  const longitude = Math_default.negativePiToPi((west + east) * 0.5);
  const latitude = (rectangle.south + rectangle.north) * 0.5;
  if (!defined_default(result)) {
    return new Cartographic_default(longitude, latitude);
  }
  result.longitude = longitude;
  result.latitude = latitude;
  result.height = 0;
  return result;
};
Rectangle.intersection = function(rectangle, otherRectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  Check_default.typeOf.object("otherRectangle", otherRectangle);
  let rectangleEast = rectangle.east;
  let rectangleWest = rectangle.west;
  let otherRectangleEast = otherRectangle.east;
  let otherRectangleWest = otherRectangle.west;
  if (rectangleEast < rectangleWest && otherRectangleEast > 0) {
    rectangleEast += Math_default.TWO_PI;
  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0) {
    otherRectangleEast += Math_default.TWO_PI;
  }
  if (rectangleEast < rectangleWest && otherRectangleWest < 0) {
    otherRectangleWest += Math_default.TWO_PI;
  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0) {
    rectangleWest += Math_default.TWO_PI;
  }
  const west = Math_default.negativePiToPi(
    Math.max(rectangleWest, otherRectangleWest)
  );
  const east = Math_default.negativePiToPi(
    Math.min(rectangleEast, otherRectangleEast)
  );
  if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {
    return void 0;
  }
  const south = Math.max(rectangle.south, otherRectangle.south);
  const north = Math.min(rectangle.north, otherRectangle.north);
  if (south >= north) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Rectangle(west, south, east, north);
  }
  result.west = west;
  result.south = south;
  result.east = east;
  result.north = north;
  return result;
};
Rectangle.simpleIntersection = function(rectangle, otherRectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  Check_default.typeOf.object("otherRectangle", otherRectangle);
  const west = Math.max(rectangle.west, otherRectangle.west);
  const south = Math.max(rectangle.south, otherRectangle.south);
  const east = Math.min(rectangle.east, otherRectangle.east);
  const north = Math.min(rectangle.north, otherRectangle.north);
  if (south >= north || west >= east) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Rectangle(west, south, east, north);
  }
  result.west = west;
  result.south = south;
  result.east = east;
  result.north = north;
  return result;
};
Rectangle.union = function(rectangle, otherRectangle, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  Check_default.typeOf.object("otherRectangle", otherRectangle);
  if (!defined_default(result)) {
    result = new Rectangle();
  }
  let rectangleEast = rectangle.east;
  let rectangleWest = rectangle.west;
  let otherRectangleEast = otherRectangle.east;
  let otherRectangleWest = otherRectangle.west;
  if (rectangleEast < rectangleWest && otherRectangleEast > 0) {
    rectangleEast += Math_default.TWO_PI;
  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0) {
    otherRectangleEast += Math_default.TWO_PI;
  }
  if (rectangleEast < rectangleWest && otherRectangleWest < 0) {
    otherRectangleWest += Math_default.TWO_PI;
  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0) {
    rectangleWest += Math_default.TWO_PI;
  }
  const west = Math_default.negativePiToPi(
    Math.min(rectangleWest, otherRectangleWest)
  );
  const east = Math_default.negativePiToPi(
    Math.max(rectangleEast, otherRectangleEast)
  );
  result.west = west;
  result.south = Math.min(rectangle.south, otherRectangle.south);
  result.east = east;
  result.north = Math.max(rectangle.north, otherRectangle.north);
  return result;
};
Rectangle.expand = function(rectangle, cartographic, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  Check_default.typeOf.object("cartographic", cartographic);
  if (!defined_default(result)) {
    result = new Rectangle();
  }
  result.west = Math.min(rectangle.west, cartographic.longitude);
  result.south = Math.min(rectangle.south, cartographic.latitude);
  result.east = Math.max(rectangle.east, cartographic.longitude);
  result.north = Math.max(rectangle.north, cartographic.latitude);
  return result;
};
Rectangle.contains = function(rectangle, cartographic) {
  Check_default.typeOf.object("rectangle", rectangle);
  Check_default.typeOf.object("cartographic", cartographic);
  let longitude = cartographic.longitude;
  const latitude = cartographic.latitude;
  const west = rectangle.west;
  let east = rectangle.east;
  if (east < west) {
    east += Math_default.TWO_PI;
    if (longitude < 0) {
      longitude += Math_default.TWO_PI;
    }
  }
  return (longitude > west || Math_default.equalsEpsilon(longitude, west, Math_default.EPSILON14)) && (longitude < east || Math_default.equalsEpsilon(longitude, east, Math_default.EPSILON14)) && latitude >= rectangle.south && latitude <= rectangle.north;
};
var subsampleLlaScratch = new Cartographic_default();
Rectangle.subsample = function(rectangle, ellipsoid, surfaceHeight, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  surfaceHeight = defaultValue_default(surfaceHeight, 0);
  if (!defined_default(result)) {
    result = [];
  }
  let length = 0;
  const north = rectangle.north;
  const south = rectangle.south;
  const east = rectangle.east;
  const west = rectangle.west;
  const lla = subsampleLlaScratch;
  lla.height = surfaceHeight;
  lla.longitude = west;
  lla.latitude = north;
  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
  length++;
  lla.longitude = east;
  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
  length++;
  lla.latitude = south;
  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
  length++;
  lla.longitude = west;
  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
  length++;
  if (north < 0) {
    lla.latitude = north;
  } else if (south > 0) {
    lla.latitude = south;
  } else {
    lla.latitude = 0;
  }
  for (let i = 1; i < 8; ++i) {
    lla.longitude = -Math.PI + i * Math_default.PI_OVER_TWO;
    if (Rectangle.contains(rectangle, lla)) {
      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
      length++;
    }
  }
  if (lla.latitude === 0) {
    lla.longitude = west;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.longitude = east;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
  }
  result.length = length;
  return result;
};
Rectangle.subsection = function(rectangle, westLerp, southLerp, eastLerp, northLerp, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  Check_default.typeOf.number.greaterThanOrEquals("westLerp", westLerp, 0);
  Check_default.typeOf.number.lessThanOrEquals("westLerp", westLerp, 1);
  Check_default.typeOf.number.greaterThanOrEquals("southLerp", southLerp, 0);
  Check_default.typeOf.number.lessThanOrEquals("southLerp", southLerp, 1);
  Check_default.typeOf.number.greaterThanOrEquals("eastLerp", eastLerp, 0);
  Check_default.typeOf.number.lessThanOrEquals("eastLerp", eastLerp, 1);
  Check_default.typeOf.number.greaterThanOrEquals("northLerp", northLerp, 0);
  Check_default.typeOf.number.lessThanOrEquals("northLerp", northLerp, 1);
  Check_default.typeOf.number.lessThanOrEquals("westLerp", westLerp, eastLerp);
  Check_default.typeOf.number.lessThanOrEquals("southLerp", southLerp, northLerp);
  if (!defined_default(result)) {
    result = new Rectangle();
  }
  if (rectangle.west <= rectangle.east) {
    const width = rectangle.east - rectangle.west;
    result.west = rectangle.west + westLerp * width;
    result.east = rectangle.west + eastLerp * width;
  } else {
    const width = Math_default.TWO_PI + rectangle.east - rectangle.west;
    result.west = Math_default.negativePiToPi(rectangle.west + westLerp * width);
    result.east = Math_default.negativePiToPi(rectangle.west + eastLerp * width);
  }
  const height = rectangle.north - rectangle.south;
  result.south = rectangle.south + southLerp * height;
  result.north = rectangle.south + northLerp * height;
  if (westLerp === 1) {
    result.west = rectangle.east;
  }
  if (eastLerp === 1) {
    result.east = rectangle.east;
  }
  if (southLerp === 1) {
    result.south = rectangle.north;
  }
  if (northLerp === 1) {
    result.north = rectangle.north;
  }
  return result;
};
Rectangle.MAX_VALUE = Object.freeze(
  new Rectangle(
    -Math.PI,
    -Math_default.PI_OVER_TWO,
    Math.PI,
    Math_default.PI_OVER_TWO
  )
);
var Rectangle_default = Rectangle;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/BoundingRectangle.js
function BoundingRectangle(x, y, width, height) {
  this.x = defaultValue_default(x, 0);
  this.y = defaultValue_default(y, 0);
  this.width = defaultValue_default(width, 0);
  this.height = defaultValue_default(height, 0);
}
BoundingRectangle.packedLength = 4;
BoundingRectangle.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.x;
  array[startingIndex++] = value.y;
  array[startingIndex++] = value.width;
  array[startingIndex] = value.height;
  return array;
};
BoundingRectangle.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new BoundingRectangle();
  }
  result.x = array[startingIndex++];
  result.y = array[startingIndex++];
  result.width = array[startingIndex++];
  result.height = array[startingIndex];
  return result;
};
BoundingRectangle.fromPoints = function(positions, result) {
  if (!defined_default(result)) {
    result = new BoundingRectangle();
  }
  if (!defined_default(positions) || positions.length === 0) {
    result.x = 0;
    result.y = 0;
    result.width = 0;
    result.height = 0;
    return result;
  }
  const length = positions.length;
  let minimumX = positions[0].x;
  let minimumY = positions[0].y;
  let maximumX = positions[0].x;
  let maximumY = positions[0].y;
  for (let i = 1; i < length; i++) {
    const p = positions[i];
    const x = p.x;
    const y = p.y;
    minimumX = Math.min(x, minimumX);
    maximumX = Math.max(x, maximumX);
    minimumY = Math.min(y, minimumY);
    maximumY = Math.max(y, maximumY);
  }
  result.x = minimumX;
  result.y = minimumY;
  result.width = maximumX - minimumX;
  result.height = maximumY - minimumY;
  return result;
};
var defaultProjection = new GeographicProjection_default();
var fromRectangleLowerLeft = new Cartographic_default();
var fromRectangleUpperRight = new Cartographic_default();
BoundingRectangle.fromRectangle = function(rectangle, projection, result) {
  if (!defined_default(result)) {
    result = new BoundingRectangle();
  }
  if (!defined_default(rectangle)) {
    result.x = 0;
    result.y = 0;
    result.width = 0;
    result.height = 0;
    return result;
  }
  projection = defaultValue_default(projection, defaultProjection);
  const lowerLeft = projection.project(
    Rectangle_default.southwest(rectangle, fromRectangleLowerLeft)
  );
  const upperRight = projection.project(
    Rectangle_default.northeast(rectangle, fromRectangleUpperRight)
  );
  Cartesian2_default.subtract(upperRight, lowerLeft, upperRight);
  result.x = lowerLeft.x;
  result.y = lowerLeft.y;
  result.width = upperRight.x;
  result.height = upperRight.y;
  return result;
};
BoundingRectangle.clone = function(rectangle, result) {
  if (!defined_default(rectangle)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new BoundingRectangle(
      rectangle.x,
      rectangle.y,
      rectangle.width,
      rectangle.height
    );
  }
  result.x = rectangle.x;
  result.y = rectangle.y;
  result.width = rectangle.width;
  result.height = rectangle.height;
  return result;
};
BoundingRectangle.union = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  if (!defined_default(result)) {
    result = new BoundingRectangle();
  }
  const lowerLeftX = Math.min(left.x, right.x);
  const lowerLeftY = Math.min(left.y, right.y);
  const upperRightX = Math.max(left.x + left.width, right.x + right.width);
  const upperRightY = Math.max(left.y + left.height, right.y + right.height);
  result.x = lowerLeftX;
  result.y = lowerLeftY;
  result.width = upperRightX - lowerLeftX;
  result.height = upperRightY - lowerLeftY;
  return result;
};
BoundingRectangle.expand = function(rectangle, point, result) {
  Check_default.typeOf.object("rectangle", rectangle);
  Check_default.typeOf.object("point", point);
  result = BoundingRectangle.clone(rectangle, result);
  const width = point.x - result.x;
  const height = point.y - result.y;
  if (width > result.width) {
    result.width = width;
  } else if (width < 0) {
    result.width -= width;
    result.x = point.x;
  }
  if (height > result.height) {
    result.height = height;
  } else if (height < 0) {
    result.height -= height;
    result.y = point.y;
  }
  return result;
};
BoundingRectangle.intersect = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  const leftX = left.x;
  const leftY = left.y;
  const rightX = right.x;
  const rightY = right.y;
  if (!(leftX > rightX + right.width || leftX + left.width < rightX || leftY + left.height < rightY || leftY > rightY + right.height)) {
    return Intersect_default.INTERSECTING;
  }
  return Intersect_default.OUTSIDE;
};
BoundingRectangle.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.x === right.x && left.y === right.y && left.width === right.width && left.height === right.height;
};
BoundingRectangle.prototype.clone = function(result) {
  return BoundingRectangle.clone(this, result);
};
BoundingRectangle.prototype.intersect = function(right) {
  return BoundingRectangle.intersect(this, right);
};
BoundingRectangle.prototype.equals = function(right) {
  return BoundingRectangle.equals(this, right);
};
var BoundingRectangle_default = BoundingRectangle;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/PrimitiveType.js
var PrimitiveType = {
  POINTS: WebGLConstants_default.POINTS,
  LINES: WebGLConstants_default.LINES,
  LINE_LOOP: WebGLConstants_default.LINE_LOOP,
  LINE_STRIP: WebGLConstants_default.LINE_STRIP,
  TRIANGLES: WebGLConstants_default.TRIANGLES,
  TRIANGLE_STRIP: WebGLConstants_default.TRIANGLE_STRIP,
  TRIANGLE_FAN: WebGLConstants_default.TRIANGLE_FAN
};
PrimitiveType.isLines = function(primitiveType) {
  return primitiveType === PrimitiveType.LINES || primitiveType === PrimitiveType.LINE_LOOP || primitiveType === PrimitiveType.LINE_STRIP;
};
PrimitiveType.isTriangles = function(primitiveType) {
  return primitiveType === PrimitiveType.TRIANGLES || primitiveType === PrimitiveType.TRIANGLE_STRIP || primitiveType === PrimitiveType.TRIANGLE_FAN;
};
PrimitiveType.validate = function(primitiveType) {
  return primitiveType === PrimitiveType.POINTS || primitiveType === PrimitiveType.LINES || primitiveType === PrimitiveType.LINE_LOOP || primitiveType === PrimitiveType.LINE_STRIP || primitiveType === PrimitiveType.TRIANGLES || primitiveType === PrimitiveType.TRIANGLE_STRIP || primitiveType === PrimitiveType.TRIANGLE_FAN;
};
var PrimitiveType_default = Object.freeze(PrimitiveType);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/DrawCommand.js
var Flags = {
  CULL: 1,
  OCCLUDE: 2,
  EXECUTE_IN_CLOSEST_FRUSTUM: 4,
  DEBUG_SHOW_BOUNDING_VOLUME: 8,
  CAST_SHADOWS: 16,
  RECEIVE_SHADOWS: 32,
  PICK_ONLY: 64,
  DEPTH_FOR_TRANSLUCENT_CLASSIFICATION: 128
};
function DrawCommand(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._boundingVolume = options.boundingVolume;
  this._orientedBoundingBox = options.orientedBoundingBox;
  this._modelMatrix = options.modelMatrix;
  this._primitiveType = defaultValue_default(
    options.primitiveType,
    PrimitiveType_default.TRIANGLES
  );
  this._vertexArray = options.vertexArray;
  this._count = options.count;
  this._offset = defaultValue_default(options.offset, 0);
  this._instanceCount = defaultValue_default(options.instanceCount, 0);
  this._shaderProgram = options.shaderProgram;
  this._uniformMap = options.uniformMap;
  this._renderState = options.renderState;
  this._framebuffer = options.framebuffer;
  this._pass = options.pass;
  this._owner = options.owner;
  this._debugOverlappingFrustums = 0;
  this._pickId = options.pickId;
  this._flags = 0;
  this.cull = defaultValue_default(options.cull, true);
  this.occlude = defaultValue_default(options.occlude, true);
  this.executeInClosestFrustum = defaultValue_default(
    options.executeInClosestFrustum,
    false
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.castShadows = defaultValue_default(options.castShadows, false);
  this.receiveShadows = defaultValue_default(options.receiveShadows, false);
  this.pickOnly = defaultValue_default(options.pickOnly, false);
  this.depthForTranslucentClassification = defaultValue_default(
    options.depthForTranslucentClassification,
    false
  );
  this.dirty = true;
  this.lastDirtyTime = 0;
  this.derivedCommands = {};
}
function hasFlag(command, flag) {
  return (command._flags & flag) === flag;
}
function setFlag(command, flag, value) {
  if (value) {
    command._flags |= flag;
  } else {
    command._flags &= ~flag;
  }
}
Object.defineProperties(DrawCommand.prototype, {
  boundingVolume: {
    get: function() {
      return this._boundingVolume;
    },
    set: function(value) {
      if (this._boundingVolume !== value) {
        this._boundingVolume = value;
        this.dirty = true;
      }
    }
  },
  orientedBoundingBox: {
    get: function() {
      return this._orientedBoundingBox;
    },
    set: function(value) {
      if (this._orientedBoundingBox !== value) {
        this._orientedBoundingBox = value;
        this.dirty = true;
      }
    }
  },
  cull: {
    get: function() {
      return hasFlag(this, Flags.CULL);
    },
    set: function(value) {
      if (hasFlag(this, Flags.CULL) !== value) {
        setFlag(this, Flags.CULL, value);
        this.dirty = true;
      }
    }
  },
  occlude: {
    get: function() {
      return hasFlag(this, Flags.OCCLUDE);
    },
    set: function(value) {
      if (hasFlag(this, Flags.OCCLUDE) !== value) {
        setFlag(this, Flags.OCCLUDE, value);
        this.dirty = true;
      }
    }
  },
  modelMatrix: {
    get: function() {
      return this._modelMatrix;
    },
    set: function(value) {
      if (this._modelMatrix !== value) {
        this._modelMatrix = value;
        this.dirty = true;
      }
    }
  },
  primitiveType: {
    get: function() {
      return this._primitiveType;
    },
    set: function(value) {
      if (this._primitiveType !== value) {
        this._primitiveType = value;
        this.dirty = true;
      }
    }
  },
  vertexArray: {
    get: function() {
      return this._vertexArray;
    },
    set: function(value) {
      if (this._vertexArray !== value) {
        this._vertexArray = value;
        this.dirty = true;
      }
    }
  },
  count: {
    get: function() {
      return this._count;
    },
    set: function(value) {
      if (this._count !== value) {
        this._count = value;
        this.dirty = true;
      }
    }
  },
  offset: {
    get: function() {
      return this._offset;
    },
    set: function(value) {
      if (this._offset !== value) {
        this._offset = value;
        this.dirty = true;
      }
    }
  },
  instanceCount: {
    get: function() {
      return this._instanceCount;
    },
    set: function(value) {
      if (this._instanceCount !== value) {
        this._instanceCount = value;
        this.dirty = true;
      }
    }
  },
  shaderProgram: {
    get: function() {
      return this._shaderProgram;
    },
    set: function(value) {
      if (this._shaderProgram !== value) {
        this._shaderProgram = value;
        this.dirty = true;
      }
    }
  },
  castShadows: {
    get: function() {
      return hasFlag(this, Flags.CAST_SHADOWS);
    },
    set: function(value) {
      if (hasFlag(this, Flags.CAST_SHADOWS) !== value) {
        setFlag(this, Flags.CAST_SHADOWS, value);
        this.dirty = true;
      }
    }
  },
  receiveShadows: {
    get: function() {
      return hasFlag(this, Flags.RECEIVE_SHADOWS);
    },
    set: function(value) {
      if (hasFlag(this, Flags.RECEIVE_SHADOWS) !== value) {
        setFlag(this, Flags.RECEIVE_SHADOWS, value);
        this.dirty = true;
      }
    }
  },
  uniformMap: {
    get: function() {
      return this._uniformMap;
    },
    set: function(value) {
      if (this._uniformMap !== value) {
        this._uniformMap = value;
        this.dirty = true;
      }
    }
  },
  renderState: {
    get: function() {
      return this._renderState;
    },
    set: function(value) {
      if (this._renderState !== value) {
        this._renderState = value;
        this.dirty = true;
      }
    }
  },
  framebuffer: {
    get: function() {
      return this._framebuffer;
    },
    set: function(value) {
      if (this._framebuffer !== value) {
        this._framebuffer = value;
        this.dirty = true;
      }
    }
  },
  pass: {
    get: function() {
      return this._pass;
    },
    set: function(value) {
      if (this._pass !== value) {
        this._pass = value;
        this.dirty = true;
      }
    }
  },
  executeInClosestFrustum: {
    get: function() {
      return hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM);
    },
    set: function(value) {
      if (hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM) !== value) {
        setFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM, value);
        this.dirty = true;
      }
    }
  },
  owner: {
    get: function() {
      return this._owner;
    },
    set: function(value) {
      if (this._owner !== value) {
        this._owner = value;
        this.dirty = true;
      }
    }
  },
  debugShowBoundingVolume: {
    get: function() {
      return hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME);
    },
    set: function(value) {
      if (hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME) !== value) {
        setFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME, value);
        this.dirty = true;
      }
    }
  },
  debugOverlappingFrustums: {
    get: function() {
      return this._debugOverlappingFrustums;
    },
    set: function(value) {
      if (this._debugOverlappingFrustums !== value) {
        this._debugOverlappingFrustums = value;
        this.dirty = true;
      }
    }
  },
  pickId: {
    get: function() {
      return this._pickId;
    },
    set: function(value) {
      if (this._pickId !== value) {
        this._pickId = value;
        this.dirty = true;
      }
    }
  },
  pickOnly: {
    get: function() {
      return hasFlag(this, Flags.PICK_ONLY);
    },
    set: function(value) {
      if (hasFlag(this, Flags.PICK_ONLY) !== value) {
        setFlag(this, Flags.PICK_ONLY, value);
        this.dirty = true;
      }
    }
  },
  depthForTranslucentClassification: {
    get: function() {
      return hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION);
    },
    set: function(value) {
      if (hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION) !== value) {
        setFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION, value);
        this.dirty = true;
      }
    }
  }
});
DrawCommand.shallowClone = function(command, result) {
  if (!defined_default(command)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new DrawCommand();
  }
  result._boundingVolume = command._boundingVolume;
  result._orientedBoundingBox = command._orientedBoundingBox;
  result._modelMatrix = command._modelMatrix;
  result._primitiveType = command._primitiveType;
  result._vertexArray = command._vertexArray;
  result._count = command._count;
  result._offset = command._offset;
  result._instanceCount = command._instanceCount;
  result._shaderProgram = command._shaderProgram;
  result._uniformMap = command._uniformMap;
  result._renderState = command._renderState;
  result._framebuffer = command._framebuffer;
  result._pass = command._pass;
  result._owner = command._owner;
  result._debugOverlappingFrustums = command._debugOverlappingFrustums;
  result._pickId = command._pickId;
  result._flags = command._flags;
  result.dirty = true;
  result.lastDirtyTime = 0;
  return result;
};
DrawCommand.prototype.execute = function(context, passState) {
  context.draw(this, passState);
};
var DrawCommand_default = DrawCommand;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/PixelDatatype.js
var PixelDatatype = {
  UNSIGNED_BYTE: WebGLConstants_default.UNSIGNED_BYTE,
  UNSIGNED_SHORT: WebGLConstants_default.UNSIGNED_SHORT,
  UNSIGNED_INT: WebGLConstants_default.UNSIGNED_INT,
  FLOAT: WebGLConstants_default.FLOAT,
  HALF_FLOAT: WebGLConstants_default.HALF_FLOAT_OES,
  UNSIGNED_INT_24_8: WebGLConstants_default.UNSIGNED_INT_24_8,
  UNSIGNED_SHORT_4_4_4_4: WebGLConstants_default.UNSIGNED_SHORT_4_4_4_4,
  UNSIGNED_SHORT_5_5_5_1: WebGLConstants_default.UNSIGNED_SHORT_5_5_5_1,
  UNSIGNED_SHORT_5_6_5: WebGLConstants_default.UNSIGNED_SHORT_5_6_5
};
PixelDatatype.toWebGLConstant = function(pixelDatatype, context) {
  switch (pixelDatatype) {
    case PixelDatatype.UNSIGNED_BYTE:
      return WebGLConstants_default.UNSIGNED_BYTE;
    case PixelDatatype.UNSIGNED_SHORT:
      return WebGLConstants_default.UNSIGNED_SHORT;
    case PixelDatatype.UNSIGNED_INT:
      return WebGLConstants_default.UNSIGNED_INT;
    case PixelDatatype.FLOAT:
      return WebGLConstants_default.FLOAT;
    case PixelDatatype.HALF_FLOAT:
      return context.webgl2 ? WebGLConstants_default.HALF_FLOAT : WebGLConstants_default.HALF_FLOAT_OES;
    case PixelDatatype.UNSIGNED_INT_24_8:
      return WebGLConstants_default.UNSIGNED_INT_24_8;
    case PixelDatatype.UNSIGNED_SHORT_4_4_4_4:
      return WebGLConstants_default.UNSIGNED_SHORT_4_4_4_4;
    case PixelDatatype.UNSIGNED_SHORT_5_5_5_1:
      return WebGLConstants_default.UNSIGNED_SHORT_5_5_5_1;
    case PixelDatatype.UNSIGNED_SHORT_5_6_5:
      return PixelDatatype.UNSIGNED_SHORT_5_6_5;
  }
};
PixelDatatype.isPacked = function(pixelDatatype) {
  return pixelDatatype === PixelDatatype.UNSIGNED_INT_24_8 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_4_4_4_4 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_5_5_1 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_6_5;
};
PixelDatatype.sizeInBytes = function(pixelDatatype) {
  switch (pixelDatatype) {
    case PixelDatatype.UNSIGNED_BYTE:
      return 1;
    case PixelDatatype.UNSIGNED_SHORT:
    case PixelDatatype.UNSIGNED_SHORT_4_4_4_4:
    case PixelDatatype.UNSIGNED_SHORT_5_5_5_1:
    case PixelDatatype.UNSIGNED_SHORT_5_6_5:
    case PixelDatatype.HALF_FLOAT:
      return 2;
    case PixelDatatype.UNSIGNED_INT:
    case PixelDatatype.FLOAT:
    case PixelDatatype.UNSIGNED_INT_24_8:
      return 4;
  }
};
PixelDatatype.validate = function(pixelDatatype) {
  return pixelDatatype === PixelDatatype.UNSIGNED_BYTE || pixelDatatype === PixelDatatype.UNSIGNED_SHORT || pixelDatatype === PixelDatatype.UNSIGNED_INT || pixelDatatype === PixelDatatype.FLOAT || pixelDatatype === PixelDatatype.HALF_FLOAT || pixelDatatype === PixelDatatype.UNSIGNED_INT_24_8 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_4_4_4_4 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_5_5_1 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_6_5;
};
var PixelDatatype_default = Object.freeze(PixelDatatype);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/PixelFormat.js
var PixelFormat = {
  DEPTH_COMPONENT: WebGLConstants_default.DEPTH_COMPONENT,
  DEPTH_STENCIL: WebGLConstants_default.DEPTH_STENCIL,
  ALPHA: WebGLConstants_default.ALPHA,
  RGB: WebGLConstants_default.RGB,
  RGBA: WebGLConstants_default.RGBA,
  LUMINANCE: WebGLConstants_default.LUMINANCE,
  LUMINANCE_ALPHA: WebGLConstants_default.LUMINANCE_ALPHA,
  RGB_DXT1: WebGLConstants_default.COMPRESSED_RGB_S3TC_DXT1_EXT,
  RGBA_DXT1: WebGLConstants_default.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  RGBA_DXT3: WebGLConstants_default.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  RGBA_DXT5: WebGLConstants_default.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  RGB_PVRTC_4BPPV1: WebGLConstants_default.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
  RGB_PVRTC_2BPPV1: WebGLConstants_default.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
  RGBA_PVRTC_4BPPV1: WebGLConstants_default.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
  RGBA_PVRTC_2BPPV1: WebGLConstants_default.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
  RGBA_ASTC: WebGLConstants_default.COMPRESSED_RGBA_ASTC_4x4_WEBGL,
  RGB_ETC1: WebGLConstants_default.COMPRESSED_RGB_ETC1_WEBGL,
  RGB8_ETC2: WebGLConstants_default.COMPRESSED_RGB8_ETC2,
  RGBA8_ETC2_EAC: WebGLConstants_default.COMPRESSED_RGBA8_ETC2_EAC,
  RGBA_BC7: WebGLConstants_default.COMPRESSED_RGBA_BPTC_UNORM
};
PixelFormat.componentsLength = function(pixelFormat) {
  switch (pixelFormat) {
    case PixelFormat.RGB:
      return 3;
    case PixelFormat.RGBA:
      return 4;
    case PixelFormat.LUMINANCE_ALPHA:
      return 2;
    case PixelFormat.ALPHA:
    case PixelFormat.LUMINANCE:
      return 1;
    default:
      return 1;
  }
};
PixelFormat.validate = function(pixelFormat) {
  return pixelFormat === PixelFormat.DEPTH_COMPONENT || pixelFormat === PixelFormat.DEPTH_STENCIL || pixelFormat === PixelFormat.ALPHA || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.RGBA || pixelFormat === PixelFormat.LUMINANCE || pixelFormat === PixelFormat.LUMINANCE_ALPHA || pixelFormat === PixelFormat.RGB_DXT1 || pixelFormat === PixelFormat.RGBA_DXT1 || pixelFormat === PixelFormat.RGBA_DXT3 || pixelFormat === PixelFormat.RGBA_DXT5 || pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 || pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 || pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 || pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1 || pixelFormat === PixelFormat.RGBA_ASTC || pixelFormat === PixelFormat.RGB_ETC1 || pixelFormat === PixelFormat.RGB8_ETC2 || pixelFormat === PixelFormat.RGBA8_ETC2_EAC || pixelFormat === PixelFormat.RGBA_BC7;
};
PixelFormat.isColorFormat = function(pixelFormat) {
  return pixelFormat === PixelFormat.ALPHA || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.RGBA || pixelFormat === PixelFormat.LUMINANCE || pixelFormat === PixelFormat.LUMINANCE_ALPHA;
};
PixelFormat.isDepthFormat = function(pixelFormat) {
  return pixelFormat === PixelFormat.DEPTH_COMPONENT || pixelFormat === PixelFormat.DEPTH_STENCIL;
};
PixelFormat.isCompressedFormat = function(pixelFormat) {
  return pixelFormat === PixelFormat.RGB_DXT1 || pixelFormat === PixelFormat.RGBA_DXT1 || pixelFormat === PixelFormat.RGBA_DXT3 || pixelFormat === PixelFormat.RGBA_DXT5 || pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 || pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 || pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 || pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1 || pixelFormat === PixelFormat.RGBA_ASTC || pixelFormat === PixelFormat.RGB_ETC1 || pixelFormat === PixelFormat.RGB8_ETC2 || pixelFormat === PixelFormat.RGBA8_ETC2_EAC || pixelFormat === PixelFormat.RGBA_BC7;
};
PixelFormat.isDXTFormat = function(pixelFormat) {
  return pixelFormat === PixelFormat.RGB_DXT1 || pixelFormat === PixelFormat.RGBA_DXT1 || pixelFormat === PixelFormat.RGBA_DXT3 || pixelFormat === PixelFormat.RGBA_DXT5;
};
PixelFormat.isPVRTCFormat = function(pixelFormat) {
  return pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 || pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 || pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 || pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1;
};
PixelFormat.isASTCFormat = function(pixelFormat) {
  return pixelFormat === PixelFormat.RGBA_ASTC;
};
PixelFormat.isETC1Format = function(pixelFormat) {
  return pixelFormat === PixelFormat.RGB_ETC1;
};
PixelFormat.isETC2Format = function(pixelFormat) {
  return pixelFormat === PixelFormat.RGB8_ETC2 || pixelFormat === PixelFormat.RGBA8_ETC2_EAC;
};
PixelFormat.isBC7Format = function(pixelFormat) {
  return pixelFormat === PixelFormat.RGBA_BC7;
};
PixelFormat.compressedTextureSizeInBytes = function(pixelFormat, width, height) {
  switch (pixelFormat) {
    case PixelFormat.RGB_DXT1:
    case PixelFormat.RGBA_DXT1:
    case PixelFormat.RGB_ETC1:
    case PixelFormat.RGB8_ETC2:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case PixelFormat.RGBA_DXT3:
    case PixelFormat.RGBA_DXT5:
    case PixelFormat.RGBA_ASTC:
    case PixelFormat.RGBA8_ETC2_EAC:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case PixelFormat.RGB_PVRTC_4BPPV1:
    case PixelFormat.RGBA_PVRTC_4BPPV1:
      return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);
    case PixelFormat.RGB_PVRTC_2BPPV1:
    case PixelFormat.RGBA_PVRTC_2BPPV1:
      return Math.floor(
        (Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8
      );
    case PixelFormat.RGBA_BC7:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    default:
      return 0;
  }
};
PixelFormat.textureSizeInBytes = function(pixelFormat, pixelDatatype, width, height) {
  let componentsLength = PixelFormat.componentsLength(pixelFormat);
  if (PixelDatatype_default.isPacked(pixelDatatype)) {
    componentsLength = 1;
  }
  return componentsLength * PixelDatatype_default.sizeInBytes(pixelDatatype) * width * height;
};
PixelFormat.alignmentInBytes = function(pixelFormat, pixelDatatype, width) {
  const mod = PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, width, 1) % 4;
  return mod === 0 ? 4 : mod === 2 ? 2 : 1;
};
PixelFormat.createTypedArray = function(pixelFormat, pixelDatatype, width, height) {
  let constructor;
  const sizeInBytes = PixelDatatype_default.sizeInBytes(pixelDatatype);
  if (sizeInBytes === Uint8Array.BYTES_PER_ELEMENT) {
    constructor = Uint8Array;
  } else if (sizeInBytes === Uint16Array.BYTES_PER_ELEMENT) {
    constructor = Uint16Array;
  } else if (sizeInBytes === Float32Array.BYTES_PER_ELEMENT && pixelDatatype === PixelDatatype_default.FLOAT) {
    constructor = Float32Array;
  } else {
    constructor = Uint32Array;
  }
  const size = PixelFormat.componentsLength(pixelFormat) * width * height;
  return new constructor(size);
};
PixelFormat.flipY = function(bufferView, pixelFormat, pixelDatatype, width, height) {
  if (height === 1) {
    return bufferView;
  }
  const flipped = PixelFormat.createTypedArray(
    pixelFormat,
    pixelDatatype,
    width,
    height
  );
  const numberOfComponents = PixelFormat.componentsLength(pixelFormat);
  const textureWidth = width * numberOfComponents;
  for (let i = 0; i < height; ++i) {
    const row = i * width * numberOfComponents;
    const flippedRow = (height - i - 1) * width * numberOfComponents;
    for (let j = 0; j < textureWidth; ++j) {
      flipped[flippedRow + j] = bufferView[row + j];
    }
  }
  return flipped;
};
PixelFormat.toInternalFormat = function(pixelFormat, pixelDatatype, context) {
  if (!context.webgl2) {
    return pixelFormat;
  }
  if (pixelFormat === PixelFormat.DEPTH_STENCIL) {
    return WebGLConstants_default.DEPTH24_STENCIL8;
  }
  if (pixelFormat === PixelFormat.DEPTH_COMPONENT) {
    if (pixelDatatype === PixelDatatype_default.UNSIGNED_SHORT) {
      return WebGLConstants_default.DEPTH_COMPONENT16;
    } else if (pixelDatatype === PixelDatatype_default.UNSIGNED_INT) {
      return WebGLConstants_default.DEPTH_COMPONENT24;
    }
  }
  if (pixelDatatype === PixelDatatype_default.FLOAT) {
    switch (pixelFormat) {
      case PixelFormat.RGBA:
        return WebGLConstants_default.RGBA32F;
      case PixelFormat.RGB:
        return WebGLConstants_default.RGB32F;
      case PixelFormat.RG:
        return WebGLConstants_default.RG32F;
      case PixelFormat.R:
        return WebGLConstants_default.R32F;
    }
  }
  if (pixelDatatype === PixelDatatype_default.HALF_FLOAT) {
    switch (pixelFormat) {
      case PixelFormat.RGBA:
        return WebGLConstants_default.RGBA16F;
      case PixelFormat.RGB:
        return WebGLConstants_default.RGB16F;
      case PixelFormat.RG:
        return WebGLConstants_default.RG16F;
      case PixelFormat.R:
        return WebGLConstants_default.R16F;
    }
  }
  return pixelFormat;
};
var PixelFormat_default = Object.freeze(PixelFormat);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/ContextLimits.js
var ContextLimits = {
  _maximumCombinedTextureImageUnits: 0,
  _maximumCubeMapSize: 0,
  _maximumFragmentUniformVectors: 0,
  _maximumTextureImageUnits: 0,
  _maximumRenderbufferSize: 0,
  _maximumTextureSize: 0,
  _maximumVaryingVectors: 0,
  _maximumVertexAttributes: 0,
  _maximumVertexTextureImageUnits: 0,
  _maximumVertexUniformVectors: 0,
  _minimumAliasedLineWidth: 0,
  _maximumAliasedLineWidth: 0,
  _minimumAliasedPointSize: 0,
  _maximumAliasedPointSize: 0,
  _maximumViewportWidth: 0,
  _maximumViewportHeight: 0,
  _maximumTextureFilterAnisotropy: 0,
  _maximumDrawBuffers: 0,
  _maximumColorAttachments: 0,
  _maximumSamples: 0,
  _highpFloatSupported: false,
  _highpIntSupported: false
};
Object.defineProperties(ContextLimits, {
  maximumCombinedTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumCombinedTextureImageUnits;
    }
  },
  maximumCubeMapSize: {
    get: function() {
      return ContextLimits._maximumCubeMapSize;
    }
  },
  maximumFragmentUniformVectors: {
    get: function() {
      return ContextLimits._maximumFragmentUniformVectors;
    }
  },
  maximumTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumTextureImageUnits;
    }
  },
  maximumRenderbufferSize: {
    get: function() {
      return ContextLimits._maximumRenderbufferSize;
    }
  },
  maximumTextureSize: {
    get: function() {
      return ContextLimits._maximumTextureSize;
    }
  },
  maximumVaryingVectors: {
    get: function() {
      return ContextLimits._maximumVaryingVectors;
    }
  },
  maximumVertexAttributes: {
    get: function() {
      return ContextLimits._maximumVertexAttributes;
    }
  },
  maximumVertexTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumVertexTextureImageUnits;
    }
  },
  maximumVertexUniformVectors: {
    get: function() {
      return ContextLimits._maximumVertexUniformVectors;
    }
  },
  minimumAliasedLineWidth: {
    get: function() {
      return ContextLimits._minimumAliasedLineWidth;
    }
  },
  maximumAliasedLineWidth: {
    get: function() {
      return ContextLimits._maximumAliasedLineWidth;
    }
  },
  minimumAliasedPointSize: {
    get: function() {
      return ContextLimits._minimumAliasedPointSize;
    }
  },
  maximumAliasedPointSize: {
    get: function() {
      return ContextLimits._maximumAliasedPointSize;
    }
  },
  maximumViewportWidth: {
    get: function() {
      return ContextLimits._maximumViewportWidth;
    }
  },
  maximumViewportHeight: {
    get: function() {
      return ContextLimits._maximumViewportHeight;
    }
  },
  maximumTextureFilterAnisotropy: {
    get: function() {
      return ContextLimits._maximumTextureFilterAnisotropy;
    }
  },
  maximumDrawBuffers: {
    get: function() {
      return ContextLimits._maximumDrawBuffers;
    }
  },
  maximumColorAttachments: {
    get: function() {
      return ContextLimits._maximumColorAttachments;
    }
  },
  maximumSamples: {
    get: function() {
      return ContextLimits._maximumSamples;
    }
  },
  highpFloatSupported: {
    get: function() {
      return ContextLimits._highpFloatSupported;
    }
  },
  highpIntSupported: {
    get: function() {
      return ContextLimits._highpIntSupported;
    }
  }
});
var ContextLimits_default = ContextLimits;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/WindingOrder.js
var WindingOrder = {
  CLOCKWISE: WebGLConstants_default.CW,
  COUNTER_CLOCKWISE: WebGLConstants_default.CCW
};
WindingOrder.validate = function(windingOrder) {
  return windingOrder === WindingOrder.CLOCKWISE || windingOrder === WindingOrder.COUNTER_CLOCKWISE;
};
var WindingOrder_default = Object.freeze(WindingOrder);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/freezeRenderState.js
function freezeRenderState(renderState) {
  if (typeof renderState !== "object" || renderState === null) {
    return renderState;
  }
  let propName;
  const propNames = Object.keys(renderState);
  for (let i = 0; i < propNames.length; i++) {
    propName = propNames[i];
    if (renderState.hasOwnProperty(propName) && propName !== "_applyFunctions") {
      renderState[propName] = freezeRenderState(renderState[propName]);
    }
  }
  return Object.freeze(renderState);
}
var freezeRenderState_default = freezeRenderState;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/RenderState.js
function validateBlendEquation(blendEquation) {
  return blendEquation === WebGLConstants_default.FUNC_ADD || blendEquation === WebGLConstants_default.FUNC_SUBTRACT || blendEquation === WebGLConstants_default.FUNC_REVERSE_SUBTRACT || blendEquation === WebGLConstants_default.MIN || blendEquation === WebGLConstants_default.MAX;
}
function validateBlendFunction(blendFunction) {
  return blendFunction === WebGLConstants_default.ZERO || blendFunction === WebGLConstants_default.ONE || blendFunction === WebGLConstants_default.SRC_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_SRC_COLOR || blendFunction === WebGLConstants_default.DST_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_DST_COLOR || blendFunction === WebGLConstants_default.SRC_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_SRC_ALPHA || blendFunction === WebGLConstants_default.DST_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_DST_ALPHA || blendFunction === WebGLConstants_default.CONSTANT_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_CONSTANT_COLOR || blendFunction === WebGLConstants_default.CONSTANT_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_CONSTANT_ALPHA || blendFunction === WebGLConstants_default.SRC_ALPHA_SATURATE;
}
function validateCullFace(cullFace) {
  return cullFace === WebGLConstants_default.FRONT || cullFace === WebGLConstants_default.BACK || cullFace === WebGLConstants_default.FRONT_AND_BACK;
}
function validateDepthFunction(depthFunction) {
  return depthFunction === WebGLConstants_default.NEVER || depthFunction === WebGLConstants_default.LESS || depthFunction === WebGLConstants_default.EQUAL || depthFunction === WebGLConstants_default.LEQUAL || depthFunction === WebGLConstants_default.GREATER || depthFunction === WebGLConstants_default.NOTEQUAL || depthFunction === WebGLConstants_default.GEQUAL || depthFunction === WebGLConstants_default.ALWAYS;
}
function validateStencilFunction(stencilFunction) {
  return stencilFunction === WebGLConstants_default.NEVER || stencilFunction === WebGLConstants_default.LESS || stencilFunction === WebGLConstants_default.EQUAL || stencilFunction === WebGLConstants_default.LEQUAL || stencilFunction === WebGLConstants_default.GREATER || stencilFunction === WebGLConstants_default.NOTEQUAL || stencilFunction === WebGLConstants_default.GEQUAL || stencilFunction === WebGLConstants_default.ALWAYS;
}
function validateStencilOperation(stencilOperation) {
  return stencilOperation === WebGLConstants_default.ZERO || stencilOperation === WebGLConstants_default.KEEP || stencilOperation === WebGLConstants_default.REPLACE || stencilOperation === WebGLConstants_default.INCR || stencilOperation === WebGLConstants_default.DECR || stencilOperation === WebGLConstants_default.INVERT || stencilOperation === WebGLConstants_default.INCR_WRAP || stencilOperation === WebGLConstants_default.DECR_WRAP;
}
function RenderState(renderState) {
  const rs = defaultValue_default(renderState, defaultValue_default.EMPTY_OBJECT);
  const cull = defaultValue_default(rs.cull, defaultValue_default.EMPTY_OBJECT);
  const polygonOffset = defaultValue_default(
    rs.polygonOffset,
    defaultValue_default.EMPTY_OBJECT
  );
  const scissorTest = defaultValue_default(rs.scissorTest, defaultValue_default.EMPTY_OBJECT);
  const scissorTestRectangle = defaultValue_default(
    scissorTest.rectangle,
    defaultValue_default.EMPTY_OBJECT
  );
  const depthRange = defaultValue_default(rs.depthRange, defaultValue_default.EMPTY_OBJECT);
  const depthTest = defaultValue_default(rs.depthTest, defaultValue_default.EMPTY_OBJECT);
  const colorMask = defaultValue_default(rs.colorMask, defaultValue_default.EMPTY_OBJECT);
  const blending = defaultValue_default(rs.blending, defaultValue_default.EMPTY_OBJECT);
  const blendingColor = defaultValue_default(blending.color, defaultValue_default.EMPTY_OBJECT);
  const stencilTest = defaultValue_default(rs.stencilTest, defaultValue_default.EMPTY_OBJECT);
  const stencilTestFrontOperation = defaultValue_default(
    stencilTest.frontOperation,
    defaultValue_default.EMPTY_OBJECT
  );
  const stencilTestBackOperation = defaultValue_default(
    stencilTest.backOperation,
    defaultValue_default.EMPTY_OBJECT
  );
  const sampleCoverage = defaultValue_default(
    rs.sampleCoverage,
    defaultValue_default.EMPTY_OBJECT
  );
  const viewport = rs.viewport;
  this.frontFace = defaultValue_default(rs.frontFace, WindingOrder_default.COUNTER_CLOCKWISE);
  this.cull = {
    enabled: defaultValue_default(cull.enabled, false),
    face: defaultValue_default(cull.face, WebGLConstants_default.BACK)
  };
  this.lineWidth = defaultValue_default(rs.lineWidth, 1);
  this.polygonOffset = {
    enabled: defaultValue_default(polygonOffset.enabled, false),
    factor: defaultValue_default(polygonOffset.factor, 0),
    units: defaultValue_default(polygonOffset.units, 0)
  };
  this.scissorTest = {
    enabled: defaultValue_default(scissorTest.enabled, false),
    rectangle: BoundingRectangle_default.clone(scissorTestRectangle)
  };
  this.depthRange = {
    near: defaultValue_default(depthRange.near, 0),
    far: defaultValue_default(depthRange.far, 1)
  };
  this.depthTest = {
    enabled: defaultValue_default(depthTest.enabled, false),
    func: defaultValue_default(depthTest.func, WebGLConstants_default.LESS)
  };
  this.colorMask = {
    red: defaultValue_default(colorMask.red, true),
    green: defaultValue_default(colorMask.green, true),
    blue: defaultValue_default(colorMask.blue, true),
    alpha: defaultValue_default(colorMask.alpha, true)
  };
  this.depthMask = defaultValue_default(rs.depthMask, true);
  this.stencilMask = defaultValue_default(rs.stencilMask, ~0);
  this.blending = {
    enabled: defaultValue_default(blending.enabled, false),
    color: new Color_default(
      defaultValue_default(blendingColor.red, 0),
      defaultValue_default(blendingColor.green, 0),
      defaultValue_default(blendingColor.blue, 0),
      defaultValue_default(blendingColor.alpha, 0)
    ),
    equationRgb: defaultValue_default(blending.equationRgb, WebGLConstants_default.FUNC_ADD),
    equationAlpha: defaultValue_default(
      blending.equationAlpha,
      WebGLConstants_default.FUNC_ADD
    ),
    functionSourceRgb: defaultValue_default(
      blending.functionSourceRgb,
      WebGLConstants_default.ONE
    ),
    functionSourceAlpha: defaultValue_default(
      blending.functionSourceAlpha,
      WebGLConstants_default.ONE
    ),
    functionDestinationRgb: defaultValue_default(
      blending.functionDestinationRgb,
      WebGLConstants_default.ZERO
    ),
    functionDestinationAlpha: defaultValue_default(
      blending.functionDestinationAlpha,
      WebGLConstants_default.ZERO
    )
  };
  this.stencilTest = {
    enabled: defaultValue_default(stencilTest.enabled, false),
    frontFunction: defaultValue_default(
      stencilTest.frontFunction,
      WebGLConstants_default.ALWAYS
    ),
    backFunction: defaultValue_default(stencilTest.backFunction, WebGLConstants_default.ALWAYS),
    reference: defaultValue_default(stencilTest.reference, 0),
    mask: defaultValue_default(stencilTest.mask, ~0),
    frontOperation: {
      fail: defaultValue_default(stencilTestFrontOperation.fail, WebGLConstants_default.KEEP),
      zFail: defaultValue_default(stencilTestFrontOperation.zFail, WebGLConstants_default.KEEP),
      zPass: defaultValue_default(stencilTestFrontOperation.zPass, WebGLConstants_default.KEEP)
    },
    backOperation: {
      fail: defaultValue_default(stencilTestBackOperation.fail, WebGLConstants_default.KEEP),
      zFail: defaultValue_default(stencilTestBackOperation.zFail, WebGLConstants_default.KEEP),
      zPass: defaultValue_default(stencilTestBackOperation.zPass, WebGLConstants_default.KEEP)
    }
  };
  this.sampleCoverage = {
    enabled: defaultValue_default(sampleCoverage.enabled, false),
    value: defaultValue_default(sampleCoverage.value, 1),
    invert: defaultValue_default(sampleCoverage.invert, false)
  };
  this.viewport = defined_default(viewport) ? new BoundingRectangle_default(
    viewport.x,
    viewport.y,
    viewport.width,
    viewport.height
  ) : void 0;
  if (this.lineWidth < ContextLimits_default.minimumAliasedLineWidth || this.lineWidth > ContextLimits_default.maximumAliasedLineWidth) {
    throw new DeveloperError_default(
      "renderState.lineWidth is out of range.  Check minimumAliasedLineWidth and maximumAliasedLineWidth."
    );
  }
  if (!WindingOrder_default.validate(this.frontFace)) {
    throw new DeveloperError_default("Invalid renderState.frontFace.");
  }
  if (!validateCullFace(this.cull.face)) {
    throw new DeveloperError_default("Invalid renderState.cull.face.");
  }
  if (this.scissorTest.rectangle.width < 0 || this.scissorTest.rectangle.height < 0) {
    throw new DeveloperError_default(
      "renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero."
    );
  }
  if (this.depthRange.near > this.depthRange.far) {
    throw new DeveloperError_default(
      "renderState.depthRange.near can not be greater than renderState.depthRange.far."
    );
  }
  if (this.depthRange.near < 0) {
    throw new DeveloperError_default(
      "renderState.depthRange.near must be greater than or equal to zero."
    );
  }
  if (this.depthRange.far > 1) {
    throw new DeveloperError_default(
      "renderState.depthRange.far must be less than or equal to one."
    );
  }
  if (!validateDepthFunction(this.depthTest.func)) {
    throw new DeveloperError_default("Invalid renderState.depthTest.func.");
  }
  if (this.blending.color.red < 0 || this.blending.color.red > 1 || this.blending.color.green < 0 || this.blending.color.green > 1 || this.blending.color.blue < 0 || this.blending.color.blue > 1 || this.blending.color.alpha < 0 || this.blending.color.alpha > 1) {
    throw new DeveloperError_default(
      "renderState.blending.color components must be greater than or equal to zero and less than or equal to one."
    );
  }
  if (!validateBlendEquation(this.blending.equationRgb)) {
    throw new DeveloperError_default("Invalid renderState.blending.equationRgb.");
  }
  if (!validateBlendEquation(this.blending.equationAlpha)) {
    throw new DeveloperError_default("Invalid renderState.blending.equationAlpha.");
  }
  if (!validateBlendFunction(this.blending.functionSourceRgb)) {
    throw new DeveloperError_default("Invalid renderState.blending.functionSourceRgb.");
  }
  if (!validateBlendFunction(this.blending.functionSourceAlpha)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionSourceAlpha."
    );
  }
  if (!validateBlendFunction(this.blending.functionDestinationRgb)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionDestinationRgb."
    );
  }
  if (!validateBlendFunction(this.blending.functionDestinationAlpha)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionDestinationAlpha."
    );
  }
  if (!validateStencilFunction(this.stencilTest.frontFunction)) {
    throw new DeveloperError_default("Invalid renderState.stencilTest.frontFunction.");
  }
  if (!validateStencilFunction(this.stencilTest.backFunction)) {
    throw new DeveloperError_default("Invalid renderState.stencilTest.backFunction.");
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.fail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.fail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.zFail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.zFail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.zPass)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.zPass."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.fail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.fail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.zFail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.zFail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.zPass)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.zPass."
    );
  }
  if (defined_default(this.viewport)) {
    if (this.viewport.width < 0) {
      throw new DeveloperError_default(
        "renderState.viewport.width must be greater than or equal to zero."
      );
    }
    if (this.viewport.height < 0) {
      throw new DeveloperError_default(
        "renderState.viewport.height must be greater than or equal to zero."
      );
    }
    if (this.viewport.width > ContextLimits_default.maximumViewportWidth) {
      throw new DeveloperError_default(
        `renderState.viewport.width must be less than or equal to the maximum viewport width (${ContextLimits_default.maximumViewportWidth.toString()}).  Check maximumViewportWidth.`
      );
    }
    if (this.viewport.height > ContextLimits_default.maximumViewportHeight) {
      throw new DeveloperError_default(
        `renderState.viewport.height must be less than or equal to the maximum viewport height (${ContextLimits_default.maximumViewportHeight.toString()}).  Check maximumViewportHeight.`
      );
    }
  }
  this.id = 0;
  this._applyFunctions = [];
}
var nextRenderStateId = 0;
var renderStateCache = {};
RenderState.fromCache = function(renderState) {
  const partialKey = JSON.stringify(renderState);
  let cachedState = renderStateCache[partialKey];
  if (defined_default(cachedState)) {
    ++cachedState.referenceCount;
    return cachedState.state;
  }
  let states = new RenderState(renderState);
  const fullKey = JSON.stringify(states);
  cachedState = renderStateCache[fullKey];
  if (!defined_default(cachedState)) {
    states.id = nextRenderStateId++;
    states = freezeRenderState_default(states);
    cachedState = {
      referenceCount: 0,
      state: states
    };
    renderStateCache[fullKey] = cachedState;
  }
  ++cachedState.referenceCount;
  renderStateCache[partialKey] = {
    referenceCount: 1,
    state: cachedState.state
  };
  return cachedState.state;
};
RenderState.removeFromCache = function(renderState) {
  const states = new RenderState(renderState);
  const fullKey = JSON.stringify(states);
  const fullCachedState = renderStateCache[fullKey];
  const partialKey = JSON.stringify(renderState);
  const cachedState = renderStateCache[partialKey];
  if (defined_default(cachedState)) {
    --cachedState.referenceCount;
    if (cachedState.referenceCount === 0) {
      delete renderStateCache[partialKey];
      if (defined_default(fullCachedState)) {
        --fullCachedState.referenceCount;
      }
    }
  }
  if (defined_default(fullCachedState) && fullCachedState.referenceCount === 0) {
    delete renderStateCache[fullKey];
  }
};
RenderState.getCache = function() {
  return renderStateCache;
};
RenderState.clearCache = function() {
  renderStateCache = {};
};
function enableOrDisable(gl, glEnum, enable) {
  if (enable) {
    gl.enable(glEnum);
  } else {
    gl.disable(glEnum);
  }
}
function applyFrontFace(gl, renderState) {
  gl.frontFace(renderState.frontFace);
}
function applyCull(gl, renderState) {
  const cull = renderState.cull;
  const enabled = cull.enabled;
  enableOrDisable(gl, gl.CULL_FACE, enabled);
  if (enabled) {
    gl.cullFace(cull.face);
  }
}
function applyLineWidth(gl, renderState) {
  gl.lineWidth(renderState.lineWidth);
}
function applyPolygonOffset(gl, renderState) {
  const polygonOffset = renderState.polygonOffset;
  const enabled = polygonOffset.enabled;
  enableOrDisable(gl, gl.POLYGON_OFFSET_FILL, enabled);
  if (enabled) {
    gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
  }
}
function applyScissorTest(gl, renderState, passState) {
  const scissorTest = renderState.scissorTest;
  const enabled = defined_default(passState.scissorTest) ? passState.scissorTest.enabled : scissorTest.enabled;
  enableOrDisable(gl, gl.SCISSOR_TEST, enabled);
  if (enabled) {
    const rectangle = defined_default(passState.scissorTest) ? passState.scissorTest.rectangle : scissorTest.rectangle;
    gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  }
}
function applyDepthRange(gl, renderState) {
  const depthRange = renderState.depthRange;
  gl.depthRange(depthRange.near, depthRange.far);
}
function applyDepthTest(gl, renderState) {
  const depthTest = renderState.depthTest;
  const enabled = depthTest.enabled;
  enableOrDisable(gl, gl.DEPTH_TEST, enabled);
  if (enabled) {
    gl.depthFunc(depthTest.func);
  }
}
function applyColorMask(gl, renderState) {
  const colorMask = renderState.colorMask;
  gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
}
function applyDepthMask(gl, renderState) {
  gl.depthMask(renderState.depthMask);
}
function applyStencilMask(gl, renderState) {
  gl.stencilMask(renderState.stencilMask);
}
function applyBlendingColor(gl, color) {
  gl.blendColor(color.red, color.green, color.blue, color.alpha);
}
function applyBlending(gl, renderState, passState) {
  const blending = renderState.blending;
  const enabled = defined_default(passState.blendingEnabled) ? passState.blendingEnabled : blending.enabled;
  enableOrDisable(gl, gl.BLEND, enabled);
  if (enabled) {
    applyBlendingColor(gl, blending.color);
    gl.blendEquationSeparate(blending.equationRgb, blending.equationAlpha);
    gl.blendFuncSeparate(
      blending.functionSourceRgb,
      blending.functionDestinationRgb,
      blending.functionSourceAlpha,
      blending.functionDestinationAlpha
    );
  }
}
function applyStencilTest(gl, renderState) {
  const stencilTest = renderState.stencilTest;
  const enabled = stencilTest.enabled;
  enableOrDisable(gl, gl.STENCIL_TEST, enabled);
  if (enabled) {
    const frontFunction = stencilTest.frontFunction;
    const backFunction = stencilTest.backFunction;
    const reference = stencilTest.reference;
    const mask = stencilTest.mask;
    gl.stencilFunc(frontFunction, reference, mask);
    gl.stencilFuncSeparate(gl.BACK, backFunction, reference, mask);
    gl.stencilFuncSeparate(gl.FRONT, frontFunction, reference, mask);
    const frontOperation = stencilTest.frontOperation;
    const frontOperationFail = frontOperation.fail;
    const frontOperationZFail = frontOperation.zFail;
    const frontOperationZPass = frontOperation.zPass;
    gl.stencilOpSeparate(
      gl.FRONT,
      frontOperationFail,
      frontOperationZFail,
      frontOperationZPass
    );
    const backOperation = stencilTest.backOperation;
    const backOperationFail = backOperation.fail;
    const backOperationZFail = backOperation.zFail;
    const backOperationZPass = backOperation.zPass;
    gl.stencilOpSeparate(
      gl.BACK,
      backOperationFail,
      backOperationZFail,
      backOperationZPass
    );
  }
}
function applySampleCoverage(gl, renderState) {
  const sampleCoverage = renderState.sampleCoverage;
  const enabled = sampleCoverage.enabled;
  enableOrDisable(gl, gl.SAMPLE_COVERAGE, enabled);
  if (enabled) {
    gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
  }
}
var scratchViewport = new BoundingRectangle_default();
function applyViewport(gl, renderState, passState) {
  let viewport = defaultValue_default(renderState.viewport, passState.viewport);
  if (!defined_default(viewport)) {
    viewport = scratchViewport;
    viewport.width = passState.context.drawingBufferWidth;
    viewport.height = passState.context.drawingBufferHeight;
  }
  passState.context.uniformState.viewport = viewport;
  gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
}
RenderState.apply = function(gl, renderState, passState) {
  applyFrontFace(gl, renderState);
  applyCull(gl, renderState);
  applyLineWidth(gl, renderState);
  applyPolygonOffset(gl, renderState);
  applyDepthRange(gl, renderState);
  applyDepthTest(gl, renderState);
  applyColorMask(gl, renderState);
  applyDepthMask(gl, renderState);
  applyStencilMask(gl, renderState);
  applyStencilTest(gl, renderState);
  applySampleCoverage(gl, renderState);
  applyScissorTest(gl, renderState, passState);
  applyBlending(gl, renderState, passState);
  applyViewport(gl, renderState, passState);
};
function createFuncs(previousState, nextState) {
  const funcs = [];
  if (previousState.frontFace !== nextState.frontFace) {
    funcs.push(applyFrontFace);
  }
  if (previousState.cull.enabled !== nextState.cull.enabled || previousState.cull.face !== nextState.cull.face) {
    funcs.push(applyCull);
  }
  if (previousState.lineWidth !== nextState.lineWidth) {
    funcs.push(applyLineWidth);
  }
  if (previousState.polygonOffset.enabled !== nextState.polygonOffset.enabled || previousState.polygonOffset.factor !== nextState.polygonOffset.factor || previousState.polygonOffset.units !== nextState.polygonOffset.units) {
    funcs.push(applyPolygonOffset);
  }
  if (previousState.depthRange.near !== nextState.depthRange.near || previousState.depthRange.far !== nextState.depthRange.far) {
    funcs.push(applyDepthRange);
  }
  if (previousState.depthTest.enabled !== nextState.depthTest.enabled || previousState.depthTest.func !== nextState.depthTest.func) {
    funcs.push(applyDepthTest);
  }
  if (previousState.colorMask.red !== nextState.colorMask.red || previousState.colorMask.green !== nextState.colorMask.green || previousState.colorMask.blue !== nextState.colorMask.blue || previousState.colorMask.alpha !== nextState.colorMask.alpha) {
    funcs.push(applyColorMask);
  }
  if (previousState.depthMask !== nextState.depthMask) {
    funcs.push(applyDepthMask);
  }
  if (previousState.stencilMask !== nextState.stencilMask) {
    funcs.push(applyStencilMask);
  }
  if (previousState.stencilTest.enabled !== nextState.stencilTest.enabled || previousState.stencilTest.frontFunction !== nextState.stencilTest.frontFunction || previousState.stencilTest.backFunction !== nextState.stencilTest.backFunction || previousState.stencilTest.reference !== nextState.stencilTest.reference || previousState.stencilTest.mask !== nextState.stencilTest.mask || previousState.stencilTest.frontOperation.fail !== nextState.stencilTest.frontOperation.fail || previousState.stencilTest.frontOperation.zFail !== nextState.stencilTest.frontOperation.zFail || previousState.stencilTest.backOperation.fail !== nextState.stencilTest.backOperation.fail || previousState.stencilTest.backOperation.zFail !== nextState.stencilTest.backOperation.zFail || previousState.stencilTest.backOperation.zPass !== nextState.stencilTest.backOperation.zPass) {
    funcs.push(applyStencilTest);
  }
  if (previousState.sampleCoverage.enabled !== nextState.sampleCoverage.enabled || previousState.sampleCoverage.value !== nextState.sampleCoverage.value || previousState.sampleCoverage.invert !== nextState.sampleCoverage.invert) {
    funcs.push(applySampleCoverage);
  }
  return funcs;
}
RenderState.partialApply = function(gl, previousRenderState, renderState, previousPassState, passState, clear) {
  if (previousRenderState !== renderState) {
    let funcs = renderState._applyFunctions[previousRenderState.id];
    if (!defined_default(funcs)) {
      funcs = createFuncs(previousRenderState, renderState);
      renderState._applyFunctions[previousRenderState.id] = funcs;
    }
    const len = funcs.length;
    for (let i = 0; i < len; ++i) {
      funcs[i](gl, renderState);
    }
  }
  const previousScissorTest = defined_default(previousPassState.scissorTest) ? previousPassState.scissorTest : previousRenderState.scissorTest;
  const scissorTest = defined_default(passState.scissorTest) ? passState.scissorTest : renderState.scissorTest;
  if (previousScissorTest !== scissorTest || clear) {
    applyScissorTest(gl, renderState, passState);
  }
  const previousBlendingEnabled = defined_default(previousPassState.blendingEnabled) ? previousPassState.blendingEnabled : previousRenderState.blending.enabled;
  const blendingEnabled = defined_default(passState.blendingEnabled) ? passState.blendingEnabled : renderState.blending.enabled;
  if (previousBlendingEnabled !== blendingEnabled || blendingEnabled && previousRenderState.blending !== renderState.blending) {
    applyBlending(gl, renderState, passState);
  }
  if (previousRenderState !== renderState || previousPassState !== passState || previousPassState.context !== passState.context) {
    applyViewport(gl, renderState, passState);
  }
};
RenderState.getState = function(renderState) {
  if (!defined_default(renderState)) {
    throw new DeveloperError_default("renderState is required.");
  }
  return {
    frontFace: renderState.frontFace,
    cull: {
      enabled: renderState.cull.enabled,
      face: renderState.cull.face
    },
    lineWidth: renderState.lineWidth,
    polygonOffset: {
      enabled: renderState.polygonOffset.enabled,
      factor: renderState.polygonOffset.factor,
      units: renderState.polygonOffset.units
    },
    scissorTest: {
      enabled: renderState.scissorTest.enabled,
      rectangle: BoundingRectangle_default.clone(renderState.scissorTest.rectangle)
    },
    depthRange: {
      near: renderState.depthRange.near,
      far: renderState.depthRange.far
    },
    depthTest: {
      enabled: renderState.depthTest.enabled,
      func: renderState.depthTest.func
    },
    colorMask: {
      red: renderState.colorMask.red,
      green: renderState.colorMask.green,
      blue: renderState.colorMask.blue,
      alpha: renderState.colorMask.alpha
    },
    depthMask: renderState.depthMask,
    stencilMask: renderState.stencilMask,
    blending: {
      enabled: renderState.blending.enabled,
      color: Color_default.clone(renderState.blending.color),
      equationRgb: renderState.blending.equationRgb,
      equationAlpha: renderState.blending.equationAlpha,
      functionSourceRgb: renderState.blending.functionSourceRgb,
      functionSourceAlpha: renderState.blending.functionSourceAlpha,
      functionDestinationRgb: renderState.blending.functionDestinationRgb,
      functionDestinationAlpha: renderState.blending.functionDestinationAlpha
    },
    stencilTest: {
      enabled: renderState.stencilTest.enabled,
      frontFunction: renderState.stencilTest.frontFunction,
      backFunction: renderState.stencilTest.backFunction,
      reference: renderState.stencilTest.reference,
      mask: renderState.stencilTest.mask,
      frontOperation: {
        fail: renderState.stencilTest.frontOperation.fail,
        zFail: renderState.stencilTest.frontOperation.zFail,
        zPass: renderState.stencilTest.frontOperation.zPass
      },
      backOperation: {
        fail: renderState.stencilTest.backOperation.fail,
        zFail: renderState.stencilTest.backOperation.zFail,
        zPass: renderState.stencilTest.backOperation.zPass
      }
    },
    sampleCoverage: {
      enabled: renderState.sampleCoverage.enabled,
      value: renderState.sampleCoverage.value,
      invert: renderState.sampleCoverage.invert
    },
    viewport: defined_default(renderState.viewport) ? BoundingRectangle_default.clone(renderState.viewport) : void 0
  };
};
var RenderState_default = RenderState;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Matrix2.js
function Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {
  this[0] = defaultValue_default(column0Row0, 0);
  this[1] = defaultValue_default(column0Row1, 0);
  this[2] = defaultValue_default(column1Row0, 0);
  this[3] = defaultValue_default(column1Row1, 0);
}
Matrix2.packedLength = 4;
Matrix2.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value[0];
  array[startingIndex++] = value[1];
  array[startingIndex++] = value[2];
  array[startingIndex++] = value[3];
  return array;
};
Matrix2.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Matrix2();
  }
  result[0] = array[startingIndex++];
  result[1] = array[startingIndex++];
  result[2] = array[startingIndex++];
  result[3] = array[startingIndex++];
  return result;
};
Matrix2.packArray = function(array, result) {
  Check_default.defined("array", array);
  const length = array.length;
  const resultLength = length * 4;
  if (!defined_default(result)) {
    result = new Array(resultLength);
  } else if (!Array.isArray(result) && result.length !== resultLength) {
    throw new DeveloperError_default(
      "If result is a typed array, it must have exactly array.length * 4 elements"
    );
  } else if (result.length !== resultLength) {
    result.length = resultLength;
  }
  for (let i = 0; i < length; ++i) {
    Matrix2.pack(array[i], result, i * 4);
  }
  return result;
};
Matrix2.unpackArray = function(array, result) {
  Check_default.defined("array", array);
  Check_default.typeOf.number.greaterThanOrEquals("array.length", array.length, 4);
  if (array.length % 4 !== 0) {
    throw new DeveloperError_default("array length must be a multiple of 4.");
  }
  const length = array.length;
  if (!defined_default(result)) {
    result = new Array(length / 4);
  } else {
    result.length = length / 4;
  }
  for (let i = 0; i < length; i += 4) {
    const index = i / 4;
    result[index] = Matrix2.unpack(array, i, result[index]);
  }
  return result;
};
Matrix2.clone = function(matrix, result) {
  if (!defined_default(matrix)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);
  }
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  return result;
};
Matrix2.fromArray = Matrix2.unpack;
Matrix2.fromColumnMajorArray = function(values, result) {
  Check_default.defined("values", values);
  return Matrix2.clone(values, result);
};
Matrix2.fromRowMajorArray = function(values, result) {
  Check_default.defined("values", values);
  if (!defined_default(result)) {
    return new Matrix2(values[0], values[1], values[2], values[3]);
  }
  result[0] = values[0];
  result[1] = values[2];
  result[2] = values[1];
  result[3] = values[3];
  return result;
};
Matrix2.fromScale = function(scale, result) {
  Check_default.typeOf.object("scale", scale);
  if (!defined_default(result)) {
    return new Matrix2(scale.x, 0, 0, scale.y);
  }
  result[0] = scale.x;
  result[1] = 0;
  result[2] = 0;
  result[3] = scale.y;
  return result;
};
Matrix2.fromUniformScale = function(scale, result) {
  Check_default.typeOf.number("scale", scale);
  if (!defined_default(result)) {
    return new Matrix2(scale, 0, 0, scale);
  }
  result[0] = scale;
  result[1] = 0;
  result[2] = 0;
  result[3] = scale;
  return result;
};
Matrix2.fromRotation = function(angle, result) {
  Check_default.typeOf.number("angle", angle);
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  if (!defined_default(result)) {
    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);
  }
  result[0] = cosAngle;
  result[1] = sinAngle;
  result[2] = -sinAngle;
  result[3] = cosAngle;
  return result;
};
Matrix2.toArray = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  if (!defined_default(result)) {
    return [matrix[0], matrix[1], matrix[2], matrix[3]];
  }
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[3];
  return result;
};
Matrix2.getElementIndex = function(column, row) {
  Check_default.typeOf.number.greaterThanOrEquals("row", row, 0);
  Check_default.typeOf.number.lessThanOrEquals("row", row, 1);
  Check_default.typeOf.number.greaterThanOrEquals("column", column, 0);
  Check_default.typeOf.number.lessThanOrEquals("column", column, 1);
  return column * 2 + row;
};
Matrix2.getColumn = function(matrix, index, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 1);
  Check_default.typeOf.object("result", result);
  const startIndex = index * 2;
  const x = matrix[startIndex];
  const y = matrix[startIndex + 1];
  result.x = x;
  result.y = y;
  return result;
};
Matrix2.setColumn = function(matrix, index, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 1);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result = Matrix2.clone(matrix, result);
  const startIndex = index * 2;
  result[startIndex] = cartesian.x;
  result[startIndex + 1] = cartesian.y;
  return result;
};
Matrix2.getRow = function(matrix, index, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 1);
  Check_default.typeOf.object("result", result);
  const x = matrix[index];
  const y = matrix[index + 2];
  result.x = x;
  result.y = y;
  return result;
};
Matrix2.setRow = function(matrix, index, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  Check_default.typeOf.number.lessThanOrEquals("index", index, 1);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  result = Matrix2.clone(matrix, result);
  result[index] = cartesian.x;
  result[index + 2] = cartesian.y;
  return result;
};
var scaleScratch13 = new Cartesian2_default();
Matrix2.setScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("scale", scale);
  Check_default.typeOf.object("result", result);
  const existingScale = Matrix2.getScale(matrix, scaleScratch13);
  const scaleRatioX = scale.x / existingScale.x;
  const scaleRatioY = scale.y / existingScale.y;
  result[0] = matrix[0] * scaleRatioX;
  result[1] = matrix[1] * scaleRatioX;
  result[2] = matrix[2] * scaleRatioY;
  result[3] = matrix[3] * scaleRatioY;
  return result;
};
var scaleScratch23 = new Cartesian2_default();
Matrix2.setUniformScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scale", scale);
  Check_default.typeOf.object("result", result);
  const existingScale = Matrix2.getScale(matrix, scaleScratch23);
  const scaleRatioX = scale / existingScale.x;
  const scaleRatioY = scale / existingScale.y;
  result[0] = matrix[0] * scaleRatioX;
  result[1] = matrix[1] * scaleRatioX;
  result[2] = matrix[2] * scaleRatioY;
  result[3] = matrix[3] * scaleRatioY;
  return result;
};
var scratchColumn3 = new Cartesian2_default();
Matrix2.getScale = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result.x = Cartesian2_default.magnitude(
    Cartesian2_default.fromElements(matrix[0], matrix[1], scratchColumn3)
  );
  result.y = Cartesian2_default.magnitude(
    Cartesian2_default.fromElements(matrix[2], matrix[3], scratchColumn3)
  );
  return result;
};
var scaleScratch33 = new Cartesian2_default();
Matrix2.getMaximumScale = function(matrix) {
  Matrix2.getScale(matrix, scaleScratch33);
  return Cartesian2_default.maximumComponent(scaleScratch33);
};
var scaleScratch43 = new Cartesian2_default();
Matrix2.setRotation = function(matrix, rotation, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const scale = Matrix2.getScale(matrix, scaleScratch43);
  result[0] = rotation[0] * scale.x;
  result[1] = rotation[1] * scale.x;
  result[2] = rotation[2] * scale.y;
  result[3] = rotation[3] * scale.y;
  return result;
};
var scaleScratch53 = new Cartesian2_default();
Matrix2.getRotation = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const scale = Matrix2.getScale(matrix, scaleScratch53);
  result[0] = matrix[0] / scale.x;
  result[1] = matrix[1] / scale.x;
  result[2] = matrix[2] / scale.y;
  result[3] = matrix[3] / scale.y;
  return result;
};
Matrix2.multiply = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  const column0Row0 = left[0] * right[0] + left[2] * right[1];
  const column1Row0 = left[0] * right[2] + left[2] * right[3];
  const column0Row1 = left[1] * right[0] + left[3] * right[1];
  const column1Row1 = left[1] * right[2] + left[3] * right[3];
  result[0] = column0Row0;
  result[1] = column0Row1;
  result[2] = column1Row0;
  result[3] = column1Row1;
  return result;
};
Matrix2.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result[0] = left[0] + right[0];
  result[1] = left[1] + right[1];
  result[2] = left[2] + right[2];
  result[3] = left[3] + right[3];
  return result;
};
Matrix2.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result[0] = left[0] - right[0];
  result[1] = left[1] - right[1];
  result[2] = left[2] - right[2];
  result[3] = left[3] - right[3];
  return result;
};
Matrix2.multiplyByVector = function(matrix, cartesian, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;
  const y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;
  result.x = x;
  result.y = y;
  return result;
};
Matrix2.multiplyByScalar = function(matrix, scalar, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scalar;
  result[1] = matrix[1] * scalar;
  result[2] = matrix[2] * scalar;
  result[3] = matrix[3] * scalar;
  return result;
};
Matrix2.multiplyByScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("scale", scale);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scale.x;
  result[1] = matrix[1] * scale.x;
  result[2] = matrix[2] * scale.y;
  result[3] = matrix[3] * scale.y;
  return result;
};
Matrix2.multiplyByUniformScale = function(matrix, scale, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.number("scale", scale);
  Check_default.typeOf.object("result", result);
  result[0] = matrix[0] * scale;
  result[1] = matrix[1] * scale;
  result[2] = matrix[2] * scale;
  result[3] = matrix[3] * scale;
  return result;
};
Matrix2.negate = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result[0] = -matrix[0];
  result[1] = -matrix[1];
  result[2] = -matrix[2];
  result[3] = -matrix[3];
  return result;
};
Matrix2.transpose = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  const column0Row0 = matrix[0];
  const column0Row1 = matrix[2];
  const column1Row0 = matrix[1];
  const column1Row1 = matrix[3];
  result[0] = column0Row0;
  result[1] = column0Row1;
  result[2] = column1Row0;
  result[3] = column1Row1;
  return result;
};
Matrix2.abs = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  Check_default.typeOf.object("result", result);
  result[0] = Math.abs(matrix[0]);
  result[1] = Math.abs(matrix[1]);
  result[2] = Math.abs(matrix[2]);
  result[3] = Math.abs(matrix[3]);
  return result;
};
Matrix2.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3];
};
Matrix2.equalsArray = function(matrix, array, offset) {
  return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3];
};
Matrix2.equalsEpsilon = function(left, right, epsilon) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon;
};
Matrix2.IDENTITY = Object.freeze(new Matrix2(1, 0, 0, 1));
Matrix2.ZERO = Object.freeze(new Matrix2(0, 0, 0, 0));
Matrix2.COLUMN0ROW0 = 0;
Matrix2.COLUMN0ROW1 = 1;
Matrix2.COLUMN1ROW0 = 2;
Matrix2.COLUMN1ROW1 = 3;
Object.defineProperties(Matrix2.prototype, {
  length: {
    get: function() {
      return Matrix2.packedLength;
    }
  }
});
Matrix2.prototype.clone = function(result) {
  return Matrix2.clone(this, result);
};
Matrix2.prototype.equals = function(right) {
  return Matrix2.equals(this, right);
};
Matrix2.prototype.equalsEpsilon = function(right, epsilon) {
  return Matrix2.equalsEpsilon(this, right, epsilon);
};
Matrix2.prototype.toString = function() {
  return `(${this[0]}, ${this[2]})
(${this[1]}, ${this[3]})`;
};
var Matrix2_default = Matrix2;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/createUniform.js
function createUniform(gl, activeUniform, uniformName, location2) {
  switch (activeUniform.type) {
    case gl.FLOAT:
      return new UniformFloat(gl, activeUniform, uniformName, location2);
    case gl.FLOAT_VEC2:
      return new UniformFloatVec2(gl, activeUniform, uniformName, location2);
    case gl.FLOAT_VEC3:
      return new UniformFloatVec3(gl, activeUniform, uniformName, location2);
    case gl.FLOAT_VEC4:
      return new UniformFloatVec4(gl, activeUniform, uniformName, location2);
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
      return new UniformSampler(gl, activeUniform, uniformName, location2);
    case gl.INT:
    case gl.BOOL:
      return new UniformInt(gl, activeUniform, uniformName, location2);
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
      return new UniformIntVec2(gl, activeUniform, uniformName, location2);
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
      return new UniformIntVec3(gl, activeUniform, uniformName, location2);
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
      return new UniformIntVec4(gl, activeUniform, uniformName, location2);
    case gl.FLOAT_MAT2:
      return new UniformMat2(gl, activeUniform, uniformName, location2);
    case gl.FLOAT_MAT3:
      return new UniformMat3(gl, activeUniform, uniformName, location2);
    case gl.FLOAT_MAT4:
      return new UniformMat4(gl, activeUniform, uniformName, location2);
    default:
      throw new RuntimeError_default(
        `Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`
      );
  }
}
function UniformFloat(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = 0;
  this._gl = gl;
  this._location = location2;
}
UniformFloat.prototype.set = function() {
  if (this.value !== this._value) {
    this._value = this.value;
    this._gl.uniform1f(this._location, this.value);
  }
};
function UniformFloatVec2(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian2_default();
  this._gl = gl;
  this._location = location2;
}
UniformFloatVec2.prototype.set = function() {
  const v3 = this.value;
  if (!Cartesian2_default.equals(v3, this._value)) {
    Cartesian2_default.clone(v3, this._value);
    this._gl.uniform2f(this._location, v3.x, v3.y);
  }
};
function UniformFloatVec3(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = void 0;
  this._gl = gl;
  this._location = location2;
}
UniformFloatVec3.prototype.set = function() {
  const v3 = this.value;
  if (defined_default(v3.red)) {
    if (!Color_default.equals(v3, this._value)) {
      this._value = Color_default.clone(v3, this._value);
      this._gl.uniform3f(this._location, v3.red, v3.green, v3.blue);
    }
  } else if (defined_default(v3.x)) {
    if (!Cartesian3_default.equals(v3, this._value)) {
      this._value = Cartesian3_default.clone(v3, this._value);
      this._gl.uniform3f(this._location, v3.x, v3.y, v3.z);
    }
  } else {
    throw new DeveloperError_default(`Invalid vec3 value for uniform "${this.name}".`);
  }
};
function UniformFloatVec4(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = void 0;
  this._gl = gl;
  this._location = location2;
}
UniformFloatVec4.prototype.set = function() {
  const v3 = this.value;
  if (defined_default(v3.red)) {
    if (!Color_default.equals(v3, this._value)) {
      this._value = Color_default.clone(v3, this._value);
      this._gl.uniform4f(this._location, v3.red, v3.green, v3.blue, v3.alpha);
    }
  } else if (defined_default(v3.x)) {
    if (!Cartesian4_default.equals(v3, this._value)) {
      this._value = Cartesian4_default.clone(v3, this._value);
      this._gl.uniform4f(this._location, v3.x, v3.y, v3.z, v3.w);
    }
  } else {
    throw new DeveloperError_default(`Invalid vec4 value for uniform "${this.name}".`);
  }
};
function UniformSampler(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._gl = gl;
  this._location = location2;
  this.textureUnitIndex = void 0;
}
UniformSampler.prototype.set = function() {
  const gl = this._gl;
  gl.activeTexture(gl.TEXTURE0 + this.textureUnitIndex);
  const v3 = this.value;
  gl.bindTexture(v3._target, v3._texture);
};
UniformSampler.prototype._setSampler = function(textureUnitIndex) {
  this.textureUnitIndex = textureUnitIndex;
  this._gl.uniform1i(this._location, textureUnitIndex);
  return textureUnitIndex + 1;
};
function UniformInt(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = 0;
  this._gl = gl;
  this._location = location2;
}
UniformInt.prototype.set = function() {
  if (this.value !== this._value) {
    this._value = this.value;
    this._gl.uniform1i(this._location, this.value);
  }
};
function UniformIntVec2(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian2_default();
  this._gl = gl;
  this._location = location2;
}
UniformIntVec2.prototype.set = function() {
  const v3 = this.value;
  if (!Cartesian2_default.equals(v3, this._value)) {
    Cartesian2_default.clone(v3, this._value);
    this._gl.uniform2i(this._location, v3.x, v3.y);
  }
};
function UniformIntVec3(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian3_default();
  this._gl = gl;
  this._location = location2;
}
UniformIntVec3.prototype.set = function() {
  const v3 = this.value;
  if (!Cartesian3_default.equals(v3, this._value)) {
    Cartesian3_default.clone(v3, this._value);
    this._gl.uniform3i(this._location, v3.x, v3.y, v3.z);
  }
};
function UniformIntVec4(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian4_default();
  this._gl = gl;
  this._location = location2;
}
UniformIntVec4.prototype.set = function() {
  const v3 = this.value;
  if (!Cartesian4_default.equals(v3, this._value)) {
    Cartesian4_default.clone(v3, this._value);
    this._gl.uniform4i(this._location, v3.x, v3.y, v3.z, v3.w);
  }
};
var scratchUniformArray = new Float32Array(4);
function UniformMat2(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix2_default();
  this._gl = gl;
  this._location = location2;
}
UniformMat2.prototype.set = function() {
  if (!Matrix2_default.equalsArray(this.value, this._value, 0)) {
    Matrix2_default.clone(this.value, this._value);
    const array = Matrix2_default.toArray(this.value, scratchUniformArray);
    this._gl.uniformMatrix2fv(this._location, false, array);
  }
};
var scratchMat3Array = new Float32Array(9);
function UniformMat3(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix3_default();
  this._gl = gl;
  this._location = location2;
}
UniformMat3.prototype.set = function() {
  if (!Matrix3_default.equalsArray(this.value, this._value, 0)) {
    Matrix3_default.clone(this.value, this._value);
    const array = Matrix3_default.toArray(this.value, scratchMat3Array);
    this._gl.uniformMatrix3fv(this._location, false, array);
  }
};
var scratchMat4Array = new Float32Array(16);
function UniformMat4(gl, activeUniform, uniformName, location2) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix4_default();
  this._gl = gl;
  this._location = location2;
}
UniformMat4.prototype.set = function() {
  if (!Matrix4_default.equalsArray(this.value, this._value, 0)) {
    Matrix4_default.clone(this.value, this._value);
    const array = Matrix4_default.toArray(this.value, scratchMat4Array);
    this._gl.uniformMatrix4fv(this._location, false, array);
  }
};
var createUniform_default = createUniform;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/createUniformArray.js
function createUniformArray(gl, activeUniform, uniformName, locations) {
  switch (activeUniform.type) {
    case gl.FLOAT:
      return new UniformArrayFloat(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_VEC2:
      return new UniformArrayFloatVec2(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.FLOAT_VEC3:
      return new UniformArrayFloatVec3(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.FLOAT_VEC4:
      return new UniformArrayFloatVec4(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
      return new UniformArraySampler(gl, activeUniform, uniformName, locations);
    case gl.INT:
    case gl.BOOL:
      return new UniformArrayInt(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
      return new UniformArrayIntVec2(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
      return new UniformArrayIntVec3(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
      return new UniformArrayIntVec4(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT2:
      return new UniformArrayMat2(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT3:
      return new UniformArrayMat3(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT4:
      return new UniformArrayMat4(gl, activeUniform, uniformName, locations);
    default:
      throw new RuntimeError_default(
        `Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`
      );
  }
}
function UniformArrayFloat(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloat.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (v3 !== arraybuffer[i]) {
      arraybuffer[i] = v3;
      changed = true;
    }
  }
  if (changed) {
    this._gl.uniform1fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 2);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (!Cartesian2_default.equalsArray(v3, arraybuffer, j)) {
      Cartesian2_default.pack(v3, arraybuffer, j);
      changed = true;
    }
    j += 2;
  }
  if (changed) {
    this._gl.uniform2fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 3);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (defined_default(v3.red)) {
      if (v3.red !== arraybuffer[j] || v3.green !== arraybuffer[j + 1] || v3.blue !== arraybuffer[j + 2]) {
        arraybuffer[j] = v3.red;
        arraybuffer[j + 1] = v3.green;
        arraybuffer[j + 2] = v3.blue;
        changed = true;
      }
    } else if (defined_default(v3.x)) {
      if (!Cartesian3_default.equalsArray(v3, arraybuffer, j)) {
        Cartesian3_default.pack(v3, arraybuffer, j);
        changed = true;
      }
    } else {
      throw new DeveloperError_default("Invalid vec3 value.");
    }
    j += 3;
  }
  if (changed) {
    this._gl.uniform3fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (defined_default(v3.red)) {
      if (!Color_default.equalsArray(v3, arraybuffer, j)) {
        Color_default.pack(v3, arraybuffer, j);
        changed = true;
      }
    } else if (defined_default(v3.x)) {
      if (!Cartesian4_default.equalsArray(v3, arraybuffer, j)) {
        Cartesian4_default.pack(v3, arraybuffer, j);
        changed = true;
      }
    } else {
      throw new DeveloperError_default("Invalid vec4 value.");
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniform4fv(this._location, arraybuffer);
  }
};
function UniformArraySampler(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length);
  this._gl = gl;
  this._locations = locations;
  this.textureUnitIndex = void 0;
}
UniformArraySampler.prototype.set = function() {
  const gl = this._gl;
  const textureUnitIndex = gl.TEXTURE0 + this.textureUnitIndex;
  const value = this.value;
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    gl.activeTexture(textureUnitIndex + i);
    gl.bindTexture(v3._target, v3._texture);
  }
};
UniformArraySampler.prototype._setSampler = function(textureUnitIndex) {
  this.textureUnitIndex = textureUnitIndex;
  const locations = this._locations;
  const length = locations.length;
  for (let i = 0; i < length; ++i) {
    const index = textureUnitIndex + i;
    this._gl.uniform1i(locations[i], index);
  }
  return textureUnitIndex + length;
};
function UniformArrayInt(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayInt.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (v3 !== arraybuffer[i]) {
      arraybuffer[i] = v3;
      changed = true;
    }
  }
  if (changed) {
    this._gl.uniform1iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 2);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (!Cartesian2_default.equalsArray(v3, arraybuffer, j)) {
      Cartesian2_default.pack(v3, arraybuffer, j);
      changed = true;
    }
    j += 2;
  }
  if (changed) {
    this._gl.uniform2iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 3);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (!Cartesian3_default.equalsArray(v3, arraybuffer, j)) {
      Cartesian3_default.pack(v3, arraybuffer, j);
      changed = true;
    }
    j += 3;
  }
  if (changed) {
    this._gl.uniform3iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (!Cartesian4_default.equalsArray(v3, arraybuffer, j)) {
      Cartesian4_default.pack(v3, arraybuffer, j);
      changed = true;
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniform4iv(this._location, arraybuffer);
  }
};
function UniformArrayMat2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (!Matrix2_default.equalsArray(v3, arraybuffer, j)) {
      Matrix2_default.pack(v3, arraybuffer, j);
      changed = true;
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniformMatrix2fv(this._location, false, arraybuffer);
  }
};
function UniformArrayMat3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 9);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (!Matrix3_default.equalsArray(v3, arraybuffer, j)) {
      Matrix3_default.pack(v3, arraybuffer, j);
      changed = true;
    }
    j += 9;
  }
  if (changed) {
    this._gl.uniformMatrix3fv(this._location, false, arraybuffer);
  }
};
function UniformArrayMat4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 16);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v3 = value[i];
    if (!Matrix4_default.equalsArray(v3, arraybuffer, j)) {
      Matrix4_default.pack(v3, arraybuffer, j);
      changed = true;
    }
    j += 16;
  }
  if (changed) {
    this._gl.uniformMatrix4fv(this._location, false, arraybuffer);
  }
};
var createUniformArray_default = createUniformArray;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/ShaderProgram.js
var nextShaderProgramId = 0;
function ShaderProgram(options) {
  let vertexShaderText = options.vertexShaderText;
  let fragmentShaderText = options.fragmentShaderText;
  if (typeof spector !== "undefined") {
    vertexShaderText = vertexShaderText.replace(/^#line/gm, "//#line");
    fragmentShaderText = fragmentShaderText.replace(/^#line/gm, "//#line");
  }
  const modifiedFS = handleUniformPrecisionMismatches(
    vertexShaderText,
    fragmentShaderText
  );
  this._gl = options.gl;
  this._logShaderCompilation = options.logShaderCompilation;
  this._debugShaders = options.debugShaders;
  this._attributeLocations = options.attributeLocations;
  this._program = void 0;
  this._numberOfVertexAttributes = void 0;
  this._vertexAttributes = void 0;
  this._uniformsByName = void 0;
  this._uniforms = void 0;
  this._automaticUniforms = void 0;
  this._manualUniforms = void 0;
  this._duplicateUniformNames = modifiedFS.duplicateUniformNames;
  this._cachedShader = void 0;
  this.maximumTextureUnitIndex = void 0;
  this._vertexShaderSource = options.vertexShaderSource;
  this._vertexShaderText = options.vertexShaderText;
  this._fragmentShaderSource = options.fragmentShaderSource;
  this._fragmentShaderText = modifiedFS.fragmentShaderText;
  this.id = nextShaderProgramId++;
}
ShaderProgram.fromCache = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  return options.context.shaderCache.getShaderProgram(options);
};
ShaderProgram.replaceCache = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  return options.context.shaderCache.replaceShaderProgram(options);
};
Object.defineProperties(ShaderProgram.prototype, {
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  vertexAttributes: {
    get: function() {
      initialize2(this);
      return this._vertexAttributes;
    }
  },
  numberOfVertexAttributes: {
    get: function() {
      initialize2(this);
      return this._numberOfVertexAttributes;
    }
  },
  allUniforms: {
    get: function() {
      initialize2(this);
      return this._uniformsByName;
    }
  }
});
function extractUniforms(shaderText) {
  const uniformNames = [];
  const uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);
  if (defined_default(uniformLines)) {
    const len = uniformLines.length;
    for (let i = 0; i < len; i++) {
      const line = uniformLines[i].trim();
      const name = line.slice(line.lastIndexOf(" ") + 1);
      uniformNames.push(name);
    }
  }
  return uniformNames;
}
function handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText) {
  const duplicateUniformNames = {};
  if (!ContextLimits_default.highpFloatSupported || !ContextLimits_default.highpIntSupported) {
    let i, j;
    let uniformName;
    let duplicateName;
    const vertexShaderUniforms = extractUniforms(vertexShaderText);
    const fragmentShaderUniforms = extractUniforms(fragmentShaderText);
    const vertexUniformsCount = vertexShaderUniforms.length;
    const fragmentUniformsCount = fragmentShaderUniforms.length;
    for (i = 0; i < vertexUniformsCount; i++) {
      for (j = 0; j < fragmentUniformsCount; j++) {
        if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {
          uniformName = vertexShaderUniforms[i];
          duplicateName = `czm_mediump_${uniformName}`;
          const re = new RegExp(`${uniformName}\\b`, "g");
          fragmentShaderText = fragmentShaderText.replace(re, duplicateName);
          duplicateUniformNames[duplicateName] = uniformName;
        }
      }
    }
  }
  return {
    fragmentShaderText,
    duplicateUniformNames
  };
}
var consolePrefix = "[Cesium WebGL] ";
function createAndLinkProgram(gl, shader) {
  const vsSource = shader._vertexShaderText;
  const fsSource = shader._fragmentShaderText;
  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vsSource);
  gl.compileShader(vertexShader);
  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fsSource);
  gl.compileShader(fragmentShader);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  const attributeLocations = shader._attributeLocations;
  if (defined_default(attributeLocations)) {
    for (const attribute in attributeLocations) {
      if (attributeLocations.hasOwnProperty(attribute)) {
        gl.bindAttribLocation(
          program,
          attributeLocations[attribute],
          attribute
        );
      }
    }
  }
  gl.linkProgram(program);
  let log;
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (shader._logShaderCompilation) {
      log = gl.getShaderInfoLog(vertexShader);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Vertex shader compile log: ${log}`);
      }
      log = gl.getShaderInfoLog(fragmentShader);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Fragment shader compile log: ${log}`);
      }
      log = gl.getProgramInfoLog(program);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Shader program link log: ${log}`);
      }
    }
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    return program;
  }
  let errorMessage;
  const debugShaders = shader._debugShaders;
  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    log = gl.getShaderInfoLog(fragmentShader);
    console.error(`${consolePrefix}Fragment shader compile log: ${log}`);
    console.error(`${consolePrefix} Fragment shader source:
${fsSource}`);
    errorMessage = `Fragment shader failed to compile.  Compile log: ${log}`;
  } else if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    log = gl.getShaderInfoLog(vertexShader);
    console.error(`${consolePrefix}Vertex shader compile log: ${log}`);
    console.error(`${consolePrefix} Vertex shader source:
${vsSource}`);
    errorMessage = `Vertex shader failed to compile.  Compile log: ${log}`;
  } else {
    log = gl.getProgramInfoLog(program);
    console.error(`${consolePrefix}Shader program link log: ${log}`);
    logTranslatedSource(vertexShader, "vertex");
    logTranslatedSource(fragmentShader, "fragment");
    errorMessage = `Program failed to link.  Link log: ${log}`;
  }
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  gl.deleteProgram(program);
  throw new RuntimeError_default(errorMessage);
  function logTranslatedSource(compiledShader, name) {
    if (!defined_default(debugShaders)) {
      return;
    }
    const translation = debugShaders.getTranslatedShaderSource(compiledShader);
    if (translation === "") {
      console.error(`${consolePrefix}${name} shader translation failed.`);
      return;
    }
    console.error(
      `${consolePrefix}Translated ${name} shaderSource:
${translation}`
    );
  }
}
function findVertexAttributes(gl, program, numberOfAttributes) {
  const attributes = {};
  for (let i = 0; i < numberOfAttributes; ++i) {
    const attr = gl.getActiveAttrib(program, i);
    const location2 = gl.getAttribLocation(program, attr.name);
    attributes[attr.name] = {
      name: attr.name,
      type: attr.type,
      index: location2
    };
  }
  return attributes;
}
function findUniforms(gl, program) {
  const uniformsByName = {};
  const uniforms = [];
  const samplerUniforms = [];
  const numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < numberOfUniforms; ++i) {
    const activeUniform = gl.getActiveUniform(program, i);
    const suffix = "[0]";
    const uniformName = activeUniform.name.indexOf(
      suffix,
      activeUniform.name.length - suffix.length
    ) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;
    if (uniformName.indexOf("gl_") !== 0) {
      if (activeUniform.name.indexOf("[") < 0) {
        const location2 = gl.getUniformLocation(program, uniformName);
        if (location2 !== null) {
          const uniform = createUniform_default(
            gl,
            activeUniform,
            uniformName,
            location2
          );
          uniformsByName[uniformName] = uniform;
          uniforms.push(uniform);
          if (uniform._setSampler) {
            samplerUniforms.push(uniform);
          }
        }
      } else {
        let uniformArray;
        let locations;
        let value;
        let loc;
        const indexOfBracket = uniformName.indexOf("[");
        if (indexOfBracket >= 0) {
          uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];
          if (!defined_default(uniformArray)) {
            continue;
          }
          locations = uniformArray._locations;
          if (locations.length <= 1) {
            value = uniformArray.value;
            loc = gl.getUniformLocation(program, uniformName);
            if (loc !== null) {
              locations.push(loc);
              value.push(gl.getUniform(program, loc));
            }
          }
        } else {
          locations = [];
          for (let j = 0; j < activeUniform.size; ++j) {
            loc = gl.getUniformLocation(program, `${uniformName}[${j}]`);
            if (loc !== null) {
              locations.push(loc);
            }
          }
          uniformArray = createUniformArray_default(
            gl,
            activeUniform,
            uniformName,
            locations
          );
          uniformsByName[uniformName] = uniformArray;
          uniforms.push(uniformArray);
          if (uniformArray._setSampler) {
            samplerUniforms.push(uniformArray);
          }
        }
      }
    }
  }
  return {
    uniformsByName,
    uniforms,
    samplerUniforms
  };
}
function partitionUniforms(shader, uniforms) {
  const automaticUniforms = [];
  const manualUniforms = [];
  for (const uniform in uniforms) {
    if (uniforms.hasOwnProperty(uniform)) {
      const uniformObject = uniforms[uniform];
      let uniformName = uniform;
      const duplicateUniform = shader._duplicateUniformNames[uniformName];
      if (defined_default(duplicateUniform)) {
        uniformObject.name = duplicateUniform;
        uniformName = duplicateUniform;
      }
      const automaticUniform = AutomaticUniforms_default[uniformName];
      if (defined_default(automaticUniform)) {
        automaticUniforms.push({
          uniform: uniformObject,
          automaticUniform
        });
      } else {
        manualUniforms.push(uniformObject);
      }
    }
  }
  return {
    automaticUniforms,
    manualUniforms
  };
}
function setSamplerUniforms(gl, program, samplerUniforms) {
  gl.useProgram(program);
  let textureUnitIndex = 0;
  const length = samplerUniforms.length;
  for (let i = 0; i < length; ++i) {
    textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);
  }
  gl.useProgram(null);
  return textureUnitIndex;
}
function initialize2(shader) {
  if (defined_default(shader._program)) {
    return;
  }
  reinitialize(shader);
}
function reinitialize(shader) {
  const oldProgram = shader._program;
  const gl = shader._gl;
  const program = createAndLinkProgram(gl, shader, shader._debugShaders);
  const numberOfVertexAttributes = gl.getProgramParameter(
    program,
    gl.ACTIVE_ATTRIBUTES
  );
  const uniforms = findUniforms(gl, program);
  const partitionedUniforms = partitionUniforms(
    shader,
    uniforms.uniformsByName
  );
  shader._program = program;
  shader._numberOfVertexAttributes = numberOfVertexAttributes;
  shader._vertexAttributes = findVertexAttributes(
    gl,
    program,
    numberOfVertexAttributes
  );
  shader._uniformsByName = uniforms.uniformsByName;
  shader._uniforms = uniforms.uniforms;
  shader._automaticUniforms = partitionedUniforms.automaticUniforms;
  shader._manualUniforms = partitionedUniforms.manualUniforms;
  shader.maximumTextureUnitIndex = setSamplerUniforms(
    gl,
    program,
    uniforms.samplerUniforms
  );
  if (oldProgram) {
    shader._gl.deleteProgram(oldProgram);
  }
  if (typeof spector !== "undefined") {
    shader._program.__SPECTOR_rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
      const originalVS = shader._vertexShaderText;
      const originalFS = shader._fragmentShaderText;
      const regex = / ! = /g;
      shader._vertexShaderText = vertexSourceCode.replace(regex, " != ");
      shader._fragmentShaderText = fragmentSourceCode.replace(regex, " != ");
      try {
        reinitialize(shader);
        onCompiled(shader._program);
      } catch (e) {
        shader._vertexShaderText = originalVS;
        shader._fragmentShaderText = originalFS;
        const errorMatcher = /(?:Compile|Link) error: ([^]*)/;
        const match = errorMatcher.exec(e.message);
        if (match) {
          onError(match[1]);
        } else {
          onError(e.message);
        }
      }
    };
  }
}
ShaderProgram.prototype._bind = function() {
  initialize2(this);
  this._gl.useProgram(this._program);
};
ShaderProgram.prototype._setUniforms = function(uniformMap, uniformState, validate) {
  let len;
  let i;
  if (defined_default(uniformMap)) {
    const manualUniforms = this._manualUniforms;
    len = manualUniforms.length;
    for (i = 0; i < len; ++i) {
      const mu = manualUniforms[i];
      mu.value = uniformMap[mu.name]();
    }
  }
  const automaticUniforms = this._automaticUniforms;
  len = automaticUniforms.length;
  for (i = 0; i < len; ++i) {
    const au = automaticUniforms[i];
    au.uniform.value = au.automaticUniform.getValue(uniformState);
  }
  const uniforms = this._uniforms;
  len = uniforms.length;
  for (i = 0; i < len; ++i) {
    uniforms[i].set();
  }
  if (validate) {
    const gl = this._gl;
    const program = this._program;
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
      throw new DeveloperError_default(
        `Program validation failed.  Program info log: ${gl.getProgramInfoLog(
          program
        )}`
      );
    }
  }
};
ShaderProgram.prototype.isDestroyed = function() {
  return false;
};
ShaderProgram.prototype.destroy = function() {
  this._cachedShader.cache.releaseShaderProgram(this);
  return void 0;
};
ShaderProgram.prototype.finalDestroy = function() {
  this._gl.deleteProgram(this._program);
  return destroyObject_default(this);
};
var ShaderProgram_default = ShaderProgram;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/clone.js
function clone(object, deep) {
  if (object === null || typeof object !== "object") {
    return object;
  }
  deep = defaultValue_default(deep, false);
  const result = new object.constructor();
  for (const propertyName in object) {
    if (object.hasOwnProperty(propertyName)) {
      let value = object[propertyName];
      if (deep) {
        value = clone(value, deep);
      }
      result[propertyName] = value;
    }
  }
  return result;
}
var clone_default = clone;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/ComponentDatatype.js
var ComponentDatatype = {
  BYTE: WebGLConstants_default.BYTE,
  UNSIGNED_BYTE: WebGLConstants_default.UNSIGNED_BYTE,
  SHORT: WebGLConstants_default.SHORT,
  UNSIGNED_SHORT: WebGLConstants_default.UNSIGNED_SHORT,
  INT: WebGLConstants_default.INT,
  UNSIGNED_INT: WebGLConstants_default.UNSIGNED_INT,
  FLOAT: WebGLConstants_default.FLOAT,
  DOUBLE: WebGLConstants_default.DOUBLE
};
ComponentDatatype.getSizeInBytes = function(componentDatatype) {
  if (!defined_default(componentDatatype)) {
    throw new DeveloperError_default("value is required.");
  }
  switch (componentDatatype) {
    case ComponentDatatype.BYTE:
      return Int8Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.SHORT:
      return Int16Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.INT:
      return Int32Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.FLOAT:
      return Float32Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.DOUBLE:
      return Float64Array.BYTES_PER_ELEMENT;
    default:
      throw new DeveloperError_default("componentDatatype is not a valid value.");
  }
};
ComponentDatatype.fromTypedArray = function(array) {
  if (array instanceof Int8Array) {
    return ComponentDatatype.BYTE;
  }
  if (array instanceof Uint8Array) {
    return ComponentDatatype.UNSIGNED_BYTE;
  }
  if (array instanceof Int16Array) {
    return ComponentDatatype.SHORT;
  }
  if (array instanceof Uint16Array) {
    return ComponentDatatype.UNSIGNED_SHORT;
  }
  if (array instanceof Int32Array) {
    return ComponentDatatype.INT;
  }
  if (array instanceof Uint32Array) {
    return ComponentDatatype.UNSIGNED_INT;
  }
  if (array instanceof Float32Array) {
    return ComponentDatatype.FLOAT;
  }
  if (array instanceof Float64Array) {
    return ComponentDatatype.DOUBLE;
  }
  throw new DeveloperError_default(
    "array must be an Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, or Float64Array."
  );
};
ComponentDatatype.validate = function(componentDatatype) {
  return defined_default(componentDatatype) && (componentDatatype === ComponentDatatype.BYTE || componentDatatype === ComponentDatatype.UNSIGNED_BYTE || componentDatatype === ComponentDatatype.SHORT || componentDatatype === ComponentDatatype.UNSIGNED_SHORT || componentDatatype === ComponentDatatype.INT || componentDatatype === ComponentDatatype.UNSIGNED_INT || componentDatatype === ComponentDatatype.FLOAT || componentDatatype === ComponentDatatype.DOUBLE);
};
ComponentDatatype.createTypedArray = function(componentDatatype, valuesOrLength) {
  if (!defined_default(componentDatatype)) {
    throw new DeveloperError_default("componentDatatype is required.");
  }
  if (!defined_default(valuesOrLength)) {
    throw new DeveloperError_default("valuesOrLength is required.");
  }
  switch (componentDatatype) {
    case ComponentDatatype.BYTE:
      return new Int8Array(valuesOrLength);
    case ComponentDatatype.UNSIGNED_BYTE:
      return new Uint8Array(valuesOrLength);
    case ComponentDatatype.SHORT:
      return new Int16Array(valuesOrLength);
    case ComponentDatatype.UNSIGNED_SHORT:
      return new Uint16Array(valuesOrLength);
    case ComponentDatatype.INT:
      return new Int32Array(valuesOrLength);
    case ComponentDatatype.UNSIGNED_INT:
      return new Uint32Array(valuesOrLength);
    case ComponentDatatype.FLOAT:
      return new Float32Array(valuesOrLength);
    case ComponentDatatype.DOUBLE:
      return new Float64Array(valuesOrLength);
    default:
      throw new DeveloperError_default("componentDatatype is not a valid value.");
  }
};
ComponentDatatype.createArrayBufferView = function(componentDatatype, buffer, byteOffset, length) {
  if (!defined_default(componentDatatype)) {
    throw new DeveloperError_default("componentDatatype is required.");
  }
  if (!defined_default(buffer)) {
    throw new DeveloperError_default("buffer is required.");
  }
  byteOffset = defaultValue_default(byteOffset, 0);
  length = defaultValue_default(
    length,
    (buffer.byteLength - byteOffset) / ComponentDatatype.getSizeInBytes(componentDatatype)
  );
  switch (componentDatatype) {
    case ComponentDatatype.BYTE:
      return new Int8Array(buffer, byteOffset, length);
    case ComponentDatatype.UNSIGNED_BYTE:
      return new Uint8Array(buffer, byteOffset, length);
    case ComponentDatatype.SHORT:
      return new Int16Array(buffer, byteOffset, length);
    case ComponentDatatype.UNSIGNED_SHORT:
      return new Uint16Array(buffer, byteOffset, length);
    case ComponentDatatype.INT:
      return new Int32Array(buffer, byteOffset, length);
    case ComponentDatatype.UNSIGNED_INT:
      return new Uint32Array(buffer, byteOffset, length);
    case ComponentDatatype.FLOAT:
      return new Float32Array(buffer, byteOffset, length);
    case ComponentDatatype.DOUBLE:
      return new Float64Array(buffer, byteOffset, length);
    default:
      throw new DeveloperError_default("componentDatatype is not a valid value.");
  }
};
ComponentDatatype.fromName = function(name) {
  switch (name) {
    case "BYTE":
      return ComponentDatatype.BYTE;
    case "UNSIGNED_BYTE":
      return ComponentDatatype.UNSIGNED_BYTE;
    case "SHORT":
      return ComponentDatatype.SHORT;
    case "UNSIGNED_SHORT":
      return ComponentDatatype.UNSIGNED_SHORT;
    case "INT":
      return ComponentDatatype.INT;
    case "UNSIGNED_INT":
      return ComponentDatatype.UNSIGNED_INT;
    case "FLOAT":
      return ComponentDatatype.FLOAT;
    case "DOUBLE":
      return ComponentDatatype.DOUBLE;
    default:
      throw new DeveloperError_default("name is not a valid value.");
  }
};
var ComponentDatatype_default = Object.freeze(ComponentDatatype);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeometryType.js
var GeometryType = {
  NONE: 0,
  TRIANGLES: 1,
  LINES: 2,
  POLYLINES: 3
};
var GeometryType_default = Object.freeze(GeometryType);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Quaternion.js
function Quaternion(x, y, z, w) {
  this.x = defaultValue_default(x, 0);
  this.y = defaultValue_default(y, 0);
  this.z = defaultValue_default(z, 0);
  this.w = defaultValue_default(w, 0);
}
var fromAxisAngleScratch = new Cartesian3_default();
Quaternion.fromAxisAngle = function(axis, angle, result) {
  Check_default.typeOf.object("axis", axis);
  Check_default.typeOf.number("angle", angle);
  const halfAngle = angle / 2;
  const s = Math.sin(halfAngle);
  fromAxisAngleScratch = Cartesian3_default.normalize(axis, fromAxisAngleScratch);
  const x = fromAxisAngleScratch.x * s;
  const y = fromAxisAngleScratch.y * s;
  const z = fromAxisAngleScratch.z * s;
  const w = Math.cos(halfAngle);
  if (!defined_default(result)) {
    return new Quaternion(x, y, z, w);
  }
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
var fromRotationMatrixNext = [1, 2, 0];
var fromRotationMatrixQuat = new Array(3);
Quaternion.fromRotationMatrix = function(matrix, result) {
  Check_default.typeOf.object("matrix", matrix);
  let root;
  let x;
  let y;
  let z;
  let w;
  const m00 = matrix[Matrix3_default.COLUMN0ROW0];
  const m11 = matrix[Matrix3_default.COLUMN1ROW1];
  const m22 = matrix[Matrix3_default.COLUMN2ROW2];
  const trace = m00 + m11 + m22;
  if (trace > 0) {
    root = Math.sqrt(trace + 1);
    w = 0.5 * root;
    root = 0.5 / root;
    x = (matrix[Matrix3_default.COLUMN1ROW2] - matrix[Matrix3_default.COLUMN2ROW1]) * root;
    y = (matrix[Matrix3_default.COLUMN2ROW0] - matrix[Matrix3_default.COLUMN0ROW2]) * root;
    z = (matrix[Matrix3_default.COLUMN0ROW1] - matrix[Matrix3_default.COLUMN1ROW0]) * root;
  } else {
    const next = fromRotationMatrixNext;
    let i = 0;
    if (m11 > m00) {
      i = 1;
    }
    if (m22 > m00 && m22 > m11) {
      i = 2;
    }
    const j = next[i];
    const k = next[j];
    root = Math.sqrt(
      matrix[Matrix3_default.getElementIndex(i, i)] - matrix[Matrix3_default.getElementIndex(j, j)] - matrix[Matrix3_default.getElementIndex(k, k)] + 1
    );
    const quat = fromRotationMatrixQuat;
    quat[i] = 0.5 * root;
    root = 0.5 / root;
    w = (matrix[Matrix3_default.getElementIndex(k, j)] - matrix[Matrix3_default.getElementIndex(j, k)]) * root;
    quat[j] = (matrix[Matrix3_default.getElementIndex(j, i)] + matrix[Matrix3_default.getElementIndex(i, j)]) * root;
    quat[k] = (matrix[Matrix3_default.getElementIndex(k, i)] + matrix[Matrix3_default.getElementIndex(i, k)]) * root;
    x = -quat[0];
    y = -quat[1];
    z = -quat[2];
  }
  if (!defined_default(result)) {
    return new Quaternion(x, y, z, w);
  }
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
var scratchHPRQuaternion = new Quaternion();
var scratchHeadingQuaternion = new Quaternion();
var scratchPitchQuaternion = new Quaternion();
var scratchRollQuaternion = new Quaternion();
Quaternion.fromHeadingPitchRoll = function(headingPitchRoll, result) {
  Check_default.typeOf.object("headingPitchRoll", headingPitchRoll);
  scratchRollQuaternion = Quaternion.fromAxisAngle(
    Cartesian3_default.UNIT_X,
    headingPitchRoll.roll,
    scratchHPRQuaternion
  );
  scratchPitchQuaternion = Quaternion.fromAxisAngle(
    Cartesian3_default.UNIT_Y,
    -headingPitchRoll.pitch,
    result
  );
  result = Quaternion.multiply(
    scratchPitchQuaternion,
    scratchRollQuaternion,
    scratchPitchQuaternion
  );
  scratchHeadingQuaternion = Quaternion.fromAxisAngle(
    Cartesian3_default.UNIT_Z,
    -headingPitchRoll.heading,
    scratchHPRQuaternion
  );
  return Quaternion.multiply(scratchHeadingQuaternion, result, result);
};
var sampledQuaternionAxis = new Cartesian3_default();
var sampledQuaternionRotation = new Cartesian3_default();
var sampledQuaternionTempQuaternion = new Quaternion();
var sampledQuaternionQuaternion0 = new Quaternion();
var sampledQuaternionQuaternion0Conjugate = new Quaternion();
Quaternion.packedLength = 4;
Quaternion.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.x;
  array[startingIndex++] = value.y;
  array[startingIndex++] = value.z;
  array[startingIndex] = value.w;
  return array;
};
Quaternion.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new Quaternion();
  }
  result.x = array[startingIndex];
  result.y = array[startingIndex + 1];
  result.z = array[startingIndex + 2];
  result.w = array[startingIndex + 3];
  return result;
};
Quaternion.packedInterpolationLength = 3;
Quaternion.convertPackedArrayForInterpolation = function(packedArray, startingIndex, lastIndex, result) {
  Quaternion.unpack(
    packedArray,
    lastIndex * 4,
    sampledQuaternionQuaternion0Conjugate
  );
  Quaternion.conjugate(
    sampledQuaternionQuaternion0Conjugate,
    sampledQuaternionQuaternion0Conjugate
  );
  for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {
    const offset = i * 3;
    Quaternion.unpack(
      packedArray,
      (startingIndex + i) * 4,
      sampledQuaternionTempQuaternion
    );
    Quaternion.multiply(
      sampledQuaternionTempQuaternion,
      sampledQuaternionQuaternion0Conjugate,
      sampledQuaternionTempQuaternion
    );
    if (sampledQuaternionTempQuaternion.w < 0) {
      Quaternion.negate(
        sampledQuaternionTempQuaternion,
        sampledQuaternionTempQuaternion
      );
    }
    Quaternion.computeAxis(
      sampledQuaternionTempQuaternion,
      sampledQuaternionAxis
    );
    const angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);
    if (!defined_default(result)) {
      result = [];
    }
    result[offset] = sampledQuaternionAxis.x * angle;
    result[offset + 1] = sampledQuaternionAxis.y * angle;
    result[offset + 2] = sampledQuaternionAxis.z * angle;
  }
};
Quaternion.unpackInterpolationResult = function(array, sourceArray, firstIndex, lastIndex, result) {
  if (!defined_default(result)) {
    result = new Quaternion();
  }
  Cartesian3_default.fromArray(array, 0, sampledQuaternionRotation);
  const magnitude = Cartesian3_default.magnitude(sampledQuaternionRotation);
  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);
  if (magnitude === 0) {
    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);
  } else {
    Quaternion.fromAxisAngle(
      sampledQuaternionRotation,
      magnitude,
      sampledQuaternionTempQuaternion
    );
  }
  return Quaternion.multiply(
    sampledQuaternionTempQuaternion,
    sampledQuaternionQuaternion0,
    result
  );
};
Quaternion.clone = function(quaternion, result) {
  if (!defined_default(quaternion)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Quaternion(
      quaternion.x,
      quaternion.y,
      quaternion.z,
      quaternion.w
    );
  }
  result.x = quaternion.x;
  result.y = quaternion.y;
  result.z = quaternion.z;
  result.w = quaternion.w;
  return result;
};
Quaternion.conjugate = function(quaternion, result) {
  Check_default.typeOf.object("quaternion", quaternion);
  Check_default.typeOf.object("result", result);
  result.x = -quaternion.x;
  result.y = -quaternion.y;
  result.z = -quaternion.z;
  result.w = quaternion.w;
  return result;
};
Quaternion.magnitudeSquared = function(quaternion) {
  Check_default.typeOf.object("quaternion", quaternion);
  return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
};
Quaternion.magnitude = function(quaternion) {
  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
};
Quaternion.normalize = function(quaternion, result) {
  Check_default.typeOf.object("result", result);
  const inverseMagnitude = 1 / Quaternion.magnitude(quaternion);
  const x = quaternion.x * inverseMagnitude;
  const y = quaternion.y * inverseMagnitude;
  const z = quaternion.z * inverseMagnitude;
  const w = quaternion.w * inverseMagnitude;
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
Quaternion.inverse = function(quaternion, result) {
  Check_default.typeOf.object("result", result);
  const magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
  result = Quaternion.conjugate(quaternion, result);
  return Quaternion.multiplyByScalar(result, 1 / magnitudeSquared, result);
};
Quaternion.add = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x + right.x;
  result.y = left.y + right.y;
  result.z = left.z + right.z;
  result.w = left.w + right.w;
  return result;
};
Quaternion.subtract = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  result.x = left.x - right.x;
  result.y = left.y - right.y;
  result.z = left.z - right.z;
  result.w = left.w - right.w;
  return result;
};
Quaternion.negate = function(quaternion, result) {
  Check_default.typeOf.object("quaternion", quaternion);
  Check_default.typeOf.object("result", result);
  result.x = -quaternion.x;
  result.y = -quaternion.y;
  result.z = -quaternion.z;
  result.w = -quaternion.w;
  return result;
};
Quaternion.dot = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
};
Quaternion.multiply = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  Check_default.typeOf.object("result", result);
  const leftX = left.x;
  const leftY = left.y;
  const leftZ = left.z;
  const leftW = left.w;
  const rightX = right.x;
  const rightY = right.y;
  const rightZ = right.z;
  const rightW = right.w;
  const x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
  const y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
  const z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
  const w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;
  result.x = x;
  result.y = y;
  result.z = z;
  result.w = w;
  return result;
};
Quaternion.multiplyByScalar = function(quaternion, scalar, result) {
  Check_default.typeOf.object("quaternion", quaternion);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = quaternion.x * scalar;
  result.y = quaternion.y * scalar;
  result.z = quaternion.z * scalar;
  result.w = quaternion.w * scalar;
  return result;
};
Quaternion.divideByScalar = function(quaternion, scalar, result) {
  Check_default.typeOf.object("quaternion", quaternion);
  Check_default.typeOf.number("scalar", scalar);
  Check_default.typeOf.object("result", result);
  result.x = quaternion.x / scalar;
  result.y = quaternion.y / scalar;
  result.z = quaternion.z / scalar;
  result.w = quaternion.w / scalar;
  return result;
};
Quaternion.computeAxis = function(quaternion, result) {
  Check_default.typeOf.object("quaternion", quaternion);
  Check_default.typeOf.object("result", result);
  const w = quaternion.w;
  if (Math.abs(w - 1) < Math_default.EPSILON6) {
    result.x = result.y = result.z = 0;
    return result;
  }
  const scalar = 1 / Math.sqrt(1 - w * w);
  result.x = quaternion.x * scalar;
  result.y = quaternion.y * scalar;
  result.z = quaternion.z * scalar;
  return result;
};
Quaternion.computeAngle = function(quaternion) {
  Check_default.typeOf.object("quaternion", quaternion);
  if (Math.abs(quaternion.w - 1) < Math_default.EPSILON6) {
    return 0;
  }
  return 2 * Math.acos(quaternion.w);
};
var lerpScratch4 = new Quaternion();
Quaternion.lerp = function(start, end, t, result) {
  Check_default.typeOf.object("start", start);
  Check_default.typeOf.object("end", end);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  lerpScratch4 = Quaternion.multiplyByScalar(end, t, lerpScratch4);
  result = Quaternion.multiplyByScalar(start, 1 - t, result);
  return Quaternion.add(lerpScratch4, result, result);
};
var slerpEndNegated = new Quaternion();
var slerpScaledP = new Quaternion();
var slerpScaledR = new Quaternion();
Quaternion.slerp = function(start, end, t, result) {
  Check_default.typeOf.object("start", start);
  Check_default.typeOf.object("end", end);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  let dot = Quaternion.dot(start, end);
  let r = end;
  if (dot < 0) {
    dot = -dot;
    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
  }
  if (1 - dot < Math_default.EPSILON6) {
    return Quaternion.lerp(start, r, t, result);
  }
  const theta = Math.acos(dot);
  slerpScaledP = Quaternion.multiplyByScalar(
    start,
    Math.sin((1 - t) * theta),
    slerpScaledP
  );
  slerpScaledR = Quaternion.multiplyByScalar(
    r,
    Math.sin(t * theta),
    slerpScaledR
  );
  result = Quaternion.add(slerpScaledP, slerpScaledR, result);
  return Quaternion.multiplyByScalar(result, 1 / Math.sin(theta), result);
};
Quaternion.log = function(quaternion, result) {
  Check_default.typeOf.object("quaternion", quaternion);
  Check_default.typeOf.object("result", result);
  const theta = Math_default.acosClamped(quaternion.w);
  let thetaOverSinTheta = 0;
  if (theta !== 0) {
    thetaOverSinTheta = theta / Math.sin(theta);
  }
  return Cartesian3_default.multiplyByScalar(quaternion, thetaOverSinTheta, result);
};
Quaternion.exp = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  Check_default.typeOf.object("result", result);
  const theta = Cartesian3_default.magnitude(cartesian);
  let sinThetaOverTheta = 0;
  if (theta !== 0) {
    sinThetaOverTheta = Math.sin(theta) / theta;
  }
  result.x = cartesian.x * sinThetaOverTheta;
  result.y = cartesian.y * sinThetaOverTheta;
  result.z = cartesian.z * sinThetaOverTheta;
  result.w = Math.cos(theta);
  return result;
};
var squadScratchCartesian0 = new Cartesian3_default();
var squadScratchCartesian1 = new Cartesian3_default();
var squadScratchQuaternion0 = new Quaternion();
var squadScratchQuaternion1 = new Quaternion();
Quaternion.computeInnerQuadrangle = function(q0, q12, q22, result) {
  Check_default.typeOf.object("q0", q0);
  Check_default.typeOf.object("q1", q12);
  Check_default.typeOf.object("q2", q22);
  Check_default.typeOf.object("result", result);
  const qInv = Quaternion.conjugate(q12, squadScratchQuaternion0);
  Quaternion.multiply(qInv, q22, squadScratchQuaternion1);
  const cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);
  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);
  const cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);
  Cartesian3_default.add(cart0, cart1, cart0);
  Cartesian3_default.multiplyByScalar(cart0, 0.25, cart0);
  Cartesian3_default.negate(cart0, cart0);
  Quaternion.exp(cart0, squadScratchQuaternion0);
  return Quaternion.multiply(q12, squadScratchQuaternion0, result);
};
Quaternion.squad = function(q0, q12, s0, s1, t, result) {
  Check_default.typeOf.object("q0", q0);
  Check_default.typeOf.object("q1", q12);
  Check_default.typeOf.object("s0", s0);
  Check_default.typeOf.object("s1", s1);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  const slerp0 = Quaternion.slerp(q0, q12, t, squadScratchQuaternion0);
  const slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);
  return Quaternion.slerp(slerp0, slerp1, 2 * t * (1 - t), result);
};
var fastSlerpScratchQuaternion = new Quaternion();
var opmu = 1.9011074535173003;
var u = FeatureDetection_default.supportsTypedArrays() ? new Float32Array(8) : [];
var v = FeatureDetection_default.supportsTypedArrays() ? new Float32Array(8) : [];
var bT = FeatureDetection_default.supportsTypedArrays() ? new Float32Array(8) : [];
var bD = FeatureDetection_default.supportsTypedArrays() ? new Float32Array(8) : [];
for (let i = 0; i < 7; ++i) {
  const s = i + 1;
  const t = 2 * s + 1;
  u[i] = 1 / (s * t);
  v[i] = s / t;
}
u[7] = opmu / (8 * 17);
v[7] = opmu * 8 / 17;
Quaternion.fastSlerp = function(start, end, t, result) {
  Check_default.typeOf.object("start", start);
  Check_default.typeOf.object("end", end);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  let x = Quaternion.dot(start, end);
  let sign2;
  if (x >= 0) {
    sign2 = 1;
  } else {
    sign2 = -1;
    x = -x;
  }
  const xm1 = x - 1;
  const d = 1 - t;
  const sqrT = t * t;
  const sqrD = d * d;
  for (let i = 7; i >= 0; --i) {
    bT[i] = (u[i] * sqrT - v[i]) * xm1;
    bD[i] = (u[i] * sqrD - v[i]) * xm1;
  }
  const cT = sign2 * t * (1 + bT[0] * (1 + bT[1] * (1 + bT[2] * (1 + bT[3] * (1 + bT[4] * (1 + bT[5] * (1 + bT[6] * (1 + bT[7]))))))));
  const cD = d * (1 + bD[0] * (1 + bD[1] * (1 + bD[2] * (1 + bD[3] * (1 + bD[4] * (1 + bD[5] * (1 + bD[6] * (1 + bD[7]))))))));
  const temp = Quaternion.multiplyByScalar(
    start,
    cD,
    fastSlerpScratchQuaternion
  );
  Quaternion.multiplyByScalar(end, cT, result);
  return Quaternion.add(temp, result, result);
};
Quaternion.fastSquad = function(q0, q12, s0, s1, t, result) {
  Check_default.typeOf.object("q0", q0);
  Check_default.typeOf.object("q1", q12);
  Check_default.typeOf.object("s0", s0);
  Check_default.typeOf.object("s1", s1);
  Check_default.typeOf.number("t", t);
  Check_default.typeOf.object("result", result);
  const slerp0 = Quaternion.fastSlerp(q0, q12, t, squadScratchQuaternion0);
  const slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);
  return Quaternion.fastSlerp(slerp0, slerp1, 2 * t * (1 - t), result);
};
Quaternion.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;
};
Quaternion.equalsEpsilon = function(left, right, epsilon) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && Math.abs(left.x - right.x) <= epsilon && Math.abs(left.y - right.y) <= epsilon && Math.abs(left.z - right.z) <= epsilon && Math.abs(left.w - right.w) <= epsilon;
};
Quaternion.ZERO = Object.freeze(new Quaternion(0, 0, 0, 0));
Quaternion.IDENTITY = Object.freeze(new Quaternion(0, 0, 0, 1));
Quaternion.prototype.clone = function(result) {
  return Quaternion.clone(this, result);
};
Quaternion.prototype.equals = function(right) {
  return Quaternion.equals(this, right);
};
Quaternion.prototype.equalsEpsilon = function(right, epsilon) {
  return Quaternion.equalsEpsilon(this, right, epsilon);
};
Quaternion.prototype.toString = function() {
  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;
};
var Quaternion_default = Quaternion;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/binarySearch.js
function binarySearch(array, itemToFind, comparator) {
  Check_default.defined("array", array);
  Check_default.defined("itemToFind", itemToFind);
  Check_default.defined("comparator", comparator);
  let low = 0;
  let high = array.length - 1;
  let i;
  let comparison;
  while (low <= high) {
    i = ~~((low + high) / 2);
    comparison = comparator(array[i], itemToFind);
    if (comparison < 0) {
      low = i + 1;
      continue;
    }
    if (comparison > 0) {
      high = i - 1;
      continue;
    }
    return i;
  }
  return ~(high + 1);
}
var binarySearch_default = binarySearch;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/EarthOrientationParametersSample.js
function EarthOrientationParametersSample(xPoleWander, yPoleWander, xPoleOffset, yPoleOffset, ut1MinusUtc) {
  this.xPoleWander = xPoleWander;
  this.yPoleWander = yPoleWander;
  this.xPoleOffset = xPoleOffset;
  this.yPoleOffset = yPoleOffset;
  this.ut1MinusUtc = ut1MinusUtc;
}
var EarthOrientationParametersSample_default = EarthOrientationParametersSample;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GregorianDate.js
function GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond) {
  this.year = year;
  this.month = month;
  this.day = day;
  this.hour = hour;
  this.minute = minute;
  this.second = second;
  this.millisecond = millisecond;
  this.isLeapSecond = isLeapSecond;
}
var GregorianDate_default = GregorianDate;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/isLeapYear.js
function isLeapYear(year) {
  if (year === null || isNaN(year)) {
    throw new DeveloperError_default("year is required and must be a number.");
  }
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
var isLeapYear_default = isLeapYear;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/LeapSecond.js
function LeapSecond(date, offset) {
  this.julianDate = date;
  this.offset = offset;
}
var LeapSecond_default = LeapSecond;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/TimeConstants.js
var TimeConstants = {
  SECONDS_PER_MILLISECOND: 1e-3,
  SECONDS_PER_MINUTE: 60,
  MINUTES_PER_HOUR: 60,
  HOURS_PER_DAY: 24,
  SECONDS_PER_HOUR: 3600,
  MINUTES_PER_DAY: 1440,
  SECONDS_PER_DAY: 86400,
  DAYS_PER_JULIAN_CENTURY: 36525,
  PICOSECOND: 1e-9,
  MODIFIED_JULIAN_DATE_DIFFERENCE: 24000005e-1
};
var TimeConstants_default = Object.freeze(TimeConstants);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/TimeStandard.js
var TimeStandard = {
  UTC: 0,
  TAI: 1
};
var TimeStandard_default = Object.freeze(TimeStandard);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/JulianDate.js
var gregorianDateScratch = new GregorianDate_default();
var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var daysInLeapFeburary = 29;
function compareLeapSecondDates(leapSecond, dateToFind) {
  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);
}
var binarySearchScratchLeapSecond = new LeapSecond_default();
function convertUtcToTai(julianDate) {
  binarySearchScratchLeapSecond.julianDate = julianDate;
  const leapSeconds = JulianDate.leapSeconds;
  let index = binarySearch_default(
    leapSeconds,
    binarySearchScratchLeapSecond,
    compareLeapSecondDates
  );
  if (index < 0) {
    index = ~index;
  }
  if (index >= leapSeconds.length) {
    index = leapSeconds.length - 1;
  }
  let offset = leapSeconds[index].offset;
  if (index > 0) {
    const difference = JulianDate.secondsDifference(
      leapSeconds[index].julianDate,
      julianDate
    );
    if (difference > offset) {
      index--;
      offset = leapSeconds[index].offset;
    }
  }
  JulianDate.addSeconds(julianDate, offset, julianDate);
}
function convertTaiToUtc(julianDate, result) {
  binarySearchScratchLeapSecond.julianDate = julianDate;
  const leapSeconds = JulianDate.leapSeconds;
  let index = binarySearch_default(
    leapSeconds,
    binarySearchScratchLeapSecond,
    compareLeapSecondDates
  );
  if (index < 0) {
    index = ~index;
  }
  if (index === 0) {
    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);
  }
  if (index >= leapSeconds.length) {
    return JulianDate.addSeconds(
      julianDate,
      -leapSeconds[index - 1].offset,
      result
    );
  }
  const difference = JulianDate.secondsDifference(
    leapSeconds[index].julianDate,
    julianDate
  );
  if (difference === 0) {
    return JulianDate.addSeconds(
      julianDate,
      -leapSeconds[index].offset,
      result
    );
  }
  if (difference <= 1) {
    return void 0;
  }
  return JulianDate.addSeconds(
    julianDate,
    -leapSeconds[--index].offset,
    result
  );
}
function setComponents(wholeDays, secondsOfDay, julianDate) {
  const extraDays = secondsOfDay / TimeConstants_default.SECONDS_PER_DAY | 0;
  wholeDays += extraDays;
  secondsOfDay -= TimeConstants_default.SECONDS_PER_DAY * extraDays;
  if (secondsOfDay < 0) {
    wholeDays--;
    secondsOfDay += TimeConstants_default.SECONDS_PER_DAY;
  }
  julianDate.dayNumber = wholeDays;
  julianDate.secondsOfDay = secondsOfDay;
  return julianDate;
}
function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
  const a3 = (month - 14) / 12 | 0;
  const b = year + 4800 + a3;
  let dayNumber = (1461 * b / 4 | 0) + (367 * (month - 2 - 12 * a3) / 12 | 0) - (3 * ((b + 100) / 100 | 0) / 4 | 0) + day - 32075;
  hour = hour - 12;
  if (hour < 0) {
    hour += 24;
  }
  const secondsOfDay = second + (hour * TimeConstants_default.SECONDS_PER_HOUR + minute * TimeConstants_default.SECONDS_PER_MINUTE + millisecond * TimeConstants_default.SECONDS_PER_MILLISECOND);
  if (secondsOfDay >= 43200) {
    dayNumber -= 1;
  }
  return [dayNumber, secondsOfDay];
}
var matchCalendarYear = /^(\d{4})$/;
var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
var iso8601ErrorMessage = "Invalid ISO 8601 date.";
function JulianDate(julianDayNumber, secondsOfDay, timeStandard) {
  this.dayNumber = void 0;
  this.secondsOfDay = void 0;
  julianDayNumber = defaultValue_default(julianDayNumber, 0);
  secondsOfDay = defaultValue_default(secondsOfDay, 0);
  timeStandard = defaultValue_default(timeStandard, TimeStandard_default.UTC);
  const wholeDays = julianDayNumber | 0;
  secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants_default.SECONDS_PER_DAY;
  setComponents(wholeDays, secondsOfDay, this);
  if (timeStandard === TimeStandard_default.UTC) {
    convertUtcToTai(this);
  }
}
JulianDate.fromGregorianDate = function(date, result) {
  if (!(date instanceof GregorianDate_default)) {
    throw new DeveloperError_default("date must be a valid GregorianDate.");
  }
  const components = computeJulianDateComponents(
    date.year,
    date.month,
    date.day,
    date.hour,
    date.minute,
    date.second,
    date.millisecond
  );
  if (!defined_default(result)) {
    return new JulianDate(components[0], components[1], TimeStandard_default.UTC);
  }
  setComponents(components[0], components[1], result);
  convertUtcToTai(result);
  return result;
};
JulianDate.fromDate = function(date, result) {
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    throw new DeveloperError_default("date must be a valid JavaScript Date.");
  }
  const components = computeJulianDateComponents(
    date.getUTCFullYear(),
    date.getUTCMonth() + 1,
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  );
  if (!defined_default(result)) {
    return new JulianDate(components[0], components[1], TimeStandard_default.UTC);
  }
  setComponents(components[0], components[1], result);
  convertUtcToTai(result);
  return result;
};
JulianDate.fromIso8601 = function(iso8601String, result) {
  if (typeof iso8601String !== "string") {
    throw new DeveloperError_default(iso8601ErrorMessage);
  }
  iso8601String = iso8601String.replace(",", ".");
  let tokens = iso8601String.split("T");
  let year;
  let month = 1;
  let day = 1;
  let hour = 0;
  let minute = 0;
  let second = 0;
  let millisecond = 0;
  const date = tokens[0];
  const time = tokens[1];
  let tmp2;
  let inLeapYear;
  if (!defined_default(date)) {
    throw new DeveloperError_default(iso8601ErrorMessage);
  }
  let dashCount;
  tokens = date.match(matchCalendarDate);
  if (tokens !== null) {
    dashCount = date.split("-").length - 1;
    if (dashCount > 0 && dashCount !== 2) {
      throw new DeveloperError_default(iso8601ErrorMessage);
    }
    year = +tokens[1];
    month = +tokens[2];
    day = +tokens[3];
  } else {
    tokens = date.match(matchCalendarMonth);
    if (tokens !== null) {
      year = +tokens[1];
      month = +tokens[2];
    } else {
      tokens = date.match(matchCalendarYear);
      if (tokens !== null) {
        year = +tokens[1];
      } else {
        let dayOfYear;
        tokens = date.match(matchOrdinalDate);
        if (tokens !== null) {
          year = +tokens[1];
          dayOfYear = +tokens[2];
          inLeapYear = isLeapYear_default(year);
          if (dayOfYear < 1 || inLeapYear && dayOfYear > 366 || !inLeapYear && dayOfYear > 365) {
            throw new DeveloperError_default(iso8601ErrorMessage);
          }
        } else {
          tokens = date.match(matchWeekDate);
          if (tokens !== null) {
            year = +tokens[1];
            const weekNumber = +tokens[2];
            const dayOfWeek = +tokens[3] || 0;
            dashCount = date.split("-").length - 1;
            if (dashCount > 0 && (!defined_default(tokens[3]) && dashCount !== 1 || defined_default(tokens[3]) && dashCount !== 2)) {
              throw new DeveloperError_default(iso8601ErrorMessage);
            }
            const january4 = new Date(Date.UTC(year, 0, 4));
            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;
          } else {
            throw new DeveloperError_default(iso8601ErrorMessage);
          }
        }
        tmp2 = new Date(Date.UTC(year, 0, 1));
        tmp2.setUTCDate(dayOfYear);
        month = tmp2.getUTCMonth() + 1;
        day = tmp2.getUTCDate();
      }
    }
  }
  inLeapYear = isLeapYear_default(year);
  if (month < 1 || month > 12 || day < 1 || (month !== 2 || !inLeapYear) && day > daysInMonth[month - 1] || inLeapYear && month === 2 && day > daysInLeapFeburary) {
    throw new DeveloperError_default(iso8601ErrorMessage);
  }
  let offsetIndex;
  if (defined_default(time)) {
    tokens = time.match(matchHoursMinutesSeconds);
    if (tokens !== null) {
      dashCount = time.split(":").length - 1;
      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {
        throw new DeveloperError_default(iso8601ErrorMessage);
      }
      hour = +tokens[1];
      minute = +tokens[2];
      second = +tokens[3];
      millisecond = +(tokens[4] || 0) * 1e3;
      offsetIndex = 5;
    } else {
      tokens = time.match(matchHoursMinutes);
      if (tokens !== null) {
        dashCount = time.split(":").length - 1;
        if (dashCount > 2) {
          throw new DeveloperError_default(iso8601ErrorMessage);
        }
        hour = +tokens[1];
        minute = +tokens[2];
        second = +(tokens[3] || 0) * 60;
        offsetIndex = 4;
      } else {
        tokens = time.match(matchHours);
        if (tokens !== null) {
          hour = +tokens[1];
          minute = +(tokens[2] || 0) * 60;
          offsetIndex = 3;
        } else {
          throw new DeveloperError_default(iso8601ErrorMessage);
        }
      }
    }
    if (minute >= 60 || second >= 61 || hour > 24 || hour === 24 && (minute > 0 || second > 0 || millisecond > 0)) {
      throw new DeveloperError_default(iso8601ErrorMessage);
    }
    const offset = tokens[offsetIndex];
    const offsetHours = +tokens[offsetIndex + 1];
    const offsetMinutes = +(tokens[offsetIndex + 2] || 0);
    switch (offset) {
      case "+":
        hour = hour - offsetHours;
        minute = minute - offsetMinutes;
        break;
      case "-":
        hour = hour + offsetHours;
        minute = minute + offsetMinutes;
        break;
      case "Z":
        break;
      default:
        minute = minute + new Date(
          Date.UTC(year, month - 1, day, hour, minute)
        ).getTimezoneOffset();
        break;
    }
  }
  const isLeapSecond = second === 60;
  if (isLeapSecond) {
    second--;
  }
  while (minute >= 60) {
    minute -= 60;
    hour++;
  }
  while (hour >= 24) {
    hour -= 24;
    day++;
  }
  tmp2 = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
  while (day > tmp2) {
    day -= tmp2;
    month++;
    if (month > 12) {
      month -= 12;
      year++;
    }
    tmp2 = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
  }
  while (minute < 0) {
    minute += 60;
    hour--;
  }
  while (hour < 0) {
    hour += 24;
    day--;
  }
  while (day < 1) {
    month--;
    if (month < 1) {
      month += 12;
      year--;
    }
    tmp2 = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
    day += tmp2;
  }
  const components = computeJulianDateComponents(
    year,
    month,
    day,
    hour,
    minute,
    second,
    millisecond
  );
  if (!defined_default(result)) {
    result = new JulianDate(components[0], components[1], TimeStandard_default.UTC);
  } else {
    setComponents(components[0], components[1], result);
    convertUtcToTai(result);
  }
  if (isLeapSecond) {
    JulianDate.addSeconds(result, 1, result);
  }
  return result;
};
JulianDate.now = function(result) {
  return JulianDate.fromDate(new Date(), result);
};
var toGregorianDateScratch = new JulianDate(0, 0, TimeStandard_default.TAI);
JulianDate.toGregorianDate = function(julianDate, result) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  let isLeapSecond = false;
  let thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);
  if (!defined_default(thisUtc)) {
    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);
    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);
    isLeapSecond = true;
  }
  let julianDayNumber = thisUtc.dayNumber;
  const secondsOfDay = thisUtc.secondsOfDay;
  if (secondsOfDay >= 43200) {
    julianDayNumber += 1;
  }
  let L = julianDayNumber + 68569 | 0;
  const N = 4 * L / 146097 | 0;
  L = L - ((146097 * N + 3) / 4 | 0) | 0;
  const I = 4e3 * (L + 1) / 1461001 | 0;
  L = L - (1461 * I / 4 | 0) + 31 | 0;
  const J = 80 * L / 2447 | 0;
  const day = L - (2447 * J / 80 | 0) | 0;
  L = J / 11 | 0;
  const month = J + 2 - 12 * L | 0;
  const year = 100 * (N - 49) + I + L | 0;
  let hour = secondsOfDay / TimeConstants_default.SECONDS_PER_HOUR | 0;
  let remainingSeconds = secondsOfDay - hour * TimeConstants_default.SECONDS_PER_HOUR;
  const minute = remainingSeconds / TimeConstants_default.SECONDS_PER_MINUTE | 0;
  remainingSeconds = remainingSeconds - minute * TimeConstants_default.SECONDS_PER_MINUTE;
  let second = remainingSeconds | 0;
  const millisecond = (remainingSeconds - second) / TimeConstants_default.SECONDS_PER_MILLISECOND;
  hour += 12;
  if (hour > 23) {
    hour -= 24;
  }
  if (isLeapSecond) {
    second += 1;
  }
  if (!defined_default(result)) {
    return new GregorianDate_default(
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond,
      isLeapSecond
    );
  }
  result.year = year;
  result.month = month;
  result.day = day;
  result.hour = hour;
  result.minute = minute;
  result.second = second;
  result.millisecond = millisecond;
  result.isLeapSecond = isLeapSecond;
  return result;
};
JulianDate.toDate = function(julianDate) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
  let second = gDate.second;
  if (gDate.isLeapSecond) {
    second -= 1;
  }
  return new Date(
    Date.UTC(
      gDate.year,
      gDate.month - 1,
      gDate.day,
      gDate.hour,
      gDate.minute,
      second,
      gDate.millisecond
    )
  );
};
JulianDate.toIso8601 = function(julianDate, precision) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
  let year = gDate.year;
  let month = gDate.month;
  let day = gDate.day;
  let hour = gDate.hour;
  const minute = gDate.minute;
  const second = gDate.second;
  const millisecond = gDate.millisecond;
  if (year === 1e4 && month === 1 && day === 1 && hour === 0 && minute === 0 && second === 0 && millisecond === 0) {
    year = 9999;
    month = 12;
    day = 31;
    hour = 24;
  }
  let millisecondStr;
  if (!defined_default(precision) && millisecond !== 0) {
    millisecondStr = (millisecond * 0.01).toString().replace(".", "");
    return `${year.toString().padStart(4, "0")}-${month.toString().padStart(2, "0")}-${day.toString().padStart(2, "0")}T${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}:${second.toString().padStart(2, "0")}.${millisecondStr}Z`;
  }
  if (!defined_default(precision) || precision === 0) {
    return `${year.toString().padStart(4, "0")}-${month.toString().padStart(2, "0")}-${day.toString().padStart(2, "0")}T${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}:${second.toString().padStart(2, "0")}Z`;
  }
  millisecondStr = (millisecond * 0.01).toFixed(precision).replace(".", "").slice(0, precision);
  return `${year.toString().padStart(4, "0")}-${month.toString().padStart(2, "0")}-${day.toString().padStart(2, "0")}T${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}:${second.toString().padStart(2, "0")}.${millisecondStr}Z`;
};
JulianDate.clone = function(julianDate, result) {
  if (!defined_default(julianDate)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new JulianDate(
      julianDate.dayNumber,
      julianDate.secondsOfDay,
      TimeStandard_default.TAI
    );
  }
  result.dayNumber = julianDate.dayNumber;
  result.secondsOfDay = julianDate.secondsOfDay;
  return result;
};
JulianDate.compare = function(left, right) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("left is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("right is required.");
  }
  const julianDayNumberDifference = left.dayNumber - right.dayNumber;
  if (julianDayNumberDifference !== 0) {
    return julianDayNumberDifference;
  }
  return left.secondsOfDay - right.secondsOfDay;
};
JulianDate.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.dayNumber === right.dayNumber && left.secondsOfDay === right.secondsOfDay;
};
JulianDate.equalsEpsilon = function(left, right, epsilon) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon;
};
JulianDate.totalDays = function(julianDate) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  return julianDate.dayNumber + julianDate.secondsOfDay / TimeConstants_default.SECONDS_PER_DAY;
};
JulianDate.secondsDifference = function(left, right) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("left is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("right is required.");
  }
  const dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants_default.SECONDS_PER_DAY;
  return dayDifference + (left.secondsOfDay - right.secondsOfDay);
};
JulianDate.daysDifference = function(left, right) {
  if (!defined_default(left)) {
    throw new DeveloperError_default("left is required.");
  }
  if (!defined_default(right)) {
    throw new DeveloperError_default("right is required.");
  }
  const dayDifference = left.dayNumber - right.dayNumber;
  const secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants_default.SECONDS_PER_DAY;
  return dayDifference + secondDifference;
};
JulianDate.computeTaiMinusUtc = function(julianDate) {
  binarySearchScratchLeapSecond.julianDate = julianDate;
  const leapSeconds = JulianDate.leapSeconds;
  let index = binarySearch_default(
    leapSeconds,
    binarySearchScratchLeapSecond,
    compareLeapSecondDates
  );
  if (index < 0) {
    index = ~index;
    --index;
    if (index < 0) {
      index = 0;
    }
  }
  return leapSeconds[index].offset;
};
JulianDate.addSeconds = function(julianDate, seconds, result) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  if (!defined_default(seconds)) {
    throw new DeveloperError_default("seconds is required.");
  }
  if (!defined_default(result)) {
    throw new DeveloperError_default("result is required.");
  }
  return setComponents(
    julianDate.dayNumber,
    julianDate.secondsOfDay + seconds,
    result
  );
};
JulianDate.addMinutes = function(julianDate, minutes, result) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  if (!defined_default(minutes)) {
    throw new DeveloperError_default("minutes is required.");
  }
  if (!defined_default(result)) {
    throw new DeveloperError_default("result is required.");
  }
  const newSecondsOfDay = julianDate.secondsOfDay + minutes * TimeConstants_default.SECONDS_PER_MINUTE;
  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
};
JulianDate.addHours = function(julianDate, hours, result) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  if (!defined_default(hours)) {
    throw new DeveloperError_default("hours is required.");
  }
  if (!defined_default(result)) {
    throw new DeveloperError_default("result is required.");
  }
  const newSecondsOfDay = julianDate.secondsOfDay + hours * TimeConstants_default.SECONDS_PER_HOUR;
  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
};
JulianDate.addDays = function(julianDate, days, result) {
  if (!defined_default(julianDate)) {
    throw new DeveloperError_default("julianDate is required.");
  }
  if (!defined_default(days)) {
    throw new DeveloperError_default("days is required.");
  }
  if (!defined_default(result)) {
    throw new DeveloperError_default("result is required.");
  }
  const newJulianDayNumber = julianDate.dayNumber + days;
  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);
};
JulianDate.lessThan = function(left, right) {
  return JulianDate.compare(left, right) < 0;
};
JulianDate.lessThanOrEquals = function(left, right) {
  return JulianDate.compare(left, right) <= 0;
};
JulianDate.greaterThan = function(left, right) {
  return JulianDate.compare(left, right) > 0;
};
JulianDate.greaterThanOrEquals = function(left, right) {
  return JulianDate.compare(left, right) >= 0;
};
JulianDate.prototype.clone = function(result) {
  return JulianDate.clone(this, result);
};
JulianDate.prototype.equals = function(right) {
  return JulianDate.equals(this, right);
};
JulianDate.prototype.equalsEpsilon = function(right, epsilon) {
  return JulianDate.equalsEpsilon(this, right, epsilon);
};
JulianDate.prototype.toString = function() {
  return JulianDate.toIso8601(this);
};
JulianDate.leapSeconds = [
  new LeapSecond_default(new JulianDate(2441317, 43210, TimeStandard_default.TAI), 10),
  new LeapSecond_default(new JulianDate(2441499, 43211, TimeStandard_default.TAI), 11),
  new LeapSecond_default(new JulianDate(2441683, 43212, TimeStandard_default.TAI), 12),
  new LeapSecond_default(new JulianDate(2442048, 43213, TimeStandard_default.TAI), 13),
  new LeapSecond_default(new JulianDate(2442413, 43214, TimeStandard_default.TAI), 14),
  new LeapSecond_default(new JulianDate(2442778, 43215, TimeStandard_default.TAI), 15),
  new LeapSecond_default(new JulianDate(2443144, 43216, TimeStandard_default.TAI), 16),
  new LeapSecond_default(new JulianDate(2443509, 43217, TimeStandard_default.TAI), 17),
  new LeapSecond_default(new JulianDate(2443874, 43218, TimeStandard_default.TAI), 18),
  new LeapSecond_default(new JulianDate(2444239, 43219, TimeStandard_default.TAI), 19),
  new LeapSecond_default(new JulianDate(2444786, 43220, TimeStandard_default.TAI), 20),
  new LeapSecond_default(new JulianDate(2445151, 43221, TimeStandard_default.TAI), 21),
  new LeapSecond_default(new JulianDate(2445516, 43222, TimeStandard_default.TAI), 22),
  new LeapSecond_default(new JulianDate(2446247, 43223, TimeStandard_default.TAI), 23),
  new LeapSecond_default(new JulianDate(2447161, 43224, TimeStandard_default.TAI), 24),
  new LeapSecond_default(new JulianDate(2447892, 43225, TimeStandard_default.TAI), 25),
  new LeapSecond_default(new JulianDate(2448257, 43226, TimeStandard_default.TAI), 26),
  new LeapSecond_default(new JulianDate(2448804, 43227, TimeStandard_default.TAI), 27),
  new LeapSecond_default(new JulianDate(2449169, 43228, TimeStandard_default.TAI), 28),
  new LeapSecond_default(new JulianDate(2449534, 43229, TimeStandard_default.TAI), 29),
  new LeapSecond_default(new JulianDate(2450083, 43230, TimeStandard_default.TAI), 30),
  new LeapSecond_default(new JulianDate(2450630, 43231, TimeStandard_default.TAI), 31),
  new LeapSecond_default(new JulianDate(2451179, 43232, TimeStandard_default.TAI), 32),
  new LeapSecond_default(new JulianDate(2453736, 43233, TimeStandard_default.TAI), 33),
  new LeapSecond_default(new JulianDate(2454832, 43234, TimeStandard_default.TAI), 34),
  new LeapSecond_default(new JulianDate(2456109, 43235, TimeStandard_default.TAI), 35),
  new LeapSecond_default(new JulianDate(2457204, 43236, TimeStandard_default.TAI), 36),
  new LeapSecond_default(new JulianDate(2457754, 43237, TimeStandard_default.TAI), 37)
];
var JulianDate_default = JulianDate;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Resource.js
var import_urijs6 = __toESM(require_URI(), 1);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/appendForwardSlash.js
function appendForwardSlash(url) {
  if (url.length === 0 || url[url.length - 1] !== "/") {
    url = `${url}/`;
  }
  return url;
}
var appendForwardSlash_default = appendForwardSlash;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/combine.js
function combine(object1, object2, deep) {
  deep = defaultValue_default(deep, false);
  const result = {};
  const object1Defined = defined_default(object1);
  const object2Defined = defined_default(object2);
  let property;
  let object1Value;
  let object2Value;
  if (object1Defined) {
    for (property in object1) {
      if (object1.hasOwnProperty(property)) {
        object1Value = object1[property];
        if (object2Defined && deep && typeof object1Value === "object" && object2.hasOwnProperty(property)) {
          object2Value = object2[property];
          if (typeof object2Value === "object") {
            result[property] = combine(object1Value, object2Value, deep);
          } else {
            result[property] = object1Value;
          }
        } else {
          result[property] = object1Value;
        }
      }
    }
  }
  if (object2Defined) {
    for (property in object2) {
      if (object2.hasOwnProperty(property) && !result.hasOwnProperty(property)) {
        object2Value = object2[property];
        result[property] = object2Value;
      }
    }
  }
  return result;
}
var combine_default = combine;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/defer.js
function defer() {
  let resolve;
  let reject;
  const promise = new Promise(function(res, rej) {
    resolve = res;
    reject = rej;
  });
  return {
    resolve,
    reject,
    promise
  };
}
var defer_default = defer;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/getAbsoluteUri.js
var import_urijs = __toESM(require_URI(), 1);
function getAbsoluteUri(relative, base) {
  let documentObject;
  if (typeof document !== "undefined") {
    documentObject = document;
  }
  return getAbsoluteUri._implementation(relative, base, documentObject);
}
getAbsoluteUri._implementation = function(relative, base, documentObject) {
  if (!defined_default(relative)) {
    throw new DeveloperError_default("relative uri is required.");
  }
  if (!defined_default(base)) {
    if (typeof documentObject === "undefined") {
      return relative;
    }
    base = defaultValue_default(documentObject.baseURI, documentObject.location.href);
  }
  const relativeUri = new import_urijs.default(relative);
  if (relativeUri.scheme() !== "") {
    return relativeUri.toString();
  }
  return relativeUri.absoluteTo(base).toString();
};
var getAbsoluteUri_default = getAbsoluteUri;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/getBaseUri.js
var import_urijs2 = __toESM(require_URI(), 1);
function getBaseUri(uri, includeQuery) {
  if (!defined_default(uri)) {
    throw new DeveloperError_default("uri is required.");
  }
  let basePath = "";
  const i = uri.lastIndexOf("/");
  if (i !== -1) {
    basePath = uri.substring(0, i + 1);
  }
  if (!includeQuery) {
    return basePath;
  }
  uri = new import_urijs2.default(uri);
  if (uri.query().length !== 0) {
    basePath += `?${uri.query()}`;
  }
  if (uri.fragment().length !== 0) {
    basePath += `#${uri.fragment()}`;
  }
  return basePath;
}
var getBaseUri_default = getBaseUri;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/getExtensionFromUri.js
var import_urijs3 = __toESM(require_URI(), 1);
function getExtensionFromUri(uri) {
  if (!defined_default(uri)) {
    throw new DeveloperError_default("uri is required.");
  }
  const uriObject = new import_urijs3.default(uri);
  uriObject.normalize();
  let path = uriObject.path();
  let index = path.lastIndexOf("/");
  if (index !== -1) {
    path = path.substr(index + 1);
  }
  index = path.lastIndexOf(".");
  if (index === -1) {
    path = "";
  } else {
    path = path.substr(index + 1);
  }
  return path;
}
var getExtensionFromUri_default = getExtensionFromUri;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/getImagePixels.js
var context2DsByWidthAndHeight = {};
function getImagePixels(image, width, height) {
  if (!defined_default(width)) {
    width = image.width;
  }
  if (!defined_default(height)) {
    height = image.height;
  }
  let context2DsByHeight = context2DsByWidthAndHeight[width];
  if (!defined_default(context2DsByHeight)) {
    context2DsByHeight = {};
    context2DsByWidthAndHeight[width] = context2DsByHeight;
  }
  let context2d = context2DsByHeight[height];
  if (!defined_default(context2d)) {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    context2d = canvas.getContext("2d");
    context2d.globalCompositeOperation = "copy";
    context2DsByHeight[height] = context2d;
  }
  context2d.drawImage(image, 0, 0, width, height);
  return context2d.getImageData(0, 0, width, height).data;
}
var getImagePixels_default = getImagePixels;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/isBlobUri.js
var blobUriRegex = /^blob:/i;
function isBlobUri(uri) {
  Check_default.typeOf.string("uri", uri);
  return blobUriRegex.test(uri);
}
var isBlobUri_default = isBlobUri;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/isCrossOriginUrl.js
var a;
function isCrossOriginUrl(url) {
  if (!defined_default(a)) {
    a = document.createElement("a");
  }
  a.href = window.location.href;
  const host = a.host;
  const protocol = a.protocol;
  a.href = url;
  a.href = a.href;
  return protocol !== a.protocol || host !== a.host;
}
var isCrossOriginUrl_default = isCrossOriginUrl;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/isDataUri.js
var dataUriRegex = /^data:/i;
function isDataUri(uri) {
  Check_default.typeOf.string("uri", uri);
  return dataUriRegex.test(uri);
}
var isDataUri_default = isDataUri;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/loadAndExecuteScript.js
function loadAndExecuteScript(url) {
  const script = document.createElement("script");
  script.async = true;
  script.src = url;
  return new Promise((resolve, reject) => {
    if (window.crossOriginIsolated) {
      script.setAttribute("crossorigin", "anonymous");
    }
    const head = document.getElementsByTagName("head")[0];
    script.onload = function() {
      script.onload = void 0;
      head.removeChild(script);
      resolve();
    };
    script.onerror = function(e) {
      reject(e);
    };
    head.appendChild(script);
  });
}
var loadAndExecuteScript_default = loadAndExecuteScript;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/objectToQuery.js
function objectToQuery(obj) {
  if (!defined_default(obj)) {
    throw new DeveloperError_default("obj is required.");
  }
  let result = "";
  for (const propName in obj) {
    if (obj.hasOwnProperty(propName)) {
      const value = obj[propName];
      const part = `${encodeURIComponent(propName)}=`;
      if (Array.isArray(value)) {
        for (let i = 0, len = value.length; i < len; ++i) {
          result += `${part + encodeURIComponent(value[i])}&`;
        }
      } else {
        result += `${part + encodeURIComponent(value)}&`;
      }
    }
  }
  result = result.slice(0, -1);
  return result;
}
var objectToQuery_default = objectToQuery;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/queryToObject.js
function queryToObject(queryString) {
  if (!defined_default(queryString)) {
    throw new DeveloperError_default("queryString is required.");
  }
  const result = {};
  if (queryString === "") {
    return result;
  }
  const parts = queryString.replace(/\+/g, "%20").split(/[&;]/);
  for (let i = 0, len = parts.length; i < len; ++i) {
    const subparts = parts[i].split("=");
    const name = decodeURIComponent(subparts[0]);
    let value = subparts[1];
    if (defined_default(value)) {
      value = decodeURIComponent(value);
    } else {
      value = "";
    }
    const resultValue = result[name];
    if (typeof resultValue === "string") {
      result[name] = [resultValue, value];
    } else if (Array.isArray(resultValue)) {
      resultValue.push(value);
    } else {
      result[name] = value;
    }
  }
  return result;
}
var queryToObject_default = queryToObject;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/RequestState.js
var RequestState = {
  UNISSUED: 0,
  ISSUED: 1,
  ACTIVE: 2,
  RECEIVED: 3,
  CANCELLED: 4,
  FAILED: 5
};
var RequestState_default = Object.freeze(RequestState);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/RequestType.js
var RequestType = {
  TERRAIN: 0,
  IMAGERY: 1,
  TILES3D: 2,
  OTHER: 3
};
var RequestType_default = Object.freeze(RequestType);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Request.js
function Request(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const throttleByServer = defaultValue_default(options.throttleByServer, false);
  const throttle = defaultValue_default(options.throttle, false);
  this.url = options.url;
  this.requestFunction = options.requestFunction;
  this.cancelFunction = options.cancelFunction;
  this.priorityFunction = options.priorityFunction;
  this.priority = defaultValue_default(options.priority, 0);
  this.throttle = throttle;
  this.throttleByServer = throttleByServer;
  this.type = defaultValue_default(options.type, RequestType_default.OTHER);
  this.serverKey = void 0;
  this.state = RequestState_default.UNISSUED;
  this.deferred = void 0;
  this.cancelled = false;
}
Request.prototype.cancel = function() {
  this.cancelled = true;
};
Request.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new Request(this);
  }
  result.url = this.url;
  result.requestFunction = this.requestFunction;
  result.cancelFunction = this.cancelFunction;
  result.priorityFunction = this.priorityFunction;
  result.priority = this.priority;
  result.throttle = this.throttle;
  result.throttleByServer = this.throttleByServer;
  result.type = this.type;
  result.serverKey = this.serverKey;
  result.state = this.RequestState.UNISSUED;
  result.deferred = void 0;
  result.cancelled = false;
  return result;
};
var Request_default = Request;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/parseResponseHeaders.js
function parseResponseHeaders(headerString) {
  const headers = {};
  if (!headerString) {
    return headers;
  }
  const headerPairs = headerString.split("\r\n");
  for (let i = 0; i < headerPairs.length; ++i) {
    const headerPair = headerPairs[i];
    const index = headerPair.indexOf(": ");
    if (index > 0) {
      const key = headerPair.substring(0, index);
      const val = headerPair.substring(index + 2);
      headers[key] = val;
    }
  }
  return headers;
}
var parseResponseHeaders_default = parseResponseHeaders;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/RequestErrorEvent.js
function RequestErrorEvent(statusCode, response, responseHeaders) {
  this.statusCode = statusCode;
  this.response = response;
  this.responseHeaders = responseHeaders;
  if (typeof this.responseHeaders === "string") {
    this.responseHeaders = parseResponseHeaders_default(this.responseHeaders);
  }
}
RequestErrorEvent.prototype.toString = function() {
  let str = "Request has failed.";
  if (defined_default(this.statusCode)) {
    str += ` Status Code: ${this.statusCode}`;
  }
  return str;
};
var RequestErrorEvent_default = RequestErrorEvent;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/RequestScheduler.js
var import_urijs4 = __toESM(require_URI(), 1);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Event.js
function Event() {
  this._listeners = [];
  this._scopes = [];
  this._toRemove = [];
  this._insideRaiseEvent = false;
}
Object.defineProperties(Event.prototype, {
  numberOfListeners: {
    get: function() {
      return this._listeners.length - this._toRemove.length;
    }
  }
});
Event.prototype.addEventListener = function(listener, scope) {
  Check_default.typeOf.func("listener", listener);
  this._listeners.push(listener);
  this._scopes.push(scope);
  const event = this;
  return function() {
    event.removeEventListener(listener, scope);
  };
};
Event.prototype.removeEventListener = function(listener, scope) {
  Check_default.typeOf.func("listener", listener);
  const listeners = this._listeners;
  const scopes = this._scopes;
  let index = -1;
  for (let i = 0; i < listeners.length; i++) {
    if (listeners[i] === listener && scopes[i] === scope) {
      index = i;
      break;
    }
  }
  if (index !== -1) {
    if (this._insideRaiseEvent) {
      this._toRemove.push(index);
      listeners[index] = void 0;
      scopes[index] = void 0;
    } else {
      listeners.splice(index, 1);
      scopes.splice(index, 1);
    }
    return true;
  }
  return false;
};
function compareNumber(a3, b) {
  return b - a3;
}
Event.prototype.raiseEvent = function() {
  this._insideRaiseEvent = true;
  let i;
  const listeners = this._listeners;
  const scopes = this._scopes;
  let length = listeners.length;
  for (i = 0; i < length; i++) {
    const listener = listeners[i];
    if (defined_default(listener)) {
      listeners[i].apply(scopes[i], arguments);
    }
  }
  const toRemove = this._toRemove;
  length = toRemove.length;
  if (length > 0) {
    toRemove.sort(compareNumber);
    for (i = 0; i < length; i++) {
      const index = toRemove[i];
      listeners.splice(index, 1);
      scopes.splice(index, 1);
    }
    toRemove.length = 0;
  }
  this._insideRaiseEvent = false;
};
var Event_default = Event;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Heap.js
function Heap(options) {
  Check_default.typeOf.object("options", options);
  Check_default.defined("options.comparator", options.comparator);
  this._comparator = options.comparator;
  this._array = [];
  this._length = 0;
  this._maximumLength = void 0;
}
Object.defineProperties(Heap.prototype, {
  length: {
    get: function() {
      return this._length;
    }
  },
  internalArray: {
    get: function() {
      return this._array;
    }
  },
  maximumLength: {
    get: function() {
      return this._maximumLength;
    },
    set: function(value) {
      Check_default.typeOf.number.greaterThanOrEquals("maximumLength", value, 0);
      const originalLength = this._length;
      if (value < originalLength) {
        const array = this._array;
        for (let i = value; i < originalLength; ++i) {
          array[i] = void 0;
        }
        this._length = value;
        array.length = value;
      }
      this._maximumLength = value;
    }
  },
  comparator: {
    get: function() {
      return this._comparator;
    }
  }
});
function swap(array, a3, b) {
  const temp = array[a3];
  array[a3] = array[b];
  array[b] = temp;
}
Heap.prototype.reserve = function(length) {
  length = defaultValue_default(length, this._length);
  this._array.length = length;
};
Heap.prototype.heapify = function(index) {
  index = defaultValue_default(index, 0);
  const length = this._length;
  const comparator = this._comparator;
  const array = this._array;
  let candidate = -1;
  let inserting = true;
  while (inserting) {
    const right = 2 * (index + 1);
    const left = right - 1;
    if (left < length && comparator(array[left], array[index]) < 0) {
      candidate = left;
    } else {
      candidate = index;
    }
    if (right < length && comparator(array[right], array[candidate]) < 0) {
      candidate = right;
    }
    if (candidate !== index) {
      swap(array, candidate, index);
      index = candidate;
    } else {
      inserting = false;
    }
  }
};
Heap.prototype.resort = function() {
  const length = this._length;
  for (let i = Math.ceil(length / 2); i >= 0; --i) {
    this.heapify(i);
  }
};
Heap.prototype.insert = function(element) {
  Check_default.defined("element", element);
  const array = this._array;
  const comparator = this._comparator;
  const maximumLength = this._maximumLength;
  let index = this._length++;
  if (index < array.length) {
    array[index] = element;
  } else {
    array.push(element);
  }
  while (index !== 0) {
    const parent = Math.floor((index - 1) / 2);
    if (comparator(array[index], array[parent]) < 0) {
      swap(array, index, parent);
      index = parent;
    } else {
      break;
    }
  }
  let removedElement;
  if (defined_default(maximumLength) && this._length > maximumLength) {
    removedElement = array[maximumLength];
    this._length = maximumLength;
  }
  return removedElement;
};
Heap.prototype.pop = function(index) {
  index = defaultValue_default(index, 0);
  if (this._length === 0) {
    return void 0;
  }
  Check_default.typeOf.number.lessThan("index", index, this._length);
  const array = this._array;
  const root = array[index];
  swap(array, index, --this._length);
  this.heapify(index);
  array[this._length] = void 0;
  return root;
};
var Heap_default = Heap;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/RequestScheduler.js
function sortRequests(a3, b) {
  return a3.priority - b.priority;
}
var statistics = {
  numberOfAttemptedRequests: 0,
  numberOfActiveRequests: 0,
  numberOfCancelledRequests: 0,
  numberOfCancelledActiveRequests: 0,
  numberOfFailedRequests: 0,
  numberOfActiveRequestsEver: 0,
  lastNumberOfActiveRequests: 0
};
var priorityHeapLength = 20;
var requestHeap = new Heap_default({
  comparator: sortRequests
});
requestHeap.maximumLength = priorityHeapLength;
requestHeap.reserve(priorityHeapLength);
var activeRequests = [];
var numberOfActiveRequestsByServer = {};
var pageUri = typeof document !== "undefined" ? new import_urijs4.default(document.location.href) : new import_urijs4.default();
var requestCompletedEvent = new Event_default();
function RequestScheduler() {
}
RequestScheduler.maximumRequests = 50;
RequestScheduler.maximumRequestsPerServer = 6;
RequestScheduler.requestsByServer = {
  "api.cesium.com:443": 18,
  "assets.cesium.com:443": 18
};
RequestScheduler.throttleRequests = true;
RequestScheduler.debugShowStatistics = false;
RequestScheduler.requestCompletedEvent = requestCompletedEvent;
Object.defineProperties(RequestScheduler, {
  statistics: {
    get: function() {
      return statistics;
    }
  },
  priorityHeapLength: {
    get: function() {
      return priorityHeapLength;
    },
    set: function(value) {
      if (value < priorityHeapLength) {
        while (requestHeap.length > value) {
          const request = requestHeap.pop();
          cancelRequest(request);
        }
      }
      priorityHeapLength = value;
      requestHeap.maximumLength = value;
      requestHeap.reserve(value);
    }
  }
});
function updatePriority(request) {
  if (defined_default(request.priorityFunction)) {
    request.priority = request.priorityFunction();
  }
}
RequestScheduler.serverHasOpenSlots = function(serverKey, desiredRequests) {
  desiredRequests = defaultValue_default(desiredRequests, 1);
  const maxRequests = defaultValue_default(
    RequestScheduler.requestsByServer[serverKey],
    RequestScheduler.maximumRequestsPerServer
  );
  const hasOpenSlotsServer = numberOfActiveRequestsByServer[serverKey] + desiredRequests <= maxRequests;
  return hasOpenSlotsServer;
};
RequestScheduler.heapHasOpenSlots = function(desiredRequests) {
  const hasOpenSlotsHeap = requestHeap.length + desiredRequests <= priorityHeapLength;
  return hasOpenSlotsHeap;
};
function issueRequest(request) {
  if (request.state === RequestState_default.UNISSUED) {
    request.state = RequestState_default.ISSUED;
    request.deferred = defer_default();
  }
  return request.deferred.promise;
}
function getRequestReceivedFunction(request) {
  return function(results) {
    if (request.state === RequestState_default.CANCELLED) {
      return;
    }
    const deferred = request.deferred;
    --statistics.numberOfActiveRequests;
    --numberOfActiveRequestsByServer[request.serverKey];
    requestCompletedEvent.raiseEvent();
    request.state = RequestState_default.RECEIVED;
    request.deferred = void 0;
    deferred.resolve(results);
  };
}
function getRequestFailedFunction(request) {
  return function(error) {
    if (request.state === RequestState_default.CANCELLED) {
      return;
    }
    ++statistics.numberOfFailedRequests;
    --statistics.numberOfActiveRequests;
    --numberOfActiveRequestsByServer[request.serverKey];
    requestCompletedEvent.raiseEvent(error);
    request.state = RequestState_default.FAILED;
    request.deferred.reject(error);
  };
}
function startRequest(request) {
  const promise = issueRequest(request);
  request.state = RequestState_default.ACTIVE;
  activeRequests.push(request);
  ++statistics.numberOfActiveRequests;
  ++statistics.numberOfActiveRequestsEver;
  ++numberOfActiveRequestsByServer[request.serverKey];
  request.requestFunction().then(getRequestReceivedFunction(request)).catch(getRequestFailedFunction(request));
  return promise;
}
function cancelRequest(request) {
  const active = request.state === RequestState_default.ACTIVE;
  request.state = RequestState_default.CANCELLED;
  ++statistics.numberOfCancelledRequests;
  if (defined_default(request.deferred)) {
    const deferred = request.deferred;
    request.deferred = void 0;
    deferred.reject();
  }
  if (active) {
    --statistics.numberOfActiveRequests;
    --numberOfActiveRequestsByServer[request.serverKey];
    ++statistics.numberOfCancelledActiveRequests;
  }
  if (defined_default(request.cancelFunction)) {
    request.cancelFunction();
  }
}
RequestScheduler.update = function() {
  let i;
  let request;
  let removeCount = 0;
  const activeLength = activeRequests.length;
  for (i = 0; i < activeLength; ++i) {
    request = activeRequests[i];
    if (request.cancelled) {
      cancelRequest(request);
    }
    if (request.state !== RequestState_default.ACTIVE) {
      ++removeCount;
      continue;
    }
    if (removeCount > 0) {
      activeRequests[i - removeCount] = request;
    }
  }
  activeRequests.length -= removeCount;
  const issuedRequests = requestHeap.internalArray;
  const issuedLength = requestHeap.length;
  for (i = 0; i < issuedLength; ++i) {
    updatePriority(issuedRequests[i]);
  }
  requestHeap.resort();
  const openSlots = Math.max(
    RequestScheduler.maximumRequests - activeRequests.length,
    0
  );
  let filledSlots = 0;
  while (filledSlots < openSlots && requestHeap.length > 0) {
    request = requestHeap.pop();
    if (request.cancelled) {
      cancelRequest(request);
      continue;
    }
    if (request.throttleByServer && !RequestScheduler.serverHasOpenSlots(request.serverKey)) {
      cancelRequest(request);
      continue;
    }
    startRequest(request);
    ++filledSlots;
  }
  updateStatistics();
};
RequestScheduler.getServerKey = function(url) {
  Check_default.typeOf.string("url", url);
  let uri = new import_urijs4.default(url);
  if (uri.scheme() === "") {
    uri = new import_urijs4.default(url).absoluteTo(pageUri);
    uri.normalize();
  }
  let serverKey = uri.authority();
  if (!/:/.test(serverKey)) {
    serverKey = `${serverKey}:${uri.scheme() === "https" ? "443" : "80"}`;
  }
  const length = numberOfActiveRequestsByServer[serverKey];
  if (!defined_default(length)) {
    numberOfActiveRequestsByServer[serverKey] = 0;
  }
  return serverKey;
};
RequestScheduler.request = function(request) {
  Check_default.typeOf.object("request", request);
  Check_default.typeOf.string("request.url", request.url);
  Check_default.typeOf.func("request.requestFunction", request.requestFunction);
  if (isDataUri_default(request.url) || isBlobUri_default(request.url)) {
    requestCompletedEvent.raiseEvent();
    request.state = RequestState_default.RECEIVED;
    return request.requestFunction();
  }
  ++statistics.numberOfAttemptedRequests;
  if (!defined_default(request.serverKey)) {
    request.serverKey = RequestScheduler.getServerKey(request.url);
  }
  if (RequestScheduler.throttleRequests && request.throttleByServer && !RequestScheduler.serverHasOpenSlots(request.serverKey)) {
    return void 0;
  }
  if (!RequestScheduler.throttleRequests || !request.throttle) {
    return startRequest(request);
  }
  if (activeRequests.length >= RequestScheduler.maximumRequests) {
    return void 0;
  }
  updatePriority(request);
  const removedRequest = requestHeap.insert(request);
  if (defined_default(removedRequest)) {
    if (removedRequest === request) {
      return void 0;
    }
    cancelRequest(removedRequest);
  }
  return issueRequest(request);
};
function updateStatistics() {
  if (!RequestScheduler.debugShowStatistics) {
    return;
  }
  if (statistics.numberOfActiveRequests === 0 && statistics.lastNumberOfActiveRequests > 0) {
    if (statistics.numberOfAttemptedRequests > 0) {
      console.log(
        `Number of attempted requests: ${statistics.numberOfAttemptedRequests}`
      );
      statistics.numberOfAttemptedRequests = 0;
    }
    if (statistics.numberOfCancelledRequests > 0) {
      console.log(
        `Number of cancelled requests: ${statistics.numberOfCancelledRequests}`
      );
      statistics.numberOfCancelledRequests = 0;
    }
    if (statistics.numberOfCancelledActiveRequests > 0) {
      console.log(
        `Number of cancelled active requests: ${statistics.numberOfCancelledActiveRequests}`
      );
      statistics.numberOfCancelledActiveRequests = 0;
    }
    if (statistics.numberOfFailedRequests > 0) {
      console.log(
        `Number of failed requests: ${statistics.numberOfFailedRequests}`
      );
      statistics.numberOfFailedRequests = 0;
    }
  }
  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;
}
RequestScheduler.clearForSpecs = function() {
  while (requestHeap.length > 0) {
    const request = requestHeap.pop();
    cancelRequest(request);
  }
  const length = activeRequests.length;
  for (let i = 0; i < length; ++i) {
    cancelRequest(activeRequests[i]);
  }
  activeRequests.length = 0;
  numberOfActiveRequestsByServer = {};
  statistics.numberOfAttemptedRequests = 0;
  statistics.numberOfActiveRequests = 0;
  statistics.numberOfCancelledRequests = 0;
  statistics.numberOfCancelledActiveRequests = 0;
  statistics.numberOfFailedRequests = 0;
  statistics.numberOfActiveRequestsEver = 0;
  statistics.lastNumberOfActiveRequests = 0;
};
RequestScheduler.numberOfActiveRequestsByServer = function(serverKey) {
  return numberOfActiveRequestsByServer[serverKey];
};
RequestScheduler.requestHeap = requestHeap;
var RequestScheduler_default = RequestScheduler;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/TrustedServers.js
var import_urijs5 = __toESM(require_URI(), 1);
var TrustedServers = {};
var _servers = {};
TrustedServers.add = function(host, port) {
  if (!defined_default(host)) {
    throw new DeveloperError_default("host is required.");
  }
  if (!defined_default(port) || port <= 0) {
    throw new DeveloperError_default("port is required to be greater than 0.");
  }
  const authority = `${host.toLowerCase()}:${port}`;
  if (!defined_default(_servers[authority])) {
    _servers[authority] = true;
  }
};
TrustedServers.remove = function(host, port) {
  if (!defined_default(host)) {
    throw new DeveloperError_default("host is required.");
  }
  if (!defined_default(port) || port <= 0) {
    throw new DeveloperError_default("port is required to be greater than 0.");
  }
  const authority = `${host.toLowerCase()}:${port}`;
  if (defined_default(_servers[authority])) {
    delete _servers[authority];
  }
};
function getAuthority(url) {
  const uri = new import_urijs5.default(url);
  uri.normalize();
  let authority = uri.authority();
  if (authority.length === 0) {
    return void 0;
  }
  uri.authority(authority);
  if (authority.indexOf("@") !== -1) {
    const parts = authority.split("@");
    authority = parts[1];
  }
  if (authority.indexOf(":") === -1) {
    let scheme = uri.scheme();
    if (scheme.length === 0) {
      scheme = window.location.protocol;
      scheme = scheme.substring(0, scheme.length - 1);
    }
    if (scheme === "http") {
      authority += ":80";
    } else if (scheme === "https") {
      authority += ":443";
    } else {
      return void 0;
    }
  }
  return authority;
}
TrustedServers.contains = function(url) {
  if (!defined_default(url)) {
    throw new DeveloperError_default("url is required.");
  }
  const authority = getAuthority(url);
  if (defined_default(authority) && defined_default(_servers[authority])) {
    return true;
  }
  return false;
};
TrustedServers.clear = function() {
  _servers = {};
};
var TrustedServers_default = TrustedServers;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Resource.js
var xhrBlobSupported = function() {
  try {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", "#", true);
    xhr.responseType = "blob";
    return xhr.responseType === "blob";
  } catch (e) {
    return false;
  }
}();
function parseQuery(uri, resource, merge, preserveQueryParameters) {
  const queryString = uri.query();
  if (queryString.length === 0) {
    return {};
  }
  let query;
  if (queryString.indexOf("=") === -1) {
    const result = {};
    result[queryString] = void 0;
    query = result;
  } else {
    query = queryToObject_default(queryString);
  }
  if (merge) {
    resource._queryParameters = combineQueryParameters(
      query,
      resource._queryParameters,
      preserveQueryParameters
    );
  } else {
    resource._queryParameters = query;
  }
  uri.search("");
}
function stringifyQuery(uri, resource) {
  const queryObject = resource._queryParameters;
  const keys2 = Object.keys(queryObject);
  if (keys2.length === 1 && !defined_default(queryObject[keys2[0]])) {
    uri.search(keys2[0]);
  } else {
    uri.search(objectToQuery_default(queryObject));
  }
}
function defaultClone(val, defaultVal) {
  if (!defined_default(val)) {
    return defaultVal;
  }
  return defined_default(val.clone) ? val.clone() : clone_default(val);
}
function checkAndResetRequest(request) {
  if (request.state === RequestState_default.ISSUED || request.state === RequestState_default.ACTIVE) {
    throw new RuntimeError_default("The Resource is already being fetched.");
  }
  request.state = RequestState_default.UNISSUED;
  request.deferred = void 0;
}
function combineQueryParameters(q12, q22, preserveQueryParameters) {
  if (!preserveQueryParameters) {
    return combine_default(q12, q22);
  }
  const result = clone_default(q12, true);
  for (const param in q22) {
    if (q22.hasOwnProperty(param)) {
      let value = result[param];
      const q2Value = q22[param];
      if (defined_default(value)) {
        if (!Array.isArray(value)) {
          value = result[param] = [value];
        }
        result[param] = value.concat(q2Value);
      } else {
        result[param] = Array.isArray(q2Value) ? q2Value.slice() : q2Value;
      }
    }
  }
  return result;
}
function Resource(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (typeof options === "string") {
    options = {
      url: options
    };
  }
  Check_default.typeOf.string("options.url", options.url);
  this._url = void 0;
  this._templateValues = defaultClone(options.templateValues, {});
  this._queryParameters = defaultClone(options.queryParameters, {});
  this.headers = defaultClone(options.headers, {});
  this.request = defaultValue_default(options.request, new Request_default());
  this.proxy = options.proxy;
  this.retryCallback = options.retryCallback;
  this.retryAttempts = defaultValue_default(options.retryAttempts, 0);
  this._retryCount = 0;
  const uri = new import_urijs6.default(options.url);
  parseQuery(uri, this, true, true);
  uri.fragment("");
  this._url = uri.toString();
}
Resource.createIfNeeded = function(resource) {
  if (resource instanceof Resource) {
    return resource.getDerivedResource({
      request: resource.request
    });
  }
  if (typeof resource !== "string") {
    return resource;
  }
  return new Resource({
    url: resource
  });
};
var supportsImageBitmapOptionsPromise;
Resource.supportsImageBitmapOptions = function() {
  if (defined_default(supportsImageBitmapOptionsPromise)) {
    return supportsImageBitmapOptionsPromise;
  }
  if (typeof createImageBitmap !== "function") {
    supportsImageBitmapOptionsPromise = Promise.resolve(false);
    return supportsImageBitmapOptionsPromise;
  }
  const imageDataUri = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAABGdBTUEAAE4g3rEiDgAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADElEQVQI12Ng6GAAAAEUAIngE3ZiAAAAAElFTkSuQmCC";
  supportsImageBitmapOptionsPromise = Resource.fetchBlob({
    url: imageDataUri
  }).then(function(blob) {
    const imageBitmapOptions = {
      imageOrientation: "flipY",
      premultiplyAlpha: "none",
      colorSpaceConversion: "none"
    };
    return Promise.all([
      createImageBitmap(blob, imageBitmapOptions),
      createImageBitmap(blob)
    ]);
  }).then(function(imageBitmaps) {
    const colorWithOptions = getImagePixels_default(imageBitmaps[0]);
    const colorWithDefaults = getImagePixels_default(imageBitmaps[1]);
    return colorWithOptions[1] !== colorWithDefaults[1];
  }).catch(function() {
    return false;
  });
  return supportsImageBitmapOptionsPromise;
};
Object.defineProperties(Resource, {
  isBlobSupported: {
    get: function() {
      return xhrBlobSupported;
    }
  }
});
Object.defineProperties(Resource.prototype, {
  queryParameters: {
    get: function() {
      return this._queryParameters;
    }
  },
  templateValues: {
    get: function() {
      return this._templateValues;
    }
  },
  url: {
    get: function() {
      return this.getUrlComponent(true, true);
    },
    set: function(value) {
      const uri = new import_urijs6.default(value);
      parseQuery(uri, this, false);
      uri.fragment("");
      this._url = uri.toString();
    }
  },
  extension: {
    get: function() {
      return getExtensionFromUri_default(this._url);
    }
  },
  isDataUri: {
    get: function() {
      return isDataUri_default(this._url);
    }
  },
  isBlobUri: {
    get: function() {
      return isBlobUri_default(this._url);
    }
  },
  isCrossOriginUrl: {
    get: function() {
      return isCrossOriginUrl_default(this._url);
    }
  },
  hasHeaders: {
    get: function() {
      return Object.keys(this.headers).length > 0;
    }
  }
});
Resource.prototype.toString = function() {
  return this.getUrlComponent(true, true);
};
Resource.prototype.getUrlComponent = function(query, proxy) {
  if (this.isDataUri) {
    return this._url;
  }
  const uri = new import_urijs6.default(this._url);
  if (query) {
    stringifyQuery(uri, this);
  }
  let url = uri.toString().replace(/%7B/g, "{").replace(/%7D/g, "}");
  const templateValues = this._templateValues;
  url = url.replace(/{(.*?)}/g, function(match, key) {
    const replacement = templateValues[key];
    if (defined_default(replacement)) {
      return encodeURIComponent(replacement);
    }
    return match;
  });
  if (proxy && defined_default(this.proxy)) {
    url = this.proxy.getURL(url);
  }
  return url;
};
Resource.prototype.setQueryParameters = function(params, useAsDefault) {
  if (useAsDefault) {
    this._queryParameters = combineQueryParameters(
      this._queryParameters,
      params,
      false
    );
  } else {
    this._queryParameters = combineQueryParameters(
      params,
      this._queryParameters,
      false
    );
  }
};
Resource.prototype.appendQueryParameters = function(params) {
  this._queryParameters = combineQueryParameters(
    params,
    this._queryParameters,
    true
  );
};
Resource.prototype.setTemplateValues = function(template, useAsDefault) {
  if (useAsDefault) {
    this._templateValues = combine_default(this._templateValues, template);
  } else {
    this._templateValues = combine_default(template, this._templateValues);
  }
};
Resource.prototype.getDerivedResource = function(options) {
  const resource = this.clone();
  resource._retryCount = 0;
  if (defined_default(options.url)) {
    const uri = new import_urijs6.default(options.url);
    const preserveQueryParameters = defaultValue_default(
      options.preserveQueryParameters,
      false
    );
    parseQuery(uri, resource, true, preserveQueryParameters);
    uri.fragment("");
    if (uri.scheme() !== "") {
      resource._url = uri.toString();
    } else {
      resource._url = uri.absoluteTo(new import_urijs6.default(getAbsoluteUri_default(this._url))).toString();
    }
  }
  if (defined_default(options.queryParameters)) {
    resource._queryParameters = combine_default(
      options.queryParameters,
      resource._queryParameters
    );
  }
  if (defined_default(options.templateValues)) {
    resource._templateValues = combine_default(
      options.templateValues,
      resource.templateValues
    );
  }
  if (defined_default(options.headers)) {
    resource.headers = combine_default(options.headers, resource.headers);
  }
  if (defined_default(options.proxy)) {
    resource.proxy = options.proxy;
  }
  if (defined_default(options.request)) {
    resource.request = options.request;
  }
  if (defined_default(options.retryCallback)) {
    resource.retryCallback = options.retryCallback;
  }
  if (defined_default(options.retryAttempts)) {
    resource.retryAttempts = options.retryAttempts;
  }
  return resource;
};
Resource.prototype.retryOnError = function(error) {
  const retryCallback = this.retryCallback;
  if (typeof retryCallback !== "function" || this._retryCount >= this.retryAttempts) {
    return Promise.resolve(false);
  }
  const that = this;
  return Promise.resolve(retryCallback(this, error)).then(function(result) {
    ++that._retryCount;
    return result;
  });
};
Resource.prototype.clone = function(result) {
  if (!defined_default(result)) {
    result = new Resource({
      url: this._url
    });
  }
  result._url = this._url;
  result._queryParameters = clone_default(this._queryParameters);
  result._templateValues = clone_default(this._templateValues);
  result.headers = clone_default(this.headers);
  result.proxy = this.proxy;
  result.retryCallback = this.retryCallback;
  result.retryAttempts = this.retryAttempts;
  result._retryCount = 0;
  result.request = this.request.clone();
  return result;
};
Resource.prototype.getBaseUri = function(includeQuery) {
  return getBaseUri_default(this.getUrlComponent(includeQuery), includeQuery);
};
Resource.prototype.appendForwardSlash = function() {
  this._url = appendForwardSlash_default(this._url);
};
Resource.prototype.fetchArrayBuffer = function() {
  return this.fetch({
    responseType: "arraybuffer"
  });
};
Resource.fetchArrayBuffer = function(options) {
  const resource = new Resource(options);
  return resource.fetchArrayBuffer();
};
Resource.prototype.fetchBlob = function() {
  return this.fetch({
    responseType: "blob"
  });
};
Resource.fetchBlob = function(options) {
  const resource = new Resource(options);
  return resource.fetchBlob();
};
Resource.prototype.fetchImage = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const preferImageBitmap = defaultValue_default(options.preferImageBitmap, false);
  const preferBlob = defaultValue_default(options.preferBlob, false);
  const flipY = defaultValue_default(options.flipY, false);
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  checkAndResetRequest(this.request);
  if (!xhrBlobSupported || this.isDataUri || this.isBlobUri || !this.hasHeaders && !preferBlob) {
    return fetchImage({
      resource: this,
      flipY,
      skipColorSpaceConversion,
      preferImageBitmap
    });
  }
  const blobPromise = this.fetchBlob();
  if (!defined_default(blobPromise)) {
    return;
  }
  let supportsImageBitmap;
  let useImageBitmap;
  let generatedBlobResource;
  let generatedBlob;
  return Resource.supportsImageBitmapOptions().then(function(result) {
    supportsImageBitmap = result;
    useImageBitmap = supportsImageBitmap && preferImageBitmap;
    return blobPromise;
  }).then(function(blob) {
    if (!defined_default(blob)) {
      return;
    }
    generatedBlob = blob;
    if (useImageBitmap) {
      return Resource.createImageBitmapFromBlob(blob, {
        flipY,
        premultiplyAlpha: false,
        skipColorSpaceConversion
      });
    }
    const blobUrl = window.URL.createObjectURL(blob);
    generatedBlobResource = new Resource({
      url: blobUrl
    });
    return fetchImage({
      resource: generatedBlobResource,
      flipY,
      skipColorSpaceConversion,
      preferImageBitmap: false
    });
  }).then(function(image) {
    if (!defined_default(image)) {
      return;
    }
    image.blob = generatedBlob;
    if (useImageBitmap) {
      return image;
    }
    window.URL.revokeObjectURL(generatedBlobResource.url);
    return image;
  }).catch(function(error) {
    if (defined_default(generatedBlobResource)) {
      window.URL.revokeObjectURL(generatedBlobResource.url);
    }
    error.blob = generatedBlob;
    return Promise.reject(error);
  });
};
function fetchImage(options) {
  const resource = options.resource;
  const flipY = options.flipY;
  const skipColorSpaceConversion = options.skipColorSpaceConversion;
  const preferImageBitmap = options.preferImageBitmap;
  const request = resource.request;
  request.url = resource.url;
  request.requestFunction = function() {
    let crossOrigin = false;
    if (!resource.isDataUri && !resource.isBlobUri) {
      crossOrigin = resource.isCrossOriginUrl;
    }
    const deferred = defer_default();
    Resource._Implementations.createImage(
      request,
      crossOrigin,
      deferred,
      flipY,
      skipColorSpaceConversion,
      preferImageBitmap
    );
    return deferred.promise;
  };
  const promise = RequestScheduler_default.request(request);
  if (!defined_default(promise)) {
    return;
  }
  return promise.catch(function(e) {
    if (request.state !== RequestState_default.FAILED) {
      return Promise.reject(e);
    }
    return resource.retryOnError(e).then(function(retry) {
      if (retry) {
        request.state = RequestState_default.UNISSUED;
        request.deferred = void 0;
        return fetchImage({
          resource,
          flipY,
          skipColorSpaceConversion,
          preferImageBitmap
        });
      }
      return Promise.reject(e);
    });
  });
}
Resource.fetchImage = function(options) {
  const resource = new Resource(options);
  return resource.fetchImage({
    flipY: options.flipY,
    skipColorSpaceConversion: options.skipColorSpaceConversion,
    preferBlob: options.preferBlob,
    preferImageBitmap: options.preferImageBitmap
  });
};
Resource.prototype.fetchText = function() {
  return this.fetch({
    responseType: "text"
  });
};
Resource.fetchText = function(options) {
  const resource = new Resource(options);
  return resource.fetchText();
};
Resource.prototype.fetchJson = function() {
  const promise = this.fetch({
    responseType: "text",
    headers: {
      Accept: "application/json,*/*;q=0.01"
    }
  });
  if (!defined_default(promise)) {
    return void 0;
  }
  return promise.then(function(value) {
    if (!defined_default(value)) {
      return;
    }
    return JSON.parse(value);
  });
};
Resource.fetchJson = function(options) {
  const resource = new Resource(options);
  return resource.fetchJson();
};
Resource.prototype.fetchXML = function() {
  return this.fetch({
    responseType: "document",
    overrideMimeType: "text/xml"
  });
};
Resource.fetchXML = function(options) {
  const resource = new Resource(options);
  return resource.fetchXML();
};
Resource.prototype.fetchJsonp = function(callbackParameterName) {
  callbackParameterName = defaultValue_default(callbackParameterName, "callback");
  checkAndResetRequest(this.request);
  let functionName;
  do {
    functionName = `loadJsonp${Math_default.nextRandomNumber().toString().substring(2, 8)}`;
  } while (defined_default(window[functionName]));
  return fetchJsonp(this, callbackParameterName, functionName);
};
function fetchJsonp(resource, callbackParameterName, functionName) {
  const callbackQuery = {};
  callbackQuery[callbackParameterName] = functionName;
  resource.setQueryParameters(callbackQuery);
  const request = resource.request;
  request.url = resource.url;
  request.requestFunction = function() {
    const deferred = defer_default();
    window[functionName] = function(data) {
      deferred.resolve(data);
      try {
        delete window[functionName];
      } catch (e) {
        window[functionName] = void 0;
      }
    };
    Resource._Implementations.loadAndExecuteScript(
      resource.url,
      functionName,
      deferred
    );
    return deferred.promise;
  };
  const promise = RequestScheduler_default.request(request);
  if (!defined_default(promise)) {
    return;
  }
  return promise.catch(function(e) {
    if (request.state !== RequestState_default.FAILED) {
      return Promise.reject(e);
    }
    return resource.retryOnError(e).then(function(retry) {
      if (retry) {
        request.state = RequestState_default.UNISSUED;
        request.deferred = void 0;
        return fetchJsonp(resource, callbackParameterName, functionName);
      }
      return Promise.reject(e);
    });
  });
}
Resource.fetchJsonp = function(options) {
  const resource = new Resource(options);
  return resource.fetchJsonp(options.callbackParameterName);
};
Resource.prototype._makeRequest = function(options) {
  const resource = this;
  checkAndResetRequest(resource.request);
  const request = resource.request;
  request.url = resource.url;
  request.requestFunction = function() {
    const responseType = options.responseType;
    const headers = combine_default(options.headers, resource.headers);
    const overrideMimeType = options.overrideMimeType;
    const method = options.method;
    const data = options.data;
    const deferred = defer_default();
    const xhr = Resource._Implementations.loadWithXhr(
      resource.url,
      responseType,
      method,
      data,
      headers,
      deferred,
      overrideMimeType
    );
    if (defined_default(xhr) && defined_default(xhr.abort)) {
      request.cancelFunction = function() {
        xhr.abort();
      };
    }
    return deferred.promise;
  };
  const promise = RequestScheduler_default.request(request);
  if (!defined_default(promise)) {
    return;
  }
  return promise.then(function(data) {
    request.cancelFunction = void 0;
    return data;
  }).catch(function(e) {
    request.cancelFunction = void 0;
    if (request.state !== RequestState_default.FAILED) {
      return Promise.reject(e);
    }
    return resource.retryOnError(e).then(function(retry) {
      if (retry) {
        request.state = RequestState_default.UNISSUED;
        request.deferred = void 0;
        return resource.fetch(options);
      }
      return Promise.reject(e);
    });
  });
};
var dataUriRegex2 = /^data:(.*?)(;base64)?,(.*)$/;
function decodeDataUriText(isBase64, data) {
  const result = decodeURIComponent(data);
  if (isBase64) {
    return atob(result);
  }
  return result;
}
function decodeDataUriArrayBuffer(isBase64, data) {
  const byteString = decodeDataUriText(isBase64, data);
  const buffer = new ArrayBuffer(byteString.length);
  const view = new Uint8Array(buffer);
  for (let i = 0; i < byteString.length; i++) {
    view[i] = byteString.charCodeAt(i);
  }
  return buffer;
}
function decodeDataUri(dataUriRegexResult, responseType) {
  responseType = defaultValue_default(responseType, "");
  const mimeType = dataUriRegexResult[1];
  const isBase64 = !!dataUriRegexResult[2];
  const data = dataUriRegexResult[3];
  let buffer;
  let parser;
  switch (responseType) {
    case "":
    case "text":
      return decodeDataUriText(isBase64, data);
    case "arraybuffer":
      return decodeDataUriArrayBuffer(isBase64, data);
    case "blob":
      buffer = decodeDataUriArrayBuffer(isBase64, data);
      return new Blob([buffer], {
        type: mimeType
      });
    case "document":
      parser = new DOMParser();
      return parser.parseFromString(
        decodeDataUriText(isBase64, data),
        mimeType
      );
    case "json":
      return JSON.parse(decodeDataUriText(isBase64, data));
    default:
      throw new DeveloperError_default(`Unhandled responseType: ${responseType}`);
  }
}
Resource.prototype.fetch = function(options) {
  options = defaultClone(options, {});
  options.method = "GET";
  return this._makeRequest(options);
};
Resource.fetch = function(options) {
  const resource = new Resource(options);
  return resource.fetch({
    responseType: options.responseType,
    overrideMimeType: options.overrideMimeType
  });
};
Resource.prototype.delete = function(options) {
  options = defaultClone(options, {});
  options.method = "DELETE";
  return this._makeRequest(options);
};
Resource.delete = function(options) {
  const resource = new Resource(options);
  return resource.delete({
    responseType: options.responseType,
    overrideMimeType: options.overrideMimeType,
    data: options.data
  });
};
Resource.prototype.head = function(options) {
  options = defaultClone(options, {});
  options.method = "HEAD";
  return this._makeRequest(options);
};
Resource.head = function(options) {
  const resource = new Resource(options);
  return resource.head({
    responseType: options.responseType,
    overrideMimeType: options.overrideMimeType
  });
};
Resource.prototype.options = function(options) {
  options = defaultClone(options, {});
  options.method = "OPTIONS";
  return this._makeRequest(options);
};
Resource.options = function(options) {
  const resource = new Resource(options);
  return resource.options({
    responseType: options.responseType,
    overrideMimeType: options.overrideMimeType
  });
};
Resource.prototype.post = function(data, options) {
  Check_default.defined("data", data);
  options = defaultClone(options, {});
  options.method = "POST";
  options.data = data;
  return this._makeRequest(options);
};
Resource.post = function(options) {
  const resource = new Resource(options);
  return resource.post(options.data, {
    responseType: options.responseType,
    overrideMimeType: options.overrideMimeType
  });
};
Resource.prototype.put = function(data, options) {
  Check_default.defined("data", data);
  options = defaultClone(options, {});
  options.method = "PUT";
  options.data = data;
  return this._makeRequest(options);
};
Resource.put = function(options) {
  const resource = new Resource(options);
  return resource.put(options.data, {
    responseType: options.responseType,
    overrideMimeType: options.overrideMimeType
  });
};
Resource.prototype.patch = function(data, options) {
  Check_default.defined("data", data);
  options = defaultClone(options, {});
  options.method = "PATCH";
  options.data = data;
  return this._makeRequest(options);
};
Resource.patch = function(options) {
  const resource = new Resource(options);
  return resource.patch(options.data, {
    responseType: options.responseType,
    overrideMimeType: options.overrideMimeType
  });
};
Resource._Implementations = {};
Resource._Implementations.loadImageElement = function(url, crossOrigin, deferred) {
  const image = new Image();
  image.onload = function() {
    if (image.naturalWidth === 0 && image.naturalHeight === 0 && image.width === 0 && image.height === 0) {
      image.width = 300;
      image.height = 150;
    }
    deferred.resolve(image);
  };
  image.onerror = function(e) {
    deferred.reject(e);
  };
  if (crossOrigin) {
    if (TrustedServers_default.contains(url)) {
      image.crossOrigin = "use-credentials";
    } else {
      image.crossOrigin = "";
    }
  }
  image.src = url;
};
Resource._Implementations.createImage = function(request, crossOrigin, deferred, flipY, skipColorSpaceConversion, preferImageBitmap) {
  const url = request.url;
  Resource.supportsImageBitmapOptions().then(function(supportsImageBitmap) {
    if (!(supportsImageBitmap && preferImageBitmap)) {
      Resource._Implementations.loadImageElement(url, crossOrigin, deferred);
      return;
    }
    const responseType = "blob";
    const method = "GET";
    const xhrDeferred = defer_default();
    const xhr = Resource._Implementations.loadWithXhr(
      url,
      responseType,
      method,
      void 0,
      void 0,
      xhrDeferred,
      void 0,
      void 0,
      void 0
    );
    if (defined_default(xhr) && defined_default(xhr.abort)) {
      request.cancelFunction = function() {
        xhr.abort();
      };
    }
    return xhrDeferred.promise.then(function(blob) {
      if (!defined_default(blob)) {
        deferred.reject(
          new RuntimeError_default(
            `Successfully retrieved ${url} but it contained no content.`
          )
        );
        return;
      }
      return Resource.createImageBitmapFromBlob(blob, {
        flipY,
        premultiplyAlpha: false,
        skipColorSpaceConversion
      });
    }).then(function(image) {
      deferred.resolve(image);
    });
  }).catch(function(e) {
    deferred.reject(e);
  });
};
Resource.createImageBitmapFromBlob = function(blob, options) {
  Check_default.defined("options", options);
  Check_default.typeOf.bool("options.flipY", options.flipY);
  Check_default.typeOf.bool("options.premultiplyAlpha", options.premultiplyAlpha);
  Check_default.typeOf.bool(
    "options.skipColorSpaceConversion",
    options.skipColorSpaceConversion
  );
  return createImageBitmap(blob, {
    imageOrientation: options.flipY ? "flipY" : "none",
    premultiplyAlpha: options.premultiplyAlpha ? "premultiply" : "none",
    colorSpaceConversion: options.skipColorSpaceConversion ? "none" : "default"
  });
};
function decodeResponse(loadWithHttpResponse, responseType) {
  switch (responseType) {
    case "text":
      return loadWithHttpResponse.toString("utf8");
    case "json":
      return JSON.parse(loadWithHttpResponse.toString("utf8"));
    default:
      return new Uint8Array(loadWithHttpResponse).buffer;
  }
}
function loadWithHttpRequest(url, responseType, method, data, headers, deferred, overrideMimeType) {
  let URL;
  let zlib;
  Promise.all([Promise.resolve().then(() => __toESM(require_url(), 1)), import("zlib")]).then(([urlImport, zlibImport]) => {
    URL = urlImport.parse(url);
    zlib = zlibImport;
    return URL.protocol === "https:" ? import("https") : import("http");
  }).then((http) => {
    const options = {
      protocol: URL.protocol,
      hostname: URL.hostname,
      port: URL.port,
      path: URL.path,
      query: URL.query,
      method,
      headers
    };
    http.request(options).on("response", function(res) {
      if (res.statusCode < 200 || res.statusCode >= 300) {
        deferred.reject(
          new RequestErrorEvent_default(res.statusCode, res, res.headers)
        );
        return;
      }
      const chunkArray = [];
      res.on("data", function(chunk) {
        chunkArray.push(chunk);
      });
      res.on("end", function() {
        const result = Buffer.concat(chunkArray);
        if (res.headers["content-encoding"] === "gzip") {
          zlib.gunzip(result, function(error, resultUnzipped) {
            if (error) {
              deferred.reject(
                new RuntimeError_default("Error decompressing response.")
              );
            } else {
              deferred.resolve(
                decodeResponse(resultUnzipped, responseType)
              );
            }
          });
        } else {
          deferred.resolve(decodeResponse(result, responseType));
        }
      });
    }).on("error", function(e) {
      deferred.reject(new RequestErrorEvent_default());
    }).end();
  });
}
var noXMLHttpRequest = typeof XMLHttpRequest === "undefined";
Resource._Implementations.loadWithXhr = function(url, responseType, method, data, headers, deferred, overrideMimeType) {
  const dataUriRegexResult = dataUriRegex2.exec(url);
  if (dataUriRegexResult !== null) {
    deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));
    return;
  }
  if (noXMLHttpRequest) {
    loadWithHttpRequest(
      url,
      responseType,
      method,
      data,
      headers,
      deferred,
      overrideMimeType
    );
    return;
  }
  const xhr = new XMLHttpRequest();
  if (TrustedServers_default.contains(url)) {
    xhr.withCredentials = true;
  }
  xhr.open(method, url, true);
  if (defined_default(overrideMimeType) && defined_default(xhr.overrideMimeType)) {
    xhr.overrideMimeType(overrideMimeType);
  }
  if (defined_default(headers)) {
    for (const key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  }
  if (defined_default(responseType)) {
    xhr.responseType = responseType;
  }
  let localFile = false;
  if (typeof url === "string") {
    localFile = url.indexOf("file://") === 0 || typeof window !== "undefined" && window.location.origin === "file://";
  }
  xhr.onload = function() {
    if ((xhr.status < 200 || xhr.status >= 300) && !(localFile && xhr.status === 0)) {
      deferred.reject(
        new RequestErrorEvent_default(
          xhr.status,
          xhr.response,
          xhr.getAllResponseHeaders()
        )
      );
      return;
    }
    const response = xhr.response;
    const browserResponseType = xhr.responseType;
    if (method === "HEAD" || method === "OPTIONS") {
      const responseHeaderString = xhr.getAllResponseHeaders();
      const splitHeaders = responseHeaderString.trim().split(/[\r\n]+/);
      const responseHeaders = {};
      splitHeaders.forEach(function(line) {
        const parts = line.split(": ");
        const header = parts.shift();
        responseHeaders[header] = parts.join(": ");
      });
      deferred.resolve(responseHeaders);
      return;
    }
    if (xhr.status === 204) {
      deferred.resolve();
    } else if (defined_default(response) && (!defined_default(responseType) || browserResponseType === responseType)) {
      deferred.resolve(response);
    } else if (responseType === "json" && typeof response === "string") {
      try {
        deferred.resolve(JSON.parse(response));
      } catch (e) {
        deferred.reject(e);
      }
    } else if ((browserResponseType === "" || browserResponseType === "document") && defined_default(xhr.responseXML) && xhr.responseXML.hasChildNodes()) {
      deferred.resolve(xhr.responseXML);
    } else if ((browserResponseType === "" || browserResponseType === "text") && defined_default(xhr.responseText)) {
      deferred.resolve(xhr.responseText);
    } else {
      deferred.reject(
        new RuntimeError_default("Invalid XMLHttpRequest response type.")
      );
    }
  };
  xhr.onerror = function(e) {
    deferred.reject(new RequestErrorEvent_default());
  };
  xhr.send(data);
  return xhr;
};
Resource._Implementations.loadAndExecuteScript = function(url, functionName, deferred) {
  return loadAndExecuteScript_default(url, functionName).catch(function(e) {
    deferred.reject(e);
  });
};
Resource._DefaultImplementations = {};
Resource._DefaultImplementations.createImage = Resource._Implementations.createImage;
Resource._DefaultImplementations.loadWithXhr = Resource._Implementations.loadWithXhr;
Resource._DefaultImplementations.loadAndExecuteScript = Resource._Implementations.loadAndExecuteScript;
Resource.DEFAULT = Object.freeze(
  new Resource({
    url: typeof document === "undefined" ? "" : document.location.href.split("?")[0]
  })
);
var Resource_default = Resource;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/EarthOrientationParameters.js
function EarthOrientationParameters(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._dates = void 0;
  this._samples = void 0;
  this._dateColumn = -1;
  this._xPoleWanderRadiansColumn = -1;
  this._yPoleWanderRadiansColumn = -1;
  this._ut1MinusUtcSecondsColumn = -1;
  this._xCelestialPoleOffsetRadiansColumn = -1;
  this._yCelestialPoleOffsetRadiansColumn = -1;
  this._taiMinusUtcSecondsColumn = -1;
  this._columnCount = 0;
  this._lastIndex = -1;
  this._downloadPromise = void 0;
  this._dataError = void 0;
  this._addNewLeapSeconds = defaultValue_default(options.addNewLeapSeconds, true);
  if (defined_default(options.data)) {
    onDataReady(this, options.data);
  } else if (defined_default(options.url)) {
    const resource = Resource_default.createIfNeeded(options.url);
    const that = this;
    this._downloadPromise = resource.fetchJson().then(function(eopData) {
      onDataReady(that, eopData);
    }).catch(function() {
      that._dataError = `An error occurred while retrieving the EOP data from the URL ${resource.url}.`;
    });
  } else {
    onDataReady(this, {
      columnNames: [
        "dateIso8601",
        "modifiedJulianDateUtc",
        "xPoleWanderRadians",
        "yPoleWanderRadians",
        "ut1MinusUtcSeconds",
        "lengthOfDayCorrectionSeconds",
        "xCelestialPoleOffsetRadians",
        "yCelestialPoleOffsetRadians",
        "taiMinusUtcSeconds"
      ],
      samples: []
    });
  }
}
EarthOrientationParameters.NONE = Object.freeze({
  getPromiseToLoad: function() {
    return Promise.resolve();
  },
  compute: function(date, result) {
    if (!defined_default(result)) {
      result = new EarthOrientationParametersSample_default(0, 0, 0, 0, 0);
    } else {
      result.xPoleWander = 0;
      result.yPoleWander = 0;
      result.xPoleOffset = 0;
      result.yPoleOffset = 0;
      result.ut1MinusUtc = 0;
    }
    return result;
  }
});
EarthOrientationParameters.prototype.getPromiseToLoad = function() {
  return Promise.resolve(this._downloadPromise);
};
EarthOrientationParameters.prototype.compute = function(date, result) {
  if (!defined_default(this._samples)) {
    if (defined_default(this._dataError)) {
      throw new RuntimeError_default(this._dataError);
    }
    return void 0;
  }
  if (!defined_default(result)) {
    result = new EarthOrientationParametersSample_default(0, 0, 0, 0, 0);
  }
  if (this._samples.length === 0) {
    result.xPoleWander = 0;
    result.yPoleWander = 0;
    result.xPoleOffset = 0;
    result.yPoleOffset = 0;
    result.ut1MinusUtc = 0;
    return result;
  }
  const dates = this._dates;
  const lastIndex = this._lastIndex;
  let before = 0;
  let after = 0;
  if (defined_default(lastIndex)) {
    const previousIndexDate = dates[lastIndex];
    const nextIndexDate = dates[lastIndex + 1];
    const isAfterPrevious = JulianDate_default.lessThanOrEquals(
      previousIndexDate,
      date
    );
    const isAfterLastSample = !defined_default(nextIndexDate);
    const isBeforeNext = isAfterLastSample || JulianDate_default.greaterThanOrEquals(nextIndexDate, date);
    if (isAfterPrevious && isBeforeNext) {
      before = lastIndex;
      if (!isAfterLastSample && nextIndexDate.equals(date)) {
        ++before;
      }
      after = before + 1;
      interpolate(this, dates, this._samples, date, before, after, result);
      return result;
    }
  }
  let index = binarySearch_default(dates, date, JulianDate_default.compare, this._dateColumn);
  if (index >= 0) {
    if (index < dates.length - 1 && dates[index + 1].equals(date)) {
      ++index;
    }
    before = index;
    after = index;
  } else {
    after = ~index;
    before = after - 1;
    if (before < 0) {
      before = 0;
    }
  }
  this._lastIndex = before;
  interpolate(this, dates, this._samples, date, before, after, result);
  return result;
};
function compareLeapSecondDates2(leapSecond, dateToFind) {
  return JulianDate_default.compare(leapSecond.julianDate, dateToFind);
}
function onDataReady(eop, eopData) {
  if (!defined_default(eopData.columnNames)) {
    eop._dataError = "Error in loaded EOP data: The columnNames property is required.";
    return;
  }
  if (!defined_default(eopData.samples)) {
    eop._dataError = "Error in loaded EOP data: The samples property is required.";
    return;
  }
  const dateColumn = eopData.columnNames.indexOf("modifiedJulianDateUtc");
  const xPoleWanderRadiansColumn = eopData.columnNames.indexOf(
    "xPoleWanderRadians"
  );
  const yPoleWanderRadiansColumn = eopData.columnNames.indexOf(
    "yPoleWanderRadians"
  );
  const ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf(
    "ut1MinusUtcSeconds"
  );
  const xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(
    "xCelestialPoleOffsetRadians"
  );
  const yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(
    "yCelestialPoleOffsetRadians"
  );
  const taiMinusUtcSecondsColumn = eopData.columnNames.indexOf(
    "taiMinusUtcSeconds"
  );
  if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {
    eop._dataError = "Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns";
    return;
  }
  const samples = eop._samples = eopData.samples;
  const dates = eop._dates = [];
  eop._dateColumn = dateColumn;
  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;
  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;
  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;
  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;
  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;
  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;
  eop._columnCount = eopData.columnNames.length;
  eop._lastIndex = void 0;
  let lastTaiMinusUtc;
  const addNewLeapSeconds = eop._addNewLeapSeconds;
  for (let i = 0, len = samples.length; i < len; i += eop._columnCount) {
    const mjd = samples[i + dateColumn];
    const taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];
    const day = mjd + TimeConstants_default.MODIFIED_JULIAN_DATE_DIFFERENCE;
    const date = new JulianDate_default(day, taiMinusUtc, TimeStandard_default.TAI);
    dates.push(date);
    if (addNewLeapSeconds) {
      if (taiMinusUtc !== lastTaiMinusUtc && defined_default(lastTaiMinusUtc)) {
        const leapSeconds = JulianDate_default.leapSeconds;
        const leapSecondIndex = binarySearch_default(
          leapSeconds,
          date,
          compareLeapSecondDates2
        );
        if (leapSecondIndex < 0) {
          const leapSecond = new LeapSecond_default(date, taiMinusUtc);
          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);
        }
      }
      lastTaiMinusUtc = taiMinusUtc;
    }
  }
}
function fillResultFromIndex(eop, samples, index, columnCount, result) {
  const start = index * columnCount;
  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];
  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];
  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];
  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];
  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];
}
function linearInterp(dx, y1, y2) {
  return y1 + dx * (y2 - y1);
}
function interpolate(eop, dates, samples, date, before, after, result) {
  const columnCount = eop._columnCount;
  if (after > dates.length - 1) {
    result.xPoleWander = 0;
    result.yPoleWander = 0;
    result.xPoleOffset = 0;
    result.yPoleOffset = 0;
    result.ut1MinusUtc = 0;
    return result;
  }
  const beforeDate = dates[before];
  const afterDate = dates[after];
  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {
    fillResultFromIndex(eop, samples, before, columnCount, result);
    return result;
  } else if (date.equals(afterDate)) {
    fillResultFromIndex(eop, samples, after, columnCount, result);
    return result;
  }
  const factor = JulianDate_default.secondsDifference(date, beforeDate) / JulianDate_default.secondsDifference(afterDate, beforeDate);
  const startBefore = before * columnCount;
  const startAfter = after * columnCount;
  let beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];
  let afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];
  const offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;
  if (offsetDifference > 0.5 || offsetDifference < -0.5) {
    const beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];
    const afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];
    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {
      if (afterDate.equals(date)) {
        beforeUt1MinusUtc = afterUt1MinusUtc;
      } else {
        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;
      }
    }
  }
  result.xPoleWander = linearInterp(
    factor,
    samples[startBefore + eop._xPoleWanderRadiansColumn],
    samples[startAfter + eop._xPoleWanderRadiansColumn]
  );
  result.yPoleWander = linearInterp(
    factor,
    samples[startBefore + eop._yPoleWanderRadiansColumn],
    samples[startAfter + eop._yPoleWanderRadiansColumn]
  );
  result.xPoleOffset = linearInterp(
    factor,
    samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn],
    samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]
  );
  result.yPoleOffset = linearInterp(
    factor,
    samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn],
    samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]
  );
  result.ut1MinusUtc = linearInterp(
    factor,
    beforeUt1MinusUtc,
    afterUt1MinusUtc
  );
  return result;
}
var EarthOrientationParameters_default = EarthOrientationParameters;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/HeadingPitchRoll.js
function HeadingPitchRoll(heading, pitch, roll) {
  this.heading = defaultValue_default(heading, 0);
  this.pitch = defaultValue_default(pitch, 0);
  this.roll = defaultValue_default(roll, 0);
}
HeadingPitchRoll.fromQuaternion = function(quaternion, result) {
  if (!defined_default(quaternion)) {
    throw new DeveloperError_default("quaternion is required");
  }
  if (!defined_default(result)) {
    result = new HeadingPitchRoll();
  }
  const test = 2 * (quaternion.w * quaternion.y - quaternion.z * quaternion.x);
  const denominatorRoll = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
  const numeratorRoll = 2 * (quaternion.w * quaternion.x + quaternion.y * quaternion.z);
  const denominatorHeading = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
  const numeratorHeading = 2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);
  result.heading = -Math.atan2(numeratorHeading, denominatorHeading);
  result.roll = Math.atan2(numeratorRoll, denominatorRoll);
  result.pitch = -Math_default.asinClamped(test);
  return result;
};
HeadingPitchRoll.fromDegrees = function(heading, pitch, roll, result) {
  if (!defined_default(heading)) {
    throw new DeveloperError_default("heading is required");
  }
  if (!defined_default(pitch)) {
    throw new DeveloperError_default("pitch is required");
  }
  if (!defined_default(roll)) {
    throw new DeveloperError_default("roll is required");
  }
  if (!defined_default(result)) {
    result = new HeadingPitchRoll();
  }
  result.heading = heading * Math_default.RADIANS_PER_DEGREE;
  result.pitch = pitch * Math_default.RADIANS_PER_DEGREE;
  result.roll = roll * Math_default.RADIANS_PER_DEGREE;
  return result;
};
HeadingPitchRoll.clone = function(headingPitchRoll, result) {
  if (!defined_default(headingPitchRoll)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new HeadingPitchRoll(
      headingPitchRoll.heading,
      headingPitchRoll.pitch,
      headingPitchRoll.roll
    );
  }
  result.heading = headingPitchRoll.heading;
  result.pitch = headingPitchRoll.pitch;
  result.roll = headingPitchRoll.roll;
  return result;
};
HeadingPitchRoll.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.heading === right.heading && left.pitch === right.pitch && left.roll === right.roll;
};
HeadingPitchRoll.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
  return left === right || defined_default(left) && defined_default(right) && Math_default.equalsEpsilon(
    left.heading,
    right.heading,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.pitch,
    right.pitch,
    relativeEpsilon,
    absoluteEpsilon
  ) && Math_default.equalsEpsilon(
    left.roll,
    right.roll,
    relativeEpsilon,
    absoluteEpsilon
  );
};
HeadingPitchRoll.prototype.clone = function(result) {
  return HeadingPitchRoll.clone(this, result);
};
HeadingPitchRoll.prototype.equals = function(right) {
  return HeadingPitchRoll.equals(this, right);
};
HeadingPitchRoll.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
  return HeadingPitchRoll.equalsEpsilon(
    this,
    right,
    relativeEpsilon,
    absoluteEpsilon
  );
};
HeadingPitchRoll.prototype.toString = function() {
  return `(${this.heading}, ${this.pitch}, ${this.roll})`;
};
var HeadingPitchRoll_default = HeadingPitchRoll;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/buildModuleUrl.js
var cesiumScriptRegex = /((?:.*\/)|^)Cesium\.js(?:\?|\#|$)/;
function getBaseUrlFromCesiumScript() {
  const scripts = document.getElementsByTagName("script");
  for (let i = 0, len = scripts.length; i < len; ++i) {
    const src = scripts[i].getAttribute("src");
    const result = cesiumScriptRegex.exec(src);
    if (result !== null) {
      return result[1];
    }
  }
  return void 0;
}
var a2;
function tryMakeAbsolute(url) {
  if (typeof document === "undefined") {
    return url;
  }
  if (!defined_default(a2)) {
    a2 = document.createElement("a");
  }
  a2.href = url;
  a2.href = a2.href;
  return a2.href;
}
var baseResource;
function getCesiumBaseUrl() {
  if (defined_default(baseResource)) {
    return baseResource;
  }
  let baseUrlString;
  if (typeof CESIUM_BASE_URL !== "undefined") {
    baseUrlString = CESIUM_BASE_URL;
  } else if (typeof define === "object" && defined_default(define.amd) && !define.amd.toUrlUndefined && defined_default(__require.toUrl)) {
    baseUrlString = getAbsoluteUri_default(
      "..",
      buildModuleUrl("Core/buildModuleUrl.js")
    );
  } else {
    baseUrlString = getBaseUrlFromCesiumScript();
  }
  if (!defined_default(baseUrlString)) {
    throw new DeveloperError_default(
      "Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL."
    );
  }
  baseResource = new Resource_default({
    url: tryMakeAbsolute(baseUrlString)
  });
  baseResource.appendForwardSlash();
  return baseResource;
}
function buildModuleUrlFromRequireToUrl(moduleID) {
  return tryMakeAbsolute(__require.toUrl(`../${moduleID}`));
}
function buildModuleUrlFromBaseUrl(moduleID) {
  const resource = getCesiumBaseUrl().getDerivedResource({
    url: moduleID
  });
  return resource.url;
}
var implementation;
function buildModuleUrl(relativeUrl) {
  if (!defined_default(implementation)) {
    if (typeof define === "object" && defined_default(define.amd) && !define.amd.toUrlUndefined && defined_default(__require.toUrl)) {
      implementation = buildModuleUrlFromRequireToUrl;
    } else {
      implementation = buildModuleUrlFromBaseUrl;
    }
  }
  const url = implementation(relativeUrl);
  return url;
}
buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;
buildModuleUrl._buildModuleUrlFromBaseUrl = buildModuleUrlFromBaseUrl;
buildModuleUrl._clearBaseResource = function() {
  baseResource = void 0;
};
buildModuleUrl.setBaseUrl = function(value) {
  baseResource = Resource_default.DEFAULT.getDerivedResource({
    url: value
  });
};
buildModuleUrl.getCesiumBaseUrl = getCesiumBaseUrl;
var buildModuleUrl_default = buildModuleUrl;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Iau2006XysSample.js
function Iau2006XysSample(x, y, s) {
  this.x = x;
  this.y = y;
  this.s = s;
}
var Iau2006XysSample_default = Iau2006XysSample;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Iau2006XysData.js
function Iau2006XysData(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._xysFileUrlTemplate = Resource_default.createIfNeeded(
    options.xysFileUrlTemplate
  );
  this._interpolationOrder = defaultValue_default(options.interpolationOrder, 9);
  this._sampleZeroJulianEphemerisDate = defaultValue_default(
    options.sampleZeroJulianEphemerisDate,
    24423965e-1
  );
  this._sampleZeroDateTT = new JulianDate_default(
    this._sampleZeroJulianEphemerisDate,
    0,
    TimeStandard_default.TAI
  );
  this._stepSizeDays = defaultValue_default(options.stepSizeDays, 1);
  this._samplesPerXysFile = defaultValue_default(options.samplesPerXysFile, 1e3);
  this._totalSamples = defaultValue_default(options.totalSamples, 27426);
  this._samples = new Array(this._totalSamples * 3);
  this._chunkDownloadsInProgress = [];
  const order = this._interpolationOrder;
  const denom = this._denominators = new Array(order + 1);
  const xTable = this._xTable = new Array(order + 1);
  const stepN = Math.pow(this._stepSizeDays, order);
  for (let i = 0; i <= order; ++i) {
    denom[i] = stepN;
    xTable[i] = i * this._stepSizeDays;
    for (let j = 0; j <= order; ++j) {
      if (j !== i) {
        denom[i] *= i - j;
      }
    }
    denom[i] = 1 / denom[i];
  }
  this._work = new Array(order + 1);
  this._coef = new Array(order + 1);
}
var julianDateScratch = new JulianDate_default(0, 0, TimeStandard_default.TAI);
function getDaysSinceEpoch(xys, dayTT, secondTT) {
  const dateTT = julianDateScratch;
  dateTT.dayNumber = dayTT;
  dateTT.secondsOfDay = secondTT;
  return JulianDate_default.daysDifference(dateTT, xys._sampleZeroDateTT);
}
Iau2006XysData.prototype.preload = function(startDayTT, startSecondTT, stopDayTT, stopSecondTT) {
  const startDaysSinceEpoch = getDaysSinceEpoch(
    this,
    startDayTT,
    startSecondTT
  );
  const stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);
  let startIndex = startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2 | 0;
  if (startIndex < 0) {
    startIndex = 0;
  }
  let stopIndex = stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2 | 0 + this._interpolationOrder;
  if (stopIndex >= this._totalSamples) {
    stopIndex = this._totalSamples - 1;
  }
  const startChunk = startIndex / this._samplesPerXysFile | 0;
  const stopChunk = stopIndex / this._samplesPerXysFile | 0;
  const promises = [];
  for (let i = startChunk; i <= stopChunk; ++i) {
    promises.push(requestXysChunk(this, i));
  }
  return Promise.all(promises);
};
Iau2006XysData.prototype.computeXysRadians = function(dayTT, secondTT, result) {
  const daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);
  if (daysSinceEpoch < 0) {
    return void 0;
  }
  const centerIndex = daysSinceEpoch / this._stepSizeDays | 0;
  if (centerIndex >= this._totalSamples) {
    return void 0;
  }
  const degree = this._interpolationOrder;
  let firstIndex = centerIndex - (degree / 2 | 0);
  if (firstIndex < 0) {
    firstIndex = 0;
  }
  let lastIndex = firstIndex + degree;
  if (lastIndex >= this._totalSamples) {
    lastIndex = this._totalSamples - 1;
    firstIndex = lastIndex - degree;
    if (firstIndex < 0) {
      firstIndex = 0;
    }
  }
  let isDataMissing = false;
  const samples = this._samples;
  if (!defined_default(samples[firstIndex * 3])) {
    requestXysChunk(this, firstIndex / this._samplesPerXysFile | 0);
    isDataMissing = true;
  }
  if (!defined_default(samples[lastIndex * 3])) {
    requestXysChunk(this, lastIndex / this._samplesPerXysFile | 0);
    isDataMissing = true;
  }
  if (isDataMissing) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new Iau2006XysSample_default(0, 0, 0);
  } else {
    result.x = 0;
    result.y = 0;
    result.s = 0;
  }
  const x = daysSinceEpoch - firstIndex * this._stepSizeDays;
  const work = this._work;
  const denom = this._denominators;
  const coef = this._coef;
  const xTable = this._xTable;
  let i, j;
  for (i = 0; i <= degree; ++i) {
    work[i] = x - xTable[i];
  }
  for (i = 0; i <= degree; ++i) {
    coef[i] = 1;
    for (j = 0; j <= degree; ++j) {
      if (j !== i) {
        coef[i] *= work[j];
      }
    }
    coef[i] *= denom[i];
    let sampleIndex = (firstIndex + i) * 3;
    result.x += coef[i] * samples[sampleIndex++];
    result.y += coef[i] * samples[sampleIndex++];
    result.s += coef[i] * samples[sampleIndex];
  }
  return result;
};
function requestXysChunk(xysData, chunkIndex) {
  if (xysData._chunkDownloadsInProgress[chunkIndex]) {
    return xysData._chunkDownloadsInProgress[chunkIndex];
  }
  let chunkUrl;
  const xysFileUrlTemplate = xysData._xysFileUrlTemplate;
  if (defined_default(xysFileUrlTemplate)) {
    chunkUrl = xysFileUrlTemplate.getDerivedResource({
      templateValues: {
        0: chunkIndex
      }
    });
  } else {
    chunkUrl = new Resource_default({
      url: buildModuleUrl_default(`Assets/IAU2006_XYS/IAU2006_XYS_${chunkIndex}.json`)
    });
  }
  const promise = chunkUrl.fetchJson().then(function(chunk) {
    xysData._chunkDownloadsInProgress[chunkIndex] = false;
    const samples = xysData._samples;
    const newSamples = chunk.samples;
    const startIndex = chunkIndex * xysData._samplesPerXysFile * 3;
    for (let i = 0, len = newSamples.length; i < len; ++i) {
      samples[startIndex + i] = newSamples[i];
    }
  });
  xysData._chunkDownloadsInProgress[chunkIndex] = promise;
  return promise;
}
var Iau2006XysData_default = Iau2006XysData;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Transforms.js
var Transforms = {};
var vectorProductLocalFrame = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
};
var degeneratePositionLocalFrame = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
};
var localFrameToFixedFrameCache = {};
var scratchCalculateCartesian = {
  east: new Cartesian3_default(),
  north: new Cartesian3_default(),
  up: new Cartesian3_default(),
  west: new Cartesian3_default(),
  south: new Cartesian3_default(),
  down: new Cartesian3_default()
};
var scratchFirstCartesian = new Cartesian3_default();
var scratchSecondCartesian = new Cartesian3_default();
var scratchThirdCartesian = new Cartesian3_default();
Transforms.localFrameToFixedFrameGenerator = function(firstAxis, secondAxis) {
  if (!vectorProductLocalFrame.hasOwnProperty(firstAxis) || !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)) {
    throw new DeveloperError_default(
      "firstAxis and secondAxis must be east, north, up, west, south or down."
    );
  }
  const thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];
  let resultat;
  const hashAxis = firstAxis + secondAxis;
  if (defined_default(localFrameToFixedFrameCache[hashAxis])) {
    resultat = localFrameToFixedFrameCache[hashAxis];
  } else {
    resultat = function(origin, ellipsoid, result) {
      if (!defined_default(origin)) {
        throw new DeveloperError_default("origin is required.");
      }
      if (!defined_default(result)) {
        result = new Matrix4_default();
      }
      if (Cartesian3_default.equalsEpsilon(origin, Cartesian3_default.ZERO, Math_default.EPSILON14)) {
        Cartesian3_default.unpack(
          degeneratePositionLocalFrame[firstAxis],
          0,
          scratchFirstCartesian
        );
        Cartesian3_default.unpack(
          degeneratePositionLocalFrame[secondAxis],
          0,
          scratchSecondCartesian
        );
        Cartesian3_default.unpack(
          degeneratePositionLocalFrame[thirdAxis],
          0,
          scratchThirdCartesian
        );
      } else if (Math_default.equalsEpsilon(origin.x, 0, Math_default.EPSILON14) && Math_default.equalsEpsilon(origin.y, 0, Math_default.EPSILON14)) {
        const sign2 = Math_default.sign(origin.z);
        Cartesian3_default.unpack(
          degeneratePositionLocalFrame[firstAxis],
          0,
          scratchFirstCartesian
        );
        if (firstAxis !== "east" && firstAxis !== "west") {
          Cartesian3_default.multiplyByScalar(
            scratchFirstCartesian,
            sign2,
            scratchFirstCartesian
          );
        }
        Cartesian3_default.unpack(
          degeneratePositionLocalFrame[secondAxis],
          0,
          scratchSecondCartesian
        );
        if (secondAxis !== "east" && secondAxis !== "west") {
          Cartesian3_default.multiplyByScalar(
            scratchSecondCartesian,
            sign2,
            scratchSecondCartesian
          );
        }
        Cartesian3_default.unpack(
          degeneratePositionLocalFrame[thirdAxis],
          0,
          scratchThirdCartesian
        );
        if (thirdAxis !== "east" && thirdAxis !== "west") {
          Cartesian3_default.multiplyByScalar(
            scratchThirdCartesian,
            sign2,
            scratchThirdCartesian
          );
        }
      } else {
        ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);
        const up = scratchCalculateCartesian.up;
        const east = scratchCalculateCartesian.east;
        east.x = -origin.y;
        east.y = origin.x;
        east.z = 0;
        Cartesian3_default.normalize(east, scratchCalculateCartesian.east);
        Cartesian3_default.cross(up, east, scratchCalculateCartesian.north);
        Cartesian3_default.multiplyByScalar(
          scratchCalculateCartesian.up,
          -1,
          scratchCalculateCartesian.down
        );
        Cartesian3_default.multiplyByScalar(
          scratchCalculateCartesian.east,
          -1,
          scratchCalculateCartesian.west
        );
        Cartesian3_default.multiplyByScalar(
          scratchCalculateCartesian.north,
          -1,
          scratchCalculateCartesian.south
        );
        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];
        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];
        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];
      }
      result[0] = scratchFirstCartesian.x;
      result[1] = scratchFirstCartesian.y;
      result[2] = scratchFirstCartesian.z;
      result[3] = 0;
      result[4] = scratchSecondCartesian.x;
      result[5] = scratchSecondCartesian.y;
      result[6] = scratchSecondCartesian.z;
      result[7] = 0;
      result[8] = scratchThirdCartesian.x;
      result[9] = scratchThirdCartesian.y;
      result[10] = scratchThirdCartesian.z;
      result[11] = 0;
      result[12] = origin.x;
      result[13] = origin.y;
      result[14] = origin.z;
      result[15] = 1;
      return result;
    };
    localFrameToFixedFrameCache[hashAxis] = resultat;
  }
  return resultat;
};
Transforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "east",
  "north"
);
Transforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "north",
  "east"
);
Transforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "north",
  "up"
);
Transforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "north",
  "west"
);
var scratchHPRQuaternion2 = new Quaternion_default();
var scratchScale = new Cartesian3_default(1, 1, 1);
var scratchHPRMatrix4 = new Matrix4_default();
Transforms.headingPitchRollToFixedFrame = function(origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) {
  Check_default.typeOf.object("HeadingPitchRoll", headingPitchRoll);
  fixedFrameTransform = defaultValue_default(
    fixedFrameTransform,
    Transforms.eastNorthUpToFixedFrame
  );
  const hprQuaternion = Quaternion_default.fromHeadingPitchRoll(
    headingPitchRoll,
    scratchHPRQuaternion2
  );
  const hprMatrix = Matrix4_default.fromTranslationQuaternionRotationScale(
    Cartesian3_default.ZERO,
    hprQuaternion,
    scratchScale,
    scratchHPRMatrix4
  );
  result = fixedFrameTransform(origin, ellipsoid, result);
  return Matrix4_default.multiply(result, hprMatrix, result);
};
var scratchENUMatrix4 = new Matrix4_default();
var scratchHPRMatrix3 = new Matrix3_default();
Transforms.headingPitchRollQuaternion = function(origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) {
  Check_default.typeOf.object("HeadingPitchRoll", headingPitchRoll);
  const transform = Transforms.headingPitchRollToFixedFrame(
    origin,
    headingPitchRoll,
    ellipsoid,
    fixedFrameTransform,
    scratchENUMatrix4
  );
  const rotation = Matrix4_default.getMatrix3(transform, scratchHPRMatrix3);
  return Quaternion_default.fromRotationMatrix(rotation, result);
};
var noScale = new Cartesian3_default(1, 1, 1);
var hprCenterScratch = new Cartesian3_default();
var ffScratch = new Matrix4_default();
var hprTransformScratch = new Matrix4_default();
var hprRotationScratch = new Matrix3_default();
var hprQuaternionScratch = new Quaternion_default();
Transforms.fixedFrameToHeadingPitchRoll = function(transform, ellipsoid, fixedFrameTransform, result) {
  Check_default.defined("transform", transform);
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  fixedFrameTransform = defaultValue_default(
    fixedFrameTransform,
    Transforms.eastNorthUpToFixedFrame
  );
  if (!defined_default(result)) {
    result = new HeadingPitchRoll_default();
  }
  const center = Matrix4_default.getTranslation(transform, hprCenterScratch);
  if (Cartesian3_default.equals(center, Cartesian3_default.ZERO)) {
    result.heading = 0;
    result.pitch = 0;
    result.roll = 0;
    return result;
  }
  let toFixedFrame = Matrix4_default.inverseTransformation(
    fixedFrameTransform(center, ellipsoid, ffScratch),
    ffScratch
  );
  let transformCopy = Matrix4_default.setScale(transform, noScale, hprTransformScratch);
  transformCopy = Matrix4_default.setTranslation(
    transformCopy,
    Cartesian3_default.ZERO,
    transformCopy
  );
  toFixedFrame = Matrix4_default.multiply(toFixedFrame, transformCopy, toFixedFrame);
  let quaternionRotation = Quaternion_default.fromRotationMatrix(
    Matrix4_default.getMatrix3(toFixedFrame, hprRotationScratch),
    hprQuaternionScratch
  );
  quaternionRotation = Quaternion_default.normalize(
    quaternionRotation,
    quaternionRotation
  );
  return HeadingPitchRoll_default.fromQuaternion(quaternionRotation, result);
};
var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
var gmstConstant1 = 8640184812866e-6;
var gmstConstant2 = 0.093104;
var gmstConstant3 = -62e-7;
var rateCoef = 11772758384668e-32;
var wgs84WRPrecessing = 72921158553e-15;
var twoPiOverSecondsInDay = Math_default.TWO_PI / 86400;
var dateInUtc = new JulianDate_default();
Transforms.computeTemeToPseudoFixedMatrix = function(date, result) {
  if (!defined_default(date)) {
    throw new DeveloperError_default("date is required.");
  }
  dateInUtc = JulianDate_default.addSeconds(
    date,
    -JulianDate_default.computeTaiMinusUtc(date),
    dateInUtc
  );
  const utcDayNumber = dateInUtc.dayNumber;
  const utcSecondsIntoDay = dateInUtc.secondsOfDay;
  let t;
  const diffDays = utcDayNumber - 2451545;
  if (utcSecondsIntoDay >= 43200) {
    t = (diffDays + 0.5) / TimeConstants_default.DAYS_PER_JULIAN_CENTURY;
  } else {
    t = (diffDays - 0.5) / TimeConstants_default.DAYS_PER_JULIAN_CENTURY;
  }
  const gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
  const angle = gmst0 * twoPiOverSecondsInDay % Math_default.TWO_PI;
  const ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 24515455e-1);
  const secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants_default.SECONDS_PER_DAY * 0.5) % TimeConstants_default.SECONDS_PER_DAY;
  const gha = angle + ratio * secondsSinceMidnight;
  const cosGha = Math.cos(gha);
  const sinGha = Math.sin(gha);
  if (!defined_default(result)) {
    return new Matrix3_default(
      cosGha,
      sinGha,
      0,
      -sinGha,
      cosGha,
      0,
      0,
      0,
      1
    );
  }
  result[0] = cosGha;
  result[1] = -sinGha;
  result[2] = 0;
  result[3] = sinGha;
  result[4] = cosGha;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 1;
  return result;
};
Transforms.iau2006XysData = new Iau2006XysData_default();
Transforms.earthOrientationParameters = EarthOrientationParameters_default.NONE;
var ttMinusTai = 32.184;
var j2000ttDays = 2451545;
Transforms.preloadIcrfFixed = function(timeInterval) {
  const startDayTT = timeInterval.start.dayNumber;
  const startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;
  const stopDayTT = timeInterval.stop.dayNumber;
  const stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;
  const xysPromise = Transforms.iau2006XysData.preload(
    startDayTT,
    startSecondTT,
    stopDayTT,
    stopSecondTT
  );
  const eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();
  return Promise.all([xysPromise, eopPromise]);
};
Transforms.computeIcrfToFixedMatrix = function(date, result) {
  if (!defined_default(date)) {
    throw new DeveloperError_default("date is required.");
  }
  if (!defined_default(result)) {
    result = new Matrix3_default();
  }
  const fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);
  if (!defined_default(fixedToIcrfMtx)) {
    return void 0;
  }
  return Matrix3_default.transpose(fixedToIcrfMtx, result);
};
var xysScratch = new Iau2006XysSample_default(0, 0, 0);
var eopScratch = new EarthOrientationParametersSample_default(
  0,
  0,
  0,
  0,
  0,
  0
);
var rotation1Scratch = new Matrix3_default();
var rotation2Scratch = new Matrix3_default();
Transforms.computeFixedToIcrfMatrix = function(date, result) {
  if (!defined_default(date)) {
    throw new DeveloperError_default("date is required.");
  }
  if (!defined_default(result)) {
    result = new Matrix3_default();
  }
  const eop = Transforms.earthOrientationParameters.compute(date, eopScratch);
  if (!defined_default(eop)) {
    return void 0;
  }
  const dayTT = date.dayNumber;
  const secondTT = date.secondsOfDay + ttMinusTai;
  const xys = Transforms.iau2006XysData.computeXysRadians(
    dayTT,
    secondTT,
    xysScratch
  );
  if (!defined_default(xys)) {
    return void 0;
  }
  const x = xys.x + eop.xPoleOffset;
  const y = xys.y + eop.yPoleOffset;
  const a3 = 1 / (1 + Math.sqrt(1 - x * x - y * y));
  const rotation1 = rotation1Scratch;
  rotation1[0] = 1 - a3 * x * x;
  rotation1[3] = -a3 * x * y;
  rotation1[6] = x;
  rotation1[1] = -a3 * x * y;
  rotation1[4] = 1 - a3 * y * y;
  rotation1[7] = y;
  rotation1[2] = -x;
  rotation1[5] = -y;
  rotation1[8] = 1 - a3 * (x * x + y * y);
  const rotation2 = Matrix3_default.fromRotationZ(-xys.s, rotation2Scratch);
  const matrixQ = Matrix3_default.multiply(rotation1, rotation2, rotation1Scratch);
  const dateUt1day = date.dayNumber;
  const dateUt1sec = date.secondsOfDay - JulianDate_default.computeTaiMinusUtc(date) + eop.ut1MinusUtc;
  const daysSinceJ2000 = dateUt1day - 2451545;
  const fractionOfDay = dateUt1sec / TimeConstants_default.SECONDS_PER_DAY;
  let era = 0.779057273264 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);
  era = era % 1 * Math_default.TWO_PI;
  const earthRotation = Matrix3_default.fromRotationZ(era, rotation2Scratch);
  const pfToIcrf = Matrix3_default.multiply(matrixQ, earthRotation, rotation1Scratch);
  const cosxp = Math.cos(eop.xPoleWander);
  const cosyp = Math.cos(eop.yPoleWander);
  const sinxp = Math.sin(eop.xPoleWander);
  const sinyp = Math.sin(eop.yPoleWander);
  let ttt = dayTT - j2000ttDays + secondTT / TimeConstants_default.SECONDS_PER_DAY;
  ttt /= 36525;
  const sp = -47e-6 * ttt * Math_default.RADIANS_PER_DEGREE / 3600;
  const cossp = Math.cos(sp);
  const sinsp = Math.sin(sp);
  const fToPfMtx = rotation2Scratch;
  fToPfMtx[0] = cosxp * cossp;
  fToPfMtx[1] = cosxp * sinsp;
  fToPfMtx[2] = sinxp;
  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;
  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;
  fToPfMtx[5] = -sinyp * cosxp;
  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;
  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;
  fToPfMtx[8] = cosyp * cosxp;
  return Matrix3_default.multiply(pfToIcrf, fToPfMtx, result);
};
var pointToWindowCoordinatesTemp = new Cartesian4_default();
Transforms.pointToWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {
  result = Transforms.pointToGLWindowCoordinates(
    modelViewProjectionMatrix,
    viewportTransformation,
    point,
    result
  );
  result.y = 2 * viewportTransformation[5] - result.y;
  return result;
};
Transforms.pointToGLWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {
  if (!defined_default(modelViewProjectionMatrix)) {
    throw new DeveloperError_default("modelViewProjectionMatrix is required.");
  }
  if (!defined_default(viewportTransformation)) {
    throw new DeveloperError_default("viewportTransformation is required.");
  }
  if (!defined_default(point)) {
    throw new DeveloperError_default("point is required.");
  }
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  const tmp2 = pointToWindowCoordinatesTemp;
  Matrix4_default.multiplyByVector(
    modelViewProjectionMatrix,
    Cartesian4_default.fromElements(point.x, point.y, point.z, 1, tmp2),
    tmp2
  );
  Cartesian4_default.multiplyByScalar(tmp2, 1 / tmp2.w, tmp2);
  Matrix4_default.multiplyByVector(viewportTransformation, tmp2, tmp2);
  return Cartesian2_default.fromCartesian4(tmp2, result);
};
var normalScratch = new Cartesian3_default();
var rightScratch = new Cartesian3_default();
var upScratch = new Cartesian3_default();
Transforms.rotationMatrixFromPositionVelocity = function(position, velocity, ellipsoid, result) {
  if (!defined_default(position)) {
    throw new DeveloperError_default("position is required.");
  }
  if (!defined_default(velocity)) {
    throw new DeveloperError_default("velocity is required.");
  }
  const normal2 = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84).geodeticSurfaceNormal(
    position,
    normalScratch
  );
  let right = Cartesian3_default.cross(velocity, normal2, rightScratch);
  if (Cartesian3_default.equalsEpsilon(right, Cartesian3_default.ZERO, Math_default.EPSILON6)) {
    right = Cartesian3_default.clone(Cartesian3_default.UNIT_X, right);
  }
  const up = Cartesian3_default.cross(right, velocity, upScratch);
  Cartesian3_default.normalize(up, up);
  Cartesian3_default.cross(velocity, up, right);
  Cartesian3_default.negate(right, right);
  Cartesian3_default.normalize(right, right);
  if (!defined_default(result)) {
    result = new Matrix3_default();
  }
  result[0] = velocity.x;
  result[1] = velocity.y;
  result[2] = velocity.z;
  result[3] = right.x;
  result[4] = right.y;
  result[5] = right.z;
  result[6] = up.x;
  result[7] = up.y;
  result[8] = up.z;
  return result;
};
var swizzleMatrix = new Matrix4_default(
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1
);
var scratchCartographic = new Cartographic_default();
var scratchCartesian3Projection = new Cartesian3_default();
var scratchCenter = new Cartesian3_default();
var scratchRotation = new Matrix3_default();
var scratchFromENU = new Matrix4_default();
var scratchToENU = new Matrix4_default();
Transforms.basisTo2D = function(projection, matrix, result) {
  if (!defined_default(projection)) {
    throw new DeveloperError_default("projection is required.");
  }
  if (!defined_default(matrix)) {
    throw new DeveloperError_default("matrix is required.");
  }
  if (!defined_default(result)) {
    throw new DeveloperError_default("result is required.");
  }
  const rtcCenter = Matrix4_default.getTranslation(matrix, scratchCenter);
  const ellipsoid = projection.ellipsoid;
  const cartographic = ellipsoid.cartesianToCartographic(
    rtcCenter,
    scratchCartographic
  );
  const projectedPosition = projection.project(
    cartographic,
    scratchCartesian3Projection
  );
  Cartesian3_default.fromElements(
    projectedPosition.z,
    projectedPosition.x,
    projectedPosition.y,
    projectedPosition
  );
  const fromENU = Transforms.eastNorthUpToFixedFrame(
    rtcCenter,
    ellipsoid,
    scratchFromENU
  );
  const toENU = Matrix4_default.inverseTransformation(fromENU, scratchToENU);
  const rotation = Matrix4_default.getMatrix3(matrix, scratchRotation);
  const local = Matrix4_default.multiplyByMatrix3(toENU, rotation, result);
  Matrix4_default.multiply(swizzleMatrix, local, result);
  Matrix4_default.setTranslation(result, projectedPosition, result);
  return result;
};
Transforms.wgs84To2DModelMatrix = function(projection, center, result) {
  if (!defined_default(projection)) {
    throw new DeveloperError_default("projection is required.");
  }
  if (!defined_default(center)) {
    throw new DeveloperError_default("center is required.");
  }
  if (!defined_default(result)) {
    throw new DeveloperError_default("result is required.");
  }
  const ellipsoid = projection.ellipsoid;
  const fromENU = Transforms.eastNorthUpToFixedFrame(
    center,
    ellipsoid,
    scratchFromENU
  );
  const toENU = Matrix4_default.inverseTransformation(fromENU, scratchToENU);
  const cartographic = ellipsoid.cartesianToCartographic(
    center,
    scratchCartographic
  );
  const projectedPosition = projection.project(
    cartographic,
    scratchCartesian3Projection
  );
  Cartesian3_default.fromElements(
    projectedPosition.z,
    projectedPosition.x,
    projectedPosition.y,
    projectedPosition
  );
  const translation = Matrix4_default.fromTranslation(
    projectedPosition,
    scratchFromENU
  );
  Matrix4_default.multiply(swizzleMatrix, toENU, result);
  Matrix4_default.multiply(translation, result, result);
  return result;
};
var Transforms_default = Transforms;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Geometry.js
function Geometry(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.typeOf.object("options.attributes", options.attributes);
  this.attributes = options.attributes;
  this.indices = options.indices;
  this.primitiveType = defaultValue_default(
    options.primitiveType,
    PrimitiveType_default.TRIANGLES
  );
  this.boundingSphere = options.boundingSphere;
  this.geometryType = defaultValue_default(options.geometryType, GeometryType_default.NONE);
  this.boundingSphereCV = options.boundingSphereCV;
  this.offsetAttribute = options.offsetAttribute;
}
Geometry.computeNumberOfVertices = function(geometry) {
  Check_default.typeOf.object("geometry", geometry);
  let numberOfVertices = -1;
  for (const property in geometry.attributes) {
    if (geometry.attributes.hasOwnProperty(property) && defined_default(geometry.attributes[property]) && defined_default(geometry.attributes[property].values)) {
      const attribute = geometry.attributes[property];
      const num = attribute.values.length / attribute.componentsPerAttribute;
      if (numberOfVertices !== num && numberOfVertices !== -1) {
        throw new DeveloperError_default(
          "All attribute lists must have the same number of attributes."
        );
      }
      numberOfVertices = num;
    }
  }
  return numberOfVertices;
};
var rectangleCenterScratch = new Cartographic_default();
var enuCenterScratch = new Cartesian3_default();
var fixedFrameToEnuScratch = new Matrix4_default();
var boundingRectanglePointsCartographicScratch = [
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default()
];
var boundingRectanglePointsEnuScratch = [
  new Cartesian2_default(),
  new Cartesian2_default(),
  new Cartesian2_default()
];
var points2DScratch = [new Cartesian2_default(), new Cartesian2_default(), new Cartesian2_default()];
var pointEnuScratch = new Cartesian3_default();
var enuRotationScratch = new Quaternion_default();
var enuRotationMatrixScratch = new Matrix4_default();
var rotation2DScratch = new Matrix2_default();
Geometry._textureCoordinateRotationPoints = function(positions, stRotation, ellipsoid, boundingRectangle) {
  let i;
  const rectangleCenter = Rectangle_default.center(
    boundingRectangle,
    rectangleCenterScratch
  );
  const enuCenter = Cartographic_default.toCartesian(
    rectangleCenter,
    ellipsoid,
    enuCenterScratch
  );
  const enuToFixedFrame = Transforms_default.eastNorthUpToFixedFrame(
    enuCenter,
    ellipsoid,
    fixedFrameToEnuScratch
  );
  const fixedFrameToEnu = Matrix4_default.inverse(
    enuToFixedFrame,
    fixedFrameToEnuScratch
  );
  const boundingPointsEnu = boundingRectanglePointsEnuScratch;
  const boundingPointsCarto = boundingRectanglePointsCartographicScratch;
  boundingPointsCarto[0].longitude = boundingRectangle.west;
  boundingPointsCarto[0].latitude = boundingRectangle.south;
  boundingPointsCarto[1].longitude = boundingRectangle.west;
  boundingPointsCarto[1].latitude = boundingRectangle.north;
  boundingPointsCarto[2].longitude = boundingRectangle.east;
  boundingPointsCarto[2].latitude = boundingRectangle.south;
  let posEnu = pointEnuScratch;
  for (i = 0; i < 3; i++) {
    Cartographic_default.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);
    posEnu = Matrix4_default.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);
    boundingPointsEnu[i].x = posEnu.x;
    boundingPointsEnu[i].y = posEnu.y;
  }
  const rotation = Quaternion_default.fromAxisAngle(
    Cartesian3_default.UNIT_Z,
    -stRotation,
    enuRotationScratch
  );
  const textureMatrix = Matrix3_default.fromQuaternion(
    rotation,
    enuRotationMatrixScratch
  );
  const positionsLength = positions.length;
  let enuMinX = Number.POSITIVE_INFINITY;
  let enuMinY = Number.POSITIVE_INFINITY;
  let enuMaxX = Number.NEGATIVE_INFINITY;
  let enuMaxY = Number.NEGATIVE_INFINITY;
  for (i = 0; i < positionsLength; i++) {
    posEnu = Matrix4_default.multiplyByPointAsVector(
      fixedFrameToEnu,
      positions[i],
      posEnu
    );
    posEnu = Matrix3_default.multiplyByVector(textureMatrix, posEnu, posEnu);
    enuMinX = Math.min(enuMinX, posEnu.x);
    enuMinY = Math.min(enuMinY, posEnu.y);
    enuMaxX = Math.max(enuMaxX, posEnu.x);
    enuMaxY = Math.max(enuMaxY, posEnu.y);
  }
  const toDesiredInComputed = Matrix2_default.fromRotation(
    stRotation,
    rotation2DScratch
  );
  const points2D = points2DScratch;
  points2D[0].x = enuMinX;
  points2D[0].y = enuMinY;
  points2D[1].x = enuMinX;
  points2D[1].y = enuMaxY;
  points2D[2].x = enuMaxX;
  points2D[2].y = enuMinY;
  const boundingEnuMin = boundingPointsEnu[0];
  const boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;
  const boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;
  for (i = 0; i < 3; i++) {
    const point2D = points2D[i];
    Matrix2_default.multiplyByVector(toDesiredInComputed, point2D, point2D);
    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;
    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;
  }
  const minXYCorner = points2D[0];
  const maxYCorner = points2D[1];
  const maxXCorner = points2D[2];
  const result = new Array(6);
  Cartesian2_default.pack(minXYCorner, result);
  Cartesian2_default.pack(maxYCorner, result, 2);
  Cartesian2_default.pack(maxXCorner, result, 4);
  return result;
};
var Geometry_default = Geometry;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeometryAttribute.js
function GeometryAttribute(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (!defined_default(options.componentDatatype)) {
    throw new DeveloperError_default("options.componentDatatype is required.");
  }
  if (!defined_default(options.componentsPerAttribute)) {
    throw new DeveloperError_default("options.componentsPerAttribute is required.");
  }
  if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {
    throw new DeveloperError_default(
      "options.componentsPerAttribute must be between 1 and 4."
    );
  }
  if (!defined_default(options.values)) {
    throw new DeveloperError_default("options.values is required.");
  }
  this.componentDatatype = options.componentDatatype;
  this.componentsPerAttribute = options.componentsPerAttribute;
  this.normalize = defaultValue_default(options.normalize, false);
  this.values = options.values;
}
var GeometryAttribute_default = GeometryAttribute;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/CompressedTextureBuffer.js
function CompressedTextureBuffer(internalFormat, pixelDatatype, width, height, buffer) {
  this._format = internalFormat;
  this._datatype = pixelDatatype;
  this._width = width;
  this._height = height;
  this._buffer = buffer;
}
Object.defineProperties(CompressedTextureBuffer.prototype, {
  internalFormat: {
    get: function() {
      return this._format;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._datatype;
    }
  },
  width: {
    get: function() {
      return this._width;
    }
  },
  height: {
    get: function() {
      return this._height;
    }
  },
  bufferView: {
    get: function() {
      return this._buffer;
    }
  }
});
CompressedTextureBuffer.clone = function(object) {
  if (!defined_default(object)) {
    return void 0;
  }
  return new CompressedTextureBuffer(
    object._format,
    object._datatype,
    object._width,
    object._height,
    object._buffer
  );
};
CompressedTextureBuffer.prototype.clone = function() {
  return CompressedTextureBuffer.clone(this);
};
var CompressedTextureBuffer_default = CompressedTextureBuffer;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/TaskProcessor.js
var import_urijs7 = __toESM(require_URI(), 1);
function canTransferArrayBuffer() {
  if (!defined_default(TaskProcessor._canTransferArrayBuffer)) {
    const worker = new Worker(
      getWorkerUrl("Workers/transferTypedArrayTest.js")
    );
    worker.postMessage = defaultValue_default(
      worker.webkitPostMessage,
      worker.postMessage
    );
    const value = 99;
    const array = new Int8Array([value]);
    try {
      worker.postMessage(
        {
          array
        },
        [array.buffer]
      );
    } catch (e) {
      TaskProcessor._canTransferArrayBuffer = false;
      return TaskProcessor._canTransferArrayBuffer;
    }
    const deferred = defer_default();
    worker.onmessage = function(event) {
      const array2 = event.data.array;
      const result = defined_default(array2) && array2[0] === value;
      deferred.resolve(result);
      worker.terminate();
      TaskProcessor._canTransferArrayBuffer = result;
    };
    TaskProcessor._canTransferArrayBuffer = deferred.promise;
  }
  return TaskProcessor._canTransferArrayBuffer;
}
var taskCompletedEvent = new Event_default();
function completeTask(processor, data) {
  --processor._activeTasks;
  const id = data.id;
  if (!defined_default(id)) {
    return;
  }
  const deferreds = processor._deferreds;
  const deferred = deferreds[id];
  if (defined_default(data.error)) {
    let error = data.error;
    if (error.name === "RuntimeError") {
      error = new RuntimeError_default(data.error.message);
      error.stack = data.error.stack;
    } else if (error.name === "DeveloperError") {
      error = new DeveloperError_default(data.error.message);
      error.stack = data.error.stack;
    }
    taskCompletedEvent.raiseEvent(error);
    deferred.reject(error);
  } else {
    taskCompletedEvent.raiseEvent();
    deferred.resolve(data.result);
  }
  delete deferreds[id];
}
function getWorkerUrl(moduleID) {
  let url = buildModuleUrl_default(moduleID);
  if (isCrossOriginUrl_default(url)) {
    const script = `importScripts("${url}");`;
    let blob;
    try {
      blob = new Blob([script], {
        type: "application/javascript"
      });
    } catch (e) {
      const BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
      const blobBuilder = new BlobBuilder();
      blobBuilder.append(script);
      blob = blobBuilder.getBlob("application/javascript");
    }
    const URL = window.URL || window.webkitURL;
    url = URL.createObjectURL(blob);
  }
  return url;
}
var bootstrapperUrlResult;
function getBootstrapperUrl() {
  if (!defined_default(bootstrapperUrlResult)) {
    bootstrapperUrlResult = getWorkerUrl("Workers/cesiumWorkerBootstrapper.js");
  }
  return bootstrapperUrlResult;
}
function createWorker(processor) {
  const worker = new Worker(getBootstrapperUrl());
  worker.postMessage = defaultValue_default(
    worker.webkitPostMessage,
    worker.postMessage
  );
  const bootstrapMessage = {
    loaderConfig: {
      paths: {
        Workers: buildModuleUrl_default("Workers")
      },
      baseUrl: buildModuleUrl_default.getCesiumBaseUrl().url
    },
    workerModule: processor._workerPath
  };
  worker.postMessage(bootstrapMessage);
  worker.onmessage = function(event) {
    completeTask(processor, event.data);
  };
  return worker;
}
function getWebAssemblyLoaderConfig(processor, wasmOptions) {
  const config = {
    modulePath: void 0,
    wasmBinaryFile: void 0,
    wasmBinary: void 0
  };
  if (!FeatureDetection_default.supportsWebAssembly()) {
    if (!defined_default(wasmOptions.fallbackModulePath)) {
      throw new RuntimeError_default(
        `This browser does not support Web Assembly, and no backup module was provided for ${processor._workerPath}`
      );
    }
    config.modulePath = buildModuleUrl_default(wasmOptions.fallbackModulePath);
    return Promise.resolve(config);
  }
  config.modulePath = buildModuleUrl_default(wasmOptions.modulePath);
  config.wasmBinaryFile = buildModuleUrl_default(wasmOptions.wasmBinaryFile);
  return Resource_default.fetchArrayBuffer({
    url: config.wasmBinaryFile
  }).then(function(arrayBuffer) {
    config.wasmBinary = arrayBuffer;
    return config;
  });
}
function TaskProcessor(workerPath, maximumActiveTasks) {
  const uri = new import_urijs7.default(workerPath);
  this._workerPath = uri.scheme().length !== 0 && uri.fragment().length === 0 ? workerPath : TaskProcessor._workerModulePrefix + workerPath;
  this._maximumActiveTasks = defaultValue_default(
    maximumActiveTasks,
    Number.POSITIVE_INFINITY
  );
  this._activeTasks = 0;
  this._deferreds = {};
  this._nextID = 0;
}
var emptyTransferableObjectArray = [];
TaskProcessor.prototype.scheduleTask = function(parameters, transferableObjects) {
  if (!defined_default(this._worker)) {
    this._worker = createWorker(this);
  }
  if (this._activeTasks >= this._maximumActiveTasks) {
    return void 0;
  }
  ++this._activeTasks;
  const processor = this;
  return Promise.resolve(canTransferArrayBuffer()).then(function(canTransferArrayBuffer2) {
    if (!defined_default(transferableObjects)) {
      transferableObjects = emptyTransferableObjectArray;
    } else if (!canTransferArrayBuffer2) {
      transferableObjects.length = 0;
    }
    const id = processor._nextID++;
    const deferred = defer_default();
    processor._deferreds[id] = deferred;
    processor._worker.postMessage(
      {
        id,
        parameters,
        canTransferArrayBuffer: canTransferArrayBuffer2
      },
      transferableObjects
    );
    return deferred.promise;
  });
};
TaskProcessor.prototype.initWebAssemblyModule = function(webAssemblyOptions) {
  if (!defined_default(this._worker)) {
    this._worker = createWorker(this);
  }
  const deferred = defer_default();
  const processor = this;
  const worker = this._worker;
  getWebAssemblyLoaderConfig(this, webAssemblyOptions).then(function(wasmConfig) {
    return Promise.resolve(canTransferArrayBuffer()).then(function(canTransferArrayBuffer2) {
      let transferableObjects;
      const binary = wasmConfig.wasmBinary;
      if (defined_default(binary) && canTransferArrayBuffer2) {
        transferableObjects = [binary];
      }
      worker.onmessage = function(event) {
        worker.onmessage = function(event2) {
          completeTask(processor, event2.data);
        };
        deferred.resolve(event.data);
      };
      worker.postMessage(
        { webAssemblyConfig: wasmConfig },
        transferableObjects
      );
    });
  });
  return deferred.promise;
};
TaskProcessor.prototype.isDestroyed = function() {
  return false;
};
TaskProcessor.prototype.destroy = function() {
  if (defined_default(this._worker)) {
    this._worker.terminate();
  }
  return destroyObject_default(this);
};
TaskProcessor.taskCompletedEvent = taskCompletedEvent;
TaskProcessor._defaultWorkerModulePrefix = "Workers/";
TaskProcessor._workerModulePrefix = TaskProcessor._defaultWorkerModulePrefix;
TaskProcessor._canTransferArrayBuffer = void 0;
var TaskProcessor_default = TaskProcessor;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/KTX2Transcoder.js
function KTX2Transcoder() {
}
KTX2Transcoder._transcodeTaskProcessor = new TaskProcessor_default(
  "transcodeKTX2",
  Number.POSITIVE_INFINITY
);
KTX2Transcoder._readyPromise = void 0;
function makeReadyPromise() {
  const readyPromise = KTX2Transcoder._transcodeTaskProcessor.initWebAssemblyModule({
    modulePath: "ThirdParty/Workers/basis_transcoder.js",
    wasmBinaryFile: "ThirdParty/basis_transcoder.wasm"
  }).then(function() {
    return KTX2Transcoder._transcodeTaskProcessor;
  });
  KTX2Transcoder._readyPromise = readyPromise;
}
KTX2Transcoder.transcode = function(ktx2Buffer, supportedTargetFormats) {
  Check_default.defined("supportedTargetFormats", supportedTargetFormats);
  if (!defined_default(KTX2Transcoder._readyPromise)) {
    makeReadyPromise();
  }
  return KTX2Transcoder._readyPromise.then(function(taskProcessor) {
    let parameters;
    if (ktx2Buffer instanceof ArrayBuffer) {
      const view = new Uint8Array(ktx2Buffer);
      parameters = {
        supportedTargetFormats,
        ktx2Buffer: view
      };
      return taskProcessor.scheduleTask(parameters, [ktx2Buffer]);
    }
    parameters = {
      supportedTargetFormats,
      ktx2Buffer
    };
    return taskProcessor.scheduleTask(parameters, [ktx2Buffer.buffer]);
  }).then(function(result) {
    const levelsLength = result.length;
    const faceKeys = Object.keys(result[0]);
    const faceKeysLength = faceKeys.length;
    let i;
    for (i = 0; i < levelsLength; i++) {
      const faces = result[i];
      for (let j = 0; j < faceKeysLength; j++) {
        const face = faces[faceKeys[j]];
        faces[faceKeys[j]] = new CompressedTextureBuffer_default(
          face.internalFormat,
          face.datatype,
          face.width,
          face.height,
          face.levelBuffer
        );
      }
    }
    if (faceKeysLength === 1) {
      for (i = 0; i < levelsLength; ++i) {
        result[i] = result[i][faceKeys[0]];
      }
      if (levelsLength === 1) {
        result = result[0];
      }
    }
    return result;
  }).catch(function(error) {
    throw error;
  });
};
var KTX2Transcoder_default = KTX2Transcoder;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/loadKTX2.js
var supportedTranscoderFormats;
loadKTX2.setKTX2SupportedFormats = function(s3tc, pvrtc, astc, etc, etc1, bc7) {
  supportedTranscoderFormats = {
    s3tc,
    pvrtc,
    astc,
    etc,
    etc1,
    bc7
  };
};
function loadKTX2(resourceOrUrlOrBuffer) {
  Check_default.defined("resourceOrUrlOrBuffer", resourceOrUrlOrBuffer);
  let loadPromise;
  if (resourceOrUrlOrBuffer instanceof ArrayBuffer || ArrayBuffer.isView(resourceOrUrlOrBuffer)) {
    loadPromise = Promise.resolve(resourceOrUrlOrBuffer);
  } else {
    const resource = Resource_default.createIfNeeded(resourceOrUrlOrBuffer);
    loadPromise = resource.fetchArrayBuffer();
  }
  return loadPromise.then(function(data) {
    return KTX2Transcoder_default.transcode(data, supportedTranscoderFormats);
  });
}
var loadKTX2_default = loadKTX2;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/CubeMapFace.js
function CubeMapFace(context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized) {
  this._context = context;
  this._texture = texture;
  this._textureTarget = textureTarget;
  this._targetFace = targetFace;
  this._pixelDatatype = pixelDatatype;
  this._internalFormat = internalFormat;
  this._pixelFormat = pixelFormat;
  this._size = size;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._initialized = initialized;
}
Object.defineProperties(CubeMapFace.prototype, {
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  _target: {
    get: function() {
      return this._targetFace;
    }
  }
});
CubeMapFace.prototype.copyFrom = function(options) {
  Check_default.defined("options", options);
  const xOffset = defaultValue_default(options.xOffset, 0);
  const yOffset = defaultValue_default(options.yOffset, 0);
  Check_default.defined("options.source", options.source);
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  if (xOffset + options.source.width > this._size) {
    throw new DeveloperError_default(
      "xOffset + options.source.width must be less than or equal to width."
    );
  }
  if (yOffset + options.source.height > this._size) {
    throw new DeveloperError_default(
      "yOffset + options.source.height must be less than or equal to height."
    );
  }
  const source = options.source;
  const gl = this._context._gl;
  const target = this._textureTarget;
  const targetFace = this._targetFace;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  const width = source.width;
  const height = source.height;
  let arrayBufferView = source.arrayBufferView;
  const size = this._size;
  const pixelFormat = this._pixelFormat;
  const internalFormat = this._internalFormat;
  const pixelDatatype = this._pixelDatatype;
  const preMultiplyAlpha = this._preMultiplyAlpha;
  const flipY = this._flipY;
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let unpackAlignment = 4;
  if (defined_default(arrayBufferView)) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  let uploaded = false;
  if (!this._initialized) {
    if (xOffset === 0 && yOffset === 0 && width === size && height === size) {
      if (defined_default(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            size,
            size
          );
        }
        gl.texImage2D(
          targetFace,
          0,
          internalFormat,
          size,
          size,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
          arrayBufferView
        );
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(
          targetFace,
          0,
          internalFormat,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
          source
        );
      }
      uploaded = true;
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      const bufferView = PixelFormat_default.createTypedArray(
        pixelFormat,
        pixelDatatype,
        size,
        size
      );
      gl.texImage2D(
        targetFace,
        0,
        internalFormat,
        size,
        size,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        bufferView
      );
    }
    this._initialized = true;
  }
  if (!uploaded) {
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          width,
          height
        );
      }
      gl.texSubImage2D(
        targetFace,
        0,
        xOffset,
        yOffset,
        width,
        height,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texSubImage2D(
        targetFace,
        0,
        xOffset,
        yOffset,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        source
      );
    }
  }
  gl.bindTexture(target, null);
};
CubeMapFace.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
  xOffset = defaultValue_default(xOffset, 0);
  yOffset = defaultValue_default(yOffset, 0);
  framebufferXOffset = defaultValue_default(framebufferXOffset, 0);
  framebufferYOffset = defaultValue_default(framebufferYOffset, 0);
  width = defaultValue_default(width, this._size);
  height = defaultValue_default(height, this._size);
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  if (xOffset + width > this._size) {
    throw new DeveloperError_default(
      "xOffset + source.width must be less than or equal to width."
    );
  }
  if (yOffset + height > this._size) {
    throw new DeveloperError_default(
      "yOffset + source.height must be less than or equal to height."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.HALF_FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT."
    );
  }
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.copyTexSubImage2D(
    this._targetFace,
    0,
    xOffset,
    yOffset,
    framebufferXOffset,
    framebufferYOffset,
    width,
    height
  );
  gl.bindTexture(target, null);
  this._initialized = true;
};
var CubeMapFace_default = CubeMapFace;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/MipmapHint.js
var MipmapHint = {
  DONT_CARE: WebGLConstants_default.DONT_CARE,
  FASTEST: WebGLConstants_default.FASTEST,
  NICEST: WebGLConstants_default.NICEST,
  validate: function(mipmapHint) {
    return mipmapHint === MipmapHint.DONT_CARE || mipmapHint === MipmapHint.FASTEST || mipmapHint === MipmapHint.NICEST;
  }
};
var MipmapHint_default = Object.freeze(MipmapHint);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/TextureMagnificationFilter.js
var TextureMagnificationFilter = {
  NEAREST: WebGLConstants_default.NEAREST,
  LINEAR: WebGLConstants_default.LINEAR
};
TextureMagnificationFilter.validate = function(textureMagnificationFilter) {
  return textureMagnificationFilter === TextureMagnificationFilter.NEAREST || textureMagnificationFilter === TextureMagnificationFilter.LINEAR;
};
var TextureMagnificationFilter_default = Object.freeze(TextureMagnificationFilter);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/TextureMinificationFilter.js
var TextureMinificationFilter = {
  NEAREST: WebGLConstants_default.NEAREST,
  LINEAR: WebGLConstants_default.LINEAR,
  NEAREST_MIPMAP_NEAREST: WebGLConstants_default.NEAREST_MIPMAP_NEAREST,
  LINEAR_MIPMAP_NEAREST: WebGLConstants_default.LINEAR_MIPMAP_NEAREST,
  NEAREST_MIPMAP_LINEAR: WebGLConstants_default.NEAREST_MIPMAP_LINEAR,
  LINEAR_MIPMAP_LINEAR: WebGLConstants_default.LINEAR_MIPMAP_LINEAR
};
TextureMinificationFilter.validate = function(textureMinificationFilter) {
  return textureMinificationFilter === TextureMinificationFilter.NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;
};
var TextureMinificationFilter_default = Object.freeze(TextureMinificationFilter);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/TextureWrap.js
var TextureWrap = {
  CLAMP_TO_EDGE: WebGLConstants_default.CLAMP_TO_EDGE,
  REPEAT: WebGLConstants_default.REPEAT,
  MIRRORED_REPEAT: WebGLConstants_default.MIRRORED_REPEAT,
  validate: function(textureWrap) {
    return textureWrap === TextureWrap.CLAMP_TO_EDGE || textureWrap === TextureWrap.REPEAT || textureWrap === TextureWrap.MIRRORED_REPEAT;
  }
};
var TextureWrap_default = Object.freeze(TextureWrap);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/Sampler.js
function Sampler(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const wrapS = defaultValue_default(options.wrapS, TextureWrap_default.CLAMP_TO_EDGE);
  const wrapT = defaultValue_default(options.wrapT, TextureWrap_default.CLAMP_TO_EDGE);
  const minificationFilter = defaultValue_default(
    options.minificationFilter,
    TextureMinificationFilter_default.LINEAR
  );
  const magnificationFilter = defaultValue_default(
    options.magnificationFilter,
    TextureMagnificationFilter_default.LINEAR
  );
  const maximumAnisotropy = defined_default(options.maximumAnisotropy) ? options.maximumAnisotropy : 1;
  if (!TextureWrap_default.validate(wrapS)) {
    throw new DeveloperError_default("Invalid sampler.wrapS.");
  }
  if (!TextureWrap_default.validate(wrapT)) {
    throw new DeveloperError_default("Invalid sampler.wrapT.");
  }
  if (!TextureMinificationFilter_default.validate(minificationFilter)) {
    throw new DeveloperError_default("Invalid sampler.minificationFilter.");
  }
  if (!TextureMagnificationFilter_default.validate(magnificationFilter)) {
    throw new DeveloperError_default("Invalid sampler.magnificationFilter.");
  }
  Check_default.typeOf.number.greaterThanOrEquals(
    "maximumAnisotropy",
    maximumAnisotropy,
    1
  );
  this._wrapS = wrapS;
  this._wrapT = wrapT;
  this._minificationFilter = minificationFilter;
  this._magnificationFilter = magnificationFilter;
  this._maximumAnisotropy = maximumAnisotropy;
}
Object.defineProperties(Sampler.prototype, {
  wrapS: {
    get: function() {
      return this._wrapS;
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT;
    }
  },
  minificationFilter: {
    get: function() {
      return this._minificationFilter;
    }
  },
  magnificationFilter: {
    get: function() {
      return this._magnificationFilter;
    }
  },
  maximumAnisotropy: {
    get: function() {
      return this._maximumAnisotropy;
    }
  }
});
Sampler.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left._wrapS === right._wrapS && left._wrapT === right._wrapT && left._minificationFilter === right._minificationFilter && left._magnificationFilter === right._magnificationFilter && left._maximumAnisotropy === right._maximumAnisotropy;
};
Sampler.NEAREST = Object.freeze(
  new Sampler({
    wrapS: TextureWrap_default.CLAMP_TO_EDGE,
    wrapT: TextureWrap_default.CLAMP_TO_EDGE,
    minificationFilter: TextureMinificationFilter_default.NEAREST,
    magnificationFilter: TextureMagnificationFilter_default.NEAREST
  })
);
var Sampler_default = Sampler;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/CubeMap.js
function CubeMap(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const source = options.source;
  let width;
  let height;
  if (defined_default(source)) {
    const faces = [
      source.positiveX,
      source.negativeX,
      source.positiveY,
      source.negativeY,
      source.positiveZ,
      source.negativeZ
    ];
    if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {
      throw new DeveloperError_default(
        "options.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces."
      );
    }
    width = faces[0].width;
    height = faces[0].height;
    for (let i = 1; i < 6; ++i) {
      if (Number(faces[i].width) !== width || Number(faces[i].height) !== height) {
        throw new DeveloperError_default(
          "Each face in options.source must have the same width and height."
        );
      }
    }
  } else {
    width = options.width;
    height = options.height;
  }
  const size = width;
  const pixelDatatype = defaultValue_default(
    options.pixelDatatype,
    PixelDatatype_default.UNSIGNED_BYTE
  );
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  const internalFormat = PixelFormat_default.toInternalFormat(
    pixelFormat,
    pixelDatatype,
    context
  );
  if (!defined_default(width) || !defined_default(height)) {
    throw new DeveloperError_default(
      "options requires a source field to create an initialized cube map or width and height fields to create a blank cube map."
    );
  }
  if (width !== height) {
    throw new DeveloperError_default("Width must equal height.");
  }
  if (size <= 0) {
    throw new DeveloperError_default("Width and height must be greater than zero.");
  }
  if (size > ContextLimits_default.maximumCubeMapSize) {
    throw new DeveloperError_default(
      `Width and height must be less than or equal to the maximum cube map size (${ContextLimits_default.maximumCubeMapSize}).  Check maximumCubeMapSize.`
    );
  }
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid options.pixelFormat.");
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat)) {
    throw new DeveloperError_default(
      "options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (!PixelDatatype_default.validate(pixelDatatype)) {
    throw new DeveloperError_default("Invalid options.pixelDatatype.");
  }
  if (pixelDatatype === PixelDatatype_default.FLOAT && !context.floatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension."
    );
  }
  if (pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.halfFloatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension."
    );
  }
  const sizeInBytes = PixelFormat_default.textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6;
  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat_default.RGB || pixelFormat === PixelFormat_default.LUMINANCE;
  const flipY = defaultValue_default(options.flipY, true);
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  const gl = context._gl;
  const textureTarget = gl.TEXTURE_CUBE_MAP;
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  function createFace(target, sourceFace, preMultiplyAlpha2, flipY2, skipColorSpaceConversion2) {
    let arrayBufferView = sourceFace.arrayBufferView;
    if (!defined_default(arrayBufferView)) {
      arrayBufferView = sourceFace.bufferView;
    }
    let unpackAlignment = 4;
    if (defined_default(arrayBufferView)) {
      unpackAlignment = PixelFormat_default.alignmentInBytes(
        pixelFormat,
        pixelDatatype,
        width
      );
    }
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    if (skipColorSpaceConversion2) {
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    } else {
      gl.pixelStorei(
        gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
        gl.BROWSER_DEFAULT_WEBGL
      );
    }
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY2) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          size,
          size
        );
      }
      gl.texImage2D(
        target,
        0,
        internalFormat,
        size,
        size,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha2);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY2);
      gl.texImage2D(
        target,
        0,
        internalFormat,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        sourceFace
      );
    }
  }
  if (defined_default(source)) {
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      source.positiveX,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      source.negativeX,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      source.positiveY,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      source.negativeY,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      source.positiveZ,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
      source.negativeZ,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
  } else {
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
  }
  gl.bindTexture(textureTarget, null);
  this._context = context;
  this._textureFilterAnisotropic = context._textureFilterAnisotropic;
  this._textureTarget = textureTarget;
  this._texture = texture;
  this._pixelFormat = pixelFormat;
  this._pixelDatatype = pixelDatatype;
  this._size = size;
  this._hasMipmap = false;
  this._sizeInBytes = sizeInBytes;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._sampler = void 0;
  const initialized = defined_default(source);
  this._positiveX = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeX = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._positiveY = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeY = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._positiveZ = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeZ = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this.sampler = defined_default(options.sampler) ? options.sampler : new Sampler_default();
}
Object.defineProperties(CubeMap.prototype, {
  positiveX: {
    get: function() {
      return this._positiveX;
    }
  },
  negativeX: {
    get: function() {
      return this._negativeX;
    }
  },
  positiveY: {
    get: function() {
      return this._positiveY;
    }
  },
  negativeY: {
    get: function() {
      return this._negativeY;
    }
  },
  positiveZ: {
    get: function() {
      return this._positiveZ;
    }
  },
  negativeZ: {
    get: function() {
      return this._negativeZ;
    }
  },
  sampler: {
    get: function() {
      return this._sampler;
    },
    set: function(sampler) {
      let minificationFilter = sampler.minificationFilter;
      let magnificationFilter = sampler.magnificationFilter;
      const mipmap = minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_LINEAR || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_LINEAR;
      const context = this._context;
      const pixelDatatype = this._pixelDatatype;
      if (pixelDatatype === PixelDatatype_default.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.textureHalfFloatLinear) {
        minificationFilter = mipmap ? TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter_default.NEAREST;
        magnificationFilter = TextureMagnificationFilter_default.NEAREST;
      }
      const gl = context._gl;
      const target = this._textureTarget;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
      if (defined_default(this._textureFilterAnisotropic)) {
        gl.texParameteri(
          target,
          this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          sampler.maximumAnisotropy
        );
      }
      gl.bindTexture(target, null);
      this._sampler = sampler;
    }
  },
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  width: {
    get: function() {
      return this._size;
    }
  },
  height: {
    get: function() {
      return this._size;
    }
  },
  sizeInBytes: {
    get: function() {
      if (this._hasMipmap) {
        return Math.floor(this._sizeInBytes * 4 / 3);
      }
      return this._sizeInBytes;
    }
  },
  preMultiplyAlpha: {
    get: function() {
      return this._preMultiplyAlpha;
    }
  },
  flipY: {
    get: function() {
      return this._flipY;
    }
  },
  _target: {
    get: function() {
      return this._textureTarget;
    }
  }
});
CubeMap.prototype.generateMipmap = function(hint) {
  hint = defaultValue_default(hint, MipmapHint_default.DONT_CARE);
  if (this._size > 1 && !Math_default.isPowerOfTwo(this._size)) {
    throw new DeveloperError_default(
      "width and height must be a power of two to call generateMipmap()."
    );
  }
  if (!MipmapHint_default.validate(hint)) {
    throw new DeveloperError_default("hint is invalid.");
  }
  this._hasMipmap = true;
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.generateMipmap(target);
  gl.bindTexture(target, null);
};
CubeMap.prototype.isDestroyed = function() {
  return false;
};
CubeMap.prototype.destroy = function() {
  this._context._gl.deleteTexture(this._texture);
  this._positiveX = destroyObject_default(this._positiveX);
  this._negativeX = destroyObject_default(this._negativeX);
  this._positiveY = destroyObject_default(this._positiveY);
  this._negativeY = destroyObject_default(this._negativeY);
  this._positiveZ = destroyObject_default(this._positiveZ);
  this._negativeZ = destroyObject_default(this._negativeZ);
  return destroyObject_default(this);
};
var CubeMap_default = CubeMap;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/modernizeShader.js
function modernizeShader(source, isFragmentShader) {
  const outputDeclarationRegex = /#define OUTPUT_DECLARATION/;
  const splitSource = source.split("\n");
  if (/#version 300 es/g.test(source)) {
    return source;
  }
  let outputDeclarationLine = -1;
  let i, line;
  for (i = 0; i < splitSource.length; ++i) {
    line = splitSource[i];
    if (outputDeclarationRegex.test(line)) {
      outputDeclarationLine = i;
      break;
    }
  }
  if (outputDeclarationLine === -1) {
    throw new DeveloperError_default("Could not find a #define OUTPUT_DECLARATION!");
  }
  const outputVariables = [];
  for (i = 0; i < 10; i++) {
    const fragDataString = `gl_FragData\\[${i}\\]`;
    const newOutput = `czm_out${i}`;
    const regex = new RegExp(fragDataString, "g");
    if (regex.test(source)) {
      setAdd(newOutput, outputVariables);
      replaceInSourceString(fragDataString, newOutput, splitSource);
      splitSource.splice(
        outputDeclarationLine,
        0,
        `layout(location = ${i}) out vec4 ${newOutput};`
      );
      outputDeclarationLine += 1;
    }
  }
  const czmFragColor = "czm_fragColor";
  if (findInSource("gl_FragColor", splitSource)) {
    setAdd(czmFragColor, outputVariables);
    replaceInSourceString("gl_FragColor", czmFragColor, splitSource);
    splitSource.splice(
      outputDeclarationLine,
      0,
      "layout(location = 0) out vec4 czm_fragColor;"
    );
    outputDeclarationLine += 1;
  }
  const variableMap = getVariablePreprocessorBranch(
    outputVariables,
    splitSource
  );
  const lineAdds = {};
  for (i = 0; i < splitSource.length; i++) {
    line = splitSource[i];
    for (const variable in variableMap) {
      if (variableMap.hasOwnProperty(variable)) {
        const matchVar = new RegExp(
          `(layout)[^]+(out)[^]+(${variable})[^]+`,
          "g"
        );
        if (matchVar.test(line)) {
          lineAdds[line] = variable;
        }
      }
    }
  }
  for (const layoutDeclaration in lineAdds) {
    if (lineAdds.hasOwnProperty(layoutDeclaration)) {
      const variableName = lineAdds[layoutDeclaration];
      let lineNumber = splitSource.indexOf(layoutDeclaration);
      const entry = variableMap[variableName];
      const depth = entry.length;
      for (let d = 0; d < depth; d++) {
        splitSource.splice(lineNumber, 0, entry[d]);
      }
      lineNumber += depth + 1;
      for (let d = depth - 1; d >= 0; d--) {
        splitSource.splice(lineNumber, 0, `#endif //${entry[d]}`);
      }
    }
  }
  const webgl2UniqueID = "WEBGL_2";
  const webgl2DefineMacro = `#define ${webgl2UniqueID}`;
  const versionThree = "#version 300 es";
  let foundVersion = false;
  for (i = 0; i < splitSource.length; i++) {
    if (/#version/.test(splitSource[i])) {
      splitSource[i] = versionThree;
      foundVersion = true;
      break;
    }
  }
  if (!foundVersion) {
    splitSource.splice(0, 0, versionThree);
  }
  splitSource.splice(1, 0, webgl2DefineMacro);
  removeExtension("EXT_draw_buffers", webgl2UniqueID, splitSource);
  removeExtension("EXT_frag_depth", webgl2UniqueID, splitSource);
  removeExtension("OES_standard_derivatives", webgl2UniqueID, splitSource);
  replaceInSourceString("texture2D", "texture", splitSource);
  replaceInSourceString("texture3D", "texture", splitSource);
  replaceInSourceString("textureCube", "texture", splitSource);
  replaceInSourceString("gl_FragDepthEXT", "gl_FragDepth", splitSource);
  if (isFragmentShader) {
    replaceInSourceString("varying", "in", splitSource);
  } else {
    replaceInSourceString("attribute", "in", splitSource);
    replaceInSourceString("varying", "out", splitSource);
  }
  return compileSource(splitSource);
}
function replaceInSourceString(str, replacement, splitSource) {
  const regexStr = `(^|[^\\w])(${str})($|[^\\w])`;
  const regex = new RegExp(regexStr, "g");
  const splitSourceLength = splitSource.length;
  for (let i = 0; i < splitSourceLength; ++i) {
    const line = splitSource[i];
    splitSource[i] = line.replace(regex, `$1${replacement}$3`);
  }
}
function replaceInSourceRegex(regex, replacement, splitSource) {
  const splitSourceLength = splitSource.length;
  for (let i = 0; i < splitSourceLength; ++i) {
    const line = splitSource[i];
    splitSource[i] = line.replace(regex, replacement);
  }
}
function findInSource(str, splitSource) {
  const regexStr = `(^|[^\\w])(${str})($|[^\\w])`;
  const regex = new RegExp(regexStr, "g");
  const splitSourceLength = splitSource.length;
  for (let i = 0; i < splitSourceLength; ++i) {
    const line = splitSource[i];
    if (regex.test(line)) {
      return true;
    }
  }
  return false;
}
function compileSource(splitSource) {
  let wholeSource = "";
  const splitSourceLength = splitSource.length;
  for (let i = 0; i < splitSourceLength; ++i) {
    wholeSource += `${splitSource[i]}
`;
  }
  return wholeSource;
}
function setAdd(variable, set) {
  if (set.indexOf(variable) === -1) {
    set.push(variable);
  }
}
function getVariablePreprocessorBranch(layoutVariables, splitSource) {
  const variableMap = {};
  const numLayoutVariables = layoutVariables.length;
  const stack = [];
  for (let i = 0; i < splitSource.length; ++i) {
    const line = splitSource[i];
    const hasIF = /(#ifdef|#if)/g.test(line);
    const hasELSE = /#else/g.test(line);
    const hasENDIF = /#endif/g.test(line);
    if (hasIF) {
      stack.push(line);
    } else if (hasELSE) {
      const top = stack[stack.length - 1];
      let op = top.replace("ifdef", "ifndef");
      if (/if/g.test(op)) {
        op = op.replace(/(#if\s+)(\S*)([^]*)/, "$1!($2)$3");
      }
      stack.pop();
      stack.push(op);
    } else if (hasENDIF) {
      stack.pop();
    } else if (!/layout/g.test(line)) {
      for (let varIndex = 0; varIndex < numLayoutVariables; ++varIndex) {
        const varName = layoutVariables[varIndex];
        if (line.indexOf(varName) !== -1) {
          if (!defined_default(variableMap[varName])) {
            variableMap[varName] = stack.slice();
          } else {
            variableMap[varName] = variableMap[varName].filter(function(x) {
              return stack.indexOf(x) >= 0;
            });
          }
        }
      }
    }
  }
  return variableMap;
}
function removeExtension(name, webgl2UniqueID, splitSource) {
  const regex = `#extension\\s+GL_${name}\\s+:\\s+[a-zA-Z0-9]+\\s*$`;
  replaceInSourceRegex(new RegExp(regex, "g"), "", splitSource);
  replaceInSourceString(`GL_${name}`, webgl2UniqueID, splitSource);
}
var modernizeShader_default = modernizeShader;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/degreesPerRadian.js
var degreesPerRadian_default = "/**\n * A built-in GLSL floating-point constant for converting radians to degrees.\n *\n * @alias czm_degreesPerRadian\n * @glslConstant\n *\n * @see CesiumMath.DEGREES_PER_RADIAN\n *\n * @example\n * // GLSL declaration\n * const float czm_degreesPerRadian = ...;\n *\n * // Example\n * float deg = czm_degreesPerRadian * rad;\n */\nconst float czm_degreesPerRadian = 57.29577951308232;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/depthRange.js
var depthRange_default = "/**\n * A built-in GLSL vec2 constant for defining the depth range.\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\n *\n * @alias czm_depthRange\n * @glslConstant\n *\n * @example\n * // GLSL declaration\n * float depthRangeNear = czm_depthRange.near;\n * float depthRangeFar = czm_depthRange.far;\n *\n */\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon1.js
var epsilon1_default = "/**\n * 0.1\n *\n * @name czm_epsilon1\n * @glslConstant\n */\nconst float czm_epsilon1 = 0.1;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon2.js
var epsilon2_default = "/**\n * 0.01\n *\n * @name czm_epsilon2\n * @glslConstant\n */\nconst float czm_epsilon2 = 0.01;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon3.js
var epsilon3_default = "/**\n * 0.001\n *\n * @name czm_epsilon3\n * @glslConstant\n */\nconst float czm_epsilon3 = 0.001;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon4.js
var epsilon4_default = "/**\n * 0.0001\n *\n * @name czm_epsilon4\n * @glslConstant\n */\nconst float czm_epsilon4 = 0.0001;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon5.js
var epsilon5_default = "/**\n * 0.00001\n *\n * @name czm_epsilon5\n * @glslConstant\n */\nconst float czm_epsilon5 = 0.00001;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon6.js
var epsilon6_default = "/**\n * 0.000001\n *\n * @name czm_epsilon6\n * @glslConstant\n */\nconst float czm_epsilon6 = 0.000001;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon7.js
var epsilon7_default = "/**\n * 0.0000001\n *\n * @name czm_epsilon7\n * @glslConstant\n */\nconst float czm_epsilon7 = 0.0000001;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/infinity.js
var infinity_default = "/**\n * DOC_TBA\n *\n * @name czm_infinity\n * @glslConstant\n */\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/oneOverPi.js
var oneOverPi_default = "/**\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\n *\n * @alias czm_oneOverPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverPi = ...;\n *\n * // Example\n * float pi = 1.0 / czm_oneOverPi;\n */\nconst float czm_oneOverPi = 0.3183098861837907;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/oneOverTwoPi.js
var oneOverTwoPi_default = "/**\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\n *\n * @alias czm_oneOverTwoPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverTwoPi = ...;\n *\n * // Example\n * float pi = 2.0 * czm_oneOverTwoPi;\n */\nconst float czm_oneOverTwoPi = 0.15915494309189535;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passCesium3DTile.js
var passCesium3DTile_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE}\n *\n * @name czm_passCesium3DTile\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTile = 4.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passCesium3DTileClassification.js
var passCesium3DTileClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION}\n *\n * @name czm_passCesium3DTileClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassification = 5.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passCesium3DTileClassificationIgnoreShow.js
var passCesium3DTileClassificationIgnoreShow_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW}\n *\n * @name czm_passCesium3DTileClassificationIgnoreShow\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassificationIgnoreShow = 6.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passClassification.js
var passClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#CLASSIFICATION}\n *\n * @name czm_passClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passClassification = 7.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passCompute.js
var passCompute_default = "/**\n * The automatic GLSL constant for {@link Pass#COMPUTE}\n *\n * @name czm_passCompute\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCompute = 1.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passEnvironment.js
var passEnvironment_default = "/**\n * The automatic GLSL constant for {@link Pass#ENVIRONMENT}\n *\n * @name czm_passEnvironment\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passEnvironment = 0.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passGlobe.js
var passGlobe_default = "/**\n * The automatic GLSL constant for {@link Pass#GLOBE}\n *\n * @name czm_passGlobe\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passGlobe = 2.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passOpaque.js
var passOpaque_default = "/**\n * The automatic GLSL constant for {@link Pass#OPAQUE}\n *\n * @name czm_passOpaque\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOpaque = 7.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passOverlay.js
var passOverlay_default = "/**\n * The automatic GLSL constant for {@link Pass#OVERLAY}\n *\n * @name czm_passOverlay\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOverlay = 9.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passTerrainClassification.js
var passTerrainClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#TERRAIN_CLASSIFICATION}\n *\n * @name czm_passTerrainClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTerrainClassification = 3.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/passTranslucent.js
var passTranslucent_default = "/**\n * The automatic GLSL constant for {@link Pass#TRANSLUCENT}\n *\n * @name czm_passTranslucent\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTranslucent = 8.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/pi.js
var pi_default = "/**\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\n *\n * @alias czm_pi\n * @glslConstant\n *\n * @see CesiumMath.PI\n *\n * @example\n * // GLSL declaration\n * const float czm_pi = ...;\n *\n * // Example\n * float twoPi = 2.0 * czm_pi;\n */\nconst float czm_pi = 3.141592653589793;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/piOverFour.js
var piOverFour_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\n *\n * @alias czm_piOverFour\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_FOUR\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverFour = ...;\n *\n * // Example\n * float pi = 4.0 * czm_piOverFour;\n */\nconst float czm_piOverFour = 0.7853981633974483;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/piOverSix.js
var piOverSix_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\n *\n * @alias czm_piOverSix\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_SIX\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverSix = ...;\n *\n * // Example\n * float pi = 6.0 * czm_piOverSix;\n */\nconst float czm_piOverSix = 0.5235987755982988;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/piOverThree.js
var piOverThree_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\n *\n * @alias czm_piOverThree\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_THREE\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverThree = ...;\n *\n * // Example\n * float pi = 3.0 * czm_piOverThree;\n */\nconst float czm_piOverThree = 1.0471975511965976;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/piOverTwo.js
var piOverTwo_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\n *\n * @alias czm_piOverTwo\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverTwo = ...;\n *\n * // Example\n * float pi = 2.0 * czm_piOverTwo;\n */\nconst float czm_piOverTwo = 1.5707963267948966;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/radiansPerDegree.js
var radiansPerDegree_default = "/**\n * A built-in GLSL floating-point constant for converting degrees to radians.\n *\n * @alias czm_radiansPerDegree\n * @glslConstant\n *\n * @see CesiumMath.RADIANS_PER_DEGREE\n *\n * @example\n * // GLSL declaration\n * const float czm_radiansPerDegree = ...;\n *\n * // Example\n * float rad = czm_radiansPerDegree * deg;\n */\nconst float czm_radiansPerDegree = 0.017453292519943295;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/sceneMode2D.js
var sceneMode2D_default = "/**\n * The constant identifier for the 2D {@link SceneMode}\n *\n * @name czm_sceneMode2D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode2D = 2.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/sceneMode3D.js
var sceneMode3D_default = "/**\n * The constant identifier for the 3D {@link SceneMode}\n *\n * @name czm_sceneMode3D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode3D = 3.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/sceneModeColumbusView.js
var sceneModeColumbusView_default = "/**\n * The constant identifier for the Columbus View {@link SceneMode}\n *\n * @name czm_sceneModeColumbusView\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneModeColumbusView = 1.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/sceneModeMorphing.js
var sceneModeMorphing_default = "/**\n * The constant identifier for the Morphing {@link SceneMode}\n *\n * @name czm_sceneModeMorphing\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n */\nconst float czm_sceneModeMorphing = 0.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/solarRadius.js
var solarRadius_default = "/**\n * A built-in GLSL floating-point constant for one solar radius.\n *\n * @alias czm_solarRadius\n * @glslConstant\n *\n * @see CesiumMath.SOLAR_RADIUS\n *\n * @example\n * // GLSL declaration\n * const float czm_solarRadius = ...;\n */\nconst float czm_solarRadius = 695500000.0;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/threePiOver2.js
var threePiOver2_default = "/**\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\n *\n * @alias czm_threePiOver2\n * @glslConstant\n *\n * @see CesiumMath.THREE_PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_threePiOver2 = ...;\n *\n * // Example\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\n */\nconst float czm_threePiOver2 = 4.71238898038469;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/twoPi.js
var twoPi_default = "/**\n * A built-in GLSL floating-point constant for <code>2pi</code>.\n *\n * @alias czm_twoPi\n * @glslConstant\n *\n * @see CesiumMath.TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_twoPi = ...;\n *\n * // Example\n * float pi = czm_twoPi / 2.0;\n */\nconst float czm_twoPi = 6.283185307179586;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Constants/webMercatorMaxLatitude.js
var webMercatorMaxLatitude_default = "/**\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed as follows:\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n *\n * @name czm_webMercatorMaxLatitude\n * @glslConstant\n */\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/depthRangeStruct.js
var depthRangeStruct_default = "/**\n * @name czm_depthRangeStruct\n * @glslStruct\n */\nstruct czm_depthRangeStruct\n{\n    float near;\n    float far;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/material.js
var material_default = "/**\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n */\nstruct czm_material\n{\n    vec3 diffuse;\n    float specular;\n    float shininess;\n    vec3 normal;\n    vec3 emission;\n    float alpha;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/materialInput.js
var materialInput_default = "/**\n * Used as input to every material's czm_getMaterial function.\n *\n * @name czm_materialInput\n * @glslStruct\n *\n * @property {float} s 1D texture coordinates.\n * @property {vec2} st 2D texture coordinates.\n * @property {vec3} str 3D texture coordinates.\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n * @property {float} height The height of the terrain in meters above or below the WGS84 ellipsoid.  Only available for globe materials.\n * @property {float} slope The slope of the terrain in radians.  0 is flat; pi/2 is vertical.  Only available for globe materials.\n * @property {float} aspect The aspect of the terrain in radians.  0 is East, pi/2 is North, pi is West, 3pi/2 is South.  Only available for globe materials.\n */\nstruct czm_materialInput\n{\n    float s;\n    vec2 st;\n    vec3 str;\n    vec3 normalEC;\n    mat3 tangentToEyeMatrix;\n    vec3 positionToEyeEC;\n    float height;\n    float slope;\n    float aspect;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/modelMaterial.js
var modelMaterial_default = "/**\n * Struct for representing a material for a {@link Model}. The model\n * rendering pipeline will pass this struct between material, custom shaders,\n * and lighting stages. This is not to be confused with {@link czm_material}\n * which is used by the older Fabric materials system, although they are similar.\n * <p>\n * All color values (diffuse, specular, emissive) are in linear color space.\n * </p>\n *\n * @name czm_modelMaterial\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n * @property {vec3} specular Color of reflected light at normal incidence in PBR materials. This is sometimes referred to as f0 in the literature.\n * @property {float} roughness A number from 0.0 to 1.0 representing how rough the surface is. Values near 0.0 produce glossy surfaces, while values near 1.0 produce rough surfaces.\n * @property {vec3} normalEC Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {float} occlusion Ambient occlusion recieved at this point on the material. 1.0 means fully lit, 0.0 means fully occluded.\n * @property {vec3} emissive Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n */\nstruct czm_modelMaterial {\n    vec3 diffuse;\n    float alpha;\n    vec3 specular;\n    float roughness;\n    vec3 normalEC;\n    float occlusion;\n    vec3 emissive;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/modelVertexOutput.js
var modelVertexOutput_default = "/**\n * Struct for representing the output of a custom vertex shader.\n * \n * @name czm_modelVertexOutput\n * @glslStruct\n *\n * @see {@link CustomShader}\n * @see {@link Model}\n *\n * @property {vec3} positionMC The position of the vertex in model coordinates\n * @property {float} pointSize A custom value for gl_PointSize. This is only used for point primitives. \n */\nstruct czm_modelVertexOutput {\n  vec3 positionMC;\n  float pointSize;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/pbrParameters.js
var pbrParameters_default = "/**\n * Parameters for {@link czm_pbrLighting}\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuseColor the diffuse color of the material for the lambert term of the rendering equation\n * @property {float} roughness a value from 0.0 to 1.0 that indicates how rough the surface of the material is.\n * @property {vec3} f0 The reflectance of the material at normal incidence\n */\nstruct czm_pbrParameters\n{\n    vec3 diffuseColor;\n    float roughness;\n    vec3 f0;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/ray.js
var ray_default = "/**\n * DOC_TBA\n *\n * @name czm_ray\n * @glslStruct\n */\nstruct czm_ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/raySegment.js
var raySegment_default = "/**\n * DOC_TBA\n *\n * @name czm_raySegment\n * @glslStruct\n */\nstruct czm_raySegment\n{\n    float start;\n    float stop;\n};\n\n/**\n * DOC_TBA\n *\n * @name czm_emptyRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\n/**\n * DOC_TBA\n *\n * @name czm_fullRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Structs/shadowParameters.js
var shadowParameters_default = "struct czm_shadowParameters\n{\n#ifdef USE_CUBE_MAP_SHADOW\n    vec3 texCoords;\n#else\n    vec2 texCoords;\n#endif\n\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/HSBToRGB.js
var HSBToRGB_default = "/**\n * Converts an HSB color (hue, saturation, brightness) to RGB\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_HSBToRGB\n * @glslFunction\n * \n * @param {vec3} hsb The color in HSB.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\nvec3 czm_HSBToRGB(vec3 hsb)\n{\n    vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);\n    return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/HSLToRGB.js
var HSLToRGB_default = "/**\n * Converts an HSL color (hue, saturation, lightness) to RGB\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_HSLToRGB\n * @glslFunction\n * \n * @param {vec3} rgb The color in HSL.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n\nvec3 hueToRGB(float hue)\n{\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec3 czm_HSLToRGB(vec3 hsl)\n{\n    vec3 rgb = hueToRGB(hsl.x);\n    float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/RGBToHSB.js
var RGBToHSB_default = "/**\n * Converts an RGB color to HSB (hue, saturation, brightness)\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_RGBToHSB\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\nvec3 czm_RGBToHSB(vec3 rgb)\n{\n    vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/RGBToHSL.js
var RGBToHSL_default = "/**\n * Converts an RGB color to HSL (hue, saturation, lightness)\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_RGBToHSL\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSL.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n \nvec3 RGBtoHCV(vec3 rgb)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 czm_RGBToHSL(vec3 rgb)\n{\n    vec3 hcv = RGBtoHCV(rgb);\n    float l = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);\n    return vec3(hcv.x, s, l);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/RGBToXYZ.js
var RGBToXYZ_default = "/**\n * Converts an RGB color to CIE Yxy.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_RGBToXYZ\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in CIE Yxy.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n                              0.3576, 0.7152, 0.1192,\n                              0.1805, 0.0722, 0.9505);\n    vec3 xyz = RGB2XYZ * rgb;\n    vec3 Yxy;\n    Yxy.r = xyz.g;\n    float temp = dot(vec3(1.0), xyz);\n    Yxy.gb = xyz.rg / temp;\n    return Yxy;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/XYZToRGB.js
var XYZToRGB_default = "/**\n * Converts a CIE Yxy color to RGB.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_XYZToRGB\n * @glslFunction\n * \n * @param {vec3} Yxy The color in CIE Yxy.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n                              -1.5371,  1.8760, -0.2040,\n                              -0.4985,  0.0416,  1.0572);\n    vec3 xyz;\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\n    xyz.g = Yxy.r;\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\n    \n    return XYZ2RGB * xyz;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/acesTonemapping.js
var acesTonemapping_default = "// See:\n//    https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n\nvec3 czm_acesTonemapping(vec3 color) {\n    float g = 0.985;\n    float a = 0.065;\n    float b = 0.0001;\n    float c = 0.433;\n    float d = 0.238;\n\n    color = (color * (color + a) - b) / (color * (g * color + c) + d);\n\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/alphaWeight.js
var alphaWeight_default = "/**\n * @private\n */\nfloat czm_alphaWeight(float a)\n{\n    float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n\n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n    // http://jcgt.org/published/0002/02/09/\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/antialias.js
var antialias_default = "/**\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\n *\n * @name czm_antialias\n * @glslFunction\n *\n * @param {vec4} color1 The color on one side of the edge.\n * @param {vec4} color2 The color on the other side of the edge.\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\n * @param {float} dist The distance to the edge in texture coordinates.\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\n * @returns {vec4} The anti-aliased color.\n *\n * @example\n * // GLSL declarations\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\n *\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\n * float dist = abs(textureCoordinates.t - 0.5);\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\n */\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\n    val1 = val1 * (1.0 - val2);\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n    val1 = pow(val1, 0.5); //makes the transition nicer\n    \n    vec4 midColor = (color1 + color2) * 0.5;\n    return mix(midColor, currentColor, val1);\n}\n\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/approximateSphericalCoordinates.js
var approximateSphericalCoordinates_default = "/**\n * Approximately computes spherical coordinates given a normal.\n * Uses approximate inverse trigonometry for speed and consistency,\n * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU.\n *\n * @name czm_approximateSphericalCoordinates\n * @glslFunction\n *\n * @param {vec3} normal arbitrary-length normal.\n *\n * @returns {vec2} Approximate latitude and longitude spherical coordinates.\n */\nvec2 czm_approximateSphericalCoordinates(vec3 normal) {\n    // Project into plane with vertical for latitude\n    float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);\n    float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);\n    return vec2(latitudeApproximation, longitudeApproximation);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/backFacing.js
var backFacing_default = "/**\n * Determines if the fragment is back facing\n *\n * @name czm_backFacing\n * @glslFunction \n * \n * @returns {bool} <code>true</code> if the fragment is back facing; otherwise, <code>false</code>.\n */\nbool czm_backFacing()\n{\n    // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494.\n    return gl_FrontFacing == false;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/branchFreeTernary.js
var branchFreeTernary_default = "/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a float expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {float} a Value to return if the comparison is true.\n * @param {float} b Value to return if the comparison is false.\n *\n * @returns {float} equivalent of comparison ? a : b\n */\nfloat czm_branchFreeTernary(bool comparison, float a, float b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec2 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec2} a Value to return if the comparison is true.\n * @param {vec2} b Value to return if the comparison is false.\n *\n * @returns {vec2} equivalent of comparison ? a : b\n */\nvec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec3 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec4 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeColor.js
var cascadeColor_default = "\nvec4 czm_cascadeColor(vec4 weights)\n{\n    return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +\n           vec4(0.0, 1.0, 0.0, 1.0) * weights.y +\n           vec4(0.0, 0.0, 1.0, 1.0) * weights.z +\n           vec4(1.0, 0.0, 1.0, 1.0) * weights.w;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeDistance.js
var cascadeDistance_default = "\nuniform vec4 shadowMap_cascadeDistances;\n\nfloat czm_cascadeDistance(vec4 weights)\n{\n    return dot(shadowMap_cascadeDistances, weights);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeMatrix.js
var cascadeMatrix_default = "\nuniform mat4 shadowMap_cascadeMatrices[4];\n\nmat4 czm_cascadeMatrix(vec4 weights)\n{\n    return shadowMap_cascadeMatrices[0] * weights.x +\n           shadowMap_cascadeMatrices[1] * weights.y +\n           shadowMap_cascadeMatrices[2] * weights.z +\n           shadowMap_cascadeMatrices[3] * weights.w;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeWeights.js
var cascadeWeights_default = "\nuniform vec4 shadowMap_cascadeSplits[2];\n\nvec4 czm_cascadeWeights(float depthEye)\n{\n    // One component is set to 1.0 and all others set to 0.0.\n    vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));\n    vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);\n    return near * far;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/columbusViewMorph.js
var columbusViewMorph_default = "/**\n * DOC_TBA\n *\n * @name czm_columbusViewMorph\n * @glslFunction\n */\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\n    // Just linear for now.\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\n    return vec4(p, 1.0);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/computePosition.js
var computePosition_default = "/**\n * Returns a position in model coordinates relative to eye taking into\n * account the current scene mode: 3D, 2D, or Columbus view.\n * <p>\n * This uses standard position attributes, <code>position3DHigh</code>, \n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \n * and should be used when writing a vertex shader for an {@link Appearance}.\n * </p>\n *\n * @name czm_computePosition\n * @glslFunction\n *\n * @returns {vec4} The position relative to eye.\n *\n * @example\n * vec4 p = czm_computePosition();\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\n *\n * @see czm_translateRelativeToEye\n */\nvec4 czm_computePosition();\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/cosineAndSine.js
var cosineAndSine_default = "/**\n * @private\n */\nvec2 cordic(float angle)\n{\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\n// Iteration 1\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\n //   float factor = sense * 1.0;  // 2^-0\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\n    vector = rotation * vector;\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\n// Iteration 2\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    float factor = sense * 5.0e-1;  // 2^-1\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\n// Iteration 3\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.5e-1;  // 2^-2\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\n// Iteration 4\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.25e-1;  // 2^-3\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\n// Iteration 5\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.25e-2;  // 2^-4\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\n// Iteration 6\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.125e-2;  // 2^-5\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\n// Iteration 7\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.5625e-2;  // 2^-6\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\n// Iteration 8\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.8125e-3;  // 2^-7\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\n// Iteration 9\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.90625e-3;  // 2^-8\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\n// Iteration 10\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.953125e-3;  // 2^-9\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\n// Iteration 11\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.765625e-4;  // 2^-10\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\n// Iteration 12\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.8828125e-4;  // 2^-11\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\n// Iteration 13\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.44140625e-4;  // 2^-12\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\n// Iteration 14\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.220703125e-4;  // 2^-13\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\n// Iteration 15\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.103515625e-5;  // 2^-14\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\n// Iteration 16\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.0517578125e-5;  // 2^-15\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\n// Iteration 17\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.52587890625e-5;  // 2^-16\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\n// Iteration 18\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.62939453125e-6;  // 2^-17\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\n// Iteration 19\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.814697265625e-6;  // 2^-18\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\n// Iteration 20\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.9073486328125e-6;  // 2^-19\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\n// Iteration 21\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.5367431640625e-7;  // 2^-20\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\n// Iteration 22\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.76837158203125e-7;  // 2^-21\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\n// Iteration 23\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.384185791015625e-7;  // 2^-22\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\n// Iteration 24\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\n\n    return vector;\n}\n\n/**\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\n *\n * @name czm_cosineAndSine\n * @glslFunction\n *\n * @param {float} angle The angle in radians.\n *\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\n *\n * @example\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\n * float cosine = v.x;\n * float sine = v.y;\n */\nvec2 czm_cosineAndSine(float angle)\n{\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n    {\n        if (angle < 0.0)\n        {\n            return -cordic(angle + czm_pi);\n        }\n        else\n        {\n            return -cordic(angle - czm_pi);\n        }\n    }\n    else\n    {\n        return cordic(angle);\n    }\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/decompressTextureCoordinates.js
var decompressTextureCoordinates_default = "/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @name czm_decompressTextureCoordinates\n * @glslFunction\n *\n * @param {float} encoded The compressed texture coordinates.\n * @returns {vec2} The decompressed texture coordinates.\n */\n vec2 czm_decompressTextureCoordinates(float encoded)\n {\n    float temp = encoded / 4096.0;\n    float xZeroTo4095 = floor(temp);\n    float stx = xZeroTo4095 / 4095.0;\n    float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;\n    return vec2(stx, sty);\n }\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/defaultPbrMaterial.js
var defaultPbrMaterial_default = "/**\n * Get default parameters for physically based rendering. These defaults\n * describe a rough dielectric (non-metal) surface (e.g. rough plastic).\n *\n * @return {czm_pbrParameters} Default parameters for {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_defaultPbrMaterial()\n{\n    czm_pbrParameters results;\n    results.diffuseColor = vec3(1.0);\n    results.roughness = 1.0;\n\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\n    results.f0 = REFLECTANCE_DIELECTRIC;\n    return results;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/depthClamp.js
var depthClamp_default = "// emulated noperspective\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\nvarying float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP, which is not available in WebGL 1 or 2.\n * GL_DEPTH_CLAMP clamps geometry that is outside the near and far planes, \n * capping the shadow volume. More information here: \n * https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_depth_clamp.txt.\n *\n * When GL_EXT_frag_depth is available we emulate GL_DEPTH_CLAMP by ensuring \n * no geometry gets clipped by setting the clip space z value to 0.0 and then\n * sending the unaltered screen space z value (using emulated noperspective\n * interpolation) to the frag shader where it is clamped to [0,1] and then\n * written with gl_FragDepth (see czm_writeDepthClamp). This technique is based on:\n * https://stackoverflow.com/questions/5960757/how-to-emulate-gl-depth-clamp-nv.\n *\n * When GL_EXT_frag_depth is not available, which is the case on some mobile \n * devices, we must attempt to fix this only in the vertex shader. \n * The approach is to clamp the z value to the far plane, which closes the \n * shadow volume but also distorts the geometry, so there can still be artifacts\n * on frustum seams.\n *\n * @name czm_depthClamp\n * @glslFunction\n *\n * @param {vec4} coords The vertex in clip coordinates.\n * @returns {vec4} The modified vertex.\n *\n * @example\n * gl_Position = czm_depthClamp(czm_modelViewProjection * vec4(position, 1.0));\n *\n * @see czm_writeDepthClamp\n */\nvec4 czm_depthClamp(vec4 coords)\n{\n#ifndef LOG_DEPTH\n#ifdef GL_EXT_frag_depth\n    v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\n    coords.z = 0.0;\n#else\n    coords.z = min(coords.z, coords.w);\n#endif\n#endif\n    return coords;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/eastNorthUpToEyeCoordinates.js
var eastNorthUpToEyeCoordinates_default = "/**\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system \n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n * surface normal.  East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping.\n * <br /><br />\n * The ellipsoid is assumed to be centered at the model coordinate's origin.\n *\n * @name czm_eastNorthUpToEyeCoordinates\n * @glslFunction\n *\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n *\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n *\n * @example\n * // Transform a vector defined in the east-north-up coordinate \n * // system, (0, 0, 1) which is the surface normal, to eye \n * // coordinates.\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n */\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordiantes\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\n    return mat3(\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n        normalEC.x,    normalEC.y,    normalEC.z);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/ellipsoidContainsPoint.js
var ellipsoidContainsPoint_default = "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidContainsPoint\n * @glslFunction\n *\n */\nbool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)\n{\n    vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n    return (dot(scaled, scaled) <= 1.0);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/ellipsoidWgs84TextureCoordinates.js
var ellipsoidWgs84TextureCoordinates_default = "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidWgs84TextureCoordinates\n * @glslFunction\n */\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/equalsEpsilon.js
var equalsEpsilon_default = "/**\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\n * <code>vec3</code>s, or <code>vec4</code>s.\n *\n * @name czm_equalsEpsilon\n * @glslFunction\n *\n * @param {} left The first vector.\n * @param {} right The second vector.\n * @param {float} epsilon The epsilon to use for equality testing.\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\n *\n * @example\n * // GLSL declarations\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\n */\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\n\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\n    return (abs(left - right) <= epsilon);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/eyeOffset.js
var eyeOffset_default = "/**\n * DOC_TBA\n *\n * @name czm_eyeOffset\n * @glslFunction\n *\n * @param {vec4} positionEC DOC_TBA.\n * @param {vec3} eyeOffset DOC_TBA.\n *\n * @returns {vec4} DOC_TBA.\n */\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\n    // This equation is approximate in x and y.\n    vec4 p = positionEC;\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\n    p.z += zEyeOffset.z;\n    return p;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/eyeToWindowCoordinates.js
var eyeToWindowCoordinates_default = "/**\n * Transforms a position from eye to window coordinates.  The transformation\n * from eye to clip coordinates is done using {@link czm_projection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n *\n * @name czm_eyeToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in eye coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_projection\n * @see czm_viewportTransformation\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n */\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/fastApproximateAtan.js
var fastApproximateAtan_default = `/**
 * Approxiamtes atan over the range [0, 1]. Safe to flip output for negative input.
 *
 * Based on Michal Drobot's approximation from ShaderFastLibs, which in turn is based on
 * "Efficient approximations for the arctangent function," Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
 * Adapted from ShaderFastLibs under MIT License.
 *
 * Chosen for the following characteristics over range [0, 1]:
 * - basically no error at 0 and 1, important for getting around range limit (naive atan2 via atan requires infinite range atan)
 * - no visible artifacts from first-derivative discontinuities, unlike latitude via range-reduced sqrt asin approximations (at equator)
 *
 * The original code is x * (-0.1784 * abs(x) - 0.0663 * x * x + 1.0301);
 * Removed the abs() in here because it isn't needed, the input range is guaranteed as [0, 1] by how we're approximating atan2.
 *
 * @name czm_fastApproximateAtan
 * @glslFunction
 *
 * @param {float} x Value between 0 and 1 inclusive.
 *
 * @returns {float} Approximation of atan(x)
 */
float czm_fastApproximateAtan(float x) {
    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);
}

/**
 * Approximation of atan2.
 *
 * Range reduction math based on nvidia's cg reference implementation for atan2: http://developer.download.nvidia.com/cg/atan2.html
 * However, we replaced their atan curve with Michael Drobot's (see above).
 *
 * @name czm_fastApproximateAtan
 * @glslFunction
 *
 * @param {float} x Value between -1 and 1 inclusive.
 * @param {float} y Value between -1 and 1 inclusive.
 *
 * @returns {float} Approximation of atan2(x, y)
 */
float czm_fastApproximateAtan(float x, float y) {
    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.
    // So range-reduce using abs and by flipping whether x or y is on top.
    float t = abs(x); // t used as swap and atan result.
    float opposite = abs(y);
    float adjacent = max(t, opposite);
    opposite = min(t, opposite);

    t = czm_fastApproximateAtan(opposite / adjacent);

    // Undo range reduction
    t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);
    t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);
    t = czm_branchFreeTernary(y < 0.0, -t, t);
    return t;
}
`;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/fog.js
var fog_default = "/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-(scalar * scalar));\n    return mix(color, fogColor, fog);\n}\n\n/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n * @param {float} fogModifierConstant A constant to modify the appearance of fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\n    return mix(color, fogColor, fog);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/gammaCorrect.js
var gammaCorrect_default = "/**\n * Converts a color from RGB space to linear space.\n *\n * @name czm_gammaCorrect\n * @glslFunction\n *\n * @param {vec3} color The color in RGB space.\n * @returns {vec3} The color in linear space.\n */\nvec3 czm_gammaCorrect(vec3 color) {\n#ifdef HDR\n    color = pow(color, vec3(czm_gamma));\n#endif\n    return color;\n}\n\nvec4 czm_gammaCorrect(vec4 color) {\n#ifdef HDR\n    color.rgb = pow(color.rgb, vec3(czm_gamma));\n#endif\n    return color;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/geodeticSurfaceNormal.js
var geodeticSurfaceNormal_default = "/**\n * DOC_TBA\n *\n * @name czm_geodeticSurfaceNormal\n * @glslFunction\n *\n * @param {vec3} positionOnEllipsoid DOC_TBA\n * @param {vec3} ellipsoidCenter DOC_TBA\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n * \n * @returns {vec3} DOC_TBA.\n */\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/getDefaultMaterial.js
var getDefaultMaterial_default = "/**\n * An czm_material with default values. Every material's czm_getMaterial\n * should use this default material as a base for the material it returns.\n * The default normal value is given by materialInput.normalEC.\n *\n * @name czm_getDefaultMaterial\n * @glslFunction\n *\n * @param {czm_materialInput} input The input used to construct the default material.\n *\n * @returns {czm_material} The default material.\n *\n * @see czm_materialInput\n * @see czm_material\n * @see czm_getMaterial\n */\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\n    czm_material material;\n    material.diffuse = vec3(0.0);\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = materialInput.normalEC;\n    material.emission = vec3(0.0);\n    material.alpha = 1.0;\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/getLambertDiffuse.js
var getLambertDiffuse_default = "/**\n * Calculates the intensity of diffusely reflected light.\n *\n * @name czm_getLambertDiffuse\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n *\n * @returns {float} The intensity of the diffuse reflection.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\n    return max(dot(lightDirectionEC, normalEC), 0.0);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/getSpecular.js
var getSpecular_default = "/**\n * Calculates the specular intensity of reflected light.\n *\n * @name czm_getSpecular\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n *\n * @returns {float} The intensity of the specular highlight.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\n\n    // pow has undefined behavior if both parameters <= 0.\n    // Prevent this by making sure shininess is at least czm_epsilon2.\n    return pow(specular, max(shininess, czm_epsilon2));\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/getWaterNoise.js
var getWaterNoise_default = "/**\n * @private\n */\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\n    float cosAngle = cos(angleInRadians);\n    float sinAngle = sin(angleInRadians);\n\n    // time dependent sampling directions\n    vec2 s0 = vec2(1.0/17.0, 0.0);\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\n    // rotate sampling direction by specified angle\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\n    vec2 uv0 = (uv/103.0) + (time * s0);\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\n    uv0 = fract(uv0);\n    uv1 = fract(uv1);\n    uv2 = fract(uv2);\n    uv3 = fract(uv3);\n    vec4 noise = (texture2D(normalMap, uv0)) +\n                 (texture2D(normalMap, uv1)) +\n                 (texture2D(normalMap, uv2)) +\n                 (texture2D(normalMap, uv3));\n\n    // average and scale to between -1 and 1\n    return ((noise / 4.0) - 0.5) * 2.0;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/hue.js
var hue_default = "/**\n * Adjusts the hue of a color.\n * \n * @name czm_hue\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\n *\n * @returns {float} The color with the hue adjusted.\n *\n * @example\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\n */\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n                            0.595716, -0.274453, -0.321263,\n                            0.211456, -0.522591,  0.311135);\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n                            1.0, -0.2721, -0.6474,\n                            1.0, -1.107,   1.7046);\n    \n    vec3 yiq = toYIQ * rgb;\n    float hue = atan(yiq.z, yiq.y) + adjustment;\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n    \n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n    return toRGB * color;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/inverseGamma.js
var inverseGamma_default = "/**\n * Converts a color in linear space to RGB space.\n *\n * @name czm_inverseGamma\n * @glslFunction\n *\n * @param {vec3} color The color in linear space.\n * @returns {vec3} The color in RGB space.\n */\nvec3 czm_inverseGamma(vec3 color) {\n    return pow(color, vec3(1.0 / czm_gamma));\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/isEmpty.js
var isEmpty_default = "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isEmpty\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isEmpty(czm_raySegment interval)\n{\n    return (interval.stop < 0.0);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/isFull.js
var isFull_default = "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isFull\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isFull(czm_raySegment interval)\n{\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/latitudeToWebMercatorFraction.js
var latitudeToWebMercatorFraction_default = "/**\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\n *\n * @name czm_latitudeToWebMercatorFraction\n * @glslFunction\n *\n * @param {float} latitude The geodetic latitude, in radians.\n * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\n *\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n */ \nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)\n{\n    float sinLatitude = sin(latitude);\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    return (mercatorY - southMercatorY) * oneOverMercatorHeight;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/lineDistance.js
var lineDistance_default = "/**\n * Computes distance from an point in 2D to a line in 2D.\n *\n * @name czm_lineDistance\n * @glslFunction\n *\n * param {vec2} point1 A point along the line.\n * param {vec2} point2 A point along the line.\n * param {vec2} point A point that may or may not be on the line.\n * returns {float} The distance from the point to the line.\n */\nfloat czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {\n    return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/linearToSrgb.js
var linearToSrgb_default = "/**\n * Converts a linear RGB color to an sRGB color.\n *\n * @param {vec3|vec4} linearIn The color in linear color space.\n * @returns {vec3|vec4} The color in sRGB color space. The vector type matches the input.\n */\nvec3 czm_linearToSrgb(vec3 linearIn) \n{\n    return pow(linearIn, vec3(1.0/2.2));\n}\n\nvec4 czm_linearToSrgb(vec4 linearIn) \n{\n    vec3 srgbOut = pow(linearIn.rgb, vec3(1.0/2.2));\n    return vec4(srgbOut, linearIn.a);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/luminance.js
var luminance_default = "/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/metersPerPixel.js
var metersPerPixel_default = "/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when passing in a custom pixel ratio. For example, passing in 1.0 will return meters per native device pixel.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n * @param {float} pixelRatio The scaling factor from pixel space to coordinate space\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC, float pixelRatio)\n{\n    float width = czm_viewport.z;\n    float height = czm_viewport.w;\n    float pixelWidth;\n    float pixelHeight;\n\n    float top = czm_frustumPlanes.x;\n    float bottom = czm_frustumPlanes.y;\n    float left = czm_frustumPlanes.z;\n    float right = czm_frustumPlanes.w;\n\n    if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)\n    {\n        float frustumWidth = right - left;\n        float frustumHeight = top - bottom;\n        pixelWidth = frustumWidth / width;\n        pixelHeight = frustumHeight / height;\n    }\n    else\n    {\n        float distanceToPixel = -positionEC.z;\n        float inverseNear = 1.0 / czm_currentFrustum.x;\n        float tanTheta = top * inverseNear;\n        pixelHeight = 2.0 * distanceToPixel * tanTheta / height;\n        tanTheta = right * inverseNear;\n        pixelWidth = 2.0 * distanceToPixel * tanTheta / width;\n    }\n\n    return max(pixelWidth, pixelHeight) * pixelRatio;\n}\n\n/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when scaling by pixel ratio.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC)\n{\n    return czm_metersPerPixel(positionEC, czm_pixelRatio);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/modelToWindowCoordinates.js
var modelToWindowCoordinates_default = "/**\n * Transforms a position from model to window coordinates.  The transformation\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n * <br /><br />\n * This function should not be confused with {@link czm_viewportOrthographic},\n * which is an orthographic projection matrix that transforms from window \n * coordinates to clip coordinates.\n *\n * @name czm_modelToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in model coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_eyeToWindowCoordinates\n * @see czm_modelViewProjection\n * @see czm_viewportTransformation\n * @see czm_viewportOrthographic\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n */\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\n    vec4 q = czm_modelViewProjection * position;                // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/multiplyWithColorBalance.js
var multiplyWithColorBalance_default = "/**\n * DOC_TBA\n *\n * @name czm_multiplyWithColorBalance\n * @glslFunction\n */\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec3 target = left * right;\n    float leftLuminance = dot(left, W);\n    float rightLuminance = dot(right, W);\n    float targetLuminance = dot(target, W);\n    \n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/nearFarScalar.js
var nearFarScalar_default = "/**\n * Computes a value that scales with distance.  The scaling is clamped at the near and\n * far distances, and does not extrapolate.  This function works with the\n * {@link NearFarScalar} JavaScript class.\n *\n * @name czm_nearFarScalar\n * @glslFunction\n *\n * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w).\n * @param {float} cameraDistSq The square of the current distance from the camera.\n *\n * @returns {float} The value at this distance.\n */\nfloat czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\n    float valueAtMin = nearFarScalar.y;\n    float valueAtMax = nearFarScalar.w;\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\n\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\n\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\n\n    return mix(valueAtMin, valueAtMax, t);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/octDecode.js
var octDecode_default = ` /**
  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.
  * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
  *
  * @name czm_octDecode
  * @param {vec2} encoded The oct-encoded, unit-length vector
  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.
  * @returns {vec3} The decoded and normalized vector
  */
  vec3 czm_octDecode(vec2 encoded, float range)
  {
      if (encoded.x == 0.0 && encoded.y == 0.0) {
          return vec3(0.0, 0.0, 0.0);
      }

     encoded = encoded / range * 2.0 - 1.0;
     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));
     if (v.z < 0.0)
     {
         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);
     }

     return normalize(v);
  }

/**
 * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {vec2} encoded The oct-encoded, unit-length vector
 * @returns {vec3} The decoded and normalized vector
 */
 vec3 czm_octDecode(vec2 encoded)
 {
    return czm_octDecode(encoded, 255.0);
 }

 /**
 * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {float} encoded The oct-encoded, unit-length vector
 * @returns {vec3} The decoded and normalized vector
 */
 vec3 czm_octDecode(float encoded)
 {
    float temp = encoded / 256.0;
    float x = floor(temp);
    float y = (temp - x) * 256.0;
    return czm_octDecode(vec2(x, y));
 }

/**
 * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {vec2} encoded The packed oct-encoded, unit-length vectors.
 * @param {vec3} vector1 One decoded and normalized vector.
 * @param {vec3} vector2 One decoded and normalized vector.
 * @param {vec3} vector3 One decoded and normalized vector.
 */
  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)
 {
    float temp = encoded.x / 65536.0;
    float x = floor(temp);
    float encodedFloat1 = (temp - x) * 65536.0;

    temp = encoded.y / 65536.0;
    float y = floor(temp);
    float encodedFloat2 = (temp - y) * 65536.0;

    vector1 = czm_octDecode(encodedFloat1);
    vector2 = czm_octDecode(encodedFloat2);
    vector3 = czm_octDecode(vec2(x, y));
 }

`;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/packDepth.js
var packDepth_default = "/**\n * Packs a depth value into a vec3 that can be represented by unsigned bytes.\n *\n * @name czm_packDepth\n * @glslFunction\n *\n * @param {float} depth The floating-point depth.\n * @returns {vec3} The packed depth.\n */\nvec4 czm_packDepth(float depth)\n{\n    // See Aras Pranckevi\u010Dius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/pbrLighting.js
var pbrLighting_default = "vec3 lambertianDiffuse(vec3 diffuseColor)\n{\n    return diffuseColor / czm_pi;\n}\n\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat smithVisibilityG1(float NdotV, float roughness)\n{\n    // this is the k value for direct lighting.\n    // for image based lighting it will be roughness^2 / 2\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat smithVisibilityGGX(float roughness, float NdotL, float NdotV)\n{\n    return (\n        smithVisibilityG1(NdotL, roughness) *\n        smithVisibilityG1(NdotV, roughness)\n    );\n}\n\nfloat GGX(float roughness, float NdotH)\n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (czm_pi * f * f);\n}\n\n/**\n * Compute the diffuse and specular contributions using physically based\n * rendering. This function only handles direct lighting.\n * <p>\n * This function only handles the lighting calculations. Metallic/roughness\n * and specular/glossy must be handled separately. See {@czm_pbrMetallicRoughnessMaterial}, {@czm_pbrSpecularGlossinessMaterial} and {@czm_defaultPbrMaterial}\n * </p>\n *\n * @name czm_pbrlighting\n * @glslFunction\n *\n * @param {vec3} positionEC The position of the fragment in eye coordinates\n * @param {vec3} normalEC The surface normal in eye coordinates\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} lightColorHdr radiance of the light source. This is a HDR value.\n * @param {czm_pbrParameters} The computed PBR parameters.\n * @return {vec3} The computed HDR color\n *\n * @example\n * czm_pbrParameters pbrParameters = czm_pbrMetallicRoughnessMaterial(\n *  baseColor,\n *  metallic,\n *  roughness\n * );\n * vec3 color = czm_pbrlighting(\n *  positionEC,\n *  normalEC,\n *  lightDirectionEC,\n *  lightColorHdr,\n *  pbrParameters);\n */\nvec3 czm_pbrLighting(\n    vec3 positionEC,\n    vec3 normalEC,\n    vec3 lightDirectionEC,\n    vec3 lightColorHdr,\n    czm_pbrParameters pbrParameters\n)\n{\n    vec3 v = -normalize(positionEC);\n    vec3 l = normalize(lightDirectionEC);\n    vec3 h = normalize(v + l);\n    vec3 n = normalEC;\n    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n    float NdotV = abs(dot(n, v)) + 0.001;\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    vec3 f0 = pbrParameters.f0;\n    float reflectance = max(max(f0.r, f0.g), f0.b);\n    vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n    vec3 F = fresnelSchlick2(f0, f90, VdotH);\n\n    float alpha = pbrParameters.roughness;\n    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n    float D = GGX(alpha, NdotH);\n    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n\n    vec3 diffuseColor = pbrParameters.diffuseColor;\n    // F here represents the specular contribution\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n\n    // Lo = (diffuse + specular) * Li * NdotL\n    return (diffuseContribution + specularContribution) * NdotL * lightColorHdr;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/pbrMetallicRoughnessMaterial.js
var pbrMetallicRoughnessMaterial_default = "/**\n * Compute parameters for physically based rendering using the\n * metallic/roughness workflow. All inputs are linear; sRGB texture values must\n * be decoded beforehand\n *\n * @name czm_pbrMetallicRoughnessMaterial\n * @glslFunction\n *\n * @param {vec3} baseColor For dielectrics, this is the base color. For metals, this is the f0 value (reflectance at normal incidence)\n * @param {float} metallic 0.0 indicates dielectric. 1.0 indicates metal. Values in between are allowed (e.g. to model rust or dirt);\n * @param {float} roughness A value between 0.0 and 1.0\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_pbrMetallicRoughnessMaterial(\n    vec3 baseColor,\n    float metallic,\n    float roughness\n) \n{\n    czm_pbrParameters results;\n\n    // roughness is authored as perceptual roughness\n    // square it to get material roughness\n    roughness = clamp(roughness, 0.0, 1.0);\n    results.roughness = roughness * roughness;\n\n    // dielectrics use f0 = 0.04, metals use albedo as f0\n    metallic = clamp(metallic, 0.0, 1.0);\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\n    vec3 f0 = mix(REFLECTANCE_DIELECTRIC, baseColor, metallic);\n    results.f0 = f0;\n\n    // diffuse only applies to dielectrics.\n    results.diffuseColor = baseColor * (1.0 - f0) * (1.0 - metallic);\n\n    return results;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/pbrSpecularGlossinessMaterial.js
var pbrSpecularGlossinessMaterial_default = "/**\n * Compute parameters for physically based rendering using the\n * specular/glossy workflow. All inputs are linear; sRGB texture values must\n * be decoded beforehand\n *\n * @name czm_pbrSpecularGlossinessMaterial\n * @glslFunction\n *\n * @param {vec3} diffuse The diffuse color for dielectrics (non-metals)\n * @param {vec3} specular The reflectance at normal incidence (f0)\n * @param {float} glossiness A number from 0.0 to 1.0 indicating how smooth the surface is.\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_pbrSpecularGlossinessMaterial(\n    vec3 diffuse,\n    vec3 specular,\n    float glossiness\n) \n{\n    czm_pbrParameters results;\n\n    // glossiness is the opposite of roughness, but easier for artists to use.\n    float roughness = 1.0 - glossiness;\n    results.roughness = roughness * roughness;\n\n    results.diffuseColor = diffuse * (1.0 - max(max(specular.r, specular.g), specular.b));\n    results.f0 = specular;\n\n    return results;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/phong.js
var phong_default = "float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\n\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\n\n/**\n * Computes a color using the Phong lighting model.\n *\n * @name czm_phong\n * @glslFunction\n *\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n * @param {czm_material} material The fragment's material.\n *\n * @returns {vec4} The computed color.\n *\n * @example\n * vec3 positionToEyeEC = // ...\n * czm_material material = // ...\n * vec3 lightDirectionEC = // ...\n * gl_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC);\n *\n * @see czm_getMaterial\n */\nvec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down)\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n    }\n\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n\nvec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    vec3 ambient = vec3(0.0);\n    vec3 color = ambient + material.emission;\n    color += material.diffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/planeDistance.js
var planeDistance_default = "/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec4} plane A Plane in Hessian Normal Form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec4 plane, vec3 point) {\n    return (dot(plane.xyz, point) + plane.w);\n}\n\n/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec3} planeNormal Normal for a plane in Hessian Normal Form. See Plane.js\n * param {float} planeDistance Distance for a plane in Hessian Normal form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {\n    return (dot(planeNormal, point) + planeDistance);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/pointAlongRay.js
var pointAlongRay_default = "/**\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n *\n * @name czm_pointAlongRay\n * @glslFunction\n *\n * @param {czm_ray} ray The ray to compute the point along.\n * @param {float} time The time along the ray.\n * \n * @returns {vec3} The point along the ray at the given time.\n * \n * @example\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n */\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\n    return ray.origin + (time * ray.direction);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/rayEllipsoidIntersectionInterval.js
var rayEllipsoidIntersectionInterval_default = "/**\n * DOC_TBA\n *\n * @name czm_rayEllipsoidIntersectionInterval\n * @glslFunction\n */\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)\n{\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n    vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n    vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n\n    q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;\n\n    float q2 = dot(q, q);\n    float qw = dot(q, w);\n\n    if (q2 > 1.0) // Outside ellipsoid.\n    {\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n        {\n            return czm_emptyRaySegment;\n        }\n        else // qw < 0.0.\n        {\n            float qw2 = qw * qw;\n            float difference = q2 - 1.0; // Positively valued.\n            float w2 = dot(w, w);\n            float product = w2 * difference;\n\n            if (qw2 < product) // Imaginary roots (0 intersections).\n            {\n                return czm_emptyRaySegment;\n            }\n            else if (qw2 > product) // Distinct roots (2 intersections).\n            {\n                float discriminant = qw * qw - product;\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n                float root0 = temp / w2;\n                float root1 = difference / temp;\n                if (root0 < root1)\n                {\n                    czm_raySegment i = czm_raySegment(root0, root1);\n                    return i;\n                }\n                else\n                {\n                    czm_raySegment i = czm_raySegment(root1, root0);\n                    return i;\n                }\n            }\n            else // qw2 == product.  Repeated roots (2 intersections).\n            {\n                float root = sqrt(difference / w2);\n                czm_raySegment i = czm_raySegment(root, root);\n                return i;\n            }\n        }\n    }\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n    {\n        float difference = q2 - 1.0; // Negatively valued.\n        float w2 = dot(w, w);\n        float product = w2 * difference; // Negatively valued.\n        float discriminant = qw * qw - product;\n        float temp = -qw + sqrt(discriminant); // Positively valued.\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\n        return i;\n    }\n    else // q2 == 1.0. On ellipsoid.\n    {\n        if (qw < 0.0) // Looking inward.\n        {\n            float w2 = dot(w, w);\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n            return i;\n        }\n        else // qw >= 0.0.  Looking outward or tangent.\n        {\n            return czm_emptyRaySegment;\n        }\n    }\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/raySphereIntersectionInterval.js
var raySphereIntersectionInterval_default = "/**\n * Compute the intersection interval of a ray with a sphere.\n *\n * @name czm_raySphereIntersectionInterval\n * @glslFunction\n *\n * @param {czm_ray} ray The ray.\n * @param {vec3} center The center of the sphere.\n * @param {float} radius The radius of the sphere.\n * @return {czm_raySegment} The intersection interval of the ray with the sphere.\n */\nczm_raySegment czm_raySphereIntersectionInterval(czm_ray ray, vec3 center, float radius)\n{\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n\n    vec3 oc = o - center;\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, oc);\n    float c = dot(oc, oc) - (radius * radius);\n\n    float det = (b * b) - (4.0 * a * c);\n\n    if (det < 0.0) {\n        return czm_emptyRaySegment;\n    }\n\n    float sqrtDet = sqrt(det);\n\n    float t0 = (-b - sqrtDet) / (2.0 * a);\n    float t1 = (-b + sqrtDet) / (2.0 * a);\n\n    czm_raySegment result = czm_raySegment(t0, t1);\n    return result;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/readDepth.js
var readDepth_default = "float czm_readDepth(sampler2D depthTexture, vec2 texCoords)\n{\n    return czm_reverseLogDepth(texture2D(depthTexture, texCoords).r);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/readNonPerspective.js
var readNonPerspective_default = "/**\n * Reads a value previously transformed with {@link czm_writeNonPerspective}\n * by dividing it by `w`, the value used in the perspective divide.\n * This function is intended to be called in a fragment shader to access a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The value should have been\n * previously written in the vertex shader with a call to\n * {@link czm_writeNonPerspective}.\n *\n * @name czm_readNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The non-perspective value to be read.\n * @param {float} oneOverW One over the perspective divide value, `w`. Usually this is simply `gl_FragCoord.w`.\n * @returns {float|vec2|vec3|vec4} The usable value.\n */\nfloat czm_readNonPerspective(float value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec2 czm_readNonPerspective(vec2 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec3 czm_readNonPerspective(vec3 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec4 czm_readNonPerspective(vec4 value, float oneOverW) {\n    return value * oneOverW;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/reverseLogDepth.js
var reverseLogDepth_default = "float czm_reverseLogDepth(float logZ)\n{\n#ifdef LOG_DEPTH\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    return far * (1.0 - near / (depthFromNear + near)) / (far - near);\n#endif\n    return logZ;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/round.js
var round_default = "/**\n * Round a floating point value. This function exists because round() doesn't\n * exist in GLSL 1.00. \n *\n * @param {float|vec2|vec3|vec4} value The value to round\n * @param {float|vec2|vec3|vec3} The rounded value. The type matches the input.\n */\nfloat czm_round(float value) {\n  return floor(value + 0.5);\n}\n\nvec2 czm_round(vec2 value) {\n  return floor(value + 0.5);\n}\n\nvec3 czm_round(vec3 value) {\n  return floor(value + 0.5);\n}\n\nvec4 czm_round(vec4 value) {\n  return floor(value + 0.5);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/sampleOctahedralProjection.js
var sampleOctahedralProjection_default = "/**\n * Samples the 4 neighboring pixels and return the weighted average.\n *\n * @private\n */\nvec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)\n{\n    direction /= dot(vec3(1.0), abs(direction));\n    vec2 rev = abs(direction.zx) - vec2(1.0);\n    vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,\n                    direction.z < 0.0 ? rev.y : -rev.y);\n    vec2 uv = direction.y < 0.0 ? neg : direction.xz;\n    vec2 coord = 0.5 * uv + vec2(0.5);\n    vec2 pixel = 1.0 / textureSize;\n\n    if (lod > 0.0)\n    {\n        // Each subseqeuent mip level is half the size\n        float scale = 1.0 / pow(2.0, lod);\n        float offset = ((textureSize.y + 1.0) / textureSize.x);\n\n        coord.x *= offset;\n        coord *= scale;\n\n        coord.x += offset + pixel.x;\n        coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;\n    }\n    else\n    {\n        coord.x *= (textureSize.y / textureSize.x);\n    }\n\n    // Do bilinear filtering\n    #ifndef OES_texture_float_linear\n        vec3 color1 = texture2D(projectedMap, coord + vec2(0.0, pixel.y)).rgb;\n        vec3 color2 = texture2D(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;\n        vec3 color3 = texture2D(projectedMap, coord + pixel).rgb;\n        vec3 color4 = texture2D(projectedMap, coord).rgb;\n\n        vec2 texturePosition = coord * textureSize;\n\n        float fu = fract(texturePosition.x);\n        float fv = fract(texturePosition.y);\n\n        vec3 average1 = mix(color4, color2, fu);\n        vec3 average2 = mix(color1, color3, fu);\n\n        vec3 color = mix(average1, average2, fv);\n    #else\n        vec3 color = texture2D(projectedMap, coord).rgb;\n    #endif\n\n    return color;\n}\n\n\n/**\n * Samples from a cube map that has been projected using an octahedral projection from the given direction.\n *\n * @name czm_sampleOctahedralProjection\n * @glslFunction\n *\n * @param {sampler2D} projectedMap The texture with the octahedral projected cube map.\n * @param {vec2} textureSize The width and height dimensions in pixels of the projected map.\n * @param {vec3} direction The normalized direction used to sample the cube map.\n * @param {float} lod The level of detail to sample.\n * @param {float} maxLod The maximum level of detail.\n * @returns {vec3} The color of the cube map at the direction.\n */\nvec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {\n    float currentLod = floor(lod + 0.5);\n    float nextLod = min(currentLod + 1.0, maxLod);\n\n    vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);\n    vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);\n\n    return mix(colorNextLod, colorCurrentLod, nextLod - lod);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/saturation.js
var saturation_default = "/**\n * Adjusts the saturation of a color.\n * \n * @name czm_saturation\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the saturation of the color.\n *\n * @returns {float} The color with the saturation adjusted.\n *\n * @example\n * vec3 greyScale = czm_saturation(color, 0.0);\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\n */\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/shadowDepthCompare.js
var shadowDepthCompare_default = "\nfloat czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d)\n{\n    return czm_unpackDepth(textureCube(shadowMap, d));\n}\n\nfloat czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv)\n{\n#ifdef USE_SHADOW_DEPTH_TEXTURE\n    return texture2D(shadowMap, uv).r;\n#else\n    return czm_unpackDepth(texture2D(shadowMap, uv));\n#endif\n}\n\nfloat czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n\nfloat czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/shadowVisibility.js
var shadowVisibility_default = "\nfloat czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)\n{\n#ifdef USE_NORMAL_SHADING\n#ifdef USE_NORMAL_SHADING_SMOOTH\n    float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);\n#else\n    float strength = step(0.0, nDotL);\n#endif\n    visibility *= strength;\n#endif\n\n    visibility = max(visibility, darkness);\n    return visibility;\n}\n\n#ifdef USE_CUBE_MAP_SHADOW\nfloat czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n\n    depth -= depthBias;\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#else\nfloat czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n\n    depth -= depthBias;\n#ifdef USE_SOFT_SHADOWS\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility = (\n        czm_shadowDepthCompare(shadowMap, uv, depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0);\n#else\n    float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);\n#endif\n\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#endif\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/signNotZero.js
var signNotZero_default = "/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\n * \n * @name czm_signNotZero\n * @glslFunction\n *\n * @param {} value The value for which to determine the sign.\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\n */\nfloat czm_signNotZero(float value)\n{\n    return value >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 czm_signNotZero(vec2 value)\n{\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\n\nvec3 czm_signNotZero(vec3 value)\n{\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\n\nvec4 czm_signNotZero(vec4 value)\n{\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/sphericalHarmonics.js
var sphericalHarmonics_default = "/**\n * Computes a color from the third order spherical harmonic coefficients and a normalized direction vector.\n * <p>\n * The order of the coefficients is [L00, L1_1, L10, L11, L2_2, L2_1, L20, L21, L22].\n * </p>\n *\n * @name czm_sphericalHarmonics\n * @glslFunction\n *\n * @param {vec3} normal The normalized direction.\n * @param {vec3[9]} coefficients The third order spherical harmonic coefficients.\n * @returns {vec3} The color at the direction.\n *\n * @see https://graphics.stanford.edu/papers/envmap/envmap.pdf\n */\nvec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])\n{\n    vec3 L00 = coefficients[0];\n    vec3 L1_1 = coefficients[1];\n    vec3 L10 = coefficients[2];\n    vec3 L11 = coefficients[3];\n    vec3 L2_2 = coefficients[4];\n    vec3 L2_1 = coefficients[5];\n    vec3 L20 = coefficients[6];\n    vec3 L21 = coefficients[7];\n    vec3 L22 = coefficients[8];\n\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n\n    return\n          L00\n        + L1_1 * y\n        + L10 * z\n        + L11 * x\n        + L2_2 * (y * x)\n        + L2_1 * (y * z)\n        + L20 * (3.0 * z * z - 1.0)\n        + L21 * (z * x)\n        + L22 * (x * x - y * y);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/srgbToLinear.js
var srgbToLinear_default = "/**\n * Converts an sRGB color to a linear RGB color.\n *\n * @param {vec3|vec4} srgbIn The color in sRGB space\n * @returns {vec3|vec4} The color in linear color space. The vector type matches the input.\n */\nvec3 czm_srgbToLinear(vec3 srgbIn)\n{\n    return pow(srgbIn, vec3(2.2));\n}\n\nvec4 czm_srgbToLinear(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/tangentToEyeSpaceMatrix.js
var tangentToEyeSpaceMatrix_default = "/**\n * Creates a matrix that transforms vectors from tangent space to eye space.\n *\n * @name czm_tangentToEyeSpaceMatrix\n * @glslFunction\n *\n * @param {vec3} normalEC The normal vector in eye coordinates.\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\n * @param {vec3} bitangentEC The bitangent vector in eye coordinates.\n *\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\n *\n * @example\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC);\n * vec3 normal = tangentToEye * texture2D(normalMap, st).xyz;\n */\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)\n{\n    vec3 normal = normalize(normalEC);\n    vec3 tangent = normalize(tangentEC);\n    vec3 bitangent = normalize(bitangentEC);\n    return mat3(tangent.x  , tangent.y  , tangent.z,\n                bitangent.x, bitangent.y, bitangent.z,\n                normal.x   , normal.y   , normal.z);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/transformPlane.js
var transformPlane_default = "/**\n * Transforms a plane.\n * \n * @name czm_transformPlane\n * @glslFunction\n *\n * @param {vec4} plane The plane in Hessian Normal Form.\n * @param {mat4} transform The inverse-transpose of a transformation matrix.\n */\nvec4 czm_transformPlane(vec4 plane, mat4 transform) {\n    vec4 transformedPlane = transform * plane;\n    // Convert the transformed plane to Hessian Normal Form\n    float normalMagnitude = length(transformedPlane.xyz);\n    return transformedPlane / normalMagnitude;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/translateRelativeToEye.js
var translateRelativeToEye_default = "/**\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n * respectively.\n * <p>\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n * described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @name czm_translateRelativeToEye\n * @glslFunction\n *\n * @param {vec3} high The position's high bits.\n * @param {vec3} low The position's low bits.\n * @returns {vec3} The position translated to be relative to the camera's position.\n *\n * @example\n * attribute vec3 positionHigh;\n * attribute vec3 positionLow;\n *\n * void main()\n * {\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n * }\n *\n * @see czm_modelViewRelativeToEye\n * @see czm_modelViewProjectionRelativeToEye\n * @see czm_computePosition\n * @see EncodedCartesian3\n */\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\n    return vec4(highDifference + lowDifference, 1.0);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/translucentPhong.js
var translucentPhong_default = "/**\n * @private\n */\nvec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\n\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n    }\n\n    diffuse = clamp(diffuse, 0.0, 1.0);\n\n    float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/transpose.js
var transpose_default = "/**\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be\n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n *\n * @name czm_transpose\n * @glslFunction\n *\n * @param {} matrix The matrix to transpose.\n *\n * @returns {} The transposed matrix.\n *\n * @example\n * // GLSL declarations\n * mat2 czm_transpose(mat2 matrix);\n * mat3 czm_transpose(mat3 matrix);\n * mat4 czm_transpose(mat4 matrix);\n *\n * // Transpose a 3x3 rotation matrix to find its inverse.\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n *     positionMC, normalEC);\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n */\nmat2 czm_transpose(mat2 matrix)\n{\n    return mat2(\n        matrix[0][0], matrix[1][0],\n        matrix[0][1], matrix[1][1]);\n}\n\nmat3 czm_transpose(mat3 matrix)\n{\n    return mat3(\n        matrix[0][0], matrix[1][0], matrix[2][0],\n        matrix[0][1], matrix[1][1], matrix[2][1],\n        matrix[0][2], matrix[1][2], matrix[2][2]);\n}\n\nmat4 czm_transpose(mat4 matrix)\n{\n    return mat4(\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/unpackDepth.js
var unpackDepth_default = "/**\n * Unpacks a vec4 depth value to a float in [0, 1) range.\n *\n * @name czm_unpackDepth\n * @glslFunction\n *\n * @param {vec4} packedDepth The packed depth.\n *\n * @returns {float} The floating-point depth in [0, 1) range.\n */\n float czm_unpackDepth(vec4 packedDepth)\n {\n    // See Aras Pranckevi\u010Dius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n }\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/unpackFloat.js
var unpackFloat_default = "/**\n * Unpack an IEEE 754 single-precision float that is packed as a little-endian unsigned normalized vec4.\n *\n * @name czm_unpackFloat\n * @glslFunction\n *\n * @param {vec4} packedFloat The packed float.\n *\n * @returns {float} The floating-point depth in arbitrary range.\n */\nfloat czm_unpackFloat(vec4 packedFloat)\n{\n    // Convert to [0.0, 255.0] and round to integer\n    packedFloat = floor(packedFloat * 255.0 + 0.5);\n    float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;\n    float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;    \n    if (exponent == -127.0)\n    {\n        return 0.0;\n    }\n    float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);\n    float result = sign * exp2(exponent - 23.0) * mantissa;\n    return result;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/unpackUint.js
var unpackUint_default = "/**\n * Unpack unsigned integers of 1-4 bytes. in WebGL 1, there is no uint type,\n * so the return value is an int.\n * <p>\n * There are also precision limitations in WebGL 1. highp int is still limited\n * to 24 bits. Above the value of 2^24 = 16777216, precision loss may occur.\n * </p>\n *\n * @param {float|vec2|vec3|vec4} packed The packed value. For vectors, the components are listed in little-endian order.\n *\n * @return {int} The unpacked value.\n */\n int czm_unpackUint(float packedValue) {\n   float rounded = czm_round(packedValue * 255.0);\n   return int(rounded);\n }\n\n int czm_unpackUint(vec2 packedValue) {\n   vec2 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec2(1.0, 256.0)));\n }\n\n int czm_unpackUint(vec3 packedValue) {\n   vec3 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec3(1.0, 256.0, 65536.0)));\n }\n\n int czm_unpackUint(vec4 packedValue) {\n   vec4 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec4(1.0, 256.0, 65536.0, 16777216.0)));\n }\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/valueTransform.js
var valueTransform_default = "/**\n * Transform metadata values following the EXT_structural_metadata spec\n * by multiplying by scale and adding the offset. Operations are always\n * performed component-wise, even for matrices.\n * \n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} offset The offset to add\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} scale The scale factor to multiply\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} value The original value.\n *\n * @return {float|vec2|vec3|vec4|mat2|mat3|mat4} The transformed value of the same scalar/vector/matrix type as the input.\n */\nfloat czm_valueTransform(float offset, float scale, float value) {\n  return scale * value + offset;\n}\n\nvec2 czm_valueTransform(vec2 offset, vec2 scale, vec2 value) {\n  return scale * value + offset;\n}\n\nvec3 czm_valueTransform(vec3 offset, vec3 scale, vec3 value) {\n  return scale * value + offset;\n}\n\nvec4 czm_valueTransform(vec4 offset, vec4 scale, vec4 value) {\n  return scale * value + offset;\n}\n\nmat2 czm_valueTransform(mat2 offset, mat2 scale, mat2 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat3 czm_valueTransform(mat3 offset, mat3 scale, mat3 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat4 czm_valueTransform(mat4 offset, mat4 scale, mat4 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/vertexLogDepth.js
var vertexLogDepth_default = "#ifdef LOG_DEPTH\n// 1.0 at the near plane, increasing linearly from there.\nvarying float v_depthFromNearPlusOne;\n#ifdef SHADOW_MAP\nvarying vec3 v_logPositionEC;\n#endif\n#endif\n\nvec4 czm_updatePositionDepth(vec4 coords) {\n#if defined(LOG_DEPTH)\n\n#ifdef SHADOW_MAP\n    vec3 logPositionEC = (czm_inverseProjection * coords).xyz;\n    v_logPositionEC = logPositionEC;\n#endif\n\n    // With the very high far/near ratios used with the logarithmic depth\n    // buffer, floating point rounding errors can cause linear depth values\n    // to end up on the wrong side of the far plane, even for vertices that\n    // are really nowhere near it. Since we always write a correct logarithmic\n    // depth value in the fragment shader anyway, we just need to make sure\n    // such errors don't cause the primitive to be clipped entirely before\n    // we even get to the fragment shader.\n    coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;\n#endif\n\n    return coords;\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the already computed gl_Position.\n *\n * @name czm_vertexLogDepth\n * @glslFunction\n */\nvoid czm_vertexLogDepth()\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;\n    gl_Position = czm_updatePositionDepth(gl_Position);\n#endif\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the provided clip coordinates.\n * <p>\n * An example use case for this function would be moving the vertex in window coordinates\n * before converting back to clip coordinates. Use the original vertex clip coordinates.\n * </p>\n * @name czm_vertexLogDepth\n * @glslFunction\n *\n * @param {vec4} clipCoords The vertex in clip coordinates.\n *\n * @example\n * czm_vertexLogDepth(czm_projection * vec4(positionEyeCoordinates, 1.0));\n */\nvoid czm_vertexLogDepth(vec4 clipCoords)\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0;\n    czm_updatePositionDepth(clipCoords);\n#endif\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/windowToEyeCoordinates.js
var windowToEyeCoordinates_default = "/**\n * Transforms a position from window to eye coordinates.\n * The transform from window to normalized device coordinates is done using components\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\n * which is expected to be the scalar used in the perspective divide. The transformation\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n *\n * @returns {vec4} The transformed position in eye coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @example\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n */\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\n    // Reconstruct NDC coordinates\n    float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\n    float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\n    float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 q = vec4(x, y, z, 1.0);\n\n    // Reverse the perspective division to obtain clip coordinates.\n    q /= fragmentCoordinate.w;\n\n    // Reverse the projection transformation to obtain eye coordinates.\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\n    {\n        q = czm_inverseProjection * q;\n    }\n    else\n    {\n        float top = czm_frustumPlanes.x;\n        float bottom = czm_frustumPlanes.y;\n        float left = czm_frustumPlanes.z;\n        float right = czm_frustumPlanes.w;\n\n        float near = czm_currentFrustum.x;\n        float far = czm_currentFrustum.y;\n\n        q.x = (q.x * (right - left) + left + right) * 0.5;\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\n        q.z = (q.z * (near - far) - near - far) * 0.5;\n        q.w = 1.0;\n    }\n\n    return q;\n}\n\n/**\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\n * This function produces more accurate results for window positions with log depth than\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\n * of czm_windowToEyeCoordinates.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @returns {vec4} The transformed position in eye coordinates.\n */\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\n{\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\n#ifdef LOG_DEPTH\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    float depthFromCamera = depthFromNear + near;\n    vec4 windowCoord = vec4(fragmentCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\n    return eyeCoordinate;\n#else\n    vec4 windowCoord = vec4(fragmentCoordinateXY, depthOrLogDepth, 1.0);\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\n#endif\n    return eyeCoordinate;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/writeDepthClamp.js
var writeDepthClamp_default = "// emulated noperspective\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\nvarying float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP. Clamps a fragment to the near and far plane\n * by writing the fragment's depth. See czm_depthClamp for more details.\n * <p>\n * The shader must enable the GL_EXT_frag_depth extension.\n * </p>\n *\n * @name czm_writeDepthClamp\n * @glslFunction\n *\n * @example\n * gl_FragColor = color;\n * czm_writeDepthClamp();\n *\n * @see czm_depthClamp\n */\nvoid czm_writeDepthClamp()\n{\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\n    gl_FragDepthEXT = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0);\n#endif\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/writeLogDepth.js
var writeLogDepth_default = "#ifdef LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\nuniform vec2 u_polygonOffset;\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\n\n#endif\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when\n * ray-casting geometry using a full screen quad.\n * </p>\n * @name czm_writeLogDepth\n * @glslFunction\n *\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\n *                      depth increases in eye-space units from there\n *\n * @example\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\n */\nvoid czm_writeLogDepth(float depth)\n{\n#if defined(GL_EXT_frag_depth) && defined(LOG_DEPTH)\n    // Discard the vertex if it's not between the near and far planes.\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\n    // from the vertex shader (indicating the vertex should be _on_ the near\n    // plane) will not necessarily come here as exactly 1.0.\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\n        discard;\n    }\n\n#ifdef POLYGON_OFFSET\n    // Polygon offset: m * factor + r * units\n    float factor = u_polygonOffset[0];\n    float units = u_polygonOffset[1];\n\n// If we can't compute derivatives, just leave out the factor I guess?\n#ifdef GL_OES_standard_derivatives\n    if (factor != 0.0) {\n        // m = sqrt(dZdX^2 + dZdY^2);\n        float x = dFdx(depth);\n        float y = dFdy(depth);\n        float m = sqrt(x * x + y * y);\n\n        // Apply the factor before computing the log depth.\n        depth += m * factor;\n    }\n#endif\n\n#endif\n\n    gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\n    // Apply the units after the log depth.\n    gl_FragDepthEXT += czm_epsilon7 * units;\n#endif\n\n#endif\n}\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader calls {@link czm_vertexlogDepth}.\n * </p>\n *\n * @name czm_writeLogDepth\n * @glslFunction\n */\nvoid czm_writeLogDepth() {\n#ifdef LOG_DEPTH\n    czm_writeLogDepth(v_depthFromNearPlusOne);\n#endif\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/Functions/writeNonPerspective.js
var writeNonPerspective_default = "/**\n * Transforms a value for non-perspective interpolation by multiplying\n * it by w, the value used in the perspective divide. This function is\n * intended to be called in a vertex shader to compute the value of a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The fragment shader\n * must call {@link czm_readNonPerspective} to retrieve the final\n * non-perspective value.\n *\n * @name czm_writeNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The value to be interpolated without accounting for perspective.\n * @param {float} w The perspective divide value. Usually this is the computed `gl_Position.w`.\n * @returns {float|vec2|vec3|vec4} The transformed value, intended to be stored in a `varying` and read in the\n *          fragment shader with {@link czm_readNonPerspective}.\n */\nfloat czm_writeNonPerspective(float value, float w) {\n    return value * w;\n}\n\nvec2 czm_writeNonPerspective(vec2 value, float w) {\n    return value * w;\n}\n\nvec3 czm_writeNonPerspective(vec3 value, float w) {\n    return value * w;\n}\n\nvec4 czm_writeNonPerspective(vec4 value, float w) {\n    return value * w;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Builtin/CzmBuiltins.js
var CzmBuiltins_default = {
  czm_degreesPerRadian: degreesPerRadian_default,
  czm_depthRange: depthRange_default,
  czm_epsilon1: epsilon1_default,
  czm_epsilon2: epsilon2_default,
  czm_epsilon3: epsilon3_default,
  czm_epsilon4: epsilon4_default,
  czm_epsilon5: epsilon5_default,
  czm_epsilon6: epsilon6_default,
  czm_epsilon7: epsilon7_default,
  czm_infinity: infinity_default,
  czm_oneOverPi: oneOverPi_default,
  czm_oneOverTwoPi: oneOverTwoPi_default,
  czm_passCesium3DTile: passCesium3DTile_default,
  czm_passCesium3DTileClassification: passCesium3DTileClassification_default,
  czm_passCesium3DTileClassificationIgnoreShow: passCesium3DTileClassificationIgnoreShow_default,
  czm_passClassification: passClassification_default,
  czm_passCompute: passCompute_default,
  czm_passEnvironment: passEnvironment_default,
  czm_passGlobe: passGlobe_default,
  czm_passOpaque: passOpaque_default,
  czm_passOverlay: passOverlay_default,
  czm_passTerrainClassification: passTerrainClassification_default,
  czm_passTranslucent: passTranslucent_default,
  czm_pi: pi_default,
  czm_piOverFour: piOverFour_default,
  czm_piOverSix: piOverSix_default,
  czm_piOverThree: piOverThree_default,
  czm_piOverTwo: piOverTwo_default,
  czm_radiansPerDegree: radiansPerDegree_default,
  czm_sceneMode2D: sceneMode2D_default,
  czm_sceneMode3D: sceneMode3D_default,
  czm_sceneModeColumbusView: sceneModeColumbusView_default,
  czm_sceneModeMorphing: sceneModeMorphing_default,
  czm_solarRadius: solarRadius_default,
  czm_threePiOver2: threePiOver2_default,
  czm_twoPi: twoPi_default,
  czm_webMercatorMaxLatitude: webMercatorMaxLatitude_default,
  czm_depthRangeStruct: depthRangeStruct_default,
  czm_material: material_default,
  czm_materialInput: materialInput_default,
  czm_modelMaterial: modelMaterial_default,
  czm_modelVertexOutput: modelVertexOutput_default,
  czm_pbrParameters: pbrParameters_default,
  czm_ray: ray_default,
  czm_raySegment: raySegment_default,
  czm_shadowParameters: shadowParameters_default,
  czm_HSBToRGB: HSBToRGB_default,
  czm_HSLToRGB: HSLToRGB_default,
  czm_RGBToHSB: RGBToHSB_default,
  czm_RGBToHSL: RGBToHSL_default,
  czm_RGBToXYZ: RGBToXYZ_default,
  czm_XYZToRGB: XYZToRGB_default,
  czm_acesTonemapping: acesTonemapping_default,
  czm_alphaWeight: alphaWeight_default,
  czm_antialias: antialias_default,
  czm_approximateSphericalCoordinates: approximateSphericalCoordinates_default,
  czm_backFacing: backFacing_default,
  czm_branchFreeTernary: branchFreeTernary_default,
  czm_cascadeColor: cascadeColor_default,
  czm_cascadeDistance: cascadeDistance_default,
  czm_cascadeMatrix: cascadeMatrix_default,
  czm_cascadeWeights: cascadeWeights_default,
  czm_columbusViewMorph: columbusViewMorph_default,
  czm_computePosition: computePosition_default,
  czm_cosineAndSine: cosineAndSine_default,
  czm_decompressTextureCoordinates: decompressTextureCoordinates_default,
  czm_defaultPbrMaterial: defaultPbrMaterial_default,
  czm_depthClamp: depthClamp_default,
  czm_eastNorthUpToEyeCoordinates: eastNorthUpToEyeCoordinates_default,
  czm_ellipsoidContainsPoint: ellipsoidContainsPoint_default,
  czm_ellipsoidWgs84TextureCoordinates: ellipsoidWgs84TextureCoordinates_default,
  czm_equalsEpsilon: equalsEpsilon_default,
  czm_eyeOffset: eyeOffset_default,
  czm_eyeToWindowCoordinates: eyeToWindowCoordinates_default,
  czm_fastApproximateAtan: fastApproximateAtan_default,
  czm_fog: fog_default,
  czm_gammaCorrect: gammaCorrect_default,
  czm_geodeticSurfaceNormal: geodeticSurfaceNormal_default,
  czm_getDefaultMaterial: getDefaultMaterial_default,
  czm_getLambertDiffuse: getLambertDiffuse_default,
  czm_getSpecular: getSpecular_default,
  czm_getWaterNoise: getWaterNoise_default,
  czm_hue: hue_default,
  czm_inverseGamma: inverseGamma_default,
  czm_isEmpty: isEmpty_default,
  czm_isFull: isFull_default,
  czm_latitudeToWebMercatorFraction: latitudeToWebMercatorFraction_default,
  czm_lineDistance: lineDistance_default,
  czm_linearToSrgb: linearToSrgb_default,
  czm_luminance: luminance_default,
  czm_metersPerPixel: metersPerPixel_default,
  czm_modelToWindowCoordinates: modelToWindowCoordinates_default,
  czm_multiplyWithColorBalance: multiplyWithColorBalance_default,
  czm_nearFarScalar: nearFarScalar_default,
  czm_octDecode: octDecode_default,
  czm_packDepth: packDepth_default,
  czm_pbrLighting: pbrLighting_default,
  czm_pbrMetallicRoughnessMaterial: pbrMetallicRoughnessMaterial_default,
  czm_pbrSpecularGlossinessMaterial: pbrSpecularGlossinessMaterial_default,
  czm_phong: phong_default,
  czm_planeDistance: planeDistance_default,
  czm_pointAlongRay: pointAlongRay_default,
  czm_rayEllipsoidIntersectionInterval: rayEllipsoidIntersectionInterval_default,
  czm_raySphereIntersectionInterval: raySphereIntersectionInterval_default,
  czm_readDepth: readDepth_default,
  czm_readNonPerspective: readNonPerspective_default,
  czm_reverseLogDepth: reverseLogDepth_default,
  czm_round: round_default,
  czm_sampleOctahedralProjection: sampleOctahedralProjection_default,
  czm_saturation: saturation_default,
  czm_shadowDepthCompare: shadowDepthCompare_default,
  czm_shadowVisibility: shadowVisibility_default,
  czm_signNotZero: signNotZero_default,
  czm_sphericalHarmonics: sphericalHarmonics_default,
  czm_srgbToLinear: srgbToLinear_default,
  czm_tangentToEyeSpaceMatrix: tangentToEyeSpaceMatrix_default,
  czm_transformPlane: transformPlane_default,
  czm_translateRelativeToEye: translateRelativeToEye_default,
  czm_translucentPhong: translucentPhong_default,
  czm_transpose: transpose_default,
  czm_unpackDepth: unpackDepth_default,
  czm_unpackFloat: unpackFloat_default,
  czm_unpackUint: unpackUint_default,
  czm_valueTransform: valueTransform_default,
  czm_vertexLogDepth: vertexLogDepth_default,
  czm_windowToEyeCoordinates: windowToEyeCoordinates_default,
  czm_writeDepthClamp: writeDepthClamp_default,
  czm_writeLogDepth: writeLogDepth_default,
  czm_writeNonPerspective: writeNonPerspective_default
};

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/ShaderSource.js
function removeComments(source) {
  source = source.replace(/\/\/.*/g, "");
  return source.replace(/\/\*\*[\s\S]*?\*\//gm, function(match) {
    const numberOfLines = match.match(/\n/gm).length;
    let replacement = "";
    for (let lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {
      replacement += "\n";
    }
    return replacement;
  });
}
function getDependencyNode(name, glslSource, nodes) {
  let dependencyNode;
  for (let i = 0; i < nodes.length; ++i) {
    if (nodes[i].name === name) {
      dependencyNode = nodes[i];
    }
  }
  if (!defined_default(dependencyNode)) {
    glslSource = removeComments(glslSource);
    dependencyNode = {
      name,
      glslSource,
      dependsOn: [],
      requiredBy: [],
      evaluated: false
    };
    nodes.push(dependencyNode);
  }
  return dependencyNode;
}
function generateDependencies(currentNode, dependencyNodes) {
  if (currentNode.evaluated) {
    return;
  }
  currentNode.evaluated = true;
  let czmMatches = currentNode.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
  if (defined_default(czmMatches) && czmMatches !== null) {
    czmMatches = czmMatches.filter(function(elem, pos) {
      return czmMatches.indexOf(elem) === pos;
    });
    czmMatches.forEach(function(element) {
      if (element !== currentNode.name && ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)) {
        const referencedNode = getDependencyNode(
          element,
          ShaderSource._czmBuiltinsAndUniforms[element],
          dependencyNodes
        );
        currentNode.dependsOn.push(referencedNode);
        referencedNode.requiredBy.push(currentNode);
        generateDependencies(referencedNode, dependencyNodes);
      }
    });
  }
}
function sortDependencies(dependencyNodes) {
  const nodesWithoutIncomingEdges = [];
  const allNodes = [];
  while (dependencyNodes.length > 0) {
    const node = dependencyNodes.pop();
    allNodes.push(node);
    if (node.requiredBy.length === 0) {
      nodesWithoutIncomingEdges.push(node);
    }
  }
  while (nodesWithoutIncomingEdges.length > 0) {
    const currentNode = nodesWithoutIncomingEdges.shift();
    dependencyNodes.push(currentNode);
    for (let i = 0; i < currentNode.dependsOn.length; ++i) {
      const referencedNode = currentNode.dependsOn[i];
      const index = referencedNode.requiredBy.indexOf(currentNode);
      referencedNode.requiredBy.splice(index, 1);
      if (referencedNode.requiredBy.length === 0) {
        nodesWithoutIncomingEdges.push(referencedNode);
      }
    }
  }
  const badNodes = [];
  for (let j = 0; j < allNodes.length; ++j) {
    if (allNodes[j].requiredBy.length !== 0) {
      badNodes.push(allNodes[j]);
    }
  }
  if (badNodes.length !== 0) {
    let message = "A circular dependency was found in the following built-in functions/structs/constants: \n";
    for (let k = 0; k < badNodes.length; ++k) {
      message = `${message + badNodes[k].name}
`;
    }
    throw new DeveloperError_default(message);
  }
}
function getBuiltinsAndAutomaticUniforms(shaderSource) {
  const dependencyNodes = [];
  const root = getDependencyNode("main", shaderSource, dependencyNodes);
  generateDependencies(root, dependencyNodes);
  sortDependencies(dependencyNodes);
  let builtinsSource = "";
  for (let i = dependencyNodes.length - 1; i >= 0; --i) {
    builtinsSource = `${builtinsSource + dependencyNodes[i].glslSource}
`;
  }
  return builtinsSource.replace(root.glslSource, "");
}
function combineShader(shaderSource, isFragmentShader, context) {
  let i;
  let length;
  let combinedSources = "";
  const sources = shaderSource.sources;
  if (defined_default(sources)) {
    for (i = 0, length = sources.length; i < length; ++i) {
      combinedSources += `
#line 0
${sources[i]}`;
    }
  }
  combinedSources = removeComments(combinedSources);
  let version;
  combinedSources = combinedSources.replace(/#version\s+(.*?)\n/gm, function(match, group1) {
    if (defined_default(version) && version !== group1) {
      throw new DeveloperError_default(
        `inconsistent versions found: ${version} and ${group1}`
      );
    }
    version = group1;
    return "\n";
  });
  const extensions = [];
  combinedSources = combinedSources.replace(/#extension.*\n/gm, function(match) {
    extensions.push(match);
    return "\n";
  });
  combinedSources = combinedSources.replace(
    /precision\s(lowp|mediump|highp)\s(float|int);/,
    ""
  );
  const pickColorQualifier = shaderSource.pickColorQualifier;
  if (defined_default(pickColorQualifier)) {
    combinedSources = ShaderSource.createPickFragmentShaderSource(
      combinedSources,
      pickColorQualifier
    );
  }
  let result = "";
  if (defined_default(version)) {
    result = `#version ${version}
`;
  }
  const extensionsLength = extensions.length;
  for (i = 0; i < extensionsLength; i++) {
    result += extensions[i];
  }
  if (isFragmentShader) {
    result += "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n    precision mediump int;\n    #define highp mediump\n#endif\n\n";
  }
  const defines = shaderSource.defines;
  if (defined_default(defines)) {
    for (i = 0, length = defines.length; i < length; ++i) {
      const define2 = defines[i];
      if (define2.length !== 0) {
        result += `#define ${define2}
`;
      }
    }
  }
  if (context.webgl2) {
    result += "#define OUTPUT_DECLARATION\n\n";
  }
  if (context.textureFloatLinear) {
    result += "#define OES_texture_float_linear\n\n";
  }
  if (context.floatingPointTexture) {
    result += "#define OES_texture_float\n\n";
  }
  if (shaderSource.includeBuiltIns) {
    result += getBuiltinsAndAutomaticUniforms(combinedSources);
  }
  result += "\n#line 0\n";
  result += combinedSources;
  if (context.webgl2) {
    result = modernizeShader_default(result, isFragmentShader, true);
  }
  return result;
}
function ShaderSource(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const pickColorQualifier = options.pickColorQualifier;
  if (defined_default(pickColorQualifier) && pickColorQualifier !== "uniform" && pickColorQualifier !== "varying") {
    throw new DeveloperError_default(
      "options.pickColorQualifier must be 'uniform' or 'varying'."
    );
  }
  this.defines = defined_default(options.defines) ? options.defines.slice(0) : [];
  this.sources = defined_default(options.sources) ? options.sources.slice(0) : [];
  this.pickColorQualifier = pickColorQualifier;
  this.includeBuiltIns = defaultValue_default(options.includeBuiltIns, true);
}
ShaderSource.prototype.clone = function() {
  return new ShaderSource({
    sources: this.sources,
    defines: this.defines,
    pickColorQualifier: this.pickColorQualifier,
    includeBuiltIns: this.includeBuiltIns
  });
};
ShaderSource.replaceMain = function(source, renamedMain) {
  renamedMain = `void ${renamedMain}()`;
  return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, renamedMain);
};
ShaderSource.prototype.getCacheKey = function() {
  const sortedDefines = this.defines.slice().sort();
  const definesKey = sortedDefines.join(",");
  const pickKey = this.pickColorQualifier;
  const builtinsKey = this.includeBuiltIns;
  const sourcesKey = this.sources.join("\n");
  return `${definesKey}:${pickKey}:${builtinsKey}:${sourcesKey}`;
};
ShaderSource.prototype.createCombinedVertexShader = function(context) {
  return combineShader(this, false, context);
};
ShaderSource.prototype.createCombinedFragmentShader = function(context) {
  return combineShader(this, true, context);
};
ShaderSource._czmBuiltinsAndUniforms = {};
for (const builtinName in CzmBuiltins_default) {
  if (CzmBuiltins_default.hasOwnProperty(builtinName)) {
    ShaderSource._czmBuiltinsAndUniforms[builtinName] = CzmBuiltins_default[builtinName];
  }
}
for (const uniformName in AutomaticUniforms_default) {
  if (AutomaticUniforms_default.hasOwnProperty(uniformName)) {
    const uniform = AutomaticUniforms_default[uniformName];
    if (typeof uniform.getDeclaration === "function") {
      ShaderSource._czmBuiltinsAndUniforms[uniformName] = uniform.getDeclaration(uniformName);
    }
  }
}
ShaderSource.createPickVertexShaderSource = function(vertexShaderSource) {
  const renamedVS = ShaderSource.replaceMain(
    vertexShaderSource,
    "czm_old_main"
  );
  const pickMain = "attribute vec4 pickColor; \nvarying vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    czm_pickColor = pickColor; \n}";
  return `${renamedVS}
${pickMain}`;
};
ShaderSource.createPickFragmentShaderSource = function(fragmentShaderSource, pickColorQualifier) {
  const renamedFS = ShaderSource.replaceMain(
    fragmentShaderSource,
    "czm_old_main"
  );
  const pickMain = `${pickColorQualifier} vec4 czm_pickColor; 
void main() 
{ 
    czm_old_main(); 
    if (gl_FragColor.a == 0.0) { 
       discard; 
    } 
    gl_FragColor = czm_pickColor; 
}`;
  return `${renamedFS}
${pickMain}`;
};
function containsDefine(shaderSource, define2) {
  const defines = shaderSource.defines;
  const definesLength = defines.length;
  for (let i = 0; i < definesLength; ++i) {
    if (defines[i] === define2) {
      return true;
    }
  }
  return false;
}
function containsString(shaderSource, string) {
  const sources = shaderSource.sources;
  const sourcesLength = sources.length;
  for (let i = 0; i < sourcesLength; ++i) {
    if (sources[i].indexOf(string) !== -1) {
      return true;
    }
  }
  return false;
}
function findFirstString(shaderSource, strings) {
  const stringsLength = strings.length;
  for (let i = 0; i < stringsLength; ++i) {
    const string = strings[i];
    if (containsString(shaderSource, string)) {
      return string;
    }
  }
  return void 0;
}
var normalVaryingNames = ["v_normalEC", "v_normal"];
ShaderSource.findNormalVarying = function(shaderSource) {
  if (containsString(shaderSource, "#ifdef HAS_NORMALS")) {
    if (containsDefine(shaderSource, "HAS_NORMALS")) {
      return "v_normalEC";
    }
    return void 0;
  }
  return findFirstString(shaderSource, normalVaryingNames);
};
var positionVaryingNames = ["v_positionEC"];
ShaderSource.findPositionVarying = function(shaderSource) {
  return findFirstString(shaderSource, positionVaryingNames);
};
var ShaderSource_default = ShaderSource;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/Texture.js
function Texture(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  let width = options.width;
  let height = options.height;
  const source = options.source;
  if (defined_default(source)) {
    if (!defined_default(width)) {
      width = defaultValue_default(source.videoWidth, source.width);
    }
    if (!defined_default(height)) {
      height = defaultValue_default(source.videoHeight, source.height);
    }
  }
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  const pixelDatatype = defaultValue_default(
    options.pixelDatatype,
    PixelDatatype_default.UNSIGNED_BYTE
  );
  const internalFormat = PixelFormat_default.toInternalFormat(
    pixelFormat,
    pixelDatatype,
    context
  );
  const isCompressed = PixelFormat_default.isCompressedFormat(internalFormat);
  if (!defined_default(width) || !defined_default(height)) {
    throw new DeveloperError_default(
      "options requires a source field to create an initialized texture or width and height fields to create a blank texture."
    );
  }
  Check_default.typeOf.number.greaterThan("width", width, 0);
  if (width > ContextLimits_default.maximumTextureSize) {
    throw new DeveloperError_default(
      `Width must be less than or equal to the maximum texture size (${ContextLimits_default.maximumTextureSize}).  Check maximumTextureSize.`
    );
  }
  Check_default.typeOf.number.greaterThan("height", height, 0);
  if (height > ContextLimits_default.maximumTextureSize) {
    throw new DeveloperError_default(
      `Height must be less than or equal to the maximum texture size (${ContextLimits_default.maximumTextureSize}).  Check maximumTextureSize.`
    );
  }
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid options.pixelFormat.");
  }
  if (!isCompressed && !PixelDatatype_default.validate(pixelDatatype)) {
    throw new DeveloperError_default("Invalid options.pixelDatatype.");
  }
  if (pixelFormat === PixelFormat_default.DEPTH_COMPONENT && pixelDatatype !== PixelDatatype_default.UNSIGNED_SHORT && pixelDatatype !== PixelDatatype_default.UNSIGNED_INT) {
    throw new DeveloperError_default(
      "When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT."
    );
  }
  if (pixelFormat === PixelFormat_default.DEPTH_STENCIL && pixelDatatype !== PixelDatatype_default.UNSIGNED_INT_24_8) {
    throw new DeveloperError_default(
      "When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8."
    );
  }
  if (pixelDatatype === PixelDatatype_default.FLOAT && !context.floatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture."
    );
  }
  if (pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.halfFloatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture."
    );
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat)) {
    if (defined_default(source)) {
      throw new DeveloperError_default(
        "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided."
      );
    }
    if (!context.depthTexture) {
      throw new DeveloperError_default(
        "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture."
      );
    }
  }
  if (isCompressed) {
    if (!defined_default(source) || !defined_default(source.arrayBufferView)) {
      throw new DeveloperError_default(
        "When options.pixelFormat is compressed, options.source.arrayBufferView must be defined."
      );
    }
    if (PixelFormat_default.isDXTFormat(internalFormat) && !context.s3tc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_compressed_texture_s3tc extension. Check context.s3tc."
      );
    } else if (PixelFormat_default.isPVRTCFormat(internalFormat) && !context.pvrtc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_pvrtc extension. Check context.pvrtc."
      );
    } else if (PixelFormat_default.isASTCFormat(internalFormat) && !context.astc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ASTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_astc extension. Check context.astc."
      );
    } else if (PixelFormat_default.isETC2Format(internalFormat) && !context.etc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ETC2 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc extension. Check context.etc."
      );
    } else if (PixelFormat_default.isETC1Format(internalFormat) && !context.etc1) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc1 extension. Check context.etc1."
      );
    } else if (PixelFormat_default.isBC7Format(internalFormat) && !context.bc7) {
      throw new DeveloperError_default(
        "When options.pixelFormat is BC7 compressed, this WebGL implementation must support the EXT_texture_compression_bptc extension. Check context.bc7."
      );
    }
    if (PixelFormat_default.compressedTextureSizeInBytes(
      internalFormat,
      width,
      height
    ) !== source.arrayBufferView.byteLength) {
      throw new DeveloperError_default(
        "The byte length of the array buffer is invalid for the compressed texture with the given width and height."
      );
    }
  }
  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat_default.RGB || pixelFormat === PixelFormat_default.LUMINANCE;
  const flipY = defaultValue_default(options.flipY, true);
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let initialized = true;
  const gl = context._gl;
  const textureTarget = gl.TEXTURE_2D;
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  let unpackAlignment = 4;
  if (defined_default(source) && defined_default(source.arrayBufferView) && !isCompressed) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  if (defined_default(source)) {
    if (defined_default(source.arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      let arrayBufferView = source.arrayBufferView;
      let i, mipWidth, mipHeight;
      if (isCompressed) {
        gl.compressedTexImage2D(
          textureTarget,
          0,
          internalFormat,
          width,
          height,
          0,
          arrayBufferView
        );
        if (defined_default(source.mipLevels)) {
          mipWidth = width;
          mipHeight = height;
          for (i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = Math.floor(mipWidth / 2) | 0;
            if (mipWidth < 1) {
              mipWidth = 1;
            }
            mipHeight = Math.floor(mipHeight / 2) | 0;
            if (mipHeight < 1) {
              mipHeight = 1;
            }
            gl.compressedTexImage2D(
              textureTarget,
              i + 1,
              internalFormat,
              mipWidth,
              mipHeight,
              0,
              source.mipLevels[i]
            );
          }
        }
      } else {
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            width,
            height
          );
        }
        gl.texImage2D(
          textureTarget,
          0,
          internalFormat,
          width,
          height,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          arrayBufferView
        );
        if (defined_default(source.mipLevels)) {
          mipWidth = width;
          mipHeight = height;
          for (i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = Math.floor(mipWidth / 2) | 0;
            if (mipWidth < 1) {
              mipWidth = 1;
            }
            mipHeight = Math.floor(mipHeight / 2) | 0;
            if (mipHeight < 1) {
              mipHeight = 1;
            }
            gl.texImage2D(
              textureTarget,
              i + 1,
              internalFormat,
              mipWidth,
              mipHeight,
              0,
              pixelFormat,
              PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
              source.mipLevels[i]
            );
          }
        }
      }
    } else if (defined_default(source.framebuffer)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._bind();
      }
      gl.copyTexImage2D(
        textureTarget,
        0,
        internalFormat,
        source.xOffset,
        source.yOffset,
        width,
        height,
        0
      );
      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._unBind();
      }
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texImage2D(
        textureTarget,
        0,
        internalFormat,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        source
      );
    }
  } else {
    gl.texImage2D(
      textureTarget,
      0,
      internalFormat,
      width,
      height,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    initialized = false;
  }
  gl.bindTexture(textureTarget, null);
  let sizeInBytes;
  if (isCompressed) {
    sizeInBytes = PixelFormat_default.compressedTextureSizeInBytes(
      pixelFormat,
      width,
      height
    );
  } else {
    sizeInBytes = PixelFormat_default.textureSizeInBytes(
      pixelFormat,
      pixelDatatype,
      width,
      height
    );
  }
  this._id = createGuid_default();
  this._context = context;
  this._textureFilterAnisotropic = context._textureFilterAnisotropic;
  this._textureTarget = textureTarget;
  this._texture = texture;
  this._internalFormat = internalFormat;
  this._pixelFormat = pixelFormat;
  this._pixelDatatype = pixelDatatype;
  this._width = width;
  this._height = height;
  this._dimensions = new Cartesian2_default(width, height);
  this._hasMipmap = false;
  this._sizeInBytes = sizeInBytes;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._initialized = initialized;
  this._sampler = void 0;
  this.sampler = defined_default(options.sampler) ? options.sampler : new Sampler_default();
}
Texture.create = function(options) {
  return new Texture(options);
};
Texture.fromFramebuffer = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const gl = context._gl;
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGB);
  const framebufferXOffset = defaultValue_default(options.framebufferXOffset, 0);
  const framebufferYOffset = defaultValue_default(options.framebufferYOffset, 0);
  const width = defaultValue_default(options.width, gl.drawingBufferWidth);
  const height = defaultValue_default(options.height, gl.drawingBufferHeight);
  const framebuffer = options.framebuffer;
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid pixelFormat.");
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat) || PixelFormat_default.isCompressedFormat(pixelFormat)) {
    throw new DeveloperError_default(
      "pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format."
    );
  }
  Check_default.defined("options.context", options.context);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  if (framebufferXOffset + width > gl.drawingBufferWidth) {
    throw new DeveloperError_default(
      "framebufferXOffset + width must be less than or equal to drawingBufferWidth"
    );
  }
  if (framebufferYOffset + height > gl.drawingBufferHeight) {
    throw new DeveloperError_default(
      "framebufferYOffset + height must be less than or equal to drawingBufferHeight."
    );
  }
  const texture = new Texture({
    context,
    width,
    height,
    pixelFormat,
    source: {
      framebuffer: defined_default(framebuffer) ? framebuffer : context.defaultFramebuffer,
      xOffset: framebufferXOffset,
      yOffset: framebufferYOffset,
      width,
      height
    }
  });
  return texture;
};
Object.defineProperties(Texture.prototype, {
  id: {
    get: function() {
      return this._id;
    }
  },
  sampler: {
    get: function() {
      return this._sampler;
    },
    set: function(sampler) {
      let minificationFilter = sampler.minificationFilter;
      let magnificationFilter = sampler.magnificationFilter;
      const context = this._context;
      const pixelFormat = this._pixelFormat;
      const pixelDatatype = this._pixelDatatype;
      const mipmap = minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_LINEAR || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_LINEAR;
      if (pixelDatatype === PixelDatatype_default.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.textureHalfFloatLinear) {
        minificationFilter = mipmap ? TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter_default.NEAREST;
        magnificationFilter = TextureMagnificationFilter_default.NEAREST;
      }
      if (context.webgl2) {
        if (PixelFormat_default.isDepthFormat(pixelFormat)) {
          minificationFilter = TextureMinificationFilter_default.NEAREST;
          magnificationFilter = TextureMagnificationFilter_default.NEAREST;
        }
      }
      const gl = context._gl;
      const target = this._textureTarget;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
      if (defined_default(this._textureFilterAnisotropic)) {
        gl.texParameteri(
          target,
          this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          sampler.maximumAnisotropy
        );
      }
      gl.bindTexture(target, null);
      this._sampler = sampler;
    }
  },
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  dimensions: {
    get: function() {
      return this._dimensions;
    }
  },
  preMultiplyAlpha: {
    get: function() {
      return this._preMultiplyAlpha;
    }
  },
  flipY: {
    get: function() {
      return this._flipY;
    }
  },
  width: {
    get: function() {
      return this._width;
    }
  },
  height: {
    get: function() {
      return this._height;
    }
  },
  sizeInBytes: {
    get: function() {
      if (this._hasMipmap) {
        return Math.floor(this._sizeInBytes * 4 / 3);
      }
      return this._sizeInBytes;
    }
  },
  _target: {
    get: function() {
      return this._textureTarget;
    }
  }
});
Texture.prototype.copyFrom = function(options) {
  Check_default.defined("options", options);
  const xOffset = defaultValue_default(options.xOffset, 0);
  const yOffset = defaultValue_default(options.yOffset, 0);
  Check_default.defined("options.source", options.source);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom with a compressed texture pixel format."
    );
  }
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.lessThanOrEquals(
    "xOffset + options.source.width",
    xOffset + options.source.width,
    this._width
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "yOffset + options.source.height",
    yOffset + options.source.height,
    this._height
  );
  const source = options.source;
  const context = this._context;
  const gl = context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  const width = source.width;
  const height = source.height;
  let arrayBufferView = source.arrayBufferView;
  const textureWidth = this._width;
  const textureHeight = this._height;
  const internalFormat = this._internalFormat;
  const pixelFormat = this._pixelFormat;
  const pixelDatatype = this._pixelDatatype;
  const preMultiplyAlpha = this._preMultiplyAlpha;
  const flipY = this._flipY;
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let unpackAlignment = 4;
  if (defined_default(arrayBufferView)) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  let uploaded = false;
  if (!this._initialized) {
    if (xOffset === 0 && yOffset === 0 && width === textureWidth && height === textureHeight) {
      if (defined_default(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            textureWidth,
            textureHeight
          );
        }
        gl.texImage2D(
          target,
          0,
          internalFormat,
          textureWidth,
          textureHeight,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          arrayBufferView
        );
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(
          target,
          0,
          internalFormat,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          source
        );
      }
      uploaded = true;
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      const bufferView = PixelFormat_default.createTypedArray(
        pixelFormat,
        pixelDatatype,
        textureWidth,
        textureHeight
      );
      gl.texImage2D(
        target,
        0,
        internalFormat,
        textureWidth,
        textureHeight,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        bufferView
      );
    }
    this._initialized = true;
  }
  if (!uploaded) {
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          width,
          height
        );
      }
      gl.texSubImage2D(
        target,
        0,
        xOffset,
        yOffset,
        width,
        height,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texSubImage2D(
        target,
        0,
        xOffset,
        yOffset,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        source
      );
    }
  }
  gl.bindTexture(target, null);
};
Texture.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
  xOffset = defaultValue_default(xOffset, 0);
  yOffset = defaultValue_default(yOffset, 0);
  framebufferXOffset = defaultValue_default(framebufferXOffset, 0);
  framebufferYOffset = defaultValue_default(framebufferYOffset, 0);
  width = defaultValue_default(width, this._width);
  height = defaultValue_default(height, this._height);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.HALF_FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom with a compressed texture pixel format."
    );
  }
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "xOffset + width",
    xOffset + width,
    this._width
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "yOffset + height",
    yOffset + height,
    this._height
  );
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.copyTexSubImage2D(
    target,
    0,
    xOffset,
    yOffset,
    framebufferXOffset,
    framebufferYOffset,
    width,
    height
  );
  gl.bindTexture(target, null);
  this._initialized = true;
};
Texture.prototype.generateMipmap = function(hint) {
  hint = defaultValue_default(hint, MipmapHint_default.DONT_CARE);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call generateMipmap with a compressed pixel format."
    );
  }
  if (!this._context.webgl2) {
    if (this._width > 1 && !Math_default.isPowerOfTwo(this._width)) {
      throw new DeveloperError_default(
        "width must be a power of two to call generateMipmap() in a WebGL1 context."
      );
    }
    if (this._height > 1 && !Math_default.isPowerOfTwo(this._height)) {
      throw new DeveloperError_default(
        "height must be a power of two to call generateMipmap() in a WebGL1 context."
      );
    }
  }
  if (!MipmapHint_default.validate(hint)) {
    throw new DeveloperError_default("hint is invalid.");
  }
  this._hasMipmap = true;
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.generateMipmap(target);
  gl.bindTexture(target, null);
};
Texture.prototype.isDestroyed = function() {
  return false;
};
Texture.prototype.destroy = function() {
  this._context._gl.deleteTexture(this._texture);
  return destroyObject_default(this);
};
var Texture_default = Texture;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/EncodedCartesian3.js
function EncodedCartesian3() {
  this.high = Cartesian3_default.clone(Cartesian3_default.ZERO);
  this.low = Cartesian3_default.clone(Cartesian3_default.ZERO);
}
EncodedCartesian3.encode = function(value, result) {
  Check_default.typeOf.number("value", value);
  if (!defined_default(result)) {
    result = {
      high: 0,
      low: 0
    };
  }
  let doubleHigh;
  if (value >= 0) {
    doubleHigh = Math.floor(value / 65536) * 65536;
    result.high = doubleHigh;
    result.low = value - doubleHigh;
  } else {
    doubleHigh = Math.floor(-value / 65536) * 65536;
    result.high = -doubleHigh;
    result.low = value + doubleHigh;
  }
  return result;
};
var scratchEncode = {
  high: 0,
  low: 0
};
EncodedCartesian3.fromCartesian = function(cartesian, result) {
  Check_default.typeOf.object("cartesian", cartesian);
  if (!defined_default(result)) {
    result = new EncodedCartesian3();
  }
  const high = result.high;
  const low = result.low;
  EncodedCartesian3.encode(cartesian.x, scratchEncode);
  high.x = scratchEncode.high;
  low.x = scratchEncode.low;
  EncodedCartesian3.encode(cartesian.y, scratchEncode);
  high.y = scratchEncode.high;
  low.y = scratchEncode.low;
  EncodedCartesian3.encode(cartesian.z, scratchEncode);
  high.z = scratchEncode.high;
  low.z = scratchEncode.low;
  return result;
};
var encodedP = new EncodedCartesian3();
EncodedCartesian3.writeElements = function(cartesian, cartesianArray, index) {
  Check_default.defined("cartesianArray", cartesianArray);
  Check_default.typeOf.number("index", index);
  Check_default.typeOf.number.greaterThanOrEquals("index", index, 0);
  EncodedCartesian3.fromCartesian(cartesian, encodedP);
  const high = encodedP.high;
  const low = encodedP.low;
  cartesianArray[index] = high.x;
  cartesianArray[index + 1] = high.y;
  cartesianArray[index + 2] = high.z;
  cartesianArray[index + 3] = low.x;
  cartesianArray[index + 4] = low.y;
  cartesianArray[index + 5] = low.z;
};
var EncodedCartesian3_default = EncodedCartesian3;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Plane.js
function Plane(normal2, distance) {
  Check_default.typeOf.object("normal", normal2);
  if (!Math_default.equalsEpsilon(
    Cartesian3_default.magnitude(normal2),
    1,
    Math_default.EPSILON6
  )) {
    throw new DeveloperError_default("normal must be normalized.");
  }
  Check_default.typeOf.number("distance", distance);
  this.normal = Cartesian3_default.clone(normal2);
  this.distance = distance;
}
Plane.fromPointNormal = function(point, normal2, result) {
  Check_default.typeOf.object("point", point);
  Check_default.typeOf.object("normal", normal2);
  if (!Math_default.equalsEpsilon(
    Cartesian3_default.magnitude(normal2),
    1,
    Math_default.EPSILON6
  )) {
    throw new DeveloperError_default("normal must be normalized.");
  }
  const distance = -Cartesian3_default.dot(normal2, point);
  if (!defined_default(result)) {
    return new Plane(normal2, distance);
  }
  Cartesian3_default.clone(normal2, result.normal);
  result.distance = distance;
  return result;
};
var scratchNormal = new Cartesian3_default();
Plane.fromCartesian4 = function(coefficients, result) {
  Check_default.typeOf.object("coefficients", coefficients);
  const normal2 = Cartesian3_default.fromCartesian4(coefficients, scratchNormal);
  const distance = coefficients.w;
  if (!Math_default.equalsEpsilon(
    Cartesian3_default.magnitude(normal2),
    1,
    Math_default.EPSILON6
  )) {
    throw new DeveloperError_default("normal must be normalized.");
  }
  if (!defined_default(result)) {
    return new Plane(normal2, distance);
  }
  Cartesian3_default.clone(normal2, result.normal);
  result.distance = distance;
  return result;
};
Plane.getPointDistance = function(plane, point) {
  Check_default.typeOf.object("plane", plane);
  Check_default.typeOf.object("point", point);
  return Cartesian3_default.dot(plane.normal, point) + plane.distance;
};
var scratchCartesian = new Cartesian3_default();
Plane.projectPointOntoPlane = function(plane, point, result) {
  Check_default.typeOf.object("plane", plane);
  Check_default.typeOf.object("point", point);
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  const pointDistance = Plane.getPointDistance(plane, point);
  const scaledNormal = Cartesian3_default.multiplyByScalar(
    plane.normal,
    pointDistance,
    scratchCartesian
  );
  return Cartesian3_default.subtract(point, scaledNormal, result);
};
var scratchInverseTranspose = new Matrix4_default();
var scratchPlaneCartesian4 = new Cartesian4_default();
var scratchTransformNormal = new Cartesian3_default();
Plane.transform = function(plane, transform, result) {
  Check_default.typeOf.object("plane", plane);
  Check_default.typeOf.object("transform", transform);
  const normal2 = plane.normal;
  const distance = plane.distance;
  const inverseTranspose2 = Matrix4_default.inverseTranspose(
    transform,
    scratchInverseTranspose
  );
  let planeAsCartesian4 = Cartesian4_default.fromElements(
    normal2.x,
    normal2.y,
    normal2.z,
    distance,
    scratchPlaneCartesian4
  );
  planeAsCartesian4 = Matrix4_default.multiplyByVector(
    inverseTranspose2,
    planeAsCartesian4,
    planeAsCartesian4
  );
  const transformedNormal = Cartesian3_default.fromCartesian4(
    planeAsCartesian4,
    scratchTransformNormal
  );
  planeAsCartesian4 = Cartesian4_default.divideByScalar(
    planeAsCartesian4,
    Cartesian3_default.magnitude(transformedNormal),
    planeAsCartesian4
  );
  return Plane.fromCartesian4(planeAsCartesian4, result);
};
Plane.clone = function(plane, result) {
  Check_default.typeOf.object("plane", plane);
  if (!defined_default(result)) {
    return new Plane(plane.normal, plane.distance);
  }
  Cartesian3_default.clone(plane.normal, result.normal);
  result.distance = plane.distance;
  return result;
};
Plane.equals = function(left, right) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  return left.distance === right.distance && Cartesian3_default.equals(left.normal, right.normal);
};
Plane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3_default.UNIT_Z, 0));
Plane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3_default.UNIT_X, 0));
Plane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3_default.UNIT_Y, 0));
var Plane_default = Plane;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/SceneMode.js
var SceneMode = {
  MORPHING: 0,
  COLUMBUS_VIEW: 1,
  SCENE2D: 2,
  SCENE3D: 3
};
SceneMode.getMorphTime = function(value) {
  if (value === SceneMode.SCENE3D) {
    return 1;
  } else if (value === SceneMode.MORPHING) {
    return void 0;
  }
  return 0;
};
var SceneMode_default = Object.freeze(SceneMode);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Renderer/VertexArray.js
function addAttribute(attributes, attribute, index, context) {
  const hasVertexBuffer = defined_default(attribute.vertexBuffer);
  const hasValue = defined_default(attribute.value);
  const componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;
  if (!hasVertexBuffer && !hasValue) {
    throw new DeveloperError_default("attribute must have a vertexBuffer or a value.");
  }
  if (hasVertexBuffer && hasValue) {
    throw new DeveloperError_default(
      "attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices."
    );
  }
  if (componentsPerAttribute !== 1 && componentsPerAttribute !== 2 && componentsPerAttribute !== 3 && componentsPerAttribute !== 4) {
    if (hasValue) {
      throw new DeveloperError_default(
        "attribute.value.length must be in the range [1, 4]."
      );
    }
    throw new DeveloperError_default(
      "attribute.componentsPerAttribute must be in the range [1, 4]."
    );
  }
  if (defined_default(attribute.componentDatatype) && !ComponentDatatype_default.validate(attribute.componentDatatype)) {
    throw new DeveloperError_default(
      "attribute must have a valid componentDatatype or not specify it."
    );
  }
  if (defined_default(attribute.strideInBytes) && attribute.strideInBytes > 255) {
    throw new DeveloperError_default(
      "attribute must have a strideInBytes less than or equal to 255 or not specify it."
    );
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && !context.instancedArrays) {
    throw new DeveloperError_default("instanced arrays is not supported");
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {
    throw new DeveloperError_default(
      "attribute must have an instanceDivisor greater than or equal to zero"
    );
  }
  if (defined_default(attribute.instanceDivisor) && hasValue) {
    throw new DeveloperError_default(
      "attribute cannot have have an instanceDivisor if it is not backed by a buffer"
    );
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && attribute.index === 0) {
    throw new DeveloperError_default(
      "attribute zero cannot have an instanceDivisor greater than 0"
    );
  }
  const attr = {
    index: defaultValue_default(attribute.index, index),
    enabled: defaultValue_default(attribute.enabled, true),
    vertexBuffer: attribute.vertexBuffer,
    value: hasValue ? attribute.value.slice(0) : void 0,
    componentsPerAttribute,
    componentDatatype: defaultValue_default(
      attribute.componentDatatype,
      ComponentDatatype_default.FLOAT
    ),
    normalize: defaultValue_default(attribute.normalize, false),
    offsetInBytes: defaultValue_default(attribute.offsetInBytes, 0),
    strideInBytes: defaultValue_default(attribute.strideInBytes, 0),
    instanceDivisor: defaultValue_default(attribute.instanceDivisor, 0)
  };
  if (hasVertexBuffer) {
    attr.vertexAttrib = function(gl) {
      const index2 = this.index;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
      gl.vertexAttribPointer(
        index2,
        this.componentsPerAttribute,
        this.componentDatatype,
        this.normalize,
        this.strideInBytes,
        this.offsetInBytes
      );
      gl.enableVertexAttribArray(index2);
      if (this.instanceDivisor > 0) {
        context.glVertexAttribDivisor(index2, this.instanceDivisor);
        context._vertexAttribDivisors[index2] = this.instanceDivisor;
        context._previousDrawInstanced = true;
      }
    };
    attr.disableVertexAttribArray = function(gl) {
      gl.disableVertexAttribArray(this.index);
      if (this.instanceDivisor > 0) {
        context.glVertexAttribDivisor(index, 0);
      }
    };
  } else {
    switch (attr.componentsPerAttribute) {
      case 1:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib1fv(this.index, this.value);
        };
        break;
      case 2:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib2fv(this.index, this.value);
        };
        break;
      case 3:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib3fv(this.index, this.value);
        };
        break;
      case 4:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib4fv(this.index, this.value);
        };
        break;
    }
    attr.disableVertexAttribArray = function(gl) {
    };
  }
  attributes.push(attr);
}
function bind(gl, attributes, indexBuffer) {
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.enabled) {
      attribute.vertexAttrib(gl);
    }
  }
  if (defined_default(indexBuffer)) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());
  }
}
function VertexArray(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  Check_default.defined("options.attributes", options.attributes);
  const context = options.context;
  const gl = context._gl;
  const attributes = options.attributes;
  const indexBuffer = options.indexBuffer;
  let i;
  const vaAttributes = [];
  let numberOfVertices = 1;
  let hasInstancedAttributes = false;
  let hasConstantAttributes = false;
  let length = attributes.length;
  for (i = 0; i < length; ++i) {
    addAttribute(vaAttributes, attributes[i], i, context);
  }
  length = vaAttributes.length;
  for (i = 0; i < length; ++i) {
    const attribute = vaAttributes[i];
    if (defined_default(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {
      const bytes = attribute.strideInBytes || attribute.componentsPerAttribute * ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype);
      numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;
      break;
    }
  }
  for (i = 0; i < length; ++i) {
    if (vaAttributes[i].instanceDivisor > 0) {
      hasInstancedAttributes = true;
    }
    if (defined_default(vaAttributes[i].value)) {
      hasConstantAttributes = true;
    }
  }
  const uniqueIndices = {};
  for (i = 0; i < length; ++i) {
    const index = vaAttributes[i].index;
    if (uniqueIndices[index]) {
      throw new DeveloperError_default(
        `Index ${index} is used by more than one attribute.`
      );
    }
    uniqueIndices[index] = true;
  }
  let vao;
  if (context.vertexArrayObject) {
    vao = context.glCreateVertexArray();
    context.glBindVertexArray(vao);
    bind(gl, vaAttributes, indexBuffer);
    context.glBindVertexArray(null);
  }
  this._numberOfVertices = numberOfVertices;
  this._hasInstancedAttributes = hasInstancedAttributes;
  this._hasConstantAttributes = hasConstantAttributes;
  this._context = context;
  this._gl = gl;
  this._vao = vao;
  this._attributes = vaAttributes;
  this._indexBuffer = indexBuffer;
}
function computeNumberOfVertices(attribute) {
  return attribute.values.length / attribute.componentsPerAttribute;
}
function computeAttributeSizeInBytes(attribute) {
  return ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype) * attribute.componentsPerAttribute;
}
function interleaveAttributes(attributes) {
  let j;
  let name;
  let attribute;
  const names = [];
  for (name in attributes) {
    if (attributes.hasOwnProperty(name) && defined_default(attributes[name]) && defined_default(attributes[name].values)) {
      names.push(name);
      if (attributes[name].componentDatatype === ComponentDatatype_default.DOUBLE) {
        attributes[name].componentDatatype = ComponentDatatype_default.FLOAT;
        attributes[name].values = ComponentDatatype_default.createTypedArray(
          ComponentDatatype_default.FLOAT,
          attributes[name].values
        );
      }
    }
  }
  let numberOfVertices;
  const namesLength = names.length;
  if (namesLength > 0) {
    numberOfVertices = computeNumberOfVertices(attributes[names[0]]);
    for (j = 1; j < namesLength; ++j) {
      const currentNumberOfVertices = computeNumberOfVertices(
        attributes[names[j]]
      );
      if (currentNumberOfVertices !== numberOfVertices) {
        throw new RuntimeError_default(
          `${"Each attribute list must have the same number of vertices.  Attribute "}${names[j]} has a different number of vertices (${currentNumberOfVertices.toString()}) than attribute ${names[0]} (${numberOfVertices.toString()}).`
        );
      }
    }
  }
  names.sort(function(left, right) {
    return ComponentDatatype_default.getSizeInBytes(attributes[right].componentDatatype) - ComponentDatatype_default.getSizeInBytes(attributes[left].componentDatatype);
  });
  let vertexSizeInBytes = 0;
  const offsetsInBytes = {};
  for (j = 0; j < namesLength; ++j) {
    name = names[j];
    attribute = attributes[name];
    offsetsInBytes[name] = vertexSizeInBytes;
    vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
  }
  if (vertexSizeInBytes > 0) {
    const maxComponentSizeInBytes = ComponentDatatype_default.getSizeInBytes(
      attributes[names[0]].componentDatatype
    );
    const remainder = vertexSizeInBytes % maxComponentSizeInBytes;
    if (remainder !== 0) {
      vertexSizeInBytes += maxComponentSizeInBytes - remainder;
    }
    const vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;
    const buffer = new ArrayBuffer(vertexBufferSizeInBytes);
    const views = {};
    for (j = 0; j < namesLength; ++j) {
      name = names[j];
      const sizeInBytes = ComponentDatatype_default.getSizeInBytes(
        attributes[name].componentDatatype
      );
      views[name] = {
        pointer: ComponentDatatype_default.createTypedArray(
          attributes[name].componentDatatype,
          buffer
        ),
        index: offsetsInBytes[name] / sizeInBytes,
        strideInComponentType: vertexSizeInBytes / sizeInBytes
      };
    }
    for (j = 0; j < numberOfVertices; ++j) {
      for (let n = 0; n < namesLength; ++n) {
        name = names[n];
        attribute = attributes[name];
        const values = attribute.values;
        const view = views[name];
        const pointer = view.pointer;
        const numberOfComponents = attribute.componentsPerAttribute;
        for (let k = 0; k < numberOfComponents; ++k) {
          pointer[view.index + k] = values[j * numberOfComponents + k];
        }
        view.index += view.strideInComponentType;
      }
    }
    return {
      buffer,
      offsetsInBytes,
      vertexSizeInBytes
    };
  }
  return void 0;
}
VertexArray.fromGeometry = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const geometry = defaultValue_default(options.geometry, defaultValue_default.EMPTY_OBJECT);
  const bufferUsage = defaultValue_default(
    options.bufferUsage,
    BufferUsage_default.DYNAMIC_DRAW
  );
  const attributeLocations = defaultValue_default(
    options.attributeLocations,
    defaultValue_default.EMPTY_OBJECT
  );
  const interleave = defaultValue_default(options.interleave, false);
  const createdVAAttributes = options.vertexArrayAttributes;
  let name;
  let attribute;
  let vertexBuffer;
  const vaAttributes = defined_default(createdVAAttributes) ? createdVAAttributes : [];
  const attributes = geometry.attributes;
  if (interleave) {
    const interleavedAttributes = interleaveAttributes(attributes);
    if (defined_default(interleavedAttributes)) {
      vertexBuffer = Buffer_default.createVertexBuffer({
        context,
        typedArray: interleavedAttributes.buffer,
        usage: bufferUsage
      });
      const offsetsInBytes = interleavedAttributes.offsetsInBytes;
      const strideInBytes = interleavedAttributes.vertexSizeInBytes;
      for (name in attributes) {
        if (attributes.hasOwnProperty(name) && defined_default(attributes[name])) {
          attribute = attributes[name];
          if (defined_default(attribute.values)) {
            vaAttributes.push({
              index: attributeLocations[name],
              vertexBuffer,
              componentDatatype: attribute.componentDatatype,
              componentsPerAttribute: attribute.componentsPerAttribute,
              normalize: attribute.normalize,
              offsetInBytes: offsetsInBytes[name],
              strideInBytes
            });
          } else {
            vaAttributes.push({
              index: attributeLocations[name],
              value: attribute.value,
              componentDatatype: attribute.componentDatatype,
              normalize: attribute.normalize
            });
          }
        }
      }
    }
  } else {
    for (name in attributes) {
      if (attributes.hasOwnProperty(name) && defined_default(attributes[name])) {
        attribute = attributes[name];
        let componentDatatype = attribute.componentDatatype;
        if (componentDatatype === ComponentDatatype_default.DOUBLE) {
          componentDatatype = ComponentDatatype_default.FLOAT;
        }
        vertexBuffer = void 0;
        if (defined_default(attribute.values)) {
          vertexBuffer = Buffer_default.createVertexBuffer({
            context,
            typedArray: ComponentDatatype_default.createTypedArray(
              componentDatatype,
              attribute.values
            ),
            usage: bufferUsage
          });
        }
        vaAttributes.push({
          index: attributeLocations[name],
          vertexBuffer,
          value: attribute.value,
          componentDatatype,
          componentsPerAttribute: attribute.componentsPerAttribute,
          normalize: attribute.normalize
        });
      }
    }
  }
  let indexBuffer;
  const indices = geometry.indices;
  if (defined_default(indices)) {
    if (Geometry_default.computeNumberOfVertices(geometry) >= Math_default.SIXTY_FOUR_KILOBYTES && context.elementIndexUint) {
      indexBuffer = Buffer_default.createIndexBuffer({
        context,
        typedArray: new Uint32Array(indices),
        usage: bufferUsage,
        indexDatatype: IndexDatatype_default.UNSIGNED_INT
      });
    } else {
      indexBuffer = Buffer_default.createIndexBuffer({
        context,
        typedArray: new Uint16Array(indices),
        usage: bufferUsage,
        indexDatatype: IndexDatatype_default.UNSIGNED_SHORT
      });
    }
  }
  return new VertexArray({
    context,
    attributes: vaAttributes,
    indexBuffer
  });
};
Object.defineProperties(VertexArray.prototype, {
  numberOfAttributes: {
    get: function() {
      return this._attributes.length;
    }
  },
  numberOfVertices: {
    get: function() {
      return this._numberOfVertices;
    }
  },
  indexBuffer: {
    get: function() {
      return this._indexBuffer;
    }
  }
});
VertexArray.prototype.getAttribute = function(index) {
  Check_default.defined("index", index);
  return this._attributes[index];
};
function setVertexAttribDivisor(vertexArray) {
  const context = vertexArray._context;
  const hasInstancedAttributes = vertexArray._hasInstancedAttributes;
  if (!hasInstancedAttributes && !context._previousDrawInstanced) {
    return;
  }
  context._previousDrawInstanced = hasInstancedAttributes;
  const divisors = context._vertexAttribDivisors;
  const attributes = vertexArray._attributes;
  const maxAttributes = ContextLimits_default.maximumVertexAttributes;
  let i;
  if (hasInstancedAttributes) {
    const length = attributes.length;
    for (i = 0; i < length; ++i) {
      const attribute = attributes[i];
      if (attribute.enabled) {
        const divisor = attribute.instanceDivisor;
        const index = attribute.index;
        if (divisor !== divisors[index]) {
          context.glVertexAttribDivisor(index, divisor);
          divisors[index] = divisor;
        }
      }
    }
  } else {
    for (i = 0; i < maxAttributes; ++i) {
      if (divisors[i] > 0) {
        context.glVertexAttribDivisor(i, 0);
        divisors[i] = 0;
      }
    }
  }
}
function setConstantAttributes(vertexArray, gl) {
  const attributes = vertexArray._attributes;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attributes[i];
    if (attribute.enabled && defined_default(attribute.value)) {
      attribute.vertexAttrib(gl);
    }
  }
}
VertexArray.prototype._bind = function() {
  if (defined_default(this._vao)) {
    this._context.glBindVertexArray(this._vao);
    if (this._context.instancedArrays) {
      setVertexAttribDivisor(this);
    }
    if (this._hasConstantAttributes) {
      setConstantAttributes(this, this._gl);
    }
  } else {
    bind(this._gl, this._attributes, this._indexBuffer);
  }
};
VertexArray.prototype._unBind = function() {
  if (defined_default(this._vao)) {
    this._context.glBindVertexArray(null);
  } else {
    const attributes = this._attributes;
    const gl = this._gl;
    for (let i = 0; i < attributes.length; ++i) {
      const attribute = attributes[i];
      if (attribute.enabled) {
        attribute.disableVertexAttribArray(gl);
      }
    }
    if (this._indexBuffer) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
  }
};
VertexArray.prototype.isDestroyed = function() {
  return false;
};
VertexArray.prototype.destroy = function() {
  const attributes = this._attributes;
  for (let i = 0; i < attributes.length; ++i) {
    const vertexBuffer = attributes[i].vertexBuffer;
    if (defined_default(vertexBuffer) && !vertexBuffer.isDestroyed() && vertexBuffer.vertexArrayDestroyable) {
      vertexBuffer.destroy();
    }
  }
  const indexBuffer = this._indexBuffer;
  if (defined_default(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {
    indexBuffer.destroy();
  }
  if (defined_default(this._vao)) {
    this._context.glDeleteVertexArray(this._vao);
  }
  return destroyObject_default(this);
};
var VertexArray_default = VertexArray;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/ConstantProperty.js
function ConstantProperty(value) {
  this._value = void 0;
  this._hasClone = false;
  this._hasEquals = false;
  this._definitionChanged = new Event_default();
  this.setValue(value);
}
Object.defineProperties(ConstantProperty.prototype, {
  isConstant: {
    value: true
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
ConstantProperty.prototype.getValue = function(time, result) {
  return this._hasClone ? this._value.clone(result) : this._value;
};
ConstantProperty.prototype.setValue = function(value) {
  const oldValue2 = this._value;
  if (oldValue2 !== value) {
    const isDefined = defined_default(value);
    const hasClone = isDefined && typeof value.clone === "function";
    const hasEquals = isDefined && typeof value.equals === "function";
    const changed = !hasEquals || !value.equals(oldValue2);
    if (changed) {
      this._hasClone = hasClone;
      this._hasEquals = hasEquals;
      this._value = !hasClone ? value : value.clone(this._value);
      this._definitionChanged.raiseEvent(this);
    }
  }
};
ConstantProperty.prototype.equals = function(other) {
  return this === other || other instanceof ConstantProperty && (!this._hasEquals && this._value === other._value || this._hasEquals && this._value.equals(other._value));
};
ConstantProperty.prototype.valueOf = function() {
  return this._value;
};
ConstantProperty.prototype.toString = function() {
  return String(this._value);
};
var ConstantProperty_default = ConstantProperty;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/createPropertyDescriptor.js
function createProperty(name, privateName, subscriptionName, configurable, createPropertyCallback) {
  return {
    configurable,
    get: function() {
      return this[privateName];
    },
    set: function(value) {
      const oldValue2 = this[privateName];
      const subscription = this[subscriptionName];
      if (defined_default(subscription)) {
        subscription();
        this[subscriptionName] = void 0;
      }
      const hasValue = value !== void 0;
      if (hasValue && (!defined_default(value) || !defined_default(value.getValue)) && defined_default(createPropertyCallback)) {
        value = createPropertyCallback(value);
      }
      if (oldValue2 !== value) {
        this[privateName] = value;
        this._definitionChanged.raiseEvent(this, name, value, oldValue2);
      }
      if (defined_default(value) && defined_default(value.definitionChanged)) {
        this[subscriptionName] = value.definitionChanged.addEventListener(
          function() {
            this._definitionChanged.raiseEvent(this, name, value, value);
          },
          this
        );
      }
    }
  };
}
function createConstantProperty(value) {
  return new ConstantProperty_default(value);
}
function createPropertyDescriptor(name, configurable, createPropertyCallback) {
  return createProperty(
    name,
    `_${name.toString()}`,
    `_${name.toString()}Subscription`,
    defaultValue_default(configurable, false),
    defaultValue_default(createPropertyCallback, createConstantProperty)
  );
}
var createPropertyDescriptor_default = createPropertyDescriptor;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/BillboardGraphics.js
function BillboardGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._image = void 0;
  this._imageSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._pixelOffset = void 0;
  this._pixelOffsetSubscription = void 0;
  this._eyeOffset = void 0;
  this._eyeOffsetSubscription = void 0;
  this._horizontalOrigin = void 0;
  this._horizontalOriginSubscription = void 0;
  this._verticalOrigin = void 0;
  this._verticalOriginSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._alignedAxis = void 0;
  this._alignedAxisSubscription = void 0;
  this._sizeInMeters = void 0;
  this._sizeInMetersSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._pixelOffsetScaleByDistance = void 0;
  this._pixelOffsetScaleByDistanceSubscription = void 0;
  this._imageSubRegion = void 0;
  this._imageSubRegionSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(BillboardGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  image: createPropertyDescriptor_default("image"),
  scale: createPropertyDescriptor_default("scale"),
  pixelOffset: createPropertyDescriptor_default("pixelOffset"),
  eyeOffset: createPropertyDescriptor_default("eyeOffset"),
  horizontalOrigin: createPropertyDescriptor_default("horizontalOrigin"),
  verticalOrigin: createPropertyDescriptor_default("verticalOrigin"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  color: createPropertyDescriptor_default("color"),
  rotation: createPropertyDescriptor_default("rotation"),
  alignedAxis: createPropertyDescriptor_default("alignedAxis"),
  sizeInMeters: createPropertyDescriptor_default("sizeInMeters"),
  width: createPropertyDescriptor_default("width"),
  height: createPropertyDescriptor_default("height"),
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  pixelOffsetScaleByDistance: createPropertyDescriptor_default(
    "pixelOffsetScaleByDistance"
  ),
  imageSubRegion: createPropertyDescriptor_default("imageSubRegion"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
BillboardGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new BillboardGraphics(this);
  }
  result.show = this._show;
  result.image = this._image;
  result.scale = this._scale;
  result.pixelOffset = this._pixelOffset;
  result.eyeOffset = this._eyeOffset;
  result.horizontalOrigin = this._horizontalOrigin;
  result.verticalOrigin = this._verticalOrigin;
  result.heightReference = this._heightReference;
  result.color = this._color;
  result.rotation = this._rotation;
  result.alignedAxis = this._alignedAxis;
  result.sizeInMeters = this._sizeInMeters;
  result.width = this._width;
  result.height = this._height;
  result.scaleByDistance = this._scaleByDistance;
  result.translucencyByDistance = this._translucencyByDistance;
  result.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
  result.imageSubRegion = this._imageSubRegion;
  result.distanceDisplayCondition = this._distanceDisplayCondition;
  result.disableDepthTestDistance = this._disableDepthTestDistance;
  return result;
};
BillboardGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this._show, source.show);
  this.image = defaultValue_default(this._image, source.image);
  this.scale = defaultValue_default(this._scale, source.scale);
  this.pixelOffset = defaultValue_default(this._pixelOffset, source.pixelOffset);
  this.eyeOffset = defaultValue_default(this._eyeOffset, source.eyeOffset);
  this.horizontalOrigin = defaultValue_default(
    this._horizontalOrigin,
    source.horizontalOrigin
  );
  this.verticalOrigin = defaultValue_default(
    this._verticalOrigin,
    source.verticalOrigin
  );
  this.heightReference = defaultValue_default(
    this._heightReference,
    source.heightReference
  );
  this.color = defaultValue_default(this._color, source.color);
  this.rotation = defaultValue_default(this._rotation, source.rotation);
  this.alignedAxis = defaultValue_default(this._alignedAxis, source.alignedAxis);
  this.sizeInMeters = defaultValue_default(this._sizeInMeters, source.sizeInMeters);
  this.width = defaultValue_default(this._width, source.width);
  this.height = defaultValue_default(this._height, source.height);
  this.scaleByDistance = defaultValue_default(
    this._scaleByDistance,
    source.scaleByDistance
  );
  this.translucencyByDistance = defaultValue_default(
    this._translucencyByDistance,
    source.translucencyByDistance
  );
  this.pixelOffsetScaleByDistance = defaultValue_default(
    this._pixelOffsetScaleByDistance,
    source.pixelOffsetScaleByDistance
  );
  this.imageSubRegion = defaultValue_default(
    this._imageSubRegion,
    source.imageSubRegion
  );
  this.distanceDisplayCondition = defaultValue_default(
    this._distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this._disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var BillboardGraphics_default = BillboardGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/AssociativeArray.js
function AssociativeArray() {
  this._array = [];
  this._hash = {};
}
Object.defineProperties(AssociativeArray.prototype, {
  length: {
    get: function() {
      return this._array.length;
    }
  },
  values: {
    get: function() {
      return this._array;
    }
  }
});
AssociativeArray.prototype.contains = function(key) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  return defined_default(this._hash[key]);
};
AssociativeArray.prototype.set = function(key, value) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  const oldValue2 = this._hash[key];
  if (value !== oldValue2) {
    this.remove(key);
    this._hash[key] = value;
    this._array.push(value);
  }
};
AssociativeArray.prototype.get = function(key) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  return this._hash[key];
};
AssociativeArray.prototype.remove = function(key) {
  if (defined_default(key) && typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  const value = this._hash[key];
  const hasValue = defined_default(value);
  if (hasValue) {
    const array = this._array;
    array.splice(array.indexOf(value), 1);
    delete this._hash[key];
  }
  return hasValue;
};
AssociativeArray.prototype.removeAll = function() {
  const array = this._array;
  if (array.length > 0) {
    this._hash = {};
    array.length = 0;
  }
};
var AssociativeArray_default = AssociativeArray;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/HeightReference.js
var HeightReference = {
  NONE: 0,
  CLAMP_TO_GROUND: 1,
  RELATIVE_TO_GROUND: 2
};
var HeightReference_default = Object.freeze(HeightReference);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/VerticalOrigin.js
var VerticalOrigin = {
  CENTER: 0,
  BOTTOM: 1,
  BASELINE: 2,
  TOP: -1
};
var VerticalOrigin_default = Object.freeze(VerticalOrigin);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/Property.js
function Property() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(Property.prototype, {
  isConstant: {
    get: DeveloperError_default.throwInstantiationError
  },
  definitionChanged: {
    get: DeveloperError_default.throwInstantiationError
  }
});
Property.prototype.getValue = DeveloperError_default.throwInstantiationError;
Property.prototype.equals = DeveloperError_default.throwInstantiationError;
Property.equals = function(left, right) {
  return left === right || defined_default(left) && left.equals(right);
};
Property.arrayEquals = function(left, right) {
  if (left === right) {
    return true;
  }
  if (!defined_default(left) || !defined_default(right) || left.length !== right.length) {
    return false;
  }
  const length = left.length;
  for (let i = 0; i < length; i++) {
    if (!Property.equals(left[i], right[i])) {
      return false;
    }
  }
  return true;
};
Property.isConstant = function(property) {
  return !defined_default(property) || property.isConstant;
};
Property.getValueOrUndefined = function(property, time, result) {
  return defined_default(property) ? property.getValue(time, result) : void 0;
};
Property.getValueOrDefault = function(property, time, valueDefault, result) {
  return defined_default(property) ? defaultValue_default(property.getValue(time, result), valueDefault) : valueDefault;
};
Property.getValueOrClonedDefault = function(property, time, valueDefault, result) {
  let value;
  if (defined_default(property)) {
    value = property.getValue(time, result);
  }
  if (!defined_default(value)) {
    value = valueDefault.clone(value);
  }
  return value;
};
var Property_default = Property;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Interval.js
function Interval(start, stop) {
  this.start = defaultValue_default(start, 0);
  this.stop = defaultValue_default(stop, 0);
}
var Interval_default = Interval;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/BoundingSphere.js
function BoundingSphere(center, radius) {
  this.center = Cartesian3_default.clone(defaultValue_default(center, Cartesian3_default.ZERO));
  this.radius = defaultValue_default(radius, 0);
}
var fromPointsXMin = new Cartesian3_default();
var fromPointsYMin = new Cartesian3_default();
var fromPointsZMin = new Cartesian3_default();
var fromPointsXMax = new Cartesian3_default();
var fromPointsYMax = new Cartesian3_default();
var fromPointsZMax = new Cartesian3_default();
var fromPointsCurrentPos = new Cartesian3_default();
var fromPointsScratch = new Cartesian3_default();
var fromPointsRitterCenter = new Cartesian3_default();
var fromPointsMinBoxPt = new Cartesian3_default();
var fromPointsMaxBoxPt = new Cartesian3_default();
var fromPointsNaiveCenterScratch = new Cartesian3_default();
var volumeConstant = 4 / 3 * Math_default.PI;
BoundingSphere.fromPoints = function(positions, result) {
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  if (!defined_default(positions) || positions.length === 0) {
    result.center = Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
    result.radius = 0;
    return result;
  }
  const currentPos = Cartesian3_default.clone(positions[0], fromPointsCurrentPos);
  const xMin = Cartesian3_default.clone(currentPos, fromPointsXMin);
  const yMin = Cartesian3_default.clone(currentPos, fromPointsYMin);
  const zMin = Cartesian3_default.clone(currentPos, fromPointsZMin);
  const xMax = Cartesian3_default.clone(currentPos, fromPointsXMax);
  const yMax = Cartesian3_default.clone(currentPos, fromPointsYMax);
  const zMax = Cartesian3_default.clone(currentPos, fromPointsZMax);
  const numPositions = positions.length;
  let i;
  for (i = 1; i < numPositions; i++) {
    Cartesian3_default.clone(positions[i], currentPos);
    const x = currentPos.x;
    const y = currentPos.y;
    const z = currentPos.z;
    if (x < xMin.x) {
      Cartesian3_default.clone(currentPos, xMin);
    }
    if (x > xMax.x) {
      Cartesian3_default.clone(currentPos, xMax);
    }
    if (y < yMin.y) {
      Cartesian3_default.clone(currentPos, yMin);
    }
    if (y > yMax.y) {
      Cartesian3_default.clone(currentPos, yMax);
    }
    if (z < zMin.z) {
      Cartesian3_default.clone(currentPos, zMin);
    }
    if (z > zMax.z) {
      Cartesian3_default.clone(currentPos, zMax);
    }
  }
  const xSpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(xMax, xMin, fromPointsScratch)
  );
  const ySpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(yMax, yMin, fromPointsScratch)
  );
  const zSpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(zMax, zMin, fromPointsScratch)
  );
  let diameter1 = xMin;
  let diameter2 = xMax;
  let maxSpan = xSpan;
  if (ySpan > maxSpan) {
    maxSpan = ySpan;
    diameter1 = yMin;
    diameter2 = yMax;
  }
  if (zSpan > maxSpan) {
    maxSpan = zSpan;
    diameter1 = zMin;
    diameter2 = zMax;
  }
  const ritterCenter = fromPointsRitterCenter;
  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
  let radiusSquared = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(diameter2, ritterCenter, fromPointsScratch)
  );
  let ritterRadius = Math.sqrt(radiusSquared);
  const minBoxPt = fromPointsMinBoxPt;
  minBoxPt.x = xMin.x;
  minBoxPt.y = yMin.y;
  minBoxPt.z = zMin.z;
  const maxBoxPt = fromPointsMaxBoxPt;
  maxBoxPt.x = xMax.x;
  maxBoxPt.y = yMax.y;
  maxBoxPt.z = zMax.z;
  const naiveCenter = Cartesian3_default.midpoint(
    minBoxPt,
    maxBoxPt,
    fromPointsNaiveCenterScratch
  );
  let naiveRadius = 0;
  for (i = 0; i < numPositions; i++) {
    Cartesian3_default.clone(positions[i], currentPos);
    const r = Cartesian3_default.magnitude(
      Cartesian3_default.subtract(currentPos, naiveCenter, fromPointsScratch)
    );
    if (r > naiveRadius) {
      naiveRadius = r;
    }
    const oldCenterToPointSquared = Cartesian3_default.magnitudeSquared(
      Cartesian3_default.subtract(currentPos, ritterCenter, fromPointsScratch)
    );
    if (oldCenterToPointSquared > radiusSquared) {
      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
      radiusSquared = ritterRadius * ritterRadius;
      const oldToNew = oldCenterToPoint - ritterRadius;
      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
    }
  }
  if (ritterRadius < naiveRadius) {
    Cartesian3_default.clone(ritterCenter, result.center);
    result.radius = ritterRadius;
  } else {
    Cartesian3_default.clone(naiveCenter, result.center);
    result.radius = naiveRadius;
  }
  return result;
};
var defaultProjection2 = new GeographicProjection_default();
var fromRectangle2DLowerLeft = new Cartesian3_default();
var fromRectangle2DUpperRight = new Cartesian3_default();
var fromRectangle2DSouthwest = new Cartographic_default();
var fromRectangle2DNortheast = new Cartographic_default();
BoundingSphere.fromRectangle2D = function(rectangle, projection, result) {
  return BoundingSphere.fromRectangleWithHeights2D(
    rectangle,
    projection,
    0,
    0,
    result
  );
};
BoundingSphere.fromRectangleWithHeights2D = function(rectangle, projection, minimumHeight, maximumHeight, result) {
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  if (!defined_default(rectangle)) {
    result.center = Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
    result.radius = 0;
    return result;
  }
  projection = defaultValue_default(projection, defaultProjection2);
  Rectangle_default.southwest(rectangle, fromRectangle2DSouthwest);
  fromRectangle2DSouthwest.height = minimumHeight;
  Rectangle_default.northeast(rectangle, fromRectangle2DNortheast);
  fromRectangle2DNortheast.height = maximumHeight;
  const lowerLeft = projection.project(
    fromRectangle2DSouthwest,
    fromRectangle2DLowerLeft
  );
  const upperRight = projection.project(
    fromRectangle2DNortheast,
    fromRectangle2DUpperRight
  );
  const width = upperRight.x - lowerLeft.x;
  const height = upperRight.y - lowerLeft.y;
  const elevation = upperRight.z - lowerLeft.z;
  result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;
  const center = result.center;
  center.x = lowerLeft.x + width * 0.5;
  center.y = lowerLeft.y + height * 0.5;
  center.z = lowerLeft.z + elevation * 0.5;
  return result;
};
var fromRectangle3DScratch = [];
BoundingSphere.fromRectangle3D = function(rectangle, ellipsoid, surfaceHeight, result) {
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  surfaceHeight = defaultValue_default(surfaceHeight, 0);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  if (!defined_default(rectangle)) {
    result.center = Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
    result.radius = 0;
    return result;
  }
  const positions = Rectangle_default.subsample(
    rectangle,
    ellipsoid,
    surfaceHeight,
    fromRectangle3DScratch
  );
  return BoundingSphere.fromPoints(positions, result);
};
BoundingSphere.fromVertices = function(positions, center, stride, result) {
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  if (!defined_default(positions) || positions.length === 0) {
    result.center = Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
    result.radius = 0;
    return result;
  }
  center = defaultValue_default(center, Cartesian3_default.ZERO);
  stride = defaultValue_default(stride, 3);
  Check_default.typeOf.number.greaterThanOrEquals("stride", stride, 3);
  const currentPos = fromPointsCurrentPos;
  currentPos.x = positions[0] + center.x;
  currentPos.y = positions[1] + center.y;
  currentPos.z = positions[2] + center.z;
  const xMin = Cartesian3_default.clone(currentPos, fromPointsXMin);
  const yMin = Cartesian3_default.clone(currentPos, fromPointsYMin);
  const zMin = Cartesian3_default.clone(currentPos, fromPointsZMin);
  const xMax = Cartesian3_default.clone(currentPos, fromPointsXMax);
  const yMax = Cartesian3_default.clone(currentPos, fromPointsYMax);
  const zMax = Cartesian3_default.clone(currentPos, fromPointsZMax);
  const numElements = positions.length;
  let i;
  for (i = 0; i < numElements; i += stride) {
    const x = positions[i] + center.x;
    const y = positions[i + 1] + center.y;
    const z = positions[i + 2] + center.z;
    currentPos.x = x;
    currentPos.y = y;
    currentPos.z = z;
    if (x < xMin.x) {
      Cartesian3_default.clone(currentPos, xMin);
    }
    if (x > xMax.x) {
      Cartesian3_default.clone(currentPos, xMax);
    }
    if (y < yMin.y) {
      Cartesian3_default.clone(currentPos, yMin);
    }
    if (y > yMax.y) {
      Cartesian3_default.clone(currentPos, yMax);
    }
    if (z < zMin.z) {
      Cartesian3_default.clone(currentPos, zMin);
    }
    if (z > zMax.z) {
      Cartesian3_default.clone(currentPos, zMax);
    }
  }
  const xSpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(xMax, xMin, fromPointsScratch)
  );
  const ySpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(yMax, yMin, fromPointsScratch)
  );
  const zSpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(zMax, zMin, fromPointsScratch)
  );
  let diameter1 = xMin;
  let diameter2 = xMax;
  let maxSpan = xSpan;
  if (ySpan > maxSpan) {
    maxSpan = ySpan;
    diameter1 = yMin;
    diameter2 = yMax;
  }
  if (zSpan > maxSpan) {
    maxSpan = zSpan;
    diameter1 = zMin;
    diameter2 = zMax;
  }
  const ritterCenter = fromPointsRitterCenter;
  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
  let radiusSquared = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(diameter2, ritterCenter, fromPointsScratch)
  );
  let ritterRadius = Math.sqrt(radiusSquared);
  const minBoxPt = fromPointsMinBoxPt;
  minBoxPt.x = xMin.x;
  minBoxPt.y = yMin.y;
  minBoxPt.z = zMin.z;
  const maxBoxPt = fromPointsMaxBoxPt;
  maxBoxPt.x = xMax.x;
  maxBoxPt.y = yMax.y;
  maxBoxPt.z = zMax.z;
  const naiveCenter = Cartesian3_default.midpoint(
    minBoxPt,
    maxBoxPt,
    fromPointsNaiveCenterScratch
  );
  let naiveRadius = 0;
  for (i = 0; i < numElements; i += stride) {
    currentPos.x = positions[i] + center.x;
    currentPos.y = positions[i + 1] + center.y;
    currentPos.z = positions[i + 2] + center.z;
    const r = Cartesian3_default.magnitude(
      Cartesian3_default.subtract(currentPos, naiveCenter, fromPointsScratch)
    );
    if (r > naiveRadius) {
      naiveRadius = r;
    }
    const oldCenterToPointSquared = Cartesian3_default.magnitudeSquared(
      Cartesian3_default.subtract(currentPos, ritterCenter, fromPointsScratch)
    );
    if (oldCenterToPointSquared > radiusSquared) {
      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
      radiusSquared = ritterRadius * ritterRadius;
      const oldToNew = oldCenterToPoint - ritterRadius;
      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
    }
  }
  if (ritterRadius < naiveRadius) {
    Cartesian3_default.clone(ritterCenter, result.center);
    result.radius = ritterRadius;
  } else {
    Cartesian3_default.clone(naiveCenter, result.center);
    result.radius = naiveRadius;
  }
  return result;
};
BoundingSphere.fromEncodedCartesianVertices = function(positionsHigh, positionsLow, result) {
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  if (!defined_default(positionsHigh) || !defined_default(positionsLow) || positionsHigh.length !== positionsLow.length || positionsHigh.length === 0) {
    result.center = Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
    result.radius = 0;
    return result;
  }
  const currentPos = fromPointsCurrentPos;
  currentPos.x = positionsHigh[0] + positionsLow[0];
  currentPos.y = positionsHigh[1] + positionsLow[1];
  currentPos.z = positionsHigh[2] + positionsLow[2];
  const xMin = Cartesian3_default.clone(currentPos, fromPointsXMin);
  const yMin = Cartesian3_default.clone(currentPos, fromPointsYMin);
  const zMin = Cartesian3_default.clone(currentPos, fromPointsZMin);
  const xMax = Cartesian3_default.clone(currentPos, fromPointsXMax);
  const yMax = Cartesian3_default.clone(currentPos, fromPointsYMax);
  const zMax = Cartesian3_default.clone(currentPos, fromPointsZMax);
  const numElements = positionsHigh.length;
  let i;
  for (i = 0; i < numElements; i += 3) {
    const x = positionsHigh[i] + positionsLow[i];
    const y = positionsHigh[i + 1] + positionsLow[i + 1];
    const z = positionsHigh[i + 2] + positionsLow[i + 2];
    currentPos.x = x;
    currentPos.y = y;
    currentPos.z = z;
    if (x < xMin.x) {
      Cartesian3_default.clone(currentPos, xMin);
    }
    if (x > xMax.x) {
      Cartesian3_default.clone(currentPos, xMax);
    }
    if (y < yMin.y) {
      Cartesian3_default.clone(currentPos, yMin);
    }
    if (y > yMax.y) {
      Cartesian3_default.clone(currentPos, yMax);
    }
    if (z < zMin.z) {
      Cartesian3_default.clone(currentPos, zMin);
    }
    if (z > zMax.z) {
      Cartesian3_default.clone(currentPos, zMax);
    }
  }
  const xSpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(xMax, xMin, fromPointsScratch)
  );
  const ySpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(yMax, yMin, fromPointsScratch)
  );
  const zSpan = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(zMax, zMin, fromPointsScratch)
  );
  let diameter1 = xMin;
  let diameter2 = xMax;
  let maxSpan = xSpan;
  if (ySpan > maxSpan) {
    maxSpan = ySpan;
    diameter1 = yMin;
    diameter2 = yMax;
  }
  if (zSpan > maxSpan) {
    maxSpan = zSpan;
    diameter1 = zMin;
    diameter2 = zMax;
  }
  const ritterCenter = fromPointsRitterCenter;
  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
  let radiusSquared = Cartesian3_default.magnitudeSquared(
    Cartesian3_default.subtract(diameter2, ritterCenter, fromPointsScratch)
  );
  let ritterRadius = Math.sqrt(radiusSquared);
  const minBoxPt = fromPointsMinBoxPt;
  minBoxPt.x = xMin.x;
  minBoxPt.y = yMin.y;
  minBoxPt.z = zMin.z;
  const maxBoxPt = fromPointsMaxBoxPt;
  maxBoxPt.x = xMax.x;
  maxBoxPt.y = yMax.y;
  maxBoxPt.z = zMax.z;
  const naiveCenter = Cartesian3_default.midpoint(
    minBoxPt,
    maxBoxPt,
    fromPointsNaiveCenterScratch
  );
  let naiveRadius = 0;
  for (i = 0; i < numElements; i += 3) {
    currentPos.x = positionsHigh[i] + positionsLow[i];
    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];
    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];
    const r = Cartesian3_default.magnitude(
      Cartesian3_default.subtract(currentPos, naiveCenter, fromPointsScratch)
    );
    if (r > naiveRadius) {
      naiveRadius = r;
    }
    const oldCenterToPointSquared = Cartesian3_default.magnitudeSquared(
      Cartesian3_default.subtract(currentPos, ritterCenter, fromPointsScratch)
    );
    if (oldCenterToPointSquared > radiusSquared) {
      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
      radiusSquared = ritterRadius * ritterRadius;
      const oldToNew = oldCenterToPoint - ritterRadius;
      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
    }
  }
  if (ritterRadius < naiveRadius) {
    Cartesian3_default.clone(ritterCenter, result.center);
    result.radius = ritterRadius;
  } else {
    Cartesian3_default.clone(naiveCenter, result.center);
    result.radius = naiveRadius;
  }
  return result;
};
BoundingSphere.fromCornerPoints = function(corner, oppositeCorner, result) {
  Check_default.typeOf.object("corner", corner);
  Check_default.typeOf.object("oppositeCorner", oppositeCorner);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  const center = Cartesian3_default.midpoint(corner, oppositeCorner, result.center);
  result.radius = Cartesian3_default.distance(center, oppositeCorner);
  return result;
};
BoundingSphere.fromEllipsoid = function(ellipsoid, result) {
  Check_default.typeOf.object("ellipsoid", ellipsoid);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
  result.radius = ellipsoid.maximumRadius;
  return result;
};
var fromBoundingSpheresScratch = new Cartesian3_default();
BoundingSphere.fromBoundingSpheres = function(boundingSpheres, result) {
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  if (!defined_default(boundingSpheres) || boundingSpheres.length === 0) {
    result.center = Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
    result.radius = 0;
    return result;
  }
  const length = boundingSpheres.length;
  if (length === 1) {
    return BoundingSphere.clone(boundingSpheres[0], result);
  }
  if (length === 2) {
    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);
  }
  const positions = [];
  let i;
  for (i = 0; i < length; i++) {
    positions.push(boundingSpheres[i].center);
  }
  result = BoundingSphere.fromPoints(positions, result);
  const center = result.center;
  let radius = result.radius;
  for (i = 0; i < length; i++) {
    const tmp2 = boundingSpheres[i];
    radius = Math.max(
      radius,
      Cartesian3_default.distance(center, tmp2.center, fromBoundingSpheresScratch) + tmp2.radius
    );
  }
  result.radius = radius;
  return result;
};
var fromOrientedBoundingBoxScratchU = new Cartesian3_default();
var fromOrientedBoundingBoxScratchV = new Cartesian3_default();
var fromOrientedBoundingBoxScratchW = new Cartesian3_default();
BoundingSphere.fromOrientedBoundingBox = function(orientedBoundingBox, result) {
  Check_default.defined("orientedBoundingBox", orientedBoundingBox);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  const halfAxes = orientedBoundingBox.halfAxes;
  const u3 = Matrix3_default.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);
  const v3 = Matrix3_default.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);
  const w = Matrix3_default.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);
  Cartesian3_default.add(u3, v3, u3);
  Cartesian3_default.add(u3, w, u3);
  result.center = Cartesian3_default.clone(orientedBoundingBox.center, result.center);
  result.radius = Cartesian3_default.magnitude(u3);
  return result;
};
var scratchFromTransformationCenter = new Cartesian3_default();
var scratchFromTransformationScale = new Cartesian3_default();
BoundingSphere.fromTransformation = function(transformation, result) {
  Check_default.typeOf.object("transformation", transformation);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  const center = Matrix4_default.getTranslation(
    transformation,
    scratchFromTransformationCenter
  );
  const scale = Matrix4_default.getScale(
    transformation,
    scratchFromTransformationScale
  );
  const radius = 0.5 * Cartesian3_default.magnitude(scale);
  result.center = Cartesian3_default.clone(center, result.center);
  result.radius = radius;
  return result;
};
BoundingSphere.clone = function(sphere, result) {
  if (!defined_default(sphere)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new BoundingSphere(sphere.center, sphere.radius);
  }
  result.center = Cartesian3_default.clone(sphere.center, result.center);
  result.radius = sphere.radius;
  return result;
};
BoundingSphere.packedLength = 4;
BoundingSphere.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  const center = value.center;
  array[startingIndex++] = center.x;
  array[startingIndex++] = center.y;
  array[startingIndex++] = center.z;
  array[startingIndex] = value.radius;
  return array;
};
BoundingSphere.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  const center = result.center;
  center.x = array[startingIndex++];
  center.y = array[startingIndex++];
  center.z = array[startingIndex++];
  result.radius = array[startingIndex];
  return result;
};
var unionScratch = new Cartesian3_default();
var unionScratchCenter = new Cartesian3_default();
BoundingSphere.union = function(left, right, result) {
  Check_default.typeOf.object("left", left);
  Check_default.typeOf.object("right", right);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  const leftCenter = left.center;
  const leftRadius = left.radius;
  const rightCenter = right.center;
  const rightRadius = right.radius;
  const toRightCenter = Cartesian3_default.subtract(
    rightCenter,
    leftCenter,
    unionScratch
  );
  const centerSeparation = Cartesian3_default.magnitude(toRightCenter);
  if (leftRadius >= centerSeparation + rightRadius) {
    left.clone(result);
    return result;
  }
  if (rightRadius >= centerSeparation + leftRadius) {
    right.clone(result);
    return result;
  }
  const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
  const center = Cartesian3_default.multiplyByScalar(
    toRightCenter,
    (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation,
    unionScratchCenter
  );
  Cartesian3_default.add(center, leftCenter, center);
  Cartesian3_default.clone(center, result.center);
  result.radius = halfDistanceBetweenTangentPoints;
  return result;
};
var expandScratch = new Cartesian3_default();
BoundingSphere.expand = function(sphere, point, result) {
  Check_default.typeOf.object("sphere", sphere);
  Check_default.typeOf.object("point", point);
  result = BoundingSphere.clone(sphere, result);
  const radius = Cartesian3_default.magnitude(
    Cartesian3_default.subtract(point, result.center, expandScratch)
  );
  if (radius > result.radius) {
    result.radius = radius;
  }
  return result;
};
BoundingSphere.intersectPlane = function(sphere, plane) {
  Check_default.typeOf.object("sphere", sphere);
  Check_default.typeOf.object("plane", plane);
  const center = sphere.center;
  const radius = sphere.radius;
  const normal2 = plane.normal;
  const distanceToPlane = Cartesian3_default.dot(normal2, center) + plane.distance;
  if (distanceToPlane < -radius) {
    return Intersect_default.OUTSIDE;
  } else if (distanceToPlane < radius) {
    return Intersect_default.INTERSECTING;
  }
  return Intersect_default.INSIDE;
};
BoundingSphere.transform = function(sphere, transform, result) {
  Check_default.typeOf.object("sphere", sphere);
  Check_default.typeOf.object("transform", transform);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  result.center = Matrix4_default.multiplyByPoint(
    transform,
    sphere.center,
    result.center
  );
  result.radius = Matrix4_default.getMaximumScale(transform) * sphere.radius;
  return result;
};
var distanceSquaredToScratch = new Cartesian3_default();
BoundingSphere.distanceSquaredTo = function(sphere, cartesian) {
  Check_default.typeOf.object("sphere", sphere);
  Check_default.typeOf.object("cartesian", cartesian);
  const diff = Cartesian3_default.subtract(
    sphere.center,
    cartesian,
    distanceSquaredToScratch
  );
  const distance = Cartesian3_default.magnitude(diff) - sphere.radius;
  if (distance <= 0) {
    return 0;
  }
  return distance * distance;
};
BoundingSphere.transformWithoutScale = function(sphere, transform, result) {
  Check_default.typeOf.object("sphere", sphere);
  Check_default.typeOf.object("transform", transform);
  if (!defined_default(result)) {
    result = new BoundingSphere();
  }
  result.center = Matrix4_default.multiplyByPoint(
    transform,
    sphere.center,
    result.center
  );
  result.radius = sphere.radius;
  return result;
};
var scratchCartesian3 = new Cartesian3_default();
BoundingSphere.computePlaneDistances = function(sphere, position, direction2, result) {
  Check_default.typeOf.object("sphere", sphere);
  Check_default.typeOf.object("position", position);
  Check_default.typeOf.object("direction", direction2);
  if (!defined_default(result)) {
    result = new Interval_default();
  }
  const toCenter = Cartesian3_default.subtract(
    sphere.center,
    position,
    scratchCartesian3
  );
  const mag = Cartesian3_default.dot(direction2, toCenter);
  result.start = mag - sphere.radius;
  result.stop = mag + sphere.radius;
  return result;
};
var projectTo2DNormalScratch = new Cartesian3_default();
var projectTo2DEastScratch = new Cartesian3_default();
var projectTo2DNorthScratch = new Cartesian3_default();
var projectTo2DWestScratch = new Cartesian3_default();
var projectTo2DSouthScratch = new Cartesian3_default();
var projectTo2DCartographicScratch = new Cartographic_default();
var projectTo2DPositionsScratch = new Array(8);
for (let n = 0; n < 8; ++n) {
  projectTo2DPositionsScratch[n] = new Cartesian3_default();
}
var projectTo2DProjection = new GeographicProjection_default();
BoundingSphere.projectTo2D = function(sphere, projection, result) {
  Check_default.typeOf.object("sphere", sphere);
  projection = defaultValue_default(projection, projectTo2DProjection);
  const ellipsoid = projection.ellipsoid;
  let center = sphere.center;
  const radius = sphere.radius;
  let normal2;
  if (Cartesian3_default.equals(center, Cartesian3_default.ZERO)) {
    normal2 = Cartesian3_default.clone(Cartesian3_default.UNIT_X, projectTo2DNormalScratch);
  } else {
    normal2 = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);
  }
  const east = Cartesian3_default.cross(
    Cartesian3_default.UNIT_Z,
    normal2,
    projectTo2DEastScratch
  );
  Cartesian3_default.normalize(east, east);
  const north = Cartesian3_default.cross(normal2, east, projectTo2DNorthScratch);
  Cartesian3_default.normalize(north, north);
  Cartesian3_default.multiplyByScalar(normal2, radius, normal2);
  Cartesian3_default.multiplyByScalar(north, radius, north);
  Cartesian3_default.multiplyByScalar(east, radius, east);
  const south = Cartesian3_default.negate(north, projectTo2DSouthScratch);
  const west = Cartesian3_default.negate(east, projectTo2DWestScratch);
  const positions = projectTo2DPositionsScratch;
  let corner = positions[0];
  Cartesian3_default.add(normal2, north, corner);
  Cartesian3_default.add(corner, east, corner);
  corner = positions[1];
  Cartesian3_default.add(normal2, north, corner);
  Cartesian3_default.add(corner, west, corner);
  corner = positions[2];
  Cartesian3_default.add(normal2, south, corner);
  Cartesian3_default.add(corner, west, corner);
  corner = positions[3];
  Cartesian3_default.add(normal2, south, corner);
  Cartesian3_default.add(corner, east, corner);
  Cartesian3_default.negate(normal2, normal2);
  corner = positions[4];
  Cartesian3_default.add(normal2, north, corner);
  Cartesian3_default.add(corner, east, corner);
  corner = positions[5];
  Cartesian3_default.add(normal2, north, corner);
  Cartesian3_default.add(corner, west, corner);
  corner = positions[6];
  Cartesian3_default.add(normal2, south, corner);
  Cartesian3_default.add(corner, west, corner);
  corner = positions[7];
  Cartesian3_default.add(normal2, south, corner);
  Cartesian3_default.add(corner, east, corner);
  const length = positions.length;
  for (let i = 0; i < length; ++i) {
    const position = positions[i];
    Cartesian3_default.add(center, position, position);
    const cartographic = ellipsoid.cartesianToCartographic(
      position,
      projectTo2DCartographicScratch
    );
    projection.project(cartographic, position);
  }
  result = BoundingSphere.fromPoints(positions, result);
  center = result.center;
  const x = center.x;
  const y = center.y;
  const z = center.z;
  center.x = z;
  center.y = x;
  center.z = y;
  return result;
};
BoundingSphere.isOccluded = function(sphere, occluder) {
  Check_default.typeOf.object("sphere", sphere);
  Check_default.typeOf.object("occluder", occluder);
  return !occluder.isBoundingSphereVisible(sphere);
};
BoundingSphere.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && Cartesian3_default.equals(left.center, right.center) && left.radius === right.radius;
};
BoundingSphere.prototype.intersectPlane = function(plane) {
  return BoundingSphere.intersectPlane(this, plane);
};
BoundingSphere.prototype.distanceSquaredTo = function(cartesian) {
  return BoundingSphere.distanceSquaredTo(this, cartesian);
};
BoundingSphere.prototype.computePlaneDistances = function(position, direction2, result) {
  return BoundingSphere.computePlaneDistances(
    this,
    position,
    direction2,
    result
  );
};
BoundingSphere.prototype.isOccluded = function(occluder) {
  return BoundingSphere.isOccluded(this, occluder);
};
BoundingSphere.prototype.equals = function(right) {
  return BoundingSphere.equals(this, right);
};
BoundingSphere.prototype.clone = function(result) {
  return BoundingSphere.clone(this, result);
};
BoundingSphere.prototype.volume = function() {
  const radius = this.radius;
  return volumeConstant * radius * radius * radius;
};
var BoundingSphere_default = BoundingSphere;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeometryAttributes.js
function GeometryAttributes(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.position = options.position;
  this.normal = options.normal;
  this.st = options.st;
  this.bitangent = options.bitangent;
  this.tangent = options.tangent;
  this.color = options.color;
}
var GeometryAttributes_default = GeometryAttributes;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeometryOffsetAttribute.js
var GeometryOffsetAttribute = {
  NONE: 0,
  TOP: 1,
  ALL: 2
};
var GeometryOffsetAttribute_default = Object.freeze(GeometryOffsetAttribute);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/VertexFormat.js
function VertexFormat(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.position = defaultValue_default(options.position, false);
  this.normal = defaultValue_default(options.normal, false);
  this.st = defaultValue_default(options.st, false);
  this.bitangent = defaultValue_default(options.bitangent, false);
  this.tangent = defaultValue_default(options.tangent, false);
  this.color = defaultValue_default(options.color, false);
}
VertexFormat.POSITION_ONLY = Object.freeze(
  new VertexFormat({
    position: true
  })
);
VertexFormat.POSITION_AND_NORMAL = Object.freeze(
  new VertexFormat({
    position: true,
    normal: true
  })
);
VertexFormat.POSITION_NORMAL_AND_ST = Object.freeze(
  new VertexFormat({
    position: true,
    normal: true,
    st: true
  })
);
VertexFormat.POSITION_AND_ST = Object.freeze(
  new VertexFormat({
    position: true,
    st: true
  })
);
VertexFormat.POSITION_AND_COLOR = Object.freeze(
  new VertexFormat({
    position: true,
    color: true
  })
);
VertexFormat.ALL = Object.freeze(
  new VertexFormat({
    position: true,
    normal: true,
    st: true,
    tangent: true,
    bitangent: true
  })
);
VertexFormat.DEFAULT = VertexFormat.POSITION_NORMAL_AND_ST;
VertexFormat.packedLength = 6;
VertexFormat.pack = function(value, array, startingIndex) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required");
  }
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.position ? 1 : 0;
  array[startingIndex++] = value.normal ? 1 : 0;
  array[startingIndex++] = value.st ? 1 : 0;
  array[startingIndex++] = value.tangent ? 1 : 0;
  array[startingIndex++] = value.bitangent ? 1 : 0;
  array[startingIndex] = value.color ? 1 : 0;
  return array;
};
VertexFormat.unpack = function(array, startingIndex, result) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new VertexFormat();
  }
  result.position = array[startingIndex++] === 1;
  result.normal = array[startingIndex++] === 1;
  result.st = array[startingIndex++] === 1;
  result.tangent = array[startingIndex++] === 1;
  result.bitangent = array[startingIndex++] === 1;
  result.color = array[startingIndex] === 1;
  return result;
};
VertexFormat.clone = function(vertexFormat, result) {
  if (!defined_default(vertexFormat)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new VertexFormat();
  }
  result.position = vertexFormat.position;
  result.normal = vertexFormat.normal;
  result.st = vertexFormat.st;
  result.tangent = vertexFormat.tangent;
  result.bitangent = vertexFormat.bitangent;
  result.color = vertexFormat.color;
  return result;
};
var VertexFormat_default = VertexFormat;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/ColorGeometryInstanceAttribute.js
function ColorGeometryInstanceAttribute(red, green, blue, alpha) {
  red = defaultValue_default(red, 1);
  green = defaultValue_default(green, 1);
  blue = defaultValue_default(blue, 1);
  alpha = defaultValue_default(alpha, 1);
  this.value = new Uint8Array([
    Color_default.floatToByte(red),
    Color_default.floatToByte(green),
    Color_default.floatToByte(blue),
    Color_default.floatToByte(alpha)
  ]);
}
Object.defineProperties(ColorGeometryInstanceAttribute.prototype, {
  componentDatatype: {
    get: function() {
      return ComponentDatatype_default.UNSIGNED_BYTE;
    }
  },
  componentsPerAttribute: {
    get: function() {
      return 4;
    }
  },
  normalize: {
    get: function() {
      return true;
    }
  }
});
ColorGeometryInstanceAttribute.fromColor = function(color) {
  if (!defined_default(color)) {
    throw new DeveloperError_default("color is required.");
  }
  return new ColorGeometryInstanceAttribute(
    color.red,
    color.green,
    color.blue,
    color.alpha
  );
};
ColorGeometryInstanceAttribute.toValue = function(color, result) {
  if (!defined_default(color)) {
    throw new DeveloperError_default("color is required.");
  }
  if (!defined_default(result)) {
    return new Uint8Array(color.toBytes());
  }
  return color.toBytes(result);
};
ColorGeometryInstanceAttribute.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.value[0] === right.value[0] && left.value[1] === right.value[1] && left.value[2] === right.value[2] && left.value[3] === right.value[3];
};
var ColorGeometryInstanceAttribute_default = ColorGeometryInstanceAttribute;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeometryInstance.js
function GeometryInstance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (!defined_default(options.geometry)) {
    throw new DeveloperError_default("options.geometry is required.");
  }
  this.geometry = options.geometry;
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this.id = options.id;
  this.pickPrimitive = options.pickPrimitive;
  this.attributes = defaultValue_default(options.attributes, {});
  this.westHemisphereGeometry = void 0;
  this.eastHemisphereGeometry = void 0;
}
var GeometryInstance_default = GeometryInstance;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/OffsetGeometryInstanceAttribute.js
function OffsetGeometryInstanceAttribute(x, y, z) {
  x = defaultValue_default(x, 0);
  y = defaultValue_default(y, 0);
  z = defaultValue_default(z, 0);
  this.value = new Float32Array([x, y, z]);
}
Object.defineProperties(OffsetGeometryInstanceAttribute.prototype, {
  componentDatatype: {
    get: function() {
      return ComponentDatatype_default.FLOAT;
    }
  },
  componentsPerAttribute: {
    get: function() {
      return 3;
    }
  },
  normalize: {
    get: function() {
      return false;
    }
  }
});
OffsetGeometryInstanceAttribute.fromCartesian3 = function(offset) {
  Check_default.defined("offset", offset);
  return new OffsetGeometryInstanceAttribute(offset.x, offset.y, offset.z);
};
OffsetGeometryInstanceAttribute.toValue = function(offset, result) {
  Check_default.defined("offset", offset);
  if (!defined_default(result)) {
    result = new Float32Array([offset.x, offset.y, offset.z]);
  }
  result[0] = offset.x;
  result[1] = offset.y;
  result[2] = offset.z;
  return result;
};
var OffsetGeometryInstanceAttribute_default = OffsetGeometryInstanceAttribute;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/BlendEquation.js
var BlendEquation = {
  ADD: WebGLConstants_default.FUNC_ADD,
  SUBTRACT: WebGLConstants_default.FUNC_SUBTRACT,
  REVERSE_SUBTRACT: WebGLConstants_default.FUNC_REVERSE_SUBTRACT,
  MIN: WebGLConstants_default.MIN,
  MAX: WebGLConstants_default.MAX
};
var BlendEquation_default = Object.freeze(BlendEquation);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/BlendFunction.js
var BlendFunction = {
  ZERO: WebGLConstants_default.ZERO,
  ONE: WebGLConstants_default.ONE,
  SOURCE_COLOR: WebGLConstants_default.SRC_COLOR,
  ONE_MINUS_SOURCE_COLOR: WebGLConstants_default.ONE_MINUS_SRC_COLOR,
  DESTINATION_COLOR: WebGLConstants_default.DST_COLOR,
  ONE_MINUS_DESTINATION_COLOR: WebGLConstants_default.ONE_MINUS_DST_COLOR,
  SOURCE_ALPHA: WebGLConstants_default.SRC_ALPHA,
  ONE_MINUS_SOURCE_ALPHA: WebGLConstants_default.ONE_MINUS_SRC_ALPHA,
  DESTINATION_ALPHA: WebGLConstants_default.DST_ALPHA,
  ONE_MINUS_DESTINATION_ALPHA: WebGLConstants_default.ONE_MINUS_DST_ALPHA,
  CONSTANT_COLOR: WebGLConstants_default.CONSTANT_COLOR,
  ONE_MINUS_CONSTANT_COLOR: WebGLConstants_default.ONE_MINUS_CONSTANT_COLOR,
  CONSTANT_ALPHA: WebGLConstants_default.CONSTANT_ALPHA,
  ONE_MINUS_CONSTANT_ALPHA: WebGLConstants_default.ONE_MINUS_CONSTANT_ALPHA,
  SOURCE_ALPHA_SATURATE: WebGLConstants_default.SRC_ALPHA_SATURATE
};
var BlendFunction_default = Object.freeze(BlendFunction);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/BlendingState.js
var BlendingState = {
  DISABLED: Object.freeze({
    enabled: false
  }),
  ALPHA_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.SOURCE_ALPHA,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA,
    functionDestinationAlpha: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA
  }),
  PRE_MULTIPLIED_ALPHA_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.ONE,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA,
    functionDestinationAlpha: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA
  }),
  ADDITIVE_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.SOURCE_ALPHA,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE,
    functionDestinationAlpha: BlendFunction_default.ONE
  })
};
var BlendingState_default = Object.freeze(BlendingState);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/CullFace.js
var CullFace = {
  FRONT: WebGLConstants_default.FRONT,
  BACK: WebGLConstants_default.BACK,
  FRONT_AND_BACK: WebGLConstants_default.FRONT_AND_BACK
};
var CullFace_default = Object.freeze(CullFace);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/Appearance.js
function Appearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.material = options.material;
  this.translucent = defaultValue_default(options.translucent, true);
  this._vertexShaderSource = options.vertexShaderSource;
  this._fragmentShaderSource = options.fragmentShaderSource;
  this._renderState = options.renderState;
  this._closed = defaultValue_default(options.closed, false);
}
Object.defineProperties(Appearance.prototype, {
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  closed: {
    get: function() {
      return this._closed;
    }
  }
});
Appearance.prototype.getFragmentShaderSource = function() {
  const parts = [];
  if (this.flat) {
    parts.push("#define FLAT");
  }
  if (this.faceForward) {
    parts.push("#define FACE_FORWARD");
  }
  if (defined_default(this.material)) {
    parts.push(this.material.shaderSource);
  }
  parts.push(this.fragmentShaderSource);
  return parts.join("\n");
};
Appearance.prototype.isTranslucent = function() {
  return defined_default(this.material) && this.material.isTranslucent() || !defined_default(this.material) && this.translucent;
};
Appearance.prototype.getRenderState = function() {
  const translucent = this.isTranslucent();
  const rs = clone_default(this.renderState, false);
  if (translucent) {
    rs.depthMask = false;
    rs.blending = BlendingState_default.ALPHA_BLEND;
  } else {
    rs.depthMask = true;
  }
  return rs;
};
Appearance.getDefaultRenderState = function(translucent, closed, existing) {
  let rs = {
    depthTest: {
      enabled: true
    }
  };
  if (translucent) {
    rs.depthMask = false;
    rs.blending = BlendingState_default.ALPHA_BLEND;
  }
  if (closed) {
    rs.cull = {
      enabled: true,
      face: CullFace_default.BACK
    };
  }
  if (defined_default(existing)) {
    rs = combine_default(existing, rs, true);
  }
  return rs;
};
var Appearance_default = Appearance;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/AspectRampMaterial.js
var AspectRampMaterial_default = "uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture2D(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/BumpMapMaterial.js
var BumpMapMaterial_default = "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    vec2 centerPixel = fract(repeat * st);\n    float centerBump = texture2D(image, centerPixel).channel;\n\n    float imageWidth = float(imageDimensions.x);\n    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n    float rightBump = texture2D(image, rightPixel).channel;\n\n    float imageHeight = float(imageDimensions.y);\n    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n    float topBump = texture2D(image, leftPixel).channel;\n\n    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n\n    material.normal = normalEC;\n    material.diffuse = vec3(0.01);\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/CheckerboardMaterial.js
var CheckerboardMaterial_default = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\n\n    // Find the distance from the closest separator (region between two colors)\n    float scaledWidth = fract(repeat.s * st.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(repeat.t * st.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n    float value = min(scaledWidth, scaledHeight);\n\n    vec4 currentColor = mix(lightColor, darkColor, b);\n    vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\n\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/DotMaterial.js
var DotMaterial_default = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\n\n    vec4 color = mix(lightColor, darkColor, b);\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/ElevationBandMaterial.js
var ElevationBandMaterial_default = "uniform sampler2D heights;\nuniform sampler2D colors;\n\n// This material expects heights to be sorted from lowest to highest.\n\nfloat getHeight(int idx, float invTexSize)\n{\n    vec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5);\n#ifdef OES_texture_float\n    return texture2D(heights, uv).x;\n#else\n    return czm_unpackFloat(texture2D(heights, uv));\n#endif\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float height = materialInput.height;\n    float invTexSize = 1.0 / float(heightsDimensions.x);\n\n    float minHeight = getHeight(0, invTexSize);\n    float maxHeight = getHeight(heightsDimensions.x - 1, invTexSize);\n\n    // early-out when outside the height range\n    if (height < minHeight || height > maxHeight) {\n        material.diffuse = vec3(0.0);\n        material.alpha = 0.0;\n        return material;\n    }\n\n    // Binary search to find heights above and below.\n    int idxBelow = 0;\n    int idxAbove = heightsDimensions.x;\n    float heightBelow = minHeight;\n    float heightAbove = maxHeight;\n\n    // while loop not allowed, so use for loop with max iterations.\n    // maxIterations of 16 supports a texture size up to 65536 (2^16).\n    const int maxIterations = 16;\n    for (int i = 0; i < maxIterations; i++) {\n        if (idxBelow >= idxAbove - 1) {\n            break;\n        }\n\n        int idxMid = (idxBelow + idxAbove) / 2;\n        float heightTex = getHeight(idxMid, invTexSize);\n\n        if (height > heightTex) {\n            idxBelow = idxMid;\n            heightBelow = heightTex;\n        } else {\n            idxAbove = idxMid;\n            heightAbove = heightTex;\n        }\n    }\n\n    float lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow);\n    vec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5);\n    vec4 color = texture2D(colors, colorUv);\n\n    // undo preumultiplied alpha\n    if (color.a > 0.0) \n    {\n        color.rgb /= color.a;\n    }\n    \n    color.rgb = czm_gammaCorrect(color.rgb);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/ElevationContourMaterial.js
var ElevationContourMaterial_default = "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform vec4 color;\nuniform float spacing;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float distanceToContour = mod(materialInput.height, spacing);\n\n#ifdef GL_OES_standard_derivatives\n    float dxc = abs(dFdx(materialInput.height));\n    float dyc = abs(dFdy(materialInput.height));\n    float dF = max(dxc, dyc) * czm_pixelRatio * width;\n    float alpha = (distanceToContour < dF) ? 1.0 : 0.0;\n#else\n    float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0;\n#endif\n\n    vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a));\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/ElevationRampMaterial.js
var ElevationRampMaterial_default = "uniform sampler2D image;\nuniform float minimumHeight;\nuniform float maximumHeight;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0);\n    vec4 rampColor = texture2D(image, vec2(scaledHeight, 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/FadeMaterial.js
var FadeMaterial_default = "uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\n\nfloat getTime(float t, float coord)\n{\n    float scalar = 1.0 / maximumDistance;\n    float q  = distance(t, coord) * scalar;\n    if (repeat)\n    {\n        float r = distance(t, coord + 1.0) * scalar;\n        float s = distance(t, coord - 1.0) * scalar;\n        q = min(min(r, s), q);\n    }\n    return clamp(q, 0.0, 1.0);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float s = getTime(time.x, st.s) * fadeDirection.s;\n    float t = getTime(time.y, st.t) * fadeDirection.t;\n\n    float u = length(vec2(s, t));\n    vec4 color = mix(fadeInColor, fadeOutColor, u);\n\n    color = czm_gammaCorrect(color);\n    material.emission = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/GridMaterial.js
var GridMaterial_default = '#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nuniform vec2 lineOffset;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n\n    float value;\n#ifdef GL_OES_standard_derivatives\n    // Fuzz Factor - Controls blurriness of lines\n    const float fuzz = 1.2;\n    vec2 thickness = (lineThickness * czm_pixelRatio) - 1.0;\n\n    // From "3D Engine Design for Virtual Globes" by Cozzi and Ring, Listing 4.13.\n    vec2 dx = abs(dFdx(st));\n    vec2 dy = abs(dFdy(st));\n    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\n    value = min(\n        smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\n        smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\n    // Fuzz Factor - Controls blurriness of lines\n    const float fuzz = 0.05;\n\n    vec2 range = 0.5 - (lineThickness * 0.05);\n    value = min(\n        1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n        1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\n\n    // Edges taken from RimLightingMaterial.glsl\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\n    float sRim = smoothstep(0.8, 1.0, dRim);\n    value *= (1.0 - sRim);\n\n    vec4 halfColor;\n    halfColor.rgb = color.rgb * 0.5;\n    halfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value));\n    halfColor = czm_gammaCorrect(halfColor);\n    material.diffuse = halfColor.rgb;\n    material.emission = halfColor.rgb;\n    material.alpha = halfColor.a;\n\n    return material;\n}\n';

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/NormalMapMaterial.js
var NormalMapMaterial_default = "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec4 textureValue = texture2D(image, fract(repeat * materialInput.st));\n    vec3 normalTangentSpace = textureValue.channels;\n    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n    normalTangentSpace = normalize(normalTangentSpace);\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n    \n    material.normal = normalEC;\n    \n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/PolylineArrowMaterial.js
var PolylineArrowMaterial_default = "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform vec4 color;\n\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\n    float slope = (p0.y - p1.y) / (p0.x - p1.x);\n    return slope * (x - p0.x) + p0.y;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n#ifdef GL_OES_standard_derivatives\n    float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio;\n#else\n    float base = 0.975; // 2.5% of the line will be the arrow head\n#endif\n\n    vec2 center = vec2(1.0, 0.5);\n    float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\n    float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\n\n    float halfWidth = 0.15;\n    float s = step(0.5 - halfWidth, st.t);\n    s *= 1.0 - step(0.5 + halfWidth, st.t);\n    s *= 1.0 - step(base, st.s);\n\n    float t = step(base, materialInput.st.s);\n    t *= 1.0 - step(ptOnUpperLine, st.t);\n    t *= step(ptOnLowerLine, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float dist;\n    if (st.s < base)\n    {\n        float d1 = abs(st.t - (0.5 - halfWidth));\n        float d2 = abs(st.t - (0.5 + halfWidth));\n        dist = min(d1, d2);\n    }\n    else\n    {\n        float d1 = czm_infinity;\n        if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n        {\n            d1 = abs(st.s - base);\n        }\n        float d2 = abs(st.t - ptOnUpperLine);\n        float d3 = abs(st.t - ptOnLowerLine);\n        dist = min(min(d1, d2), d3);\n    }\n\n    vec4 outsideColor = vec4(0.0);\n    vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\n    vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\n\n    outColor = czm_gammaCorrect(outColor);\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/PolylineDashMaterial.js
var PolylineDashMaterial_default = "uniform vec4 color;\nuniform vec4 gapColor;\nuniform float dashLength;\nuniform float dashPattern;\nvarying float v_polylineAngle;\n\nconst float maskLength = 16.0;\n\nmat2 rotate(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;\n\n    // Get the relative position within the dash from 0 to 1\n    float dashPosition = fract(pos.x / (dashLength * czm_pixelRatio));\n    // Figure out the mask index.\n    float maskIndex = floor(dashPosition * maskLength);\n    // Test the bit mask.\n    float maskTest = floor(dashPattern / pow(2.0, maskIndex));\n    vec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color;\n    if (fragColor.a < 0.005) {   // matches 0/255 and 1/255\n        discard;\n    }\n\n    fragColor = czm_gammaCorrect(fragColor);\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/PolylineGlowMaterial.js
var PolylineGlowMaterial_default = "uniform vec4 color;\nuniform float glowPower;\nuniform float taperPower;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\n\n    if (taperPower <= 0.99999) {\n        glow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5));\n    }\n\n    vec4 fragColor;\n    fragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb);\n    fragColor.a = clamp(0.0, 1.0, glow) * color.a;\n    fragColor = czm_gammaCorrect(fragColor);\n\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/PolylineOutlineMaterial.js
var PolylineOutlineMaterial_default = "uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\n\nvarying float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\n    float b = step(0.5 - halfInteriorWidth, st.t);\n    b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float d1 = abs(st.t - (0.5 - halfInteriorWidth));\n    float d2 = abs(st.t - (0.5 + halfInteriorWidth));\n    float dist = min(d1, d2);\n\n    vec4 currentColor = mix(outlineColor, color, b);\n    vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\n    outColor = czm_gammaCorrect(outColor);\n\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/RimLightingMaterial.js
var RimLightingMaterial_default = "uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\n    float s = smoothstep(1.0 - width, 1.0, d);\n\n    vec4 outColor = czm_gammaCorrect(color);\n    vec4 outRimColor = czm_gammaCorrect(rimColor);\n\n    material.diffuse = outColor.rgb;\n    material.emission = outRimColor.rgb * s;\n    material.alpha = mix(outColor.a, outRimColor.a, s);\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/SlopeRampMaterial.js
var SlopeRampMaterial_default = "uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture2D(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/StripeMaterial.js
var StripeMaterial_default = "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\n    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n    float value = fract((coord - offset) * (repeat * 0.5));\n    float dist = min(value, min(abs(value - 0.5), 1.0 - value));\n\n    vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\n    vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\n    color = czm_gammaCorrect(color);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Materials/Water.js
var Water_default = "// Thanks for the contribution Jonas\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\nuniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float time = czm_frameNumber * animationSpeed;\n\n    // fade is a function of the distance from the fragment and the frequency of the waves\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n\n    float specularMapValue = texture2D(specularMap, materialInput.st).r;\n\n    // note: not using directional motion at this time, just set the angle to 0.0;\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n\n    // fade out the normal perturbation as we move further from the water surface\n    normalTangentSpace.xy /= fade;\n\n    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n\n    normalTangentSpace = normalize(normalTangentSpace);\n\n    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\n    // fade out water effect as specular map value decreases\n    material.alpha = mix(blendColor.a, baseWaterColor.a, specularMapValue) * specularMapValue;\n\n    // base color is a blend of the water and non-water color based on the value from the specular map\n    // may need a uniform blend factor to better control this\n    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n\n    // diffuse highlights are based on how perturbed the normal is\n    material.diffuse += (0.1 * tsPerturbationRatio);\n\n    material.diffuse = material.diffuse;\n\n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n\n    material.specular = specularIntensity;\n    material.shininess = 10.0;\n\n    return material;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/Material.js
function Material(options) {
  this.type = void 0;
  this.shaderSource = void 0;
  this.materials = void 0;
  this.uniforms = void 0;
  this._uniforms = void 0;
  this.translucent = void 0;
  this._minificationFilter = defaultValue_default(
    options.minificationFilter,
    TextureMinificationFilter_default.LINEAR
  );
  this._magnificationFilter = defaultValue_default(
    options.magnificationFilter,
    TextureMagnificationFilter_default.LINEAR
  );
  this._strict = void 0;
  this._template = void 0;
  this._count = void 0;
  this._texturePaths = {};
  this._loadedImages = [];
  this._loadedCubeMaps = [];
  this._textures = {};
  this._updateFunctions = [];
  this._defaultTexture = void 0;
  initializeMaterial(options, this);
  Object.defineProperties(this, {
    type: {
      value: this.type,
      writable: false
    }
  });
  if (!defined_default(Material._uniformList[this.type])) {
    Material._uniformList[this.type] = Object.keys(this._uniforms);
  }
}
Material._uniformList = {};
Material.fromType = function(type2, uniforms) {
  if (!defined_default(Material._materialCache.getMaterial(type2))) {
    throw new DeveloperError_default(`material with type '${type2}' does not exist.`);
  }
  const material = new Material({
    fabric: {
      type: type2
    }
  });
  if (defined_default(uniforms)) {
    for (const name in uniforms) {
      if (uniforms.hasOwnProperty(name)) {
        material.uniforms[name] = uniforms[name];
      }
    }
  }
  return material;
};
Material.prototype.isTranslucent = function() {
  if (defined_default(this.translucent)) {
    if (typeof this.translucent === "function") {
      return this.translucent();
    }
    return this.translucent;
  }
  let translucent = true;
  const funcs = this._translucentFunctions;
  const length = funcs.length;
  for (let i = 0; i < length; ++i) {
    const func = funcs[i];
    if (typeof func === "function") {
      translucent = translucent && func();
    } else {
      translucent = translucent && func;
    }
    if (!translucent) {
      break;
    }
  }
  return translucent;
};
Material.prototype.update = function(context) {
  this._defaultTexture = context.defaultTexture;
  let i;
  let uniformId;
  const loadedImages = this._loadedImages;
  let length = loadedImages.length;
  for (i = 0; i < length; ++i) {
    const loadedImage = loadedImages[i];
    uniformId = loadedImage.id;
    let image = loadedImage.image;
    let mipLevels;
    if (Array.isArray(image)) {
      mipLevels = image.slice(1, image.length).map(function(mipLevel) {
        return mipLevel.bufferView;
      });
      image = image[0];
    }
    const sampler = new Sampler_default({
      minificationFilter: this._minificationFilter,
      magnificationFilter: this._magnificationFilter
    });
    let texture;
    if (defined_default(image.internalFormat)) {
      texture = new Texture_default({
        context,
        pixelFormat: image.internalFormat,
        width: image.width,
        height: image.height,
        source: {
          arrayBufferView: image.bufferView,
          mipLevels
        },
        sampler
      });
    } else {
      texture = new Texture_default({
        context,
        source: image,
        sampler
      });
    }
    const oldTexture = this._textures[uniformId];
    if (defined_default(oldTexture) && oldTexture !== this._defaultTexture) {
      oldTexture.destroy();
    }
    this._textures[uniformId] = texture;
    const uniformDimensionsName = `${uniformId}Dimensions`;
    if (this.uniforms.hasOwnProperty(uniformDimensionsName)) {
      const uniformDimensions = this.uniforms[uniformDimensionsName];
      uniformDimensions.x = texture._width;
      uniformDimensions.y = texture._height;
    }
  }
  loadedImages.length = 0;
  const loadedCubeMaps = this._loadedCubeMaps;
  length = loadedCubeMaps.length;
  for (i = 0; i < length; ++i) {
    const loadedCubeMap = loadedCubeMaps[i];
    uniformId = loadedCubeMap.id;
    const images = loadedCubeMap.images;
    const cubeMap = new CubeMap_default({
      context,
      source: {
        positiveX: images[0],
        negativeX: images[1],
        positiveY: images[2],
        negativeY: images[3],
        positiveZ: images[4],
        negativeZ: images[5]
      },
      sampler: new Sampler_default({
        minificationFilter: this._minificationFilter,
        magnificationFilter: this._magnificationFilter
      })
    });
    this._textures[uniformId] = cubeMap;
  }
  loadedCubeMaps.length = 0;
  const updateFunctions = this._updateFunctions;
  length = updateFunctions.length;
  for (i = 0; i < length; ++i) {
    updateFunctions[i](this, context);
  }
  const subMaterials = this.materials;
  for (const name in subMaterials) {
    if (subMaterials.hasOwnProperty(name)) {
      subMaterials[name].update(context);
    }
  }
};
Material.prototype.isDestroyed = function() {
  return false;
};
Material.prototype.destroy = function() {
  const textures = this._textures;
  for (const texture in textures) {
    if (textures.hasOwnProperty(texture)) {
      const instance = textures[texture];
      if (instance !== this._defaultTexture) {
        instance.destroy();
      }
    }
  }
  const materials = this.materials;
  for (const material in materials) {
    if (materials.hasOwnProperty(material)) {
      materials[material].destroy();
    }
  }
  return destroyObject_default(this);
};
function initializeMaterial(options, result) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  result._strict = defaultValue_default(options.strict, false);
  result._count = defaultValue_default(options.count, 0);
  result._template = clone_default(
    defaultValue_default(options.fabric, defaultValue_default.EMPTY_OBJECT)
  );
  result._template.uniforms = clone_default(
    defaultValue_default(result._template.uniforms, defaultValue_default.EMPTY_OBJECT)
  );
  result._template.materials = clone_default(
    defaultValue_default(result._template.materials, defaultValue_default.EMPTY_OBJECT)
  );
  result.type = defined_default(result._template.type) ? result._template.type : createGuid_default();
  result.shaderSource = "";
  result.materials = {};
  result.uniforms = {};
  result._uniforms = {};
  result._translucentFunctions = [];
  let translucent;
  const cachedMaterial = Material._materialCache.getMaterial(result.type);
  if (defined_default(cachedMaterial)) {
    const template = clone_default(cachedMaterial.fabric, true);
    result._template = combine_default(result._template, template, true);
    translucent = cachedMaterial.translucent;
  }
  checkForTemplateErrors(result);
  if (!defined_default(cachedMaterial)) {
    Material._materialCache.addMaterial(result.type, result);
  }
  createMethodDefinition(result);
  createUniforms(result);
  createSubMaterials(result);
  const defaultTranslucent = result._translucentFunctions.length === 0 ? true : void 0;
  translucent = defaultValue_default(translucent, defaultTranslucent);
  translucent = defaultValue_default(options.translucent, translucent);
  if (defined_default(translucent)) {
    if (typeof translucent === "function") {
      const wrappedTranslucent = function() {
        return translucent(result);
      };
      result._translucentFunctions.push(wrappedTranslucent);
    } else {
      result._translucentFunctions.push(translucent);
    }
  }
}
function checkForValidProperties(object, properties, result, throwNotFound) {
  if (defined_default(object)) {
    for (const property in object) {
      if (object.hasOwnProperty(property)) {
        const hasProperty = properties.indexOf(property) !== -1;
        if (throwNotFound && !hasProperty || !throwNotFound && hasProperty) {
          result(property, properties);
        }
      }
    }
  }
}
function invalidNameError(property, properties) {
  let errorString = `fabric: property name '${property}' is not valid. It should be `;
  for (let i = 0; i < properties.length; i++) {
    const propertyName = `'${properties[i]}'`;
    errorString += i === properties.length - 1 ? `or ${propertyName}.` : `${propertyName}, `;
  }
  throw new DeveloperError_default(errorString);
}
function duplicateNameError(property, properties) {
  const errorString = `fabric: uniforms and materials cannot share the same property '${property}'`;
  throw new DeveloperError_default(errorString);
}
var templateProperties = [
  "type",
  "materials",
  "uniforms",
  "components",
  "source"
];
var componentProperties = [
  "diffuse",
  "specular",
  "shininess",
  "normal",
  "emission",
  "alpha"
];
function checkForTemplateErrors(material) {
  const template = material._template;
  const uniforms = template.uniforms;
  const materials = template.materials;
  const components = template.components;
  if (defined_default(components) && defined_default(template.source)) {
    throw new DeveloperError_default(
      "fabric: cannot have source and components in the same template."
    );
  }
  checkForValidProperties(template, templateProperties, invalidNameError, true);
  checkForValidProperties(
    components,
    componentProperties,
    invalidNameError,
    true
  );
  const materialNames = [];
  for (const property in materials) {
    if (materials.hasOwnProperty(property)) {
      materialNames.push(property);
    }
  }
  checkForValidProperties(uniforms, materialNames, duplicateNameError, false);
}
function isMaterialFused(shaderComponent, material) {
  const materials = material._template.materials;
  for (const subMaterialId in materials) {
    if (materials.hasOwnProperty(subMaterialId)) {
      if (shaderComponent.indexOf(subMaterialId) > -1) {
        return true;
      }
    }
  }
  return false;
}
function createMethodDefinition(material) {
  const components = material._template.components;
  const source = material._template.source;
  if (defined_default(source)) {
    material.shaderSource += `${source}
`;
  } else {
    material.shaderSource += "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n";
    material.shaderSource += "czm_material material = czm_getDefaultMaterial(materialInput);\n";
    if (defined_default(components)) {
      const isMultiMaterial = Object.keys(material._template.materials).length > 0;
      for (const component in components) {
        if (components.hasOwnProperty(component)) {
          if (component === "diffuse" || component === "emission") {
            const isFusion = isMultiMaterial && isMaterialFused(components[component], material);
            const componentSource = isFusion ? components[component] : `czm_gammaCorrect(${components[component]})`;
            material.shaderSource += `material.${component} = ${componentSource}; 
`;
          } else if (component === "alpha") {
            material.shaderSource += `material.alpha = ${components.alpha}; 
`;
          } else {
            material.shaderSource += `material.${component} = ${components[component]};
`;
          }
        }
      }
    }
    material.shaderSource += "return material;\n}\n";
  }
}
var matrixMap = {
  mat2: Matrix2_default,
  mat3: Matrix3_default,
  mat4: Matrix4_default
};
var ktx2Regex = /\.ktx2$/i;
function createTexture2DUpdateFunction(uniformId) {
  let oldUniformValue;
  return function(material, context) {
    const uniforms = material.uniforms;
    const uniformValue = uniforms[uniformId];
    const uniformChanged = oldUniformValue !== uniformValue;
    const uniformValueIsDefaultImage = !defined_default(uniformValue) || uniformValue === Material.DefaultImageId;
    oldUniformValue = uniformValue;
    let texture = material._textures[uniformId];
    let uniformDimensionsName;
    let uniformDimensions;
    if (uniformValue instanceof HTMLVideoElement) {
      if (uniformValue.readyState >= 2) {
        if (uniformChanged && defined_default(texture)) {
          if (texture !== context.defaultTexture) {
            texture.destroy();
          }
          texture = void 0;
        }
        if (!defined_default(texture) || texture === context.defaultTexture) {
          const sampler = new Sampler_default({
            minificationFilter: material._minificationFilter,
            magnificationFilter: material._magnificationFilter
          });
          texture = new Texture_default({
            context,
            source: uniformValue,
            sampler
          });
          material._textures[uniformId] = texture;
          return;
        }
        texture.copyFrom({
          source: uniformValue
        });
      } else if (!defined_default(texture)) {
        material._textures[uniformId] = context.defaultTexture;
      }
      return;
    }
    if (uniformValue instanceof Texture_default && uniformValue !== texture) {
      material._texturePaths[uniformId] = void 0;
      const tmp2 = material._textures[uniformId];
      if (defined_default(tmp2) && tmp2 !== material._defaultTexture) {
        tmp2.destroy();
      }
      material._textures[uniformId] = uniformValue;
      uniformDimensionsName = `${uniformId}Dimensions`;
      if (uniforms.hasOwnProperty(uniformDimensionsName)) {
        uniformDimensions = uniforms[uniformDimensionsName];
        uniformDimensions.x = uniformValue._width;
        uniformDimensions.y = uniformValue._height;
      }
      return;
    }
    if (uniformChanged && defined_default(texture) && uniformValueIsDefaultImage) {
      if (texture !== material._defaultTexture) {
        texture.destroy();
      }
      texture = void 0;
    }
    if (!defined_default(texture)) {
      material._texturePaths[uniformId] = void 0;
      texture = material._textures[uniformId] = material._defaultTexture;
      uniformDimensionsName = `${uniformId}Dimensions`;
      if (uniforms.hasOwnProperty(uniformDimensionsName)) {
        uniformDimensions = uniforms[uniformDimensionsName];
        uniformDimensions.x = texture._width;
        uniformDimensions.y = texture._height;
      }
    }
    if (uniformValueIsDefaultImage) {
      return;
    }
    const isResource = uniformValue instanceof Resource_default;
    if (!defined_default(material._texturePaths[uniformId]) || isResource && uniformValue.url !== material._texturePaths[uniformId].url || !isResource && uniformValue !== material._texturePaths[uniformId]) {
      if (typeof uniformValue === "string" || isResource) {
        const resource = isResource ? uniformValue : Resource_default.createIfNeeded(uniformValue);
        let promise;
        if (ktx2Regex.test(resource.url)) {
          promise = loadKTX2_default(resource.url);
        } else {
          promise = resource.fetchImage();
        }
        Promise.resolve(promise).then(function(image) {
          material._loadedImages.push({
            id: uniformId,
            image
          });
        }).catch(function() {
          if (defined_default(texture) && texture !== material._defaultTexture) {
            texture.destroy();
          }
          material._textures[uniformId] = material._defaultTexture;
        });
      } else if (uniformValue instanceof HTMLCanvasElement || uniformValue instanceof HTMLImageElement) {
        material._loadedImages.push({
          id: uniformId,
          image: uniformValue
        });
      }
      material._texturePaths[uniformId] = uniformValue;
    }
  };
}
function createCubeMapUpdateFunction(uniformId) {
  return function(material, context) {
    const uniformValue = material.uniforms[uniformId];
    if (uniformValue instanceof CubeMap_default) {
      const tmp2 = material._textures[uniformId];
      if (tmp2 !== material._defaultTexture) {
        tmp2.destroy();
      }
      material._texturePaths[uniformId] = void 0;
      material._textures[uniformId] = uniformValue;
      return;
    }
    if (!defined_default(material._textures[uniformId])) {
      material._texturePaths[uniformId] = void 0;
      material._textures[uniformId] = context.defaultCubeMap;
    }
    if (uniformValue === Material.DefaultCubeMapId) {
      return;
    }
    const path = uniformValue.positiveX + uniformValue.negativeX + uniformValue.positiveY + uniformValue.negativeY + uniformValue.positiveZ + uniformValue.negativeZ;
    if (path !== material._texturePaths[uniformId]) {
      const promises = [
        Resource_default.createIfNeeded(uniformValue.positiveX).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeX).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.positiveY).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeY).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.positiveZ).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeZ).fetchImage()
      ];
      Promise.all(promises).then(function(images) {
        material._loadedCubeMaps.push({
          id: uniformId,
          images
        });
      });
      material._texturePaths[uniformId] = path;
    }
  };
}
function createUniforms(material) {
  const uniforms = material._template.uniforms;
  for (const uniformId in uniforms) {
    if (uniforms.hasOwnProperty(uniformId)) {
      createUniform2(material, uniformId);
    }
  }
}
function createUniform2(material, uniformId) {
  const strict = material._strict;
  const materialUniforms = material._template.uniforms;
  const uniformValue = materialUniforms[uniformId];
  const uniformType = getUniformType(uniformValue);
  if (!defined_default(uniformType)) {
    throw new DeveloperError_default(
      `fabric: uniform '${uniformId}' has invalid type.`
    );
  }
  let replacedTokenCount;
  if (uniformType === "channels") {
    replacedTokenCount = replaceToken(material, uniformId, uniformValue, false);
    if (replacedTokenCount === 0 && strict) {
      throw new DeveloperError_default(
        `strict: shader source does not use channels '${uniformId}'.`
      );
    }
  } else {
    if (uniformType === "sampler2D") {
      const imageDimensionsUniformName = `${uniformId}Dimensions`;
      if (getNumberOfTokens(material, imageDimensionsUniformName) > 0) {
        materialUniforms[imageDimensionsUniformName] = {
          type: "ivec3",
          x: 1,
          y: 1
        };
        createUniform2(material, imageDimensionsUniformName);
      }
    }
    const uniformDeclarationRegex = new RegExp(
      `uniform\\s+${uniformType}\\s+${uniformId}\\s*;`
    );
    if (!uniformDeclarationRegex.test(material.shaderSource)) {
      const uniformDeclaration = `uniform ${uniformType} ${uniformId};`;
      material.shaderSource = uniformDeclaration + material.shaderSource;
    }
    const newUniformId = `${uniformId}_${material._count++}`;
    replacedTokenCount = replaceToken(material, uniformId, newUniformId);
    if (replacedTokenCount === 1 && strict) {
      throw new DeveloperError_default(
        `strict: shader source does not use uniform '${uniformId}'.`
      );
    }
    material.uniforms[uniformId] = uniformValue;
    if (uniformType === "sampler2D") {
      material._uniforms[newUniformId] = function() {
        return material._textures[uniformId];
      };
      material._updateFunctions.push(createTexture2DUpdateFunction(uniformId));
    } else if (uniformType === "samplerCube") {
      material._uniforms[newUniformId] = function() {
        return material._textures[uniformId];
      };
      material._updateFunctions.push(createCubeMapUpdateFunction(uniformId));
    } else if (uniformType.indexOf("mat") !== -1) {
      const scratchMatrix = new matrixMap[uniformType]();
      material._uniforms[newUniformId] = function() {
        return matrixMap[uniformType].fromColumnMajorArray(
          material.uniforms[uniformId],
          scratchMatrix
        );
      };
    } else {
      material._uniforms[newUniformId] = function() {
        return material.uniforms[uniformId];
      };
    }
  }
}
function getUniformType(uniformValue) {
  let uniformType = uniformValue.type;
  if (!defined_default(uniformType)) {
    const type2 = typeof uniformValue;
    if (type2 === "number") {
      uniformType = "float";
    } else if (type2 === "boolean") {
      uniformType = "bool";
    } else if (type2 === "string" || uniformValue instanceof Resource_default || uniformValue instanceof HTMLCanvasElement || uniformValue instanceof HTMLImageElement) {
      if (/^([rgba]){1,4}$/i.test(uniformValue)) {
        uniformType = "channels";
      } else if (uniformValue === Material.DefaultCubeMapId) {
        uniformType = "samplerCube";
      } else {
        uniformType = "sampler2D";
      }
    } else if (type2 === "object") {
      if (Array.isArray(uniformValue)) {
        if (uniformValue.length === 4 || uniformValue.length === 9 || uniformValue.length === 16) {
          uniformType = `mat${Math.sqrt(uniformValue.length)}`;
        }
      } else {
        let numAttributes = 0;
        for (const attribute in uniformValue) {
          if (uniformValue.hasOwnProperty(attribute)) {
            numAttributes += 1;
          }
        }
        if (numAttributes >= 2 && numAttributes <= 4) {
          uniformType = `vec${numAttributes}`;
        } else if (numAttributes === 6) {
          uniformType = "samplerCube";
        }
      }
    }
  }
  return uniformType;
}
function createSubMaterials(material) {
  const strict = material._strict;
  const subMaterialTemplates = material._template.materials;
  for (const subMaterialId in subMaterialTemplates) {
    if (subMaterialTemplates.hasOwnProperty(subMaterialId)) {
      const subMaterial = new Material({
        strict,
        fabric: subMaterialTemplates[subMaterialId],
        count: material._count
      });
      material._count = subMaterial._count;
      material._uniforms = combine_default(
        material._uniforms,
        subMaterial._uniforms,
        true
      );
      material.materials[subMaterialId] = subMaterial;
      material._translucentFunctions = material._translucentFunctions.concat(
        subMaterial._translucentFunctions
      );
      const originalMethodName = "czm_getMaterial";
      const newMethodName = `${originalMethodName}_${material._count++}`;
      replaceToken(subMaterial, originalMethodName, newMethodName);
      material.shaderSource = subMaterial.shaderSource + material.shaderSource;
      const materialMethodCall = `${newMethodName}(materialInput)`;
      const tokensReplacedCount = replaceToken(
        material,
        subMaterialId,
        materialMethodCall
      );
      if (tokensReplacedCount === 0 && strict) {
        throw new DeveloperError_default(
          `strict: shader source does not use material '${subMaterialId}'.`
        );
      }
    }
  }
}
function replaceToken(material, token, newToken, excludePeriod) {
  excludePeriod = defaultValue_default(excludePeriod, true);
  let count = 0;
  const suffixChars = "([\\w])?";
  const prefixChars = `([\\w${excludePeriod ? "." : ""}])?`;
  const regExp = new RegExp(prefixChars + token + suffixChars, "g");
  material.shaderSource = material.shaderSource.replace(regExp, function($0, $1, $2) {
    if ($1 || $2) {
      return $0;
    }
    count += 1;
    return newToken;
  });
  return count;
}
function getNumberOfTokens(material, token, excludePeriod) {
  return replaceToken(material, token, token, excludePeriod);
}
Material._materialCache = {
  _materials: {},
  addMaterial: function(type2, materialTemplate) {
    this._materials[type2] = materialTemplate;
  },
  getMaterial: function(type2) {
    return this._materials[type2];
  }
};
Material.DefaultImageId = "czm_defaultImage";
Material.DefaultCubeMapId = "czm_defaultCubeMap";
Material.ColorType = "Color";
Material._materialCache.addMaterial(Material.ColorType, {
  fabric: {
    type: Material.ColorType,
    uniforms: {
      color: new Color_default(1, 0, 0, 0.5)
    },
    components: {
      diffuse: "color.rgb",
      alpha: "color.a"
    }
  },
  translucent: function(material) {
    return material.uniforms.color.alpha < 1;
  }
});
Material.ImageType = "Image";
Material._materialCache.addMaterial(Material.ImageType, {
  fabric: {
    type: Material.ImageType,
    uniforms: {
      image: Material.DefaultImageId,
      repeat: new Cartesian2_default(1, 1),
      color: new Color_default(1, 1, 1, 1)
    },
    components: {
      diffuse: "texture2D(image, fract(repeat * materialInput.st)).rgb * color.rgb",
      alpha: "texture2D(image, fract(repeat * materialInput.st)).a * color.a"
    }
  },
  translucent: function(material) {
    return material.uniforms.color.alpha < 1;
  }
});
Material.DiffuseMapType = "DiffuseMap";
Material._materialCache.addMaterial(Material.DiffuseMapType, {
  fabric: {
    type: Material.DiffuseMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      diffuse: "texture2D(image, fract(repeat * materialInput.st)).channels"
    }
  },
  translucent: false
});
Material.AlphaMapType = "AlphaMap";
Material._materialCache.addMaterial(Material.AlphaMapType, {
  fabric: {
    type: Material.AlphaMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "a",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      alpha: "texture2D(image, fract(repeat * materialInput.st)).channel"
    }
  },
  translucent: true
});
Material.SpecularMapType = "SpecularMap";
Material._materialCache.addMaterial(Material.SpecularMapType, {
  fabric: {
    type: Material.SpecularMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "r",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      specular: "texture2D(image, fract(repeat * materialInput.st)).channel"
    }
  },
  translucent: false
});
Material.EmissionMapType = "EmissionMap";
Material._materialCache.addMaterial(Material.EmissionMapType, {
  fabric: {
    type: Material.EmissionMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      emission: "texture2D(image, fract(repeat * materialInput.st)).channels"
    }
  },
  translucent: false
});
Material.BumpMapType = "BumpMap";
Material._materialCache.addMaterial(Material.BumpMapType, {
  fabric: {
    type: Material.BumpMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "r",
      strength: 0.8,
      repeat: new Cartesian2_default(1, 1)
    },
    source: BumpMapMaterial_default
  },
  translucent: false
});
Material.NormalMapType = "NormalMap";
Material._materialCache.addMaterial(Material.NormalMapType, {
  fabric: {
    type: Material.NormalMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      strength: 0.8,
      repeat: new Cartesian2_default(1, 1)
    },
    source: NormalMapMaterial_default
  },
  translucent: false
});
Material.GridType = "Grid";
Material._materialCache.addMaterial(Material.GridType, {
  fabric: {
    type: Material.GridType,
    uniforms: {
      color: new Color_default(0, 1, 0, 1),
      cellAlpha: 0.1,
      lineCount: new Cartesian2_default(8, 8),
      lineThickness: new Cartesian2_default(1, 1),
      lineOffset: new Cartesian2_default(0, 0)
    },
    source: GridMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.cellAlpha < 1;
  }
});
Material.StripeType = "Stripe";
Material._materialCache.addMaterial(Material.StripeType, {
  fabric: {
    type: Material.StripeType,
    uniforms: {
      horizontal: true,
      evenColor: new Color_default(1, 1, 1, 0.5),
      oddColor: new Color_default(0, 0, 1, 0.5),
      offset: 0,
      repeat: 5
    },
    source: StripeMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.evenColor.alpha < 1 || uniforms.oddColor.alpha < 1;
  }
});
Material.CheckerboardType = "Checkerboard";
Material._materialCache.addMaterial(Material.CheckerboardType, {
  fabric: {
    type: Material.CheckerboardType,
    uniforms: {
      lightColor: new Color_default(1, 1, 1, 0.5),
      darkColor: new Color_default(0, 0, 0, 0.5),
      repeat: new Cartesian2_default(5, 5)
    },
    source: CheckerboardMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 1;
  }
});
Material.DotType = "Dot";
Material._materialCache.addMaterial(Material.DotType, {
  fabric: {
    type: Material.DotType,
    uniforms: {
      lightColor: new Color_default(1, 1, 0, 0.75),
      darkColor: new Color_default(0, 1, 1, 0.75),
      repeat: new Cartesian2_default(5, 5)
    },
    source: DotMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 1;
  }
});
Material.WaterType = "Water";
Material._materialCache.addMaterial(Material.WaterType, {
  fabric: {
    type: Material.WaterType,
    uniforms: {
      baseWaterColor: new Color_default(0.2, 0.3, 0.6, 1),
      blendColor: new Color_default(0, 1, 0.699, 1),
      specularMap: Material.DefaultImageId,
      normalMap: Material.DefaultImageId,
      frequency: 10,
      animationSpeed: 0.01,
      amplitude: 1,
      specularIntensity: 0.5,
      fadeFactor: 1
    },
    source: Water_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.baseWaterColor.alpha < 1 || uniforms.blendColor.alpha < 1;
  }
});
Material.RimLightingType = "RimLighting";
Material._materialCache.addMaterial(Material.RimLightingType, {
  fabric: {
    type: Material.RimLightingType,
    uniforms: {
      color: new Color_default(1, 0, 0, 0.7),
      rimColor: new Color_default(1, 1, 1, 0.4),
      width: 0.3
    },
    source: RimLightingMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.rimColor.alpha < 1;
  }
});
Material.FadeType = "Fade";
Material._materialCache.addMaterial(Material.FadeType, {
  fabric: {
    type: Material.FadeType,
    uniforms: {
      fadeInColor: new Color_default(1, 0, 0, 1),
      fadeOutColor: new Color_default(0, 0, 0, 0),
      maximumDistance: 0.5,
      repeat: true,
      fadeDirection: {
        x: true,
        y: true
      },
      time: new Cartesian2_default(0.5, 0.5)
    },
    source: FadeMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.fadeInColor.alpha < 1 || uniforms.fadeOutColor.alpha < 1;
  }
});
Material.PolylineArrowType = "PolylineArrow";
Material._materialCache.addMaterial(Material.PolylineArrowType, {
  fabric: {
    type: Material.PolylineArrowType,
    uniforms: {
      color: new Color_default(1, 1, 1, 1)
    },
    source: PolylineArrowMaterial_default
  },
  translucent: true
});
Material.PolylineDashType = "PolylineDash";
Material._materialCache.addMaterial(Material.PolylineDashType, {
  fabric: {
    type: Material.PolylineDashType,
    uniforms: {
      color: new Color_default(1, 0, 1, 1),
      gapColor: new Color_default(0, 0, 0, 0),
      dashLength: 16,
      dashPattern: 255
    },
    source: PolylineDashMaterial_default
  },
  translucent: true
});
Material.PolylineGlowType = "PolylineGlow";
Material._materialCache.addMaterial(Material.PolylineGlowType, {
  fabric: {
    type: Material.PolylineGlowType,
    uniforms: {
      color: new Color_default(0, 0.5, 1, 1),
      glowPower: 0.25,
      taperPower: 1
    },
    source: PolylineGlowMaterial_default
  },
  translucent: true
});
Material.PolylineOutlineType = "PolylineOutline";
Material._materialCache.addMaterial(Material.PolylineOutlineType, {
  fabric: {
    type: Material.PolylineOutlineType,
    uniforms: {
      color: new Color_default(1, 1, 1, 1),
      outlineColor: new Color_default(1, 0, 0, 1),
      outlineWidth: 1
    },
    source: PolylineOutlineMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.outlineColor.alpha < 1;
  }
});
Material.ElevationContourType = "ElevationContour";
Material._materialCache.addMaterial(Material.ElevationContourType, {
  fabric: {
    type: Material.ElevationContourType,
    uniforms: {
      spacing: 100,
      color: new Color_default(1, 0, 0, 1),
      width: 1
    },
    source: ElevationContourMaterial_default
  },
  translucent: false
});
Material.ElevationRampType = "ElevationRamp";
Material._materialCache.addMaterial(Material.ElevationRampType, {
  fabric: {
    type: Material.ElevationRampType,
    uniforms: {
      image: Material.DefaultImageId,
      minimumHeight: 0,
      maximumHeight: 1e4
    },
    source: ElevationRampMaterial_default
  },
  translucent: false
});
Material.SlopeRampMaterialType = "SlopeRamp";
Material._materialCache.addMaterial(Material.SlopeRampMaterialType, {
  fabric: {
    type: Material.SlopeRampMaterialType,
    uniforms: {
      image: Material.DefaultImageId
    },
    source: SlopeRampMaterial_default
  },
  translucent: false
});
Material.AspectRampMaterialType = "AspectRamp";
Material._materialCache.addMaterial(Material.AspectRampMaterialType, {
  fabric: {
    type: Material.AspectRampMaterialType,
    uniforms: {
      image: Material.DefaultImageId
    },
    source: AspectRampMaterial_default
  },
  translucent: false
});
Material.ElevationBandType = "ElevationBand";
Material._materialCache.addMaterial(Material.ElevationBandType, {
  fabric: {
    type: Material.ElevationBandType,
    uniforms: {
      heights: Material.DefaultImageId,
      colors: Material.DefaultImageId
    },
    source: ElevationBandMaterial_default
  },
  translucent: true
});
var Material_default = Material;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Appearances/PerInstanceColorAppearanceFS.js
var PerInstanceColorAppearanceFS_default = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    vec4 color = czm_gammaCorrect(v_color);\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Appearances/PerInstanceColorAppearanceVS.js
var PerInstanceColorAppearanceVS_default = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Appearances/PerInstanceFlatColorAppearanceFS.js
var PerInstanceFlatColorAppearanceFS_default = "varying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = czm_gammaCorrect(v_color);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Appearances/PerInstanceFlatColorAppearanceVS.js
var PerInstanceFlatColorAppearanceVS_default = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/PerInstanceColorAppearance.js
function PerInstanceColorAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = defaultValue_default(options.closed, false);
  const flat = defaultValue_default(options.flat, false);
  const vs = flat ? PerInstanceFlatColorAppearanceVS_default : PerInstanceColorAppearanceVS_default;
  const fs = flat ? PerInstanceFlatColorAppearanceFS_default : PerInstanceColorAppearanceFS_default;
  const vertexFormat = flat ? PerInstanceColorAppearance.FLAT_VERTEX_FORMAT : PerInstanceColorAppearance.VERTEX_FORMAT;
  this.material = void 0;
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(options.vertexShaderSource, vs);
  this._fragmentShaderSource = defaultValue_default(options.fragmentShaderSource, fs);
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
  this._flat = flat;
  this._faceForward = defaultValue_default(options.faceForward, !closed);
}
Object.defineProperties(PerInstanceColorAppearance.prototype, {
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  closed: {
    get: function() {
      return this._closed;
    }
  },
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  },
  flat: {
    get: function() {
      return this._flat;
    }
  },
  faceForward: {
    get: function() {
      return this._faceForward;
    }
  }
});
PerInstanceColorAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_AND_NORMAL;
PerInstanceColorAppearance.FLAT_VERTEX_FORMAT = VertexFormat_default.POSITION_ONLY;
PerInstanceColorAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PerInstanceColorAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PerInstanceColorAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PerInstanceColorAppearance_default = PerInstanceColorAppearance;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/ColorMaterialProperty.js
function ColorMaterialProperty(color) {
  this._definitionChanged = new Event_default();
  this._color = void 0;
  this._colorSubscription = void 0;
  this.color = color;
}
Object.defineProperties(ColorMaterialProperty.prototype, {
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._color);
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  color: createPropertyDescriptor_default("color")
});
ColorMaterialProperty.prototype.getType = function(time) {
  return "Color";
};
ColorMaterialProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = {};
  }
  result.color = Property_default.getValueOrClonedDefault(
    this._color,
    time,
    Color_default.WHITE,
    result.color
  );
  return result;
};
ColorMaterialProperty.prototype.equals = function(other) {
  return this === other || other instanceof ColorMaterialProperty && Property_default.equals(this._color, other._color);
};
var ColorMaterialProperty_default = ColorMaterialProperty;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeographicTilingScheme.js
function GeographicTilingScheme(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._ellipsoid = defaultValue_default(options.ellipsoid, Ellipsoid_default.WGS84);
  this._rectangle = defaultValue_default(options.rectangle, Rectangle_default.MAX_VALUE);
  this._projection = new GeographicProjection_default(this._ellipsoid);
  this._numberOfLevelZeroTilesX = defaultValue_default(
    options.numberOfLevelZeroTilesX,
    2
  );
  this._numberOfLevelZeroTilesY = defaultValue_default(
    options.numberOfLevelZeroTilesY,
    1
  );
}
Object.defineProperties(GeographicTilingScheme.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  rectangle: {
    get: function() {
      return this._rectangle;
    }
  },
  projection: {
    get: function() {
      return this._projection;
    }
  }
});
GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {
  return this._numberOfLevelZeroTilesX << level;
};
GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {
  return this._numberOfLevelZeroTilesY << level;
};
GeographicTilingScheme.prototype.rectangleToNativeRectangle = function(rectangle, result) {
  Check_default.defined("rectangle", rectangle);
  const west = Math_default.toDegrees(rectangle.west);
  const south = Math_default.toDegrees(rectangle.south);
  const east = Math_default.toDegrees(rectangle.east);
  const north = Math_default.toDegrees(rectangle.north);
  if (!defined_default(result)) {
    return new Rectangle_default(west, south, east, north);
  }
  result.west = west;
  result.south = south;
  result.east = east;
  result.north = north;
  return result;
};
GeographicTilingScheme.prototype.tileXYToNativeRectangle = function(x, y, level, result) {
  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);
  rectangleRadians.west = Math_default.toDegrees(rectangleRadians.west);
  rectangleRadians.south = Math_default.toDegrees(rectangleRadians.south);
  rectangleRadians.east = Math_default.toDegrees(rectangleRadians.east);
  rectangleRadians.north = Math_default.toDegrees(rectangleRadians.north);
  return rectangleRadians;
};
GeographicTilingScheme.prototype.tileXYToRectangle = function(x, y, level, result) {
  const rectangle = this._rectangle;
  const xTiles = this.getNumberOfXTilesAtLevel(level);
  const yTiles = this.getNumberOfYTilesAtLevel(level);
  const xTileWidth = rectangle.width / xTiles;
  const west = x * xTileWidth + rectangle.west;
  const east = (x + 1) * xTileWidth + rectangle.west;
  const yTileHeight = rectangle.height / yTiles;
  const north = rectangle.north - y * yTileHeight;
  const south = rectangle.north - (y + 1) * yTileHeight;
  if (!defined_default(result)) {
    result = new Rectangle_default(west, south, east, north);
  }
  result.west = west;
  result.south = south;
  result.east = east;
  result.north = north;
  return result;
};
GeographicTilingScheme.prototype.positionToTileXY = function(position, level, result) {
  const rectangle = this._rectangle;
  if (!Rectangle_default.contains(rectangle, position)) {
    return void 0;
  }
  const xTiles = this.getNumberOfXTilesAtLevel(level);
  const yTiles = this.getNumberOfYTilesAtLevel(level);
  const xTileWidth = rectangle.width / xTiles;
  const yTileHeight = rectangle.height / yTiles;
  let longitude = position.longitude;
  if (rectangle.east < rectangle.west) {
    longitude += Math_default.TWO_PI;
  }
  let xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;
  if (xTileCoordinate >= xTiles) {
    xTileCoordinate = xTiles - 1;
  }
  let yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;
  if (yTileCoordinate >= yTiles) {
    yTileCoordinate = yTiles - 1;
  }
  if (!defined_default(result)) {
    return new Cartesian2_default(xTileCoordinate, yTileCoordinate);
  }
  result.x = xTileCoordinate;
  result.y = yTileCoordinate;
  return result;
};
var GeographicTilingScheme_default = GeographicTilingScheme;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/ApproximateTerrainHeights.js
var scratchDiagonalCartesianNE = new Cartesian3_default();
var scratchDiagonalCartesianSW = new Cartesian3_default();
var scratchDiagonalCartographic = new Cartographic_default();
var scratchCenterCartesian = new Cartesian3_default();
var scratchSurfaceCartesian = new Cartesian3_default();
var scratchBoundingSphere = new BoundingSphere_default();
var tilingScheme = new GeographicTilingScheme_default();
var scratchCorners = [
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default()
];
var scratchTileXY = new Cartesian2_default();
var ApproximateTerrainHeights = {};
ApproximateTerrainHeights.initialize = function() {
  let initPromise = ApproximateTerrainHeights._initPromise;
  if (defined_default(initPromise)) {
    return initPromise;
  }
  initPromise = Resource_default.fetchJson(
    buildModuleUrl_default("Assets/approximateTerrainHeights.json")
  ).then(function(json) {
    ApproximateTerrainHeights._terrainHeights = json;
  });
  ApproximateTerrainHeights._initPromise = initPromise;
  return initPromise;
};
ApproximateTerrainHeights.getMinimumMaximumHeights = function(rectangle, ellipsoid) {
  Check_default.defined("rectangle", rectangle);
  if (!defined_default(ApproximateTerrainHeights._terrainHeights)) {
    throw new DeveloperError_default(
      "You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function"
    );
  }
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  const xyLevel = getTileXYLevel(rectangle);
  let minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;
  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;
  if (defined_default(xyLevel)) {
    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;
    const heights = ApproximateTerrainHeights._terrainHeights[key];
    if (defined_default(heights)) {
      minTerrainHeight = heights[0];
      maxTerrainHeight = heights[1];
    }
    ellipsoid.cartographicToCartesian(
      Rectangle_default.northeast(rectangle, scratchDiagonalCartographic),
      scratchDiagonalCartesianNE
    );
    ellipsoid.cartographicToCartesian(
      Rectangle_default.southwest(rectangle, scratchDiagonalCartographic),
      scratchDiagonalCartesianSW
    );
    Cartesian3_default.midpoint(
      scratchDiagonalCartesianSW,
      scratchDiagonalCartesianNE,
      scratchCenterCartesian
    );
    const surfacePosition = ellipsoid.scaleToGeodeticSurface(
      scratchCenterCartesian,
      scratchSurfaceCartesian
    );
    if (defined_default(surfacePosition)) {
      const distance = Cartesian3_default.distance(
        scratchCenterCartesian,
        surfacePosition
      );
      minTerrainHeight = Math.min(minTerrainHeight, -distance);
    } else {
      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;
    }
  }
  minTerrainHeight = Math.max(
    ApproximateTerrainHeights._defaultMinTerrainHeight,
    minTerrainHeight
  );
  return {
    minimumTerrainHeight: minTerrainHeight,
    maximumTerrainHeight: maxTerrainHeight
  };
};
ApproximateTerrainHeights.getBoundingSphere = function(rectangle, ellipsoid) {
  Check_default.defined("rectangle", rectangle);
  if (!defined_default(ApproximateTerrainHeights._terrainHeights)) {
    throw new DeveloperError_default(
      "You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function"
    );
  }
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  const xyLevel = getTileXYLevel(rectangle);
  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;
  if (defined_default(xyLevel)) {
    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;
    const heights = ApproximateTerrainHeights._terrainHeights[key];
    if (defined_default(heights)) {
      maxTerrainHeight = heights[1];
    }
  }
  const result = BoundingSphere_default.fromRectangle3D(rectangle, ellipsoid, 0);
  BoundingSphere_default.fromRectangle3D(
    rectangle,
    ellipsoid,
    maxTerrainHeight,
    scratchBoundingSphere
  );
  return BoundingSphere_default.union(result, scratchBoundingSphere, result);
};
function getTileXYLevel(rectangle) {
  Cartographic_default.fromRadians(
    rectangle.east,
    rectangle.north,
    0,
    scratchCorners[0]
  );
  Cartographic_default.fromRadians(
    rectangle.west,
    rectangle.north,
    0,
    scratchCorners[1]
  );
  Cartographic_default.fromRadians(
    rectangle.east,
    rectangle.south,
    0,
    scratchCorners[2]
  );
  Cartographic_default.fromRadians(
    rectangle.west,
    rectangle.south,
    0,
    scratchCorners[3]
  );
  let lastLevelX = 0, lastLevelY = 0;
  let currentX = 0, currentY = 0;
  const maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;
  let i;
  for (i = 0; i <= maxLevel; ++i) {
    let failed = false;
    for (let j = 0; j < 4; ++j) {
      const corner = scratchCorners[j];
      tilingScheme.positionToTileXY(corner, i, scratchTileXY);
      if (j === 0) {
        currentX = scratchTileXY.x;
        currentY = scratchTileXY.y;
      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {
        failed = true;
        break;
      }
    }
    if (failed) {
      break;
    }
    lastLevelX = currentX;
    lastLevelY = currentY;
  }
  if (i === 0) {
    return void 0;
  }
  return {
    x: lastLevelX,
    y: lastLevelY,
    level: i > maxLevel ? maxLevel : i - 1
  };
}
ApproximateTerrainHeights._terrainHeightsMaxLevel = 6;
ApproximateTerrainHeights._defaultMaxTerrainHeight = 9e3;
ApproximateTerrainHeights._defaultMinTerrainHeight = -1e5;
ApproximateTerrainHeights._terrainHeights = void 0;
ApproximateTerrainHeights._initPromise = void 0;
Object.defineProperties(ApproximateTerrainHeights, {
  initialized: {
    get: function() {
      return defined_default(ApproximateTerrainHeights._terrainHeights);
    }
  }
});
var ApproximateTerrainHeights_default = ApproximateTerrainHeights;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/AxisAlignedBoundingBox.js
function AxisAlignedBoundingBox(minimum, maximum, center) {
  this.minimum = Cartesian3_default.clone(defaultValue_default(minimum, Cartesian3_default.ZERO));
  this.maximum = Cartesian3_default.clone(defaultValue_default(maximum, Cartesian3_default.ZERO));
  if (!defined_default(center)) {
    center = Cartesian3_default.midpoint(this.minimum, this.maximum, new Cartesian3_default());
  } else {
    center = Cartesian3_default.clone(center);
  }
  this.center = center;
}
AxisAlignedBoundingBox.fromCorners = function(minimum, maximum, result) {
  Check_default.defined("minimum", minimum);
  Check_default.defined("maximum", maximum);
  if (!defined_default(result)) {
    result = new AxisAlignedBoundingBox();
  }
  result.minimum = Cartesian3_default.clone(minimum, result.minimum);
  result.maximum = Cartesian3_default.clone(maximum, result.maximum);
  result.center = Cartesian3_default.midpoint(minimum, maximum, result.center);
  return result;
};
AxisAlignedBoundingBox.fromPoints = function(positions, result) {
  if (!defined_default(result)) {
    result = new AxisAlignedBoundingBox();
  }
  if (!defined_default(positions) || positions.length === 0) {
    result.minimum = Cartesian3_default.clone(Cartesian3_default.ZERO, result.minimum);
    result.maximum = Cartesian3_default.clone(Cartesian3_default.ZERO, result.maximum);
    result.center = Cartesian3_default.clone(Cartesian3_default.ZERO, result.center);
    return result;
  }
  let minimumX = positions[0].x;
  let minimumY = positions[0].y;
  let minimumZ = positions[0].z;
  let maximumX = positions[0].x;
  let maximumY = positions[0].y;
  let maximumZ = positions[0].z;
  const length = positions.length;
  for (let i = 1; i < length; i++) {
    const p = positions[i];
    const x = p.x;
    const y = p.y;
    const z = p.z;
    minimumX = Math.min(x, minimumX);
    maximumX = Math.max(x, maximumX);
    minimumY = Math.min(y, minimumY);
    maximumY = Math.max(y, maximumY);
    minimumZ = Math.min(z, minimumZ);
    maximumZ = Math.max(z, maximumZ);
  }
  const minimum = result.minimum;
  minimum.x = minimumX;
  minimum.y = minimumY;
  minimum.z = minimumZ;
  const maximum = result.maximum;
  maximum.x = maximumX;
  maximum.y = maximumY;
  maximum.z = maximumZ;
  result.center = Cartesian3_default.midpoint(minimum, maximum, result.center);
  return result;
};
AxisAlignedBoundingBox.clone = function(box, result) {
  if (!defined_default(box)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);
  }
  result.minimum = Cartesian3_default.clone(box.minimum, result.minimum);
  result.maximum = Cartesian3_default.clone(box.maximum, result.maximum);
  result.center = Cartesian3_default.clone(box.center, result.center);
  return result;
};
AxisAlignedBoundingBox.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && Cartesian3_default.equals(left.center, right.center) && Cartesian3_default.equals(left.minimum, right.minimum) && Cartesian3_default.equals(left.maximum, right.maximum);
};
var intersectScratch = new Cartesian3_default();
AxisAlignedBoundingBox.intersectPlane = function(box, plane) {
  Check_default.defined("box", box);
  Check_default.defined("plane", plane);
  intersectScratch = Cartesian3_default.subtract(
    box.maximum,
    box.minimum,
    intersectScratch
  );
  const h = Cartesian3_default.multiplyByScalar(
    intersectScratch,
    0.5,
    intersectScratch
  );
  const normal2 = plane.normal;
  const e = h.x * Math.abs(normal2.x) + h.y * Math.abs(normal2.y) + h.z * Math.abs(normal2.z);
  const s = Cartesian3_default.dot(box.center, normal2) + plane.distance;
  if (s - e > 0) {
    return Intersect_default.INSIDE;
  }
  if (s + e < 0) {
    return Intersect_default.OUTSIDE;
  }
  return Intersect_default.INTERSECTING;
};
AxisAlignedBoundingBox.prototype.clone = function(result) {
  return AxisAlignedBoundingBox.clone(this, result);
};
AxisAlignedBoundingBox.prototype.intersectPlane = function(plane) {
  return AxisAlignedBoundingBox.intersectPlane(this, plane);
};
AxisAlignedBoundingBox.prototype.equals = function(right) {
  return AxisAlignedBoundingBox.equals(this, right);
};
var AxisAlignedBoundingBox_default = AxisAlignedBoundingBox;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/QuadraticRealPolynomial.js
var QuadraticRealPolynomial = {};
QuadraticRealPolynomial.computeDiscriminant = function(a3, b, c) {
  if (typeof a3 !== "number") {
    throw new DeveloperError_default("a is a required number.");
  }
  if (typeof b !== "number") {
    throw new DeveloperError_default("b is a required number.");
  }
  if (typeof c !== "number") {
    throw new DeveloperError_default("c is a required number.");
  }
  const discriminant = b * b - 4 * a3 * c;
  return discriminant;
};
function addWithCancellationCheck(left, right, tolerance) {
  const difference = left + right;
  if (Math_default.sign(left) !== Math_default.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
    return 0;
  }
  return difference;
}
QuadraticRealPolynomial.computeRealRoots = function(a3, b, c) {
  if (typeof a3 !== "number") {
    throw new DeveloperError_default("a is a required number.");
  }
  if (typeof b !== "number") {
    throw new DeveloperError_default("b is a required number.");
  }
  if (typeof c !== "number") {
    throw new DeveloperError_default("c is a required number.");
  }
  let ratio;
  if (a3 === 0) {
    if (b === 0) {
      return [];
    }
    return [-c / b];
  } else if (b === 0) {
    if (c === 0) {
      return [0, 0];
    }
    const cMagnitude = Math.abs(c);
    const aMagnitude = Math.abs(a3);
    if (cMagnitude < aMagnitude && cMagnitude / aMagnitude < Math_default.EPSILON14) {
      return [0, 0];
    } else if (cMagnitude > aMagnitude && aMagnitude / cMagnitude < Math_default.EPSILON14) {
      return [];
    }
    ratio = -c / a3;
    if (ratio < 0) {
      return [];
    }
    const root = Math.sqrt(ratio);
    return [-root, root];
  } else if (c === 0) {
    ratio = -b / a3;
    if (ratio < 0) {
      return [ratio, 0];
    }
    return [0, ratio];
  }
  const b2 = b * b;
  const four_ac = 4 * a3 * c;
  const radicand = addWithCancellationCheck(b2, -four_ac, Math_default.EPSILON14);
  if (radicand < 0) {
    return [];
  }
  const q = -0.5 * addWithCancellationCheck(
    b,
    Math_default.sign(b) * Math.sqrt(radicand),
    Math_default.EPSILON14
  );
  if (b > 0) {
    return [q / a3, c / q];
  }
  return [c / q, q / a3];
};
var QuadraticRealPolynomial_default = QuadraticRealPolynomial;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/CubicRealPolynomial.js
var CubicRealPolynomial = {};
CubicRealPolynomial.computeDiscriminant = function(a3, b, c, d) {
  if (typeof a3 !== "number") {
    throw new DeveloperError_default("a is a required number.");
  }
  if (typeof b !== "number") {
    throw new DeveloperError_default("b is a required number.");
  }
  if (typeof c !== "number") {
    throw new DeveloperError_default("c is a required number.");
  }
  if (typeof d !== "number") {
    throw new DeveloperError_default("d is a required number.");
  }
  const a22 = a3 * a3;
  const b2 = b * b;
  const c2 = c * c;
  const d2 = d * d;
  const discriminant = 18 * a3 * b * c * d + b2 * c2 - 27 * a22 * d2 - 4 * (a3 * c2 * c + b2 * b * d);
  return discriminant;
};
function computeRealRoots(a3, b, c, d) {
  const A = a3;
  const B = b / 3;
  const C = c / 3;
  const D = d;
  const AC = A * C;
  const BD = B * D;
  const B2 = B * B;
  const C2 = C * C;
  const delta1 = A * C - B2;
  const delta2 = A * D - B * C;
  const delta3 = B * D - C2;
  const discriminant = 4 * delta1 * delta3 - delta2 * delta2;
  let temp;
  let temp1;
  if (discriminant < 0) {
    let ABar;
    let CBar;
    let DBar;
    if (B2 * BD >= AC * C2) {
      ABar = A;
      CBar = delta1;
      DBar = -2 * B * delta1 + A * delta2;
    } else {
      ABar = D;
      CBar = delta3;
      DBar = -D * delta2 + 2 * C * delta3;
    }
    const s = DBar < 0 ? -1 : 1;
    const temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);
    temp1 = -DBar + temp0;
    const x = temp1 / 2;
    const p = x < 0 ? -Math.pow(-x, 1 / 3) : Math.pow(x, 1 / 3);
    const q = temp1 === temp0 ? -p : -CBar / p;
    temp = CBar <= 0 ? p + q : -DBar / (p * p + q * q + CBar);
    if (B2 * BD >= AC * C2) {
      return [(temp - B) / A];
    }
    return [-D / (temp + C)];
  }
  const CBarA = delta1;
  const DBarA = -2 * B * delta1 + A * delta2;
  const CBarD = delta3;
  const DBarD = -D * delta2 + 2 * C * delta3;
  const squareRootOfDiscriminant = Math.sqrt(discriminant);
  const halfSquareRootOf3 = Math.sqrt(3) / 2;
  let theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3);
  temp = 2 * Math.sqrt(-CBarA);
  let cosine = Math.cos(theta);
  temp1 = temp * cosine;
  let temp3 = temp * (-cosine / 2 - halfSquareRootOf3 * Math.sin(theta));
  const numeratorLarge = temp1 + temp3 > 2 * B ? temp1 - B : temp3 - B;
  const denominatorLarge = A;
  const root1 = numeratorLarge / denominatorLarge;
  theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3);
  temp = 2 * Math.sqrt(-CBarD);
  cosine = Math.cos(theta);
  temp1 = temp * cosine;
  temp3 = temp * (-cosine / 2 - halfSquareRootOf3 * Math.sin(theta));
  const numeratorSmall = -D;
  const denominatorSmall = temp1 + temp3 < 2 * C ? temp1 + C : temp3 + C;
  const root3 = numeratorSmall / denominatorSmall;
  const E = denominatorLarge * denominatorSmall;
  const F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;
  const G = numeratorLarge * numeratorSmall;
  const root2 = (C * F - B * G) / (-B * F + C * E);
  if (root1 <= root2) {
    if (root1 <= root3) {
      if (root2 <= root3) {
        return [root1, root2, root3];
      }
      return [root1, root3, root2];
    }
    return [root3, root1, root2];
  }
  if (root1 <= root3) {
    return [root2, root1, root3];
  }
  if (root2 <= root3) {
    return [root2, root3, root1];
  }
  return [root3, root2, root1];
}
CubicRealPolynomial.computeRealRoots = function(a3, b, c, d) {
  if (typeof a3 !== "number") {
    throw new DeveloperError_default("a is a required number.");
  }
  if (typeof b !== "number") {
    throw new DeveloperError_default("b is a required number.");
  }
  if (typeof c !== "number") {
    throw new DeveloperError_default("c is a required number.");
  }
  if (typeof d !== "number") {
    throw new DeveloperError_default("d is a required number.");
  }
  let roots;
  let ratio;
  if (a3 === 0) {
    return QuadraticRealPolynomial_default.computeRealRoots(b, c, d);
  } else if (b === 0) {
    if (c === 0) {
      if (d === 0) {
        return [0, 0, 0];
      }
      ratio = -d / a3;
      const root = ratio < 0 ? -Math.pow(-ratio, 1 / 3) : Math.pow(ratio, 1 / 3);
      return [root, root, root];
    } else if (d === 0) {
      roots = QuadraticRealPolynomial_default.computeRealRoots(a3, 0, c);
      if (roots.Length === 0) {
        return [0];
      }
      return [roots[0], 0, roots[1]];
    }
    return computeRealRoots(a3, 0, c, d);
  } else if (c === 0) {
    if (d === 0) {
      ratio = -b / a3;
      if (ratio < 0) {
        return [ratio, 0, 0];
      }
      return [0, 0, ratio];
    }
    return computeRealRoots(a3, b, 0, d);
  } else if (d === 0) {
    roots = QuadraticRealPolynomial_default.computeRealRoots(a3, b, c);
    if (roots.length === 0) {
      return [0];
    } else if (roots[1] <= 0) {
      return [roots[0], roots[1], 0];
    } else if (roots[0] >= 0) {
      return [0, roots[0], roots[1]];
    }
    return [roots[0], 0, roots[1]];
  }
  return computeRealRoots(a3, b, c, d);
};
var CubicRealPolynomial_default = CubicRealPolynomial;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/QuarticRealPolynomial.js
var QuarticRealPolynomial = {};
QuarticRealPolynomial.computeDiscriminant = function(a3, b, c, d, e) {
  if (typeof a3 !== "number") {
    throw new DeveloperError_default("a is a required number.");
  }
  if (typeof b !== "number") {
    throw new DeveloperError_default("b is a required number.");
  }
  if (typeof c !== "number") {
    throw new DeveloperError_default("c is a required number.");
  }
  if (typeof d !== "number") {
    throw new DeveloperError_default("d is a required number.");
  }
  if (typeof e !== "number") {
    throw new DeveloperError_default("e is a required number.");
  }
  const a22 = a3 * a3;
  const a32 = a22 * a3;
  const b2 = b * b;
  const b3 = b2 * b;
  const c2 = c * c;
  const c32 = c2 * c;
  const d2 = d * d;
  const d3 = d2 * d;
  const e2 = e * e;
  const e3 = e2 * e;
  const discriminant = b2 * c2 * d2 - 4 * b3 * d3 - 4 * a3 * c32 * d2 + 18 * a3 * b * c * d3 - 27 * a22 * d2 * d2 + 256 * a32 * e3 + e * (18 * b3 * c * d - 4 * b2 * c32 + 16 * a3 * c2 * c2 - 80 * a3 * b * c2 * d - 6 * a3 * b2 * d2 + 144 * a22 * c * d2) + e2 * (144 * a3 * b2 * c - 27 * b2 * b2 - 128 * a22 * c2 - 192 * a22 * b * d);
  return discriminant;
};
function original(a3, a22, a1, a0) {
  const a3Squared = a3 * a3;
  const p = a22 - 3 * a3Squared / 8;
  const q = a1 - a22 * a3 / 2 + a3Squared * a3 / 8;
  const r = a0 - a1 * a3 / 4 + a22 * a3Squared / 16 - 3 * a3Squared * a3Squared / 256;
  const cubicRoots = CubicRealPolynomial_default.computeRealRoots(
    1,
    2 * p,
    p * p - 4 * r,
    -q * q
  );
  if (cubicRoots.length > 0) {
    const temp = -a3 / 4;
    const hSquared = cubicRoots[cubicRoots.length - 1];
    if (Math.abs(hSquared) < Math_default.EPSILON14) {
      const roots = QuadraticRealPolynomial_default.computeRealRoots(1, p, r);
      if (roots.length === 2) {
        const root0 = roots[0];
        const root1 = roots[1];
        let y;
        if (root0 >= 0 && root1 >= 0) {
          const y0 = Math.sqrt(root0);
          const y1 = Math.sqrt(root1);
          return [temp - y1, temp - y0, temp + y0, temp + y1];
        } else if (root0 >= 0 && root1 < 0) {
          y = Math.sqrt(root0);
          return [temp - y, temp + y];
        } else if (root0 < 0 && root1 >= 0) {
          y = Math.sqrt(root1);
          return [temp - y, temp + y];
        }
      }
      return [];
    } else if (hSquared > 0) {
      const h = Math.sqrt(hSquared);
      const m = (p + hSquared - q / h) / 2;
      const n = (p + hSquared + q / h) / 2;
      const roots1 = QuadraticRealPolynomial_default.computeRealRoots(1, h, m);
      const roots2 = QuadraticRealPolynomial_default.computeRealRoots(1, -h, n);
      if (roots1.length !== 0) {
        roots1[0] += temp;
        roots1[1] += temp;
        if (roots2.length !== 0) {
          roots2[0] += temp;
          roots2[1] += temp;
          if (roots1[1] <= roots2[0]) {
            return [roots1[0], roots1[1], roots2[0], roots2[1]];
          } else if (roots2[1] <= roots1[0]) {
            return [roots2[0], roots2[1], roots1[0], roots1[1]];
          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
            return [roots2[0], roots1[0], roots1[1], roots2[1]];
          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
            return [roots1[0], roots2[0], roots2[1], roots1[1]];
          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
            return [roots2[0], roots1[0], roots2[1], roots1[1]];
          }
          return [roots1[0], roots2[0], roots1[1], roots2[1]];
        }
        return roots1;
      }
      if (roots2.length !== 0) {
        roots2[0] += temp;
        roots2[1] += temp;
        return roots2;
      }
      return [];
    }
  }
  return [];
}
function neumark(a3, a22, a1, a0) {
  const a1Squared = a1 * a1;
  const a2Squared = a22 * a22;
  const a3Squared = a3 * a3;
  const p = -2 * a22;
  const q = a1 * a3 + a2Squared - 4 * a0;
  const r = a3Squared * a0 - a1 * a22 * a3 + a1Squared;
  const cubicRoots = CubicRealPolynomial_default.computeRealRoots(1, p, q, r);
  if (cubicRoots.length > 0) {
    const y = cubicRoots[0];
    const temp = a22 - y;
    const tempSquared = temp * temp;
    const g1 = a3 / 2;
    const h1 = temp / 2;
    const m = tempSquared - 4 * a0;
    const mError = tempSquared + 4 * Math.abs(a0);
    const n = a3Squared - 4 * y;
    const nError = a3Squared + 4 * Math.abs(y);
    let g2;
    let h2;
    if (y < 0 || m * nError < n * mError) {
      const squareRootOfN = Math.sqrt(n);
      g2 = squareRootOfN / 2;
      h2 = squareRootOfN === 0 ? 0 : (a3 * h1 - a1) / squareRootOfN;
    } else {
      const squareRootOfM = Math.sqrt(m);
      g2 = squareRootOfM === 0 ? 0 : (a3 * h1 - a1) / squareRootOfM;
      h2 = squareRootOfM / 2;
    }
    let G;
    let g;
    if (g1 === 0 && g2 === 0) {
      G = 0;
      g = 0;
    } else if (Math_default.sign(g1) === Math_default.sign(g2)) {
      G = g1 + g2;
      g = y / G;
    } else {
      g = g1 - g2;
      G = y / g;
    }
    let H;
    let h;
    if (h1 === 0 && h2 === 0) {
      H = 0;
      h = 0;
    } else if (Math_default.sign(h1) === Math_default.sign(h2)) {
      H = h1 + h2;
      h = a0 / H;
    } else {
      h = h1 - h2;
      H = a0 / h;
    }
    const roots1 = QuadraticRealPolynomial_default.computeRealRoots(1, G, H);
    const roots2 = QuadraticRealPolynomial_default.computeRealRoots(1, g, h);
    if (roots1.length !== 0) {
      if (roots2.length !== 0) {
        if (roots1[1] <= roots2[0]) {
          return [roots1[0], roots1[1], roots2[0], roots2[1]];
        } else if (roots2[1] <= roots1[0]) {
          return [roots2[0], roots2[1], roots1[0], roots1[1]];
        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
          return [roots2[0], roots1[0], roots1[1], roots2[1]];
        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
          return [roots1[0], roots2[0], roots2[1], roots1[1]];
        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
          return [roots2[0], roots1[0], roots2[1], roots1[1]];
        }
        return [roots1[0], roots2[0], roots1[1], roots2[1]];
      }
      return roots1;
    }
    if (roots2.length !== 0) {
      return roots2;
    }
  }
  return [];
}
QuarticRealPolynomial.computeRealRoots = function(a3, b, c, d, e) {
  if (typeof a3 !== "number") {
    throw new DeveloperError_default("a is a required number.");
  }
  if (typeof b !== "number") {
    throw new DeveloperError_default("b is a required number.");
  }
  if (typeof c !== "number") {
    throw new DeveloperError_default("c is a required number.");
  }
  if (typeof d !== "number") {
    throw new DeveloperError_default("d is a required number.");
  }
  if (typeof e !== "number") {
    throw new DeveloperError_default("e is a required number.");
  }
  if (Math.abs(a3) < Math_default.EPSILON15) {
    return CubicRealPolynomial_default.computeRealRoots(b, c, d, e);
  }
  const a32 = b / a3;
  const a22 = c / a3;
  const a1 = d / a3;
  const a0 = e / a3;
  let k = a32 < 0 ? 1 : 0;
  k += a22 < 0 ? k + 1 : k;
  k += a1 < 0 ? k + 1 : k;
  k += a0 < 0 ? k + 1 : k;
  switch (k) {
    case 0:
      return original(a32, a22, a1, a0);
    case 1:
      return neumark(a32, a22, a1, a0);
    case 2:
      return neumark(a32, a22, a1, a0);
    case 3:
      return original(a32, a22, a1, a0);
    case 4:
      return original(a32, a22, a1, a0);
    case 5:
      return neumark(a32, a22, a1, a0);
    case 6:
      return original(a32, a22, a1, a0);
    case 7:
      return original(a32, a22, a1, a0);
    case 8:
      return neumark(a32, a22, a1, a0);
    case 9:
      return original(a32, a22, a1, a0);
    case 10:
      return original(a32, a22, a1, a0);
    case 11:
      return neumark(a32, a22, a1, a0);
    case 12:
      return original(a32, a22, a1, a0);
    case 13:
      return original(a32, a22, a1, a0);
    case 14:
      return original(a32, a22, a1, a0);
    case 15:
      return original(a32, a22, a1, a0);
    default:
      return void 0;
  }
};
var QuarticRealPolynomial_default = QuarticRealPolynomial;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Ray.js
function Ray(origin, direction2) {
  direction2 = Cartesian3_default.clone(defaultValue_default(direction2, Cartesian3_default.ZERO));
  if (!Cartesian3_default.equals(direction2, Cartesian3_default.ZERO)) {
    Cartesian3_default.normalize(direction2, direction2);
  }
  this.origin = Cartesian3_default.clone(defaultValue_default(origin, Cartesian3_default.ZERO));
  this.direction = direction2;
}
Ray.clone = function(ray, result) {
  if (!defined_default(ray)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new Ray(ray.origin, ray.direction);
  }
  result.origin = Cartesian3_default.clone(ray.origin);
  result.direction = Cartesian3_default.clone(ray.direction);
  return result;
};
Ray.getPoint = function(ray, t, result) {
  Check_default.typeOf.object("ray", ray);
  Check_default.typeOf.number("t", t);
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  result = Cartesian3_default.multiplyByScalar(ray.direction, t, result);
  return Cartesian3_default.add(ray.origin, result, result);
};
var Ray_default = Ray;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/IntersectionTests.js
var IntersectionTests = {};
IntersectionTests.rayPlane = function(ray, plane, result) {
  if (!defined_default(ray)) {
    throw new DeveloperError_default("ray is required.");
  }
  if (!defined_default(plane)) {
    throw new DeveloperError_default("plane is required.");
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  const origin = ray.origin;
  const direction2 = ray.direction;
  const normal2 = plane.normal;
  const denominator = Cartesian3_default.dot(normal2, direction2);
  if (Math.abs(denominator) < Math_default.EPSILON15) {
    return void 0;
  }
  const t = (-plane.distance - Cartesian3_default.dot(normal2, origin)) / denominator;
  if (t < 0) {
    return void 0;
  }
  result = Cartesian3_default.multiplyByScalar(direction2, t, result);
  return Cartesian3_default.add(origin, result, result);
};
var scratchEdge0 = new Cartesian3_default();
var scratchEdge1 = new Cartesian3_default();
var scratchPVec = new Cartesian3_default();
var scratchTVec = new Cartesian3_default();
var scratchQVec = new Cartesian3_default();
IntersectionTests.rayTriangleParametric = function(ray, p0, p1, p2, cullBackFaces) {
  if (!defined_default(ray)) {
    throw new DeveloperError_default("ray is required.");
  }
  if (!defined_default(p0)) {
    throw new DeveloperError_default("p0 is required.");
  }
  if (!defined_default(p1)) {
    throw new DeveloperError_default("p1 is required.");
  }
  if (!defined_default(p2)) {
    throw new DeveloperError_default("p2 is required.");
  }
  cullBackFaces = defaultValue_default(cullBackFaces, false);
  const origin = ray.origin;
  const direction2 = ray.direction;
  const edge0 = Cartesian3_default.subtract(p1, p0, scratchEdge0);
  const edge1 = Cartesian3_default.subtract(p2, p0, scratchEdge1);
  const p = Cartesian3_default.cross(direction2, edge1, scratchPVec);
  const det = Cartesian3_default.dot(edge0, p);
  let tvec;
  let q;
  let u3;
  let v3;
  let t;
  if (cullBackFaces) {
    if (det < Math_default.EPSILON6) {
      return void 0;
    }
    tvec = Cartesian3_default.subtract(origin, p0, scratchTVec);
    u3 = Cartesian3_default.dot(tvec, p);
    if (u3 < 0 || u3 > det) {
      return void 0;
    }
    q = Cartesian3_default.cross(tvec, edge0, scratchQVec);
    v3 = Cartesian3_default.dot(direction2, q);
    if (v3 < 0 || u3 + v3 > det) {
      return void 0;
    }
    t = Cartesian3_default.dot(edge1, q) / det;
  } else {
    if (Math.abs(det) < Math_default.EPSILON6) {
      return void 0;
    }
    const invDet = 1 / det;
    tvec = Cartesian3_default.subtract(origin, p0, scratchTVec);
    u3 = Cartesian3_default.dot(tvec, p) * invDet;
    if (u3 < 0 || u3 > 1) {
      return void 0;
    }
    q = Cartesian3_default.cross(tvec, edge0, scratchQVec);
    v3 = Cartesian3_default.dot(direction2, q) * invDet;
    if (v3 < 0 || u3 + v3 > 1) {
      return void 0;
    }
    t = Cartesian3_default.dot(edge1, q) * invDet;
  }
  return t;
};
IntersectionTests.rayTriangle = function(ray, p0, p1, p2, cullBackFaces, result) {
  const t = IntersectionTests.rayTriangleParametric(
    ray,
    p0,
    p1,
    p2,
    cullBackFaces
  );
  if (!defined_default(t) || t < 0) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  Cartesian3_default.multiplyByScalar(ray.direction, t, result);
  return Cartesian3_default.add(ray.origin, result, result);
};
var scratchLineSegmentTriangleRay = new Ray_default();
IntersectionTests.lineSegmentTriangle = function(v02, v12, p0, p1, p2, cullBackFaces, result) {
  if (!defined_default(v02)) {
    throw new DeveloperError_default("v0 is required.");
  }
  if (!defined_default(v12)) {
    throw new DeveloperError_default("v1 is required.");
  }
  if (!defined_default(p0)) {
    throw new DeveloperError_default("p0 is required.");
  }
  if (!defined_default(p1)) {
    throw new DeveloperError_default("p1 is required.");
  }
  if (!defined_default(p2)) {
    throw new DeveloperError_default("p2 is required.");
  }
  const ray = scratchLineSegmentTriangleRay;
  Cartesian3_default.clone(v02, ray.origin);
  Cartesian3_default.subtract(v12, v02, ray.direction);
  Cartesian3_default.normalize(ray.direction, ray.direction);
  const t = IntersectionTests.rayTriangleParametric(
    ray,
    p0,
    p1,
    p2,
    cullBackFaces
  );
  if (!defined_default(t) || t < 0 || t > Cartesian3_default.distance(v02, v12)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  Cartesian3_default.multiplyByScalar(ray.direction, t, result);
  return Cartesian3_default.add(ray.origin, result, result);
};
function solveQuadratic(a3, b, c, result) {
  const det = b * b - 4 * a3 * c;
  if (det < 0) {
    return void 0;
  } else if (det > 0) {
    const denom = 1 / (2 * a3);
    const disc = Math.sqrt(det);
    const root0 = (-b + disc) * denom;
    const root1 = (-b - disc) * denom;
    if (root0 < root1) {
      result.root0 = root0;
      result.root1 = root1;
    } else {
      result.root0 = root1;
      result.root1 = root0;
    }
    return result;
  }
  const root = -b / (2 * a3);
  if (root === 0) {
    return void 0;
  }
  result.root0 = result.root1 = root;
  return result;
}
var raySphereRoots = {
  root0: 0,
  root1: 0
};
function raySphere(ray, sphere, result) {
  if (!defined_default(result)) {
    result = new Interval_default();
  }
  const origin = ray.origin;
  const direction2 = ray.direction;
  const center = sphere.center;
  const radiusSquared = sphere.radius * sphere.radius;
  const diff = Cartesian3_default.subtract(origin, center, scratchPVec);
  const a3 = Cartesian3_default.dot(direction2, direction2);
  const b = 2 * Cartesian3_default.dot(direction2, diff);
  const c = Cartesian3_default.magnitudeSquared(diff) - radiusSquared;
  const roots = solveQuadratic(a3, b, c, raySphereRoots);
  if (!defined_default(roots)) {
    return void 0;
  }
  result.start = roots.root0;
  result.stop = roots.root1;
  return result;
}
IntersectionTests.raySphere = function(ray, sphere, result) {
  if (!defined_default(ray)) {
    throw new DeveloperError_default("ray is required.");
  }
  if (!defined_default(sphere)) {
    throw new DeveloperError_default("sphere is required.");
  }
  result = raySphere(ray, sphere, result);
  if (!defined_default(result) || result.stop < 0) {
    return void 0;
  }
  result.start = Math.max(result.start, 0);
  return result;
};
var scratchLineSegmentRay = new Ray_default();
IntersectionTests.lineSegmentSphere = function(p0, p1, sphere, result) {
  if (!defined_default(p0)) {
    throw new DeveloperError_default("p0 is required.");
  }
  if (!defined_default(p1)) {
    throw new DeveloperError_default("p1 is required.");
  }
  if (!defined_default(sphere)) {
    throw new DeveloperError_default("sphere is required.");
  }
  const ray = scratchLineSegmentRay;
  Cartesian3_default.clone(p0, ray.origin);
  const direction2 = Cartesian3_default.subtract(p1, p0, ray.direction);
  const maxT = Cartesian3_default.magnitude(direction2);
  Cartesian3_default.normalize(direction2, direction2);
  result = raySphere(ray, sphere, result);
  if (!defined_default(result) || result.stop < 0 || result.start > maxT) {
    return void 0;
  }
  result.start = Math.max(result.start, 0);
  result.stop = Math.min(result.stop, maxT);
  return result;
};
var scratchQ = new Cartesian3_default();
var scratchW = new Cartesian3_default();
IntersectionTests.rayEllipsoid = function(ray, ellipsoid) {
  if (!defined_default(ray)) {
    throw new DeveloperError_default("ray is required.");
  }
  if (!defined_default(ellipsoid)) {
    throw new DeveloperError_default("ellipsoid is required.");
  }
  const inverseRadii = ellipsoid.oneOverRadii;
  const q = Cartesian3_default.multiplyComponents(inverseRadii, ray.origin, scratchQ);
  const w = Cartesian3_default.multiplyComponents(
    inverseRadii,
    ray.direction,
    scratchW
  );
  const q22 = Cartesian3_default.magnitudeSquared(q);
  const qw = Cartesian3_default.dot(q, w);
  let difference, w2, product, discriminant, temp;
  if (q22 > 1) {
    if (qw >= 0) {
      return void 0;
    }
    const qw2 = qw * qw;
    difference = q22 - 1;
    w2 = Cartesian3_default.magnitudeSquared(w);
    product = w2 * difference;
    if (qw2 < product) {
      return void 0;
    } else if (qw2 > product) {
      discriminant = qw * qw - product;
      temp = -qw + Math.sqrt(discriminant);
      const root0 = temp / w2;
      const root1 = difference / temp;
      if (root0 < root1) {
        return new Interval_default(root0, root1);
      }
      return {
        start: root1,
        stop: root0
      };
    }
    const root = Math.sqrt(difference / w2);
    return new Interval_default(root, root);
  } else if (q22 < 1) {
    difference = q22 - 1;
    w2 = Cartesian3_default.magnitudeSquared(w);
    product = w2 * difference;
    discriminant = qw * qw - product;
    temp = -qw + Math.sqrt(discriminant);
    return new Interval_default(0, temp / w2);
  }
  if (qw < 0) {
    w2 = Cartesian3_default.magnitudeSquared(w);
    return new Interval_default(0, -qw / w2);
  }
  return void 0;
};
function addWithCancellationCheck2(left, right, tolerance) {
  const difference = left + right;
  if (Math_default.sign(left) !== Math_default.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
    return 0;
  }
  return difference;
}
function quadraticVectorExpression(A, b, c, x, w) {
  const xSquared = x * x;
  const wSquared = w * w;
  const l2 = (A[Matrix3_default.COLUMN1ROW1] - A[Matrix3_default.COLUMN2ROW2]) * wSquared;
  const l1 = w * (x * addWithCancellationCheck2(
    A[Matrix3_default.COLUMN1ROW0],
    A[Matrix3_default.COLUMN0ROW1],
    Math_default.EPSILON15
  ) + b.y);
  const l0 = A[Matrix3_default.COLUMN0ROW0] * xSquared + A[Matrix3_default.COLUMN2ROW2] * wSquared + x * b.x + c;
  const r1 = wSquared * addWithCancellationCheck2(
    A[Matrix3_default.COLUMN2ROW1],
    A[Matrix3_default.COLUMN1ROW2],
    Math_default.EPSILON15
  );
  const r0 = w * (x * addWithCancellationCheck2(A[Matrix3_default.COLUMN2ROW0], A[Matrix3_default.COLUMN0ROW2]) + b.z);
  let cosines;
  const solutions = [];
  if (r0 === 0 && r1 === 0) {
    cosines = QuadraticRealPolynomial_default.computeRealRoots(l2, l1, l0);
    if (cosines.length === 0) {
      return solutions;
    }
    const cosine0 = cosines[0];
    const sine0 = Math.sqrt(Math.max(1 - cosine0 * cosine0, 0));
    solutions.push(new Cartesian3_default(x, w * cosine0, w * -sine0));
    solutions.push(new Cartesian3_default(x, w * cosine0, w * sine0));
    if (cosines.length === 2) {
      const cosine1 = cosines[1];
      const sine1 = Math.sqrt(Math.max(1 - cosine1 * cosine1, 0));
      solutions.push(new Cartesian3_default(x, w * cosine1, w * -sine1));
      solutions.push(new Cartesian3_default(x, w * cosine1, w * sine1));
    }
    return solutions;
  }
  const r0Squared = r0 * r0;
  const r1Squared = r1 * r1;
  const l2Squared = l2 * l2;
  const r0r1 = r0 * r1;
  const c4 = l2Squared + r1Squared;
  const c32 = 2 * (l1 * l2 + r0r1);
  const c2 = 2 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;
  const c1 = 2 * (l0 * l1 - r0r1);
  const c0 = l0 * l0 - r0Squared;
  if (c4 === 0 && c32 === 0 && c2 === 0 && c1 === 0) {
    return solutions;
  }
  cosines = QuarticRealPolynomial_default.computeRealRoots(c4, c32, c2, c1, c0);
  const length = cosines.length;
  if (length === 0) {
    return solutions;
  }
  for (let i = 0; i < length; ++i) {
    const cosine = cosines[i];
    const cosineSquared = cosine * cosine;
    const sineSquared = Math.max(1 - cosineSquared, 0);
    const sine = Math.sqrt(sineSquared);
    let left;
    if (Math_default.sign(l2) === Math_default.sign(l0)) {
      left = addWithCancellationCheck2(
        l2 * cosineSquared + l0,
        l1 * cosine,
        Math_default.EPSILON12
      );
    } else if (Math_default.sign(l0) === Math_default.sign(l1 * cosine)) {
      left = addWithCancellationCheck2(
        l2 * cosineSquared,
        l1 * cosine + l0,
        Math_default.EPSILON12
      );
    } else {
      left = addWithCancellationCheck2(
        l2 * cosineSquared + l1 * cosine,
        l0,
        Math_default.EPSILON12
      );
    }
    const right = addWithCancellationCheck2(
      r1 * cosine,
      r0,
      Math_default.EPSILON15
    );
    const product = left * right;
    if (product < 0) {
      solutions.push(new Cartesian3_default(x, w * cosine, w * sine));
    } else if (product > 0) {
      solutions.push(new Cartesian3_default(x, w * cosine, w * -sine));
    } else if (sine !== 0) {
      solutions.push(new Cartesian3_default(x, w * cosine, w * -sine));
      solutions.push(new Cartesian3_default(x, w * cosine, w * sine));
      ++i;
    } else {
      solutions.push(new Cartesian3_default(x, w * cosine, w * sine));
    }
  }
  return solutions;
}
var firstAxisScratch = new Cartesian3_default();
var secondAxisScratch = new Cartesian3_default();
var thirdAxisScratch = new Cartesian3_default();
var referenceScratch = new Cartesian3_default();
var bCart = new Cartesian3_default();
var bScratch = new Matrix3_default();
var btScratch = new Matrix3_default();
var diScratch = new Matrix3_default();
var dScratch = new Matrix3_default();
var cScratch = new Matrix3_default();
var tempMatrix = new Matrix3_default();
var aScratch = new Matrix3_default();
var sScratch = new Cartesian3_default();
var closestScratch = new Cartesian3_default();
var surfPointScratch = new Cartographic_default();
IntersectionTests.grazingAltitudeLocation = function(ray, ellipsoid) {
  if (!defined_default(ray)) {
    throw new DeveloperError_default("ray is required.");
  }
  if (!defined_default(ellipsoid)) {
    throw new DeveloperError_default("ellipsoid is required.");
  }
  const position = ray.origin;
  const direction2 = ray.direction;
  if (!Cartesian3_default.equals(position, Cartesian3_default.ZERO)) {
    const normal2 = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);
    if (Cartesian3_default.dot(direction2, normal2) >= 0) {
      return position;
    }
  }
  const intersects = defined_default(this.rayEllipsoid(ray, ellipsoid));
  const f = ellipsoid.transformPositionToScaledSpace(
    direction2,
    firstAxisScratch
  );
  const firstAxis = Cartesian3_default.normalize(f, f);
  const reference = Cartesian3_default.mostOrthogonalAxis(f, referenceScratch);
  const secondAxis = Cartesian3_default.normalize(
    Cartesian3_default.cross(reference, firstAxis, secondAxisScratch),
    secondAxisScratch
  );
  const thirdAxis = Cartesian3_default.normalize(
    Cartesian3_default.cross(firstAxis, secondAxis, thirdAxisScratch),
    thirdAxisScratch
  );
  const B = bScratch;
  B[0] = firstAxis.x;
  B[1] = firstAxis.y;
  B[2] = firstAxis.z;
  B[3] = secondAxis.x;
  B[4] = secondAxis.y;
  B[5] = secondAxis.z;
  B[6] = thirdAxis.x;
  B[7] = thirdAxis.y;
  B[8] = thirdAxis.z;
  const B_T = Matrix3_default.transpose(B, btScratch);
  const D_I = Matrix3_default.fromScale(ellipsoid.radii, diScratch);
  const D = Matrix3_default.fromScale(ellipsoid.oneOverRadii, dScratch);
  const C = cScratch;
  C[0] = 0;
  C[1] = -direction2.z;
  C[2] = direction2.y;
  C[3] = direction2.z;
  C[4] = 0;
  C[5] = -direction2.x;
  C[6] = -direction2.y;
  C[7] = direction2.x;
  C[8] = 0;
  const temp = Matrix3_default.multiply(
    Matrix3_default.multiply(B_T, D, tempMatrix),
    C,
    tempMatrix
  );
  const A = Matrix3_default.multiply(
    Matrix3_default.multiply(temp, D_I, aScratch),
    B,
    aScratch
  );
  const b = Matrix3_default.multiplyByVector(temp, position, bCart);
  const solutions = quadraticVectorExpression(
    A,
    Cartesian3_default.negate(b, firstAxisScratch),
    0,
    0,
    1
  );
  let s;
  let altitude;
  const length = solutions.length;
  if (length > 0) {
    let closest = Cartesian3_default.clone(Cartesian3_default.ZERO, closestScratch);
    let maximumValue = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < length; ++i) {
      s = Matrix3_default.multiplyByVector(
        D_I,
        Matrix3_default.multiplyByVector(B, solutions[i], sScratch),
        sScratch
      );
      const v3 = Cartesian3_default.normalize(
        Cartesian3_default.subtract(s, position, referenceScratch),
        referenceScratch
      );
      const dotProduct = Cartesian3_default.dot(v3, direction2);
      if (dotProduct > maximumValue) {
        maximumValue = dotProduct;
        closest = Cartesian3_default.clone(s, closest);
      }
    }
    const surfacePoint = ellipsoid.cartesianToCartographic(
      closest,
      surfPointScratch
    );
    maximumValue = Math_default.clamp(maximumValue, 0, 1);
    altitude = Cartesian3_default.magnitude(
      Cartesian3_default.subtract(closest, position, referenceScratch)
    ) * Math.sqrt(1 - maximumValue * maximumValue);
    altitude = intersects ? -altitude : altitude;
    surfacePoint.height = altitude;
    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3_default());
  }
  return void 0;
};
var lineSegmentPlaneDifference = new Cartesian3_default();
IntersectionTests.lineSegmentPlane = function(endPoint0, endPoint1, plane, result) {
  if (!defined_default(endPoint0)) {
    throw new DeveloperError_default("endPoint0 is required.");
  }
  if (!defined_default(endPoint1)) {
    throw new DeveloperError_default("endPoint1 is required.");
  }
  if (!defined_default(plane)) {
    throw new DeveloperError_default("plane is required.");
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  const difference = Cartesian3_default.subtract(
    endPoint1,
    endPoint0,
    lineSegmentPlaneDifference
  );
  const normal2 = plane.normal;
  const nDotDiff = Cartesian3_default.dot(normal2, difference);
  if (Math.abs(nDotDiff) < Math_default.EPSILON6) {
    return void 0;
  }
  const nDotP0 = Cartesian3_default.dot(normal2, endPoint0);
  const t = -(plane.distance + nDotP0) / nDotDiff;
  if (t < 0 || t > 1) {
    return void 0;
  }
  Cartesian3_default.multiplyByScalar(difference, t, result);
  Cartesian3_default.add(endPoint0, result, result);
  return result;
};
IntersectionTests.trianglePlaneIntersection = function(p0, p1, p2, plane) {
  if (!defined_default(p0) || !defined_default(p1) || !defined_default(p2) || !defined_default(plane)) {
    throw new DeveloperError_default("p0, p1, p2, and plane are required.");
  }
  const planeNormal = plane.normal;
  const planeD = plane.distance;
  const p0Behind = Cartesian3_default.dot(planeNormal, p0) + planeD < 0;
  const p1Behind = Cartesian3_default.dot(planeNormal, p1) + planeD < 0;
  const p2Behind = Cartesian3_default.dot(planeNormal, p2) + planeD < 0;
  let numBehind = 0;
  numBehind += p0Behind ? 1 : 0;
  numBehind += p1Behind ? 1 : 0;
  numBehind += p2Behind ? 1 : 0;
  let u12, u22;
  if (numBehind === 1 || numBehind === 2) {
    u12 = new Cartesian3_default();
    u22 = new Cartesian3_default();
  }
  if (numBehind === 1) {
    if (p0Behind) {
      IntersectionTests.lineSegmentPlane(p0, p1, plane, u12);
      IntersectionTests.lineSegmentPlane(p0, p2, plane, u22);
      return {
        positions: [p0, p1, p2, u12, u22],
        indices: [
          0,
          3,
          4,
          1,
          2,
          4,
          1,
          4,
          3
        ]
      };
    } else if (p1Behind) {
      IntersectionTests.lineSegmentPlane(p1, p2, plane, u12);
      IntersectionTests.lineSegmentPlane(p1, p0, plane, u22);
      return {
        positions: [p0, p1, p2, u12, u22],
        indices: [
          1,
          3,
          4,
          2,
          0,
          4,
          2,
          4,
          3
        ]
      };
    } else if (p2Behind) {
      IntersectionTests.lineSegmentPlane(p2, p0, plane, u12);
      IntersectionTests.lineSegmentPlane(p2, p1, plane, u22);
      return {
        positions: [p0, p1, p2, u12, u22],
        indices: [
          2,
          3,
          4,
          0,
          1,
          4,
          0,
          4,
          3
        ]
      };
    }
  } else if (numBehind === 2) {
    if (!p0Behind) {
      IntersectionTests.lineSegmentPlane(p1, p0, plane, u12);
      IntersectionTests.lineSegmentPlane(p2, p0, plane, u22);
      return {
        positions: [p0, p1, p2, u12, u22],
        indices: [
          1,
          2,
          4,
          1,
          4,
          3,
          0,
          3,
          4
        ]
      };
    } else if (!p1Behind) {
      IntersectionTests.lineSegmentPlane(p2, p1, plane, u12);
      IntersectionTests.lineSegmentPlane(p0, p1, plane, u22);
      return {
        positions: [p0, p1, p2, u12, u22],
        indices: [
          2,
          0,
          4,
          2,
          4,
          3,
          1,
          3,
          4
        ]
      };
    } else if (!p2Behind) {
      IntersectionTests.lineSegmentPlane(p0, p2, plane, u12);
      IntersectionTests.lineSegmentPlane(p1, p2, plane, u22);
      return {
        positions: [p0, p1, p2, u12, u22],
        indices: [
          0,
          1,
          4,
          0,
          4,
          3,
          2,
          3,
          4
        ]
      };
    }
  }
  return void 0;
};
var IntersectionTests_default = IntersectionTests;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/EllipsoidTangentPlane.js
var scratchCart4 = new Cartesian4_default();
function EllipsoidTangentPlane(origin, ellipsoid) {
  Check_default.defined("origin", origin);
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  origin = ellipsoid.scaleToGeodeticSurface(origin);
  if (!defined_default(origin)) {
    throw new DeveloperError_default(
      "origin must not be at the center of the ellipsoid."
    );
  }
  const eastNorthUp = Transforms_default.eastNorthUpToFixedFrame(origin, ellipsoid);
  this._ellipsoid = ellipsoid;
  this._origin = origin;
  this._xAxis = Cartesian3_default.fromCartesian4(
    Matrix4_default.getColumn(eastNorthUp, 0, scratchCart4)
  );
  this._yAxis = Cartesian3_default.fromCartesian4(
    Matrix4_default.getColumn(eastNorthUp, 1, scratchCart4)
  );
  const normal2 = Cartesian3_default.fromCartesian4(
    Matrix4_default.getColumn(eastNorthUp, 2, scratchCart4)
  );
  this._plane = Plane_default.fromPointNormal(origin, normal2);
}
Object.defineProperties(EllipsoidTangentPlane.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  origin: {
    get: function() {
      return this._origin;
    }
  },
  plane: {
    get: function() {
      return this._plane;
    }
  },
  xAxis: {
    get: function() {
      return this._xAxis;
    }
  },
  yAxis: {
    get: function() {
      return this._yAxis;
    }
  },
  zAxis: {
    get: function() {
      return this._plane.normal;
    }
  }
});
var tmp = new AxisAlignedBoundingBox_default();
EllipsoidTangentPlane.fromPoints = function(cartesians, ellipsoid) {
  Check_default.defined("cartesians", cartesians);
  const box = AxisAlignedBoundingBox_default.fromPoints(cartesians, tmp);
  return new EllipsoidTangentPlane(box.center, ellipsoid);
};
var scratchProjectPointOntoPlaneRay = new Ray_default();
var scratchProjectPointOntoPlaneCartesian3 = new Cartesian3_default();
EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(cartesian, result) {
  Check_default.defined("cartesian", cartesian);
  const ray = scratchProjectPointOntoPlaneRay;
  ray.origin = cartesian;
  Cartesian3_default.normalize(cartesian, ray.direction);
  let intersectionPoint = IntersectionTests_default.rayPlane(
    ray,
    this._plane,
    scratchProjectPointOntoPlaneCartesian3
  );
  if (!defined_default(intersectionPoint)) {
    Cartesian3_default.negate(ray.direction, ray.direction);
    intersectionPoint = IntersectionTests_default.rayPlane(
      ray,
      this._plane,
      scratchProjectPointOntoPlaneCartesian3
    );
  }
  if (defined_default(intersectionPoint)) {
    const v3 = Cartesian3_default.subtract(
      intersectionPoint,
      this._origin,
      intersectionPoint
    );
    const x = Cartesian3_default.dot(this._xAxis, v3);
    const y = Cartesian3_default.dot(this._yAxis, v3);
    if (!defined_default(result)) {
      return new Cartesian2_default(x, y);
    }
    result.x = x;
    result.y = y;
    return result;
  }
  return void 0;
};
EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(cartesians, result) {
  Check_default.defined("cartesians", cartesians);
  if (!defined_default(result)) {
    result = [];
  }
  let count = 0;
  const length = cartesians.length;
  for (let i = 0; i < length; i++) {
    const p = this.projectPointOntoPlane(cartesians[i], result[count]);
    if (defined_default(p)) {
      result[count] = p;
      count++;
    }
  }
  result.length = count;
  return result;
};
EllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function(cartesian, result) {
  Check_default.defined("cartesian", cartesian);
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  const ray = scratchProjectPointOntoPlaneRay;
  ray.origin = cartesian;
  Cartesian3_default.clone(this._plane.normal, ray.direction);
  let intersectionPoint = IntersectionTests_default.rayPlane(
    ray,
    this._plane,
    scratchProjectPointOntoPlaneCartesian3
  );
  if (!defined_default(intersectionPoint)) {
    Cartesian3_default.negate(ray.direction, ray.direction);
    intersectionPoint = IntersectionTests_default.rayPlane(
      ray,
      this._plane,
      scratchProjectPointOntoPlaneCartesian3
    );
  }
  const v3 = Cartesian3_default.subtract(
    intersectionPoint,
    this._origin,
    intersectionPoint
  );
  const x = Cartesian3_default.dot(this._xAxis, v3);
  const y = Cartesian3_default.dot(this._yAxis, v3);
  result.x = x;
  result.y = y;
  return result;
};
EllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function(cartesians, result) {
  Check_default.defined("cartesians", cartesians);
  if (!defined_default(result)) {
    result = [];
  }
  const length = cartesians.length;
  result.length = length;
  for (let i = 0; i < length; i++) {
    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);
  }
  return result;
};
var projectPointsOntoEllipsoidScratch = new Cartesian3_default();
EllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function(cartesian, result) {
  Check_default.defined("cartesian", cartesian);
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  const ellipsoid = this._ellipsoid;
  const origin = this._origin;
  const xAxis = this._xAxis;
  const yAxis = this._yAxis;
  const tmp2 = projectPointsOntoEllipsoidScratch;
  Cartesian3_default.multiplyByScalar(xAxis, cartesian.x, tmp2);
  result = Cartesian3_default.add(origin, tmp2, result);
  Cartesian3_default.multiplyByScalar(yAxis, cartesian.y, tmp2);
  Cartesian3_default.add(result, tmp2, result);
  ellipsoid.scaleToGeocentricSurface(result, result);
  return result;
};
EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(cartesians, result) {
  Check_default.defined("cartesians", cartesians);
  const length = cartesians.length;
  if (!defined_default(result)) {
    result = new Array(length);
  } else {
    result.length = length;
  }
  for (let i = 0; i < length; ++i) {
    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);
  }
  return result;
};
var EllipsoidTangentPlane_default = EllipsoidTangentPlane;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/OrientedBoundingBox.js
function OrientedBoundingBox(center, halfAxes) {
  this.center = Cartesian3_default.clone(defaultValue_default(center, Cartesian3_default.ZERO));
  this.halfAxes = Matrix3_default.clone(defaultValue_default(halfAxes, Matrix3_default.ZERO));
}
OrientedBoundingBox.packedLength = Cartesian3_default.packedLength + Matrix3_default.packedLength;
OrientedBoundingBox.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  Cartesian3_default.pack(value.center, array, startingIndex);
  Matrix3_default.pack(value.halfAxes, array, startingIndex + Cartesian3_default.packedLength);
  return array;
};
OrientedBoundingBox.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new OrientedBoundingBox();
  }
  Cartesian3_default.unpack(array, startingIndex, result.center);
  Matrix3_default.unpack(
    array,
    startingIndex + Cartesian3_default.packedLength,
    result.halfAxes
  );
  return result;
};
var scratchCartesian1 = new Cartesian3_default();
var scratchCartesian2 = new Cartesian3_default();
var scratchCartesian32 = new Cartesian3_default();
var scratchCartesian4 = new Cartesian3_default();
var scratchCartesian5 = new Cartesian3_default();
var scratchCartesian6 = new Cartesian3_default();
var scratchCovarianceResult = new Matrix3_default();
var scratchEigenResult = {
  unitary: new Matrix3_default(),
  diagonal: new Matrix3_default()
};
OrientedBoundingBox.fromPoints = function(positions, result) {
  if (!defined_default(result)) {
    result = new OrientedBoundingBox();
  }
  if (!defined_default(positions) || positions.length === 0) {
    result.halfAxes = Matrix3_default.ZERO;
    result.center = Cartesian3_default.ZERO;
    return result;
  }
  let i;
  const length = positions.length;
  const meanPoint = Cartesian3_default.clone(positions[0], scratchCartesian1);
  for (i = 1; i < length; i++) {
    Cartesian3_default.add(meanPoint, positions[i], meanPoint);
  }
  const invLength = 1 / length;
  Cartesian3_default.multiplyByScalar(meanPoint, invLength, meanPoint);
  let exx = 0;
  let exy = 0;
  let exz = 0;
  let eyy = 0;
  let eyz = 0;
  let ezz = 0;
  let p;
  for (i = 0; i < length; i++) {
    p = Cartesian3_default.subtract(positions[i], meanPoint, scratchCartesian2);
    exx += p.x * p.x;
    exy += p.x * p.y;
    exz += p.x * p.z;
    eyy += p.y * p.y;
    eyz += p.y * p.z;
    ezz += p.z * p.z;
  }
  exx *= invLength;
  exy *= invLength;
  exz *= invLength;
  eyy *= invLength;
  eyz *= invLength;
  ezz *= invLength;
  const covarianceMatrix = scratchCovarianceResult;
  covarianceMatrix[0] = exx;
  covarianceMatrix[1] = exy;
  covarianceMatrix[2] = exz;
  covarianceMatrix[3] = exy;
  covarianceMatrix[4] = eyy;
  covarianceMatrix[5] = eyz;
  covarianceMatrix[6] = exz;
  covarianceMatrix[7] = eyz;
  covarianceMatrix[8] = ezz;
  const eigenDecomposition = Matrix3_default.computeEigenDecomposition(
    covarianceMatrix,
    scratchEigenResult
  );
  const rotation = Matrix3_default.clone(eigenDecomposition.unitary, result.halfAxes);
  let v12 = Matrix3_default.getColumn(rotation, 0, scratchCartesian4);
  let v22 = Matrix3_default.getColumn(rotation, 1, scratchCartesian5);
  let v3 = Matrix3_default.getColumn(rotation, 2, scratchCartesian6);
  let u12 = -Number.MAX_VALUE;
  let u22 = -Number.MAX_VALUE;
  let u3 = -Number.MAX_VALUE;
  let l1 = Number.MAX_VALUE;
  let l2 = Number.MAX_VALUE;
  let l3 = Number.MAX_VALUE;
  for (i = 0; i < length; i++) {
    p = positions[i];
    u12 = Math.max(Cartesian3_default.dot(v12, p), u12);
    u22 = Math.max(Cartesian3_default.dot(v22, p), u22);
    u3 = Math.max(Cartesian3_default.dot(v3, p), u3);
    l1 = Math.min(Cartesian3_default.dot(v12, p), l1);
    l2 = Math.min(Cartesian3_default.dot(v22, p), l2);
    l3 = Math.min(Cartesian3_default.dot(v3, p), l3);
  }
  v12 = Cartesian3_default.multiplyByScalar(v12, 0.5 * (l1 + u12), v12);
  v22 = Cartesian3_default.multiplyByScalar(v22, 0.5 * (l2 + u22), v22);
  v3 = Cartesian3_default.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);
  const center = Cartesian3_default.add(v12, v22, result.center);
  Cartesian3_default.add(center, v3, center);
  const scale = scratchCartesian32;
  scale.x = u12 - l1;
  scale.y = u22 - l2;
  scale.z = u3 - l3;
  Cartesian3_default.multiplyByScalar(scale, 0.5, scale);
  Matrix3_default.multiplyByScale(result.halfAxes, scale, result.halfAxes);
  return result;
};
var scratchOffset = new Cartesian3_default();
var scratchScale2 = new Cartesian3_default();
function fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeZAxis, minimumX, maximumX, minimumY, maximumY, minimumZ, maximumZ, result) {
  if (!defined_default(minimumX) || !defined_default(maximumX) || !defined_default(minimumY) || !defined_default(maximumY) || !defined_default(minimumZ) || !defined_default(maximumZ)) {
    throw new DeveloperError_default(
      "all extents (minimum/maximum X/Y/Z) are required."
    );
  }
  if (!defined_default(result)) {
    result = new OrientedBoundingBox();
  }
  const halfAxes = result.halfAxes;
  Matrix3_default.setColumn(halfAxes, 0, planeXAxis, halfAxes);
  Matrix3_default.setColumn(halfAxes, 1, planeYAxis, halfAxes);
  Matrix3_default.setColumn(halfAxes, 2, planeZAxis, halfAxes);
  let centerOffset = scratchOffset;
  centerOffset.x = (minimumX + maximumX) / 2;
  centerOffset.y = (minimumY + maximumY) / 2;
  centerOffset.z = (minimumZ + maximumZ) / 2;
  const scale = scratchScale2;
  scale.x = (maximumX - minimumX) / 2;
  scale.y = (maximumY - minimumY) / 2;
  scale.z = (maximumZ - minimumZ) / 2;
  const center = result.center;
  centerOffset = Matrix3_default.multiplyByVector(halfAxes, centerOffset, centerOffset);
  Cartesian3_default.add(planeOrigin, centerOffset, center);
  Matrix3_default.multiplyByScale(halfAxes, scale, halfAxes);
  return result;
}
var scratchRectangleCenterCartographic = new Cartographic_default();
var scratchRectangleCenter = new Cartesian3_default();
var scratchPerimeterCartographicNC = new Cartographic_default();
var scratchPerimeterCartographicNW = new Cartographic_default();
var scratchPerimeterCartographicCW = new Cartographic_default();
var scratchPerimeterCartographicSW = new Cartographic_default();
var scratchPerimeterCartographicSC = new Cartographic_default();
var scratchPerimeterCartesianNC = new Cartesian3_default();
var scratchPerimeterCartesianNW = new Cartesian3_default();
var scratchPerimeterCartesianCW = new Cartesian3_default();
var scratchPerimeterCartesianSW = new Cartesian3_default();
var scratchPerimeterCartesianSC = new Cartesian3_default();
var scratchPerimeterProjectedNC = new Cartesian2_default();
var scratchPerimeterProjectedNW = new Cartesian2_default();
var scratchPerimeterProjectedCW = new Cartesian2_default();
var scratchPerimeterProjectedSW = new Cartesian2_default();
var scratchPerimeterProjectedSC = new Cartesian2_default();
var scratchPlaneOrigin = new Cartesian3_default();
var scratchPlaneNormal = new Cartesian3_default();
var scratchPlaneXAxis = new Cartesian3_default();
var scratchHorizonCartesian = new Cartesian3_default();
var scratchHorizonProjected = new Cartesian2_default();
var scratchMaxY = new Cartesian3_default();
var scratchMinY = new Cartesian3_default();
var scratchZ = new Cartesian3_default();
var scratchPlane = new Plane_default(Cartesian3_default.UNIT_X, 0);
OrientedBoundingBox.fromRectangle = function(rectangle, minimumHeight, maximumHeight, ellipsoid, result) {
  if (!defined_default(rectangle)) {
    throw new DeveloperError_default("rectangle is required");
  }
  if (rectangle.width < 0 || rectangle.width > Math_default.TWO_PI) {
    throw new DeveloperError_default("Rectangle width must be between 0 and 2*pi");
  }
  if (rectangle.height < 0 || rectangle.height > Math_default.PI) {
    throw new DeveloperError_default("Rectangle height must be between 0 and pi");
  }
  if (defined_default(ellipsoid) && !Math_default.equalsEpsilon(
    ellipsoid.radii.x,
    ellipsoid.radii.y,
    Math_default.EPSILON15
  )) {
    throw new DeveloperError_default(
      "Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)"
    );
  }
  minimumHeight = defaultValue_default(minimumHeight, 0);
  maximumHeight = defaultValue_default(maximumHeight, 0);
  ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  let minX, maxX, minY, maxY, minZ, maxZ, plane;
  if (rectangle.width <= Math_default.PI) {
    const tangentPointCartographic = Rectangle_default.center(
      rectangle,
      scratchRectangleCenterCartographic
    );
    const tangentPoint = ellipsoid.cartographicToCartesian(
      tangentPointCartographic,
      scratchRectangleCenter
    );
    const tangentPlane = new EllipsoidTangentPlane_default(tangentPoint, ellipsoid);
    plane = tangentPlane.plane;
    const lonCenter = tangentPointCartographic.longitude;
    const latCenter = rectangle.south < 0 && rectangle.north > 0 ? 0 : tangentPointCartographic.latitude;
    const perimeterCartographicNC = Cartographic_default.fromRadians(
      lonCenter,
      rectangle.north,
      maximumHeight,
      scratchPerimeterCartographicNC
    );
    const perimeterCartographicNW = Cartographic_default.fromRadians(
      rectangle.west,
      rectangle.north,
      maximumHeight,
      scratchPerimeterCartographicNW
    );
    const perimeterCartographicCW = Cartographic_default.fromRadians(
      rectangle.west,
      latCenter,
      maximumHeight,
      scratchPerimeterCartographicCW
    );
    const perimeterCartographicSW = Cartographic_default.fromRadians(
      rectangle.west,
      rectangle.south,
      maximumHeight,
      scratchPerimeterCartographicSW
    );
    const perimeterCartographicSC = Cartographic_default.fromRadians(
      lonCenter,
      rectangle.south,
      maximumHeight,
      scratchPerimeterCartographicSC
    );
    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(
      perimeterCartographicNC,
      scratchPerimeterCartesianNC
    );
    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(
      perimeterCartographicNW,
      scratchPerimeterCartesianNW
    );
    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(
      perimeterCartographicCW,
      scratchPerimeterCartesianCW
    );
    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(
      perimeterCartographicSW,
      scratchPerimeterCartesianSW
    );
    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(
      perimeterCartographicSC,
      scratchPerimeterCartesianSC
    );
    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(
      perimeterCartesianNC,
      scratchPerimeterProjectedNC
    );
    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(
      perimeterCartesianNW,
      scratchPerimeterProjectedNW
    );
    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(
      perimeterCartesianCW,
      scratchPerimeterProjectedCW
    );
    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(
      perimeterCartesianSW,
      scratchPerimeterProjectedSW
    );
    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(
      perimeterCartesianSC,
      scratchPerimeterProjectedSC
    );
    minX = Math.min(
      perimeterProjectedNW.x,
      perimeterProjectedCW.x,
      perimeterProjectedSW.x
    );
    maxX = -minX;
    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);
    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);
    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;
    perimeterCartesianNW = ellipsoid.cartographicToCartesian(
      perimeterCartographicNW,
      scratchPerimeterCartesianNW
    );
    perimeterCartesianSW = ellipsoid.cartographicToCartesian(
      perimeterCartographicSW,
      scratchPerimeterCartesianSW
    );
    minZ = Math.min(
      Plane_default.getPointDistance(plane, perimeterCartesianNW),
      Plane_default.getPointDistance(plane, perimeterCartesianSW)
    );
    maxZ = maximumHeight;
    return fromPlaneExtents(
      tangentPlane.origin,
      tangentPlane.xAxis,
      tangentPlane.yAxis,
      tangentPlane.zAxis,
      minX,
      maxX,
      minY,
      maxY,
      minZ,
      maxZ,
      result
    );
  }
  const fullyAboveEquator = rectangle.south > 0;
  const fullyBelowEquator = rectangle.north < 0;
  const latitudeNearestToEquator = fullyAboveEquator ? rectangle.south : fullyBelowEquator ? rectangle.north : 0;
  const centerLongitude = Rectangle_default.center(
    rectangle,
    scratchRectangleCenterCartographic
  ).longitude;
  const planeOrigin = Cartesian3_default.fromRadians(
    centerLongitude,
    latitudeNearestToEquator,
    maximumHeight,
    ellipsoid,
    scratchPlaneOrigin
  );
  planeOrigin.z = 0;
  const isPole = Math.abs(planeOrigin.x) < Math_default.EPSILON10 && Math.abs(planeOrigin.y) < Math_default.EPSILON10;
  const planeNormal = !isPole ? Cartesian3_default.normalize(planeOrigin, scratchPlaneNormal) : Cartesian3_default.UNIT_X;
  const planeYAxis = Cartesian3_default.UNIT_Z;
  const planeXAxis = Cartesian3_default.cross(
    planeNormal,
    planeYAxis,
    scratchPlaneXAxis
  );
  plane = Plane_default.fromPointNormal(planeOrigin, planeNormal, scratchPlane);
  const horizonCartesian = Cartesian3_default.fromRadians(
    centerLongitude + Math_default.PI_OVER_TWO,
    latitudeNearestToEquator,
    maximumHeight,
    ellipsoid,
    scratchHorizonCartesian
  );
  maxX = Cartesian3_default.dot(
    Plane_default.projectPointOntoPlane(
      plane,
      horizonCartesian,
      scratchHorizonProjected
    ),
    planeXAxis
  );
  minX = -maxX;
  maxY = Cartesian3_default.fromRadians(
    0,
    rectangle.north,
    fullyBelowEquator ? minimumHeight : maximumHeight,
    ellipsoid,
    scratchMaxY
  ).z;
  minY = Cartesian3_default.fromRadians(
    0,
    rectangle.south,
    fullyAboveEquator ? minimumHeight : maximumHeight,
    ellipsoid,
    scratchMinY
  ).z;
  const farZ = Cartesian3_default.fromRadians(
    rectangle.east,
    latitudeNearestToEquator,
    maximumHeight,
    ellipsoid,
    scratchZ
  );
  minZ = Plane_default.getPointDistance(plane, farZ);
  maxZ = 0;
  return fromPlaneExtents(
    planeOrigin,
    planeXAxis,
    planeYAxis,
    planeNormal,
    minX,
    maxX,
    minY,
    maxY,
    minZ,
    maxZ,
    result
  );
};
OrientedBoundingBox.fromTransformation = function(transformation, result) {
  Check_default.typeOf.object("transformation", transformation);
  if (!defined_default(result)) {
    result = new OrientedBoundingBox();
  }
  result.center = Matrix4_default.getTranslation(transformation, result.center);
  result.halfAxes = Matrix4_default.getMatrix3(transformation, result.halfAxes);
  result.halfAxes = Matrix3_default.multiplyByScalar(
    result.halfAxes,
    0.5,
    result.halfAxes
  );
  return result;
};
OrientedBoundingBox.clone = function(box, result) {
  if (!defined_default(box)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new OrientedBoundingBox(box.center, box.halfAxes);
  }
  Cartesian3_default.clone(box.center, result.center);
  Matrix3_default.clone(box.halfAxes, result.halfAxes);
  return result;
};
OrientedBoundingBox.intersectPlane = function(box, plane) {
  if (!defined_default(box)) {
    throw new DeveloperError_default("box is required.");
  }
  if (!defined_default(plane)) {
    throw new DeveloperError_default("plane is required.");
  }
  const center = box.center;
  const normal2 = plane.normal;
  const halfAxes = box.halfAxes;
  const normalX = normal2.x, normalY = normal2.y, normalZ = normal2.z;
  const radEffective = Math.abs(
    normalX * halfAxes[Matrix3_default.COLUMN0ROW0] + normalY * halfAxes[Matrix3_default.COLUMN0ROW1] + normalZ * halfAxes[Matrix3_default.COLUMN0ROW2]
  ) + Math.abs(
    normalX * halfAxes[Matrix3_default.COLUMN1ROW0] + normalY * halfAxes[Matrix3_default.COLUMN1ROW1] + normalZ * halfAxes[Matrix3_default.COLUMN1ROW2]
  ) + Math.abs(
    normalX * halfAxes[Matrix3_default.COLUMN2ROW0] + normalY * halfAxes[Matrix3_default.COLUMN2ROW1] + normalZ * halfAxes[Matrix3_default.COLUMN2ROW2]
  );
  const distanceToPlane = Cartesian3_default.dot(normal2, center) + plane.distance;
  if (distanceToPlane <= -radEffective) {
    return Intersect_default.OUTSIDE;
  } else if (distanceToPlane >= radEffective) {
    return Intersect_default.INSIDE;
  }
  return Intersect_default.INTERSECTING;
};
var scratchCartesianU = new Cartesian3_default();
var scratchCartesianV = new Cartesian3_default();
var scratchCartesianW = new Cartesian3_default();
var scratchValidAxis2 = new Cartesian3_default();
var scratchValidAxis3 = new Cartesian3_default();
var scratchPPrime = new Cartesian3_default();
OrientedBoundingBox.distanceSquaredTo = function(box, cartesian) {
  if (!defined_default(box)) {
    throw new DeveloperError_default("box is required.");
  }
  if (!defined_default(cartesian)) {
    throw new DeveloperError_default("cartesian is required.");
  }
  const offset = Cartesian3_default.subtract(cartesian, box.center, scratchOffset);
  const halfAxes = box.halfAxes;
  let u3 = Matrix3_default.getColumn(halfAxes, 0, scratchCartesianU);
  let v3 = Matrix3_default.getColumn(halfAxes, 1, scratchCartesianV);
  let w = Matrix3_default.getColumn(halfAxes, 2, scratchCartesianW);
  const uHalf = Cartesian3_default.magnitude(u3);
  const vHalf = Cartesian3_default.magnitude(v3);
  const wHalf = Cartesian3_default.magnitude(w);
  let uValid = true;
  let vValid = true;
  let wValid = true;
  if (uHalf > 0) {
    Cartesian3_default.divideByScalar(u3, uHalf, u3);
  } else {
    uValid = false;
  }
  if (vHalf > 0) {
    Cartesian3_default.divideByScalar(v3, vHalf, v3);
  } else {
    vValid = false;
  }
  if (wHalf > 0) {
    Cartesian3_default.divideByScalar(w, wHalf, w);
  } else {
    wValid = false;
  }
  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;
  let validAxis1;
  let validAxis2;
  let validAxis3;
  if (numberOfDegenerateAxes === 1) {
    let degenerateAxis = u3;
    validAxis1 = v3;
    validAxis2 = w;
    if (!vValid) {
      degenerateAxis = v3;
      validAxis1 = u3;
    } else if (!wValid) {
      degenerateAxis = w;
      validAxis2 = u3;
    }
    validAxis3 = Cartesian3_default.cross(validAxis1, validAxis2, scratchValidAxis3);
    if (degenerateAxis === u3) {
      u3 = validAxis3;
    } else if (degenerateAxis === v3) {
      v3 = validAxis3;
    } else if (degenerateAxis === w) {
      w = validAxis3;
    }
  } else if (numberOfDegenerateAxes === 2) {
    validAxis1 = u3;
    if (vValid) {
      validAxis1 = v3;
    } else if (wValid) {
      validAxis1 = w;
    }
    let crossVector = Cartesian3_default.UNIT_Y;
    if (crossVector.equalsEpsilon(validAxis1, Math_default.EPSILON3)) {
      crossVector = Cartesian3_default.UNIT_X;
    }
    validAxis2 = Cartesian3_default.cross(validAxis1, crossVector, scratchValidAxis2);
    Cartesian3_default.normalize(validAxis2, validAxis2);
    validAxis3 = Cartesian3_default.cross(validAxis1, validAxis2, scratchValidAxis3);
    Cartesian3_default.normalize(validAxis3, validAxis3);
    if (validAxis1 === u3) {
      v3 = validAxis2;
      w = validAxis3;
    } else if (validAxis1 === v3) {
      w = validAxis2;
      u3 = validAxis3;
    } else if (validAxis1 === w) {
      u3 = validAxis2;
      v3 = validAxis3;
    }
  } else if (numberOfDegenerateAxes === 3) {
    u3 = Cartesian3_default.UNIT_X;
    v3 = Cartesian3_default.UNIT_Y;
    w = Cartesian3_default.UNIT_Z;
  }
  const pPrime = scratchPPrime;
  pPrime.x = Cartesian3_default.dot(offset, u3);
  pPrime.y = Cartesian3_default.dot(offset, v3);
  pPrime.z = Cartesian3_default.dot(offset, w);
  let distanceSquared = 0;
  let d;
  if (pPrime.x < -uHalf) {
    d = pPrime.x + uHalf;
    distanceSquared += d * d;
  } else if (pPrime.x > uHalf) {
    d = pPrime.x - uHalf;
    distanceSquared += d * d;
  }
  if (pPrime.y < -vHalf) {
    d = pPrime.y + vHalf;
    distanceSquared += d * d;
  } else if (pPrime.y > vHalf) {
    d = pPrime.y - vHalf;
    distanceSquared += d * d;
  }
  if (pPrime.z < -wHalf) {
    d = pPrime.z + wHalf;
    distanceSquared += d * d;
  } else if (pPrime.z > wHalf) {
    d = pPrime.z - wHalf;
    distanceSquared += d * d;
  }
  return distanceSquared;
};
var scratchCorner = new Cartesian3_default();
var scratchToCenter = new Cartesian3_default();
OrientedBoundingBox.computePlaneDistances = function(box, position, direction2, result) {
  if (!defined_default(box)) {
    throw new DeveloperError_default("box is required.");
  }
  if (!defined_default(position)) {
    throw new DeveloperError_default("position is required.");
  }
  if (!defined_default(direction2)) {
    throw new DeveloperError_default("direction is required.");
  }
  if (!defined_default(result)) {
    result = new Interval_default();
  }
  let minDist = Number.POSITIVE_INFINITY;
  let maxDist = Number.NEGATIVE_INFINITY;
  const center = box.center;
  const halfAxes = box.halfAxes;
  const u3 = Matrix3_default.getColumn(halfAxes, 0, scratchCartesianU);
  const v3 = Matrix3_default.getColumn(halfAxes, 1, scratchCartesianV);
  const w = Matrix3_default.getColumn(halfAxes, 2, scratchCartesianW);
  const corner = Cartesian3_default.add(u3, v3, scratchCorner);
  Cartesian3_default.add(corner, w, corner);
  Cartesian3_default.add(corner, center, corner);
  const toCenter = Cartesian3_default.subtract(corner, position, scratchToCenter);
  let mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  Cartesian3_default.add(center, u3, corner);
  Cartesian3_default.add(corner, v3, corner);
  Cartesian3_default.subtract(corner, w, corner);
  Cartesian3_default.subtract(corner, position, toCenter);
  mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  Cartesian3_default.add(center, u3, corner);
  Cartesian3_default.subtract(corner, v3, corner);
  Cartesian3_default.add(corner, w, corner);
  Cartesian3_default.subtract(corner, position, toCenter);
  mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  Cartesian3_default.add(center, u3, corner);
  Cartesian3_default.subtract(corner, v3, corner);
  Cartesian3_default.subtract(corner, w, corner);
  Cartesian3_default.subtract(corner, position, toCenter);
  mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  Cartesian3_default.subtract(center, u3, corner);
  Cartesian3_default.add(corner, v3, corner);
  Cartesian3_default.add(corner, w, corner);
  Cartesian3_default.subtract(corner, position, toCenter);
  mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  Cartesian3_default.subtract(center, u3, corner);
  Cartesian3_default.add(corner, v3, corner);
  Cartesian3_default.subtract(corner, w, corner);
  Cartesian3_default.subtract(corner, position, toCenter);
  mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  Cartesian3_default.subtract(center, u3, corner);
  Cartesian3_default.subtract(corner, v3, corner);
  Cartesian3_default.add(corner, w, corner);
  Cartesian3_default.subtract(corner, position, toCenter);
  mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  Cartesian3_default.subtract(center, u3, corner);
  Cartesian3_default.subtract(corner, v3, corner);
  Cartesian3_default.subtract(corner, w, corner);
  Cartesian3_default.subtract(corner, position, toCenter);
  mag = Cartesian3_default.dot(direction2, toCenter);
  minDist = Math.min(mag, minDist);
  maxDist = Math.max(mag, maxDist);
  result.start = minDist;
  result.stop = maxDist;
  return result;
};
var scratchXAxis = new Cartesian3_default();
var scratchYAxis = new Cartesian3_default();
var scratchZAxis = new Cartesian3_default();
OrientedBoundingBox.computeCorners = function(box, result) {
  Check_default.typeOf.object("box", box);
  if (!defined_default(result)) {
    result = [
      new Cartesian3_default(),
      new Cartesian3_default(),
      new Cartesian3_default(),
      new Cartesian3_default(),
      new Cartesian3_default(),
      new Cartesian3_default(),
      new Cartesian3_default(),
      new Cartesian3_default()
    ];
  }
  const center = box.center;
  const halfAxes = box.halfAxes;
  const xAxis = Matrix3_default.getColumn(halfAxes, 0, scratchXAxis);
  const yAxis = Matrix3_default.getColumn(halfAxes, 1, scratchYAxis);
  const zAxis = Matrix3_default.getColumn(halfAxes, 2, scratchZAxis);
  Cartesian3_default.clone(center, result[0]);
  Cartesian3_default.subtract(result[0], xAxis, result[0]);
  Cartesian3_default.subtract(result[0], yAxis, result[0]);
  Cartesian3_default.subtract(result[0], zAxis, result[0]);
  Cartesian3_default.clone(center, result[1]);
  Cartesian3_default.subtract(result[1], xAxis, result[1]);
  Cartesian3_default.subtract(result[1], yAxis, result[1]);
  Cartesian3_default.add(result[1], zAxis, result[1]);
  Cartesian3_default.clone(center, result[2]);
  Cartesian3_default.subtract(result[2], xAxis, result[2]);
  Cartesian3_default.add(result[2], yAxis, result[2]);
  Cartesian3_default.subtract(result[2], zAxis, result[2]);
  Cartesian3_default.clone(center, result[3]);
  Cartesian3_default.subtract(result[3], xAxis, result[3]);
  Cartesian3_default.add(result[3], yAxis, result[3]);
  Cartesian3_default.add(result[3], zAxis, result[3]);
  Cartesian3_default.clone(center, result[4]);
  Cartesian3_default.add(result[4], xAxis, result[4]);
  Cartesian3_default.subtract(result[4], yAxis, result[4]);
  Cartesian3_default.subtract(result[4], zAxis, result[4]);
  Cartesian3_default.clone(center, result[5]);
  Cartesian3_default.add(result[5], xAxis, result[5]);
  Cartesian3_default.subtract(result[5], yAxis, result[5]);
  Cartesian3_default.add(result[5], zAxis, result[5]);
  Cartesian3_default.clone(center, result[6]);
  Cartesian3_default.add(result[6], xAxis, result[6]);
  Cartesian3_default.add(result[6], yAxis, result[6]);
  Cartesian3_default.subtract(result[6], zAxis, result[6]);
  Cartesian3_default.clone(center, result[7]);
  Cartesian3_default.add(result[7], xAxis, result[7]);
  Cartesian3_default.add(result[7], yAxis, result[7]);
  Cartesian3_default.add(result[7], zAxis, result[7]);
  return result;
};
var scratchRotationScale = new Matrix3_default();
OrientedBoundingBox.computeTransformation = function(box, result) {
  Check_default.typeOf.object("box", box);
  if (!defined_default(result)) {
    result = new Matrix4_default();
  }
  const translation = box.center;
  const rotationScale = Matrix3_default.multiplyByUniformScale(
    box.halfAxes,
    2,
    scratchRotationScale
  );
  return Matrix4_default.fromRotationTranslation(rotationScale, translation, result);
};
var scratchBoundingSphere2 = new BoundingSphere_default();
OrientedBoundingBox.isOccluded = function(box, occluder) {
  if (!defined_default(box)) {
    throw new DeveloperError_default("box is required.");
  }
  if (!defined_default(occluder)) {
    throw new DeveloperError_default("occluder is required.");
  }
  const sphere = BoundingSphere_default.fromOrientedBoundingBox(
    box,
    scratchBoundingSphere2
  );
  return !occluder.isBoundingSphereVisible(sphere);
};
OrientedBoundingBox.prototype.intersectPlane = function(plane) {
  return OrientedBoundingBox.intersectPlane(this, plane);
};
OrientedBoundingBox.prototype.distanceSquaredTo = function(cartesian) {
  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);
};
OrientedBoundingBox.prototype.computePlaneDistances = function(position, direction2, result) {
  return OrientedBoundingBox.computePlaneDistances(
    this,
    position,
    direction2,
    result
  );
};
OrientedBoundingBox.prototype.computeCorners = function(result) {
  return OrientedBoundingBox.computeCorners(this, result);
};
OrientedBoundingBox.prototype.computeTransformation = function(result) {
  return OrientedBoundingBox.computeTransformation(this, result);
};
OrientedBoundingBox.prototype.isOccluded = function(occluder) {
  return OrientedBoundingBox.isOccluded(this, occluder);
};
OrientedBoundingBox.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && Cartesian3_default.equals(left.center, right.center) && Matrix3_default.equals(left.halfAxes, right.halfAxes);
};
OrientedBoundingBox.prototype.clone = function(result) {
  return OrientedBoundingBox.clone(this, result);
};
OrientedBoundingBox.prototype.equals = function(right) {
  return OrientedBoundingBox.equals(this, right);
};
var OrientedBoundingBox_default = OrientedBoundingBox;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/TerrainExaggeration.js
var TerrainExaggeration = {};
TerrainExaggeration.getHeight = function(height, scale, relativeHeight) {
  return (height - relativeHeight) * scale + relativeHeight;
};
var scratchCartographic2 = new Cartesian3_default();
TerrainExaggeration.getPosition = function(position, ellipsoid, terrainExaggeration, terrainExaggerationRelativeHeight, result) {
  const cartographic = ellipsoid.cartesianToCartographic(
    position,
    scratchCartographic2
  );
  const newHeight = TerrainExaggeration.getHeight(
    cartographic.height,
    terrainExaggeration,
    terrainExaggerationRelativeHeight
  );
  return Cartesian3_default.fromRadians(
    cartographic.longitude,
    cartographic.latitude,
    newHeight,
    ellipsoid,
    result
  );
};
var TerrainExaggeration_default = TerrainExaggeration;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/ShadowVolumeAppearanceVS.js
var ShadowVolumeAppearanceVS_default = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute float batchId;\n\n#ifdef EXTRUDED_GEOMETRY\nattribute vec3 extrudeDirection;\n\nuniform float u_globeMinimumAltitude;\n#endif // EXTRUDED_GEOMETRY\n\n#ifdef PER_INSTANCE_COLOR\nvarying vec4 v_color;\n#endif // PER_INSTANCE_COLOR\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nvarying vec4 v_sphericalExtents;\n#else // SPHERICAL\nvarying vec2 v_inversePlaneExtents;\nvarying vec4 v_westPlane;\nvarying vec4 v_southPlane;\n#endif // SPHERICAL\nvarying vec3 v_uvMinAndSphericalLongitudeRotation;\nvarying vec3 v_uMaxAndInverseDistance;\nvarying vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\nvoid main()\n{\n    vec4 position = czm_computePosition();\n\n#ifdef EXTRUDED_GEOMETRY\n    float delta = min(u_globeMinimumAltitude, czm_geometricToleranceOverMeter * length(position.xyz));\n    delta *= czm_sceneMode == czm_sceneMode3D ? 1.0 : 0.0;\n\n    //extrudeDirection is zero for the top layer\n    position = position + vec4(extrudeDirection * delta, 0.0);\n#endif\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\n    v_sphericalExtents = czm_batchTable_sphericalExtents(batchId);\n    v_uvMinAndSphericalLongitudeRotation.z = czm_batchTable_longitudeRotation(batchId);\n#else // SPHERICAL\n#ifdef COLUMBUS_VIEW_2D\n    vec4 planes2D_high = czm_batchTable_planes2D_HIGH(batchId);\n    vec4 planes2D_low = czm_batchTable_planes2D_LOW(batchId);\n\n    // If the primitive is split across the IDL (planes2D_high.x > planes2D_high.w):\n    // - If this vertex is on the east side of the IDL (position3DLow.y > 0.0, comparison with position3DHigh may produce artifacts)\n    // - existing "east" is on the wrong side of the world, far away (planes2D_high/low.w)\n    // - so set "east" as beyond the eastmost extent of the projection (idlSplitNewPlaneHiLow)\n    vec2 idlSplitNewPlaneHiLow = vec2(EAST_MOST_X_HIGH - (WEST_MOST_X_HIGH - planes2D_high.w), EAST_MOST_X_LOW - (WEST_MOST_X_LOW - planes2D_low.w));\n    bool idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y > 0.0;\n    planes2D_high.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.w);\n    planes2D_low.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.w);\n\n    // - else, if this vertex is on the west side of the IDL (position3DLow.y < 0.0)\n    // - existing "west" is on the wrong side of the world, far away (planes2D_high/low.x)\n    // - so set "west" as beyond the westmost extent of the projection (idlSplitNewPlaneHiLow)\n    idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y < 0.0;\n    idlSplitNewPlaneHiLow = vec2(WEST_MOST_X_HIGH - (EAST_MOST_X_HIGH - planes2D_high.x), WEST_MOST_X_LOW - (EAST_MOST_X_LOW - planes2D_low.x));\n    planes2D_high.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.x);\n    planes2D_low.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.x);\n\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.xy), vec3(0.0, planes2D_low.xy))).xyz;\n    vec3 northWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.x, planes2D_high.z), vec3(0.0, planes2D_low.x, planes2D_low.z))).xyz;\n    vec3 southEastCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.w, planes2D_high.y), vec3(0.0, planes2D_low.w, planes2D_low.y))).xyz;\n#else // COLUMBUS_VIEW_2D\n    // 3D case has smaller "plane extents," so planes encoded as a 64 bit position and 2 vec3s for distances/direction\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(czm_batchTable_southWest_HIGH(batchId), czm_batchTable_southWest_LOW(batchId))).xyz;\n    vec3 northWestCorner = czm_normal * czm_batchTable_northward(batchId) + southWestCorner;\n    vec3 southEastCorner = czm_normal * czm_batchTable_eastward(batchId) + southWestCorner;\n#endif // COLUMBUS_VIEW_2D\n\n    vec3 eastWard = southEastCorner - southWestCorner;\n    float eastExtent = length(eastWard);\n    eastWard /= eastExtent;\n\n    vec3 northWard = northWestCorner - southWestCorner;\n    float northExtent = length(northWard);\n    northWard /= northExtent;\n\n    v_westPlane = vec4(eastWard, -dot(eastWard, southWestCorner));\n    v_southPlane = vec4(northWard, -dot(northWard, southWestCorner));\n    v_inversePlaneExtents = vec2(1.0 / eastExtent, 1.0 / northExtent);\n#endif // SPHERICAL\n    vec4 uvMinAndExtents = czm_batchTable_uvMinAndExtents(batchId);\n    vec4 uMaxVmax = czm_batchTable_uMaxVmax(batchId);\n\n    v_uMaxAndInverseDistance = vec3(uMaxVmax.xy, uvMinAndExtents.z);\n    v_vMaxAndInverseDistance = vec3(uMaxVmax.zw, uvMinAndExtents.w);\n    v_uvMinAndSphericalLongitudeRotation.xy = uvMinAndExtents.xy;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif\n\n    gl_Position = czm_depthClamp(czm_modelViewProjectionRelativeToEye * position);\n}\n';

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/ShadowVolumeFS.js
var ShadowVolumeFS_default = "#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n\n#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvoid main(void)\n{\n#ifdef VECTOR_TILE\n    gl_FragColor = czm_gammaCorrect(u_highlightColor);\n#else\n    gl_FragColor = vec4(1.0);\n#endif\n    czm_writeDepthClamp();\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/ClassificationType.js
var ClassificationType = {
  TERRAIN: 0,
  CESIUM_3D_TILE: 1,
  BOTH: 2
};
ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES = 3;
var ClassificationType_default = Object.freeze(ClassificationType);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/DepthFunction.js
var DepthFunction = {
  NEVER: WebGLConstants_default.NEVER,
  LESS: WebGLConstants_default.LESS,
  EQUAL: WebGLConstants_default.EQUAL,
  LESS_OR_EQUAL: WebGLConstants_default.LEQUAL,
  GREATER: WebGLConstants_default.GREATER,
  NOT_EQUAL: WebGLConstants_default.NOTEQUAL,
  GREATER_OR_EQUAL: WebGLConstants_default.GEQUAL,
  ALWAYS: WebGLConstants_default.ALWAYS
};
var DepthFunction_default = Object.freeze(DepthFunction);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/subdivideArray.js
function subdivideArray(array, numberOfArrays) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required.");
  }
  if (!defined_default(numberOfArrays) || numberOfArrays < 1) {
    throw new DeveloperError_default("numberOfArrays must be greater than 0.");
  }
  const result = [];
  const len = array.length;
  let i = 0;
  while (i < len) {
    const size = Math.ceil((len - i) / numberOfArrays--);
    result.push(array.slice(i, i + size));
    i += size;
  }
  return result;
}
var subdivideArray_default = subdivideArray;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/BatchTable.js
function BatchTable(context, attributes, numberOfInstances) {
  if (!defined_default(context)) {
    throw new DeveloperError_default("context is required");
  }
  if (!defined_default(attributes)) {
    throw new DeveloperError_default("attributes is required");
  }
  if (!defined_default(numberOfInstances)) {
    throw new DeveloperError_default("numberOfInstances is required");
  }
  this._attributes = attributes;
  this._numberOfInstances = numberOfInstances;
  if (attributes.length === 0) {
    return;
  }
  const pixelDatatype = getDatatype(attributes);
  const textureFloatSupported = context.floatingPointTexture;
  const packFloats = pixelDatatype === PixelDatatype_default.FLOAT && !textureFloatSupported;
  const offsets = createOffsets(attributes, packFloats);
  const stride = getStride(offsets, attributes, packFloats);
  const maxNumberOfInstancesPerRow = Math.floor(
    ContextLimits_default.maximumTextureSize / stride
  );
  const instancesPerWidth = Math.min(
    numberOfInstances,
    maxNumberOfInstancesPerRow
  );
  const width = stride * instancesPerWidth;
  const height = Math.ceil(numberOfInstances / instancesPerWidth);
  const stepX = 1 / width;
  const centerX = stepX * 0.5;
  const stepY = 1 / height;
  const centerY = stepY * 0.5;
  this._textureDimensions = new Cartesian2_default(width, height);
  this._textureStep = new Cartesian4_default(stepX, centerX, stepY, centerY);
  this._pixelDatatype = !packFloats ? pixelDatatype : PixelDatatype_default.UNSIGNED_BYTE;
  this._packFloats = packFloats;
  this._offsets = offsets;
  this._stride = stride;
  this._texture = void 0;
  const batchLength = 4 * width * height;
  this._batchValues = pixelDatatype === PixelDatatype_default.FLOAT && !packFloats ? new Float32Array(batchLength) : new Uint8Array(batchLength);
  this._batchValuesDirty = false;
}
Object.defineProperties(BatchTable.prototype, {
  attributes: {
    get: function() {
      return this._attributes;
    }
  },
  numberOfInstances: {
    get: function() {
      return this._numberOfInstances;
    }
  }
});
function getDatatype(attributes) {
  let foundFloatDatatype = false;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    if (attributes[i].componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE) {
      foundFloatDatatype = true;
      break;
    }
  }
  return foundFloatDatatype ? PixelDatatype_default.FLOAT : PixelDatatype_default.UNSIGNED_BYTE;
}
function getAttributeType(attributes, attributeIndex) {
  const componentsPerAttribute = attributes[attributeIndex].componentsPerAttribute;
  if (componentsPerAttribute === 2) {
    return Cartesian2_default;
  } else if (componentsPerAttribute === 3) {
    return Cartesian3_default;
  } else if (componentsPerAttribute === 4) {
    return Cartesian4_default;
  }
  return Number;
}
function createOffsets(attributes, packFloats) {
  const offsets = new Array(attributes.length);
  let currentOffset = 0;
  const attributesLength = attributes.length;
  for (let i = 0; i < attributesLength; ++i) {
    const attribute = attributes[i];
    const componentDatatype = attribute.componentDatatype;
    offsets[i] = currentOffset;
    if (componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE && packFloats) {
      currentOffset += 4;
    } else {
      ++currentOffset;
    }
  }
  return offsets;
}
function getStride(offsets, attributes, packFloats) {
  const length = offsets.length;
  const lastOffset = offsets[length - 1];
  const lastAttribute = attributes[length - 1];
  const componentDatatype = lastAttribute.componentDatatype;
  if (componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE && packFloats) {
    return lastOffset + 4;
  }
  return lastOffset + 1;
}
var scratchPackedFloatCartesian4 = new Cartesian4_default();
function getPackedFloat(array, index, result) {
  let packed = Cartesian4_default.unpack(array, index, scratchPackedFloatCartesian4);
  const x = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 4, scratchPackedFloatCartesian4);
  const y = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 8, scratchPackedFloatCartesian4);
  const z = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 12, scratchPackedFloatCartesian4);
  const w = Cartesian4_default.unpackFloat(packed);
  return Cartesian4_default.fromElements(x, y, z, w, result);
}
function setPackedAttribute(value, array, index) {
  let packed = Cartesian4_default.packFloat(value.x, scratchPackedFloatCartesian4);
  Cartesian4_default.pack(packed, array, index);
  packed = Cartesian4_default.packFloat(value.y, packed);
  Cartesian4_default.pack(packed, array, index + 4);
  packed = Cartesian4_default.packFloat(value.z, packed);
  Cartesian4_default.pack(packed, array, index + 8);
  packed = Cartesian4_default.packFloat(value.w, packed);
  Cartesian4_default.pack(packed, array, index + 12);
}
var scratchGetAttributeCartesian4 = new Cartesian4_default();
BatchTable.prototype.getBatchedAttribute = function(instanceIndex, attributeIndex, result) {
  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {
    throw new DeveloperError_default("instanceIndex is out of range.");
  }
  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {
    throw new DeveloperError_default("attributeIndex is out of range");
  }
  const attributes = this._attributes;
  const offset = this._offsets[attributeIndex];
  const stride = this._stride;
  const index = 4 * stride * instanceIndex + 4 * offset;
  let value;
  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    value = getPackedFloat(
      this._batchValues,
      index,
      scratchGetAttributeCartesian4
    );
  } else {
    value = Cartesian4_default.unpack(
      this._batchValues,
      index,
      scratchGetAttributeCartesian4
    );
  }
  const attributeType = getAttributeType(attributes, attributeIndex);
  if (defined_default(attributeType.fromCartesian4)) {
    return attributeType.fromCartesian4(value, result);
  } else if (defined_default(attributeType.clone)) {
    return attributeType.clone(value, result);
  }
  return value.x;
};
var setAttributeScratchValues = [
  void 0,
  void 0,
  new Cartesian2_default(),
  new Cartesian3_default(),
  new Cartesian4_default()
];
var setAttributeScratchCartesian4 = new Cartesian4_default();
BatchTable.prototype.setBatchedAttribute = function(instanceIndex, attributeIndex, value) {
  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {
    throw new DeveloperError_default("instanceIndex is out of range.");
  }
  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {
    throw new DeveloperError_default("attributeIndex is out of range");
  }
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required.");
  }
  const attributes = this._attributes;
  const result = setAttributeScratchValues[attributes[attributeIndex].componentsPerAttribute];
  const currentAttribute = this.getBatchedAttribute(
    instanceIndex,
    attributeIndex,
    result
  );
  const attributeType = getAttributeType(this._attributes, attributeIndex);
  const entriesEqual = defined_default(attributeType.equals) ? attributeType.equals(currentAttribute, value) : currentAttribute === value;
  if (entriesEqual) {
    return;
  }
  const attributeValue = setAttributeScratchCartesian4;
  attributeValue.x = defined_default(value.x) ? value.x : value;
  attributeValue.y = defined_default(value.y) ? value.y : 0;
  attributeValue.z = defined_default(value.z) ? value.z : 0;
  attributeValue.w = defined_default(value.w) ? value.w : 0;
  const offset = this._offsets[attributeIndex];
  const stride = this._stride;
  const index = 4 * stride * instanceIndex + 4 * offset;
  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    setPackedAttribute(attributeValue, this._batchValues, index);
  } else {
    Cartesian4_default.pack(attributeValue, this._batchValues, index);
  }
  this._batchValuesDirty = true;
};
function createTexture(batchTable, context) {
  const dimensions = batchTable._textureDimensions;
  batchTable._texture = new Texture_default({
    context,
    pixelFormat: PixelFormat_default.RGBA,
    pixelDatatype: batchTable._pixelDatatype,
    width: dimensions.x,
    height: dimensions.y,
    sampler: Sampler_default.NEAREST,
    flipY: false
  });
}
function updateTexture(batchTable) {
  const dimensions = batchTable._textureDimensions;
  batchTable._texture.copyFrom({
    source: {
      width: dimensions.x,
      height: dimensions.y,
      arrayBufferView: batchTable._batchValues
    }
  });
}
BatchTable.prototype.update = function(frameState) {
  if (defined_default(this._texture) && !this._batchValuesDirty || this._attributes.length === 0) {
    return;
  }
  this._batchValuesDirty = false;
  if (!defined_default(this._texture)) {
    createTexture(this, frameState.context);
  }
  updateTexture(this);
};
BatchTable.prototype.getUniformMapCallback = function() {
  const that = this;
  return function(uniformMap) {
    if (that._attributes.length === 0) {
      return uniformMap;
    }
    const batchUniformMap = {
      batchTexture: function() {
        return that._texture;
      },
      batchTextureDimensions: function() {
        return that._textureDimensions;
      },
      batchTextureStep: function() {
        return that._textureStep;
      }
    };
    return combine_default(uniformMap, batchUniformMap);
  };
};
function getGlslComputeSt(batchTable) {
  const stride = batchTable._stride;
  if (batchTable._textureDimensions.y === 1) {
    return `${"uniform vec4 batchTextureStep; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float numberOfAttributes = float("}${stride}); 
    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); 
} 
`;
  }
  return `${"uniform vec4 batchTextureStep; \nuniform vec2 batchTextureDimensions; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float stepY = batchTextureStep.z; \n    float centerY = batchTextureStep.w; \n    float numberOfAttributes = float("}${stride}); 
    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); 
    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); 
    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); 
} 
`;
}
function getComponentType(componentsPerAttribute) {
  if (componentsPerAttribute === 1) {
    return "float";
  }
  return `vec${componentsPerAttribute}`;
}
function getComponentSwizzle(componentsPerAttribute) {
  if (componentsPerAttribute === 1) {
    return ".x";
  } else if (componentsPerAttribute === 2) {
    return ".xy";
  } else if (componentsPerAttribute === 3) {
    return ".xyz";
  }
  return "";
}
function getGlslAttributeFunction(batchTable, attributeIndex) {
  const attributes = batchTable._attributes;
  const attribute = attributes[attributeIndex];
  const componentsPerAttribute = attribute.componentsPerAttribute;
  const functionName = attribute.functionName;
  const functionReturnType = getComponentType(componentsPerAttribute);
  const functionReturnValue = getComponentSwizzle(componentsPerAttribute);
  const offset = batchTable._offsets[attributeIndex];
  let glslFunction = `${functionReturnType} ${functionName}(float batchId) 
{ 
    vec2 st = computeSt(batchId); 
    st.x += batchTextureStep.x * float(${offset}); 
`;
  if (batchTable._packFloats && attribute.componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    glslFunction += "vec4 textureValue; \ntextureValue.x = czm_unpackFloat(texture2D(batchTexture, st)); \ntextureValue.y = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \ntextureValue.z = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \ntextureValue.w = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \n";
  } else {
    glslFunction += "    vec4 textureValue = texture2D(batchTexture, st); \n";
  }
  glslFunction += `    ${functionReturnType} value = textureValue${functionReturnValue}; 
`;
  if (batchTable._pixelDatatype === PixelDatatype_default.UNSIGNED_BYTE && attribute.componentDatatype === ComponentDatatype_default.UNSIGNED_BYTE && !attribute.normalize) {
    glslFunction += "value *= 255.0; \n";
  } else if (batchTable._pixelDatatype === PixelDatatype_default.FLOAT && attribute.componentDatatype === ComponentDatatype_default.UNSIGNED_BYTE && attribute.normalize) {
    glslFunction += "value /= 255.0; \n";
  }
  glslFunction += "    return value; \n} \n";
  return glslFunction;
}
BatchTable.prototype.getVertexShaderCallback = function() {
  const attributes = this._attributes;
  if (attributes.length === 0) {
    return function(source) {
      return source;
    };
  }
  let batchTableShader = "uniform highp sampler2D batchTexture; \n";
  batchTableShader += `${getGlslComputeSt(this)}
`;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    batchTableShader += getGlslAttributeFunction(this, i);
  }
  return function(source) {
    const mainIndex = source.indexOf("void main");
    const beforeMain = source.substring(0, mainIndex);
    const afterMain = source.substring(mainIndex);
    return `${beforeMain}
${batchTableShader}
${afterMain}`;
  };
};
BatchTable.prototype.isDestroyed = function() {
  return false;
};
BatchTable.prototype.destroy = function() {
  this._texture = this._texture && this._texture.destroy();
  return destroyObject_default(this);
};
var BatchTable_default = BatchTable;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/AttributeType.js
var AttributeType = {
  SCALAR: "SCALAR",
  VEC2: "VEC2",
  VEC3: "VEC3",
  VEC4: "VEC4",
  MAT2: "MAT2",
  MAT3: "MAT3",
  MAT4: "MAT4"
};
AttributeType.getMathType = function(attributeType) {
  switch (attributeType) {
    case AttributeType.SCALAR:
      return Number;
    case AttributeType.VEC2:
      return Cartesian2_default;
    case AttributeType.VEC3:
      return Cartesian3_default;
    case AttributeType.VEC4:
      return Cartesian4_default;
    case AttributeType.MAT2:
      return Matrix2_default;
    case AttributeType.MAT3:
      return Matrix3_default;
    case AttributeType.MAT4:
      return Matrix4_default;
    default:
      throw new DeveloperError_default("attributeType is not a valid value.");
  }
};
AttributeType.getNumberOfComponents = function(attributeType) {
  switch (attributeType) {
    case AttributeType.SCALAR:
      return 1;
    case AttributeType.VEC2:
      return 2;
    case AttributeType.VEC3:
      return 3;
    case AttributeType.VEC4:
    case AttributeType.MAT2:
      return 4;
    case AttributeType.MAT3:
      return 9;
    case AttributeType.MAT4:
      return 16;
    default:
      throw new DeveloperError_default("attributeType is not a valid value.");
  }
};
AttributeType.getAttributeLocationCount = function(attributeType) {
  switch (attributeType) {
    case AttributeType.SCALAR:
    case AttributeType.VEC2:
    case AttributeType.VEC3:
    case AttributeType.VEC4:
      return 1;
    case AttributeType.MAT2:
      return 2;
    case AttributeType.MAT3:
      return 3;
    case AttributeType.MAT4:
      return 4;
    default:
      throw new DeveloperError_default("attributeType is not a valid value.");
  }
};
AttributeType.getGlslType = function(attributeType) {
  Check_default.typeOf.string("attributeType", attributeType);
  switch (attributeType) {
    case AttributeType.SCALAR:
      return "float";
    case AttributeType.VEC2:
      return "vec2";
    case AttributeType.VEC3:
      return "vec3";
    case AttributeType.VEC4:
      return "vec4";
    case AttributeType.MAT2:
      return "mat2";
    case AttributeType.MAT3:
      return "mat3";
    case AttributeType.MAT4:
      return "mat4";
    default:
      throw new DeveloperError_default("attributeType is not a valid value.");
  }
};
var AttributeType_default = Object.freeze(AttributeType);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/AttributeCompression.js
var RIGHT_SHIFT = 1 / 256;
var LEFT_SHIFT = 256;
var AttributeCompression = {};
AttributeCompression.octEncodeInRange = function(vector, rangeMax, result) {
  Check_default.defined("vector", vector);
  Check_default.defined("result", result);
  const magSquared = Cartesian3_default.magnitudeSquared(vector);
  if (Math.abs(magSquared - 1) > Math_default.EPSILON6) {
    throw new DeveloperError_default("vector must be normalized.");
  }
  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));
  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));
  if (vector.z < 0) {
    const x = result.x;
    const y = result.y;
    result.x = (1 - Math.abs(y)) * Math_default.signNotZero(x);
    result.y = (1 - Math.abs(x)) * Math_default.signNotZero(y);
  }
  result.x = Math_default.toSNorm(result.x, rangeMax);
  result.y = Math_default.toSNorm(result.y, rangeMax);
  return result;
};
AttributeCompression.octEncode = function(vector, result) {
  return AttributeCompression.octEncodeInRange(vector, 255, result);
};
var octEncodeScratch = new Cartesian2_default();
var uint8ForceArray = new Uint8Array(1);
function forceUint8(value) {
  uint8ForceArray[0] = value;
  return uint8ForceArray[0];
}
AttributeCompression.octEncodeToCartesian4 = function(vector, result) {
  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);
  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);
  result.y = forceUint8(octEncodeScratch.x);
  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);
  result.w = forceUint8(octEncodeScratch.y);
  return result;
};
AttributeCompression.octDecodeInRange = function(x, y, rangeMax, result) {
  Check_default.defined("result", result);
  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {
    throw new DeveloperError_default(
      `x and y must be unsigned normalized integers between 0 and ${rangeMax}`
    );
  }
  result.x = Math_default.fromSNorm(x, rangeMax);
  result.y = Math_default.fromSNorm(y, rangeMax);
  result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
  if (result.z < 0) {
    const oldVX = result.x;
    result.x = (1 - Math.abs(result.y)) * Math_default.signNotZero(oldVX);
    result.y = (1 - Math.abs(oldVX)) * Math_default.signNotZero(result.y);
  }
  return Cartesian3_default.normalize(result, result);
};
AttributeCompression.octDecode = function(x, y, result) {
  return AttributeCompression.octDecodeInRange(x, y, 255, result);
};
AttributeCompression.octDecodeFromCartesian4 = function(encoded, result) {
  Check_default.typeOf.object("encoded", encoded);
  Check_default.typeOf.object("result", result);
  const x = encoded.x;
  const y = encoded.y;
  const z = encoded.z;
  const w = encoded.w;
  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {
    throw new DeveloperError_default(
      "x, y, z, and w must be unsigned normalized integers between 0 and 255"
    );
  }
  const xOct16 = x * LEFT_SHIFT + y;
  const yOct16 = z * LEFT_SHIFT + w;
  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);
};
AttributeCompression.octPackFloat = function(encoded) {
  Check_default.defined("encoded", encoded);
  return 256 * encoded.x + encoded.y;
};
var scratchEncodeCart2 = new Cartesian2_default();
AttributeCompression.octEncodeFloat = function(vector) {
  AttributeCompression.octEncode(vector, scratchEncodeCart2);
  return AttributeCompression.octPackFloat(scratchEncodeCart2);
};
AttributeCompression.octDecodeFloat = function(value, result) {
  Check_default.defined("value", value);
  const temp = value / 256;
  const x = Math.floor(temp);
  const y = (temp - x) * 256;
  return AttributeCompression.octDecode(x, y, result);
};
AttributeCompression.octPack = function(v12, v22, v3, result) {
  Check_default.defined("v1", v12);
  Check_default.defined("v2", v22);
  Check_default.defined("v3", v3);
  Check_default.defined("result", result);
  const encoded1 = AttributeCompression.octEncodeFloat(v12);
  const encoded2 = AttributeCompression.octEncodeFloat(v22);
  const encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);
  result.x = 65536 * encoded3.x + encoded1;
  result.y = 65536 * encoded3.y + encoded2;
  return result;
};
AttributeCompression.octUnpack = function(packed, v12, v22, v3) {
  Check_default.defined("packed", packed);
  Check_default.defined("v1", v12);
  Check_default.defined("v2", v22);
  Check_default.defined("v3", v3);
  let temp = packed.x / 65536;
  const x = Math.floor(temp);
  const encodedFloat1 = (temp - x) * 65536;
  temp = packed.y / 65536;
  const y = Math.floor(temp);
  const encodedFloat2 = (temp - y) * 65536;
  AttributeCompression.octDecodeFloat(encodedFloat1, v12);
  AttributeCompression.octDecodeFloat(encodedFloat2, v22);
  AttributeCompression.octDecode(x, y, v3);
};
AttributeCompression.compressTextureCoordinates = function(textureCoordinates) {
  Check_default.defined("textureCoordinates", textureCoordinates);
  const x = textureCoordinates.x * 4095 | 0;
  const y = textureCoordinates.y * 4095 | 0;
  return 4096 * x + y;
};
AttributeCompression.decompressTextureCoordinates = function(compressed, result) {
  Check_default.defined("compressed", compressed);
  Check_default.defined("result", result);
  const temp = compressed / 4096;
  const xZeroTo4095 = Math.floor(temp);
  result.x = xZeroTo4095 / 4095;
  result.y = (compressed - xZeroTo4095 * 4096) / 4095;
  return result;
};
function zigZagDecode(value) {
  return value >> 1 ^ -(value & 1);
}
AttributeCompression.zigZagDeltaDecode = function(uBuffer, vBuffer, heightBuffer) {
  Check_default.defined("uBuffer", uBuffer);
  Check_default.defined("vBuffer", vBuffer);
  Check_default.typeOf.number.equals(
    "uBuffer.length",
    "vBuffer.length",
    uBuffer.length,
    vBuffer.length
  );
  if (defined_default(heightBuffer)) {
    Check_default.typeOf.number.equals(
      "uBuffer.length",
      "heightBuffer.length",
      uBuffer.length,
      heightBuffer.length
    );
  }
  const count = uBuffer.length;
  let u3 = 0;
  let v3 = 0;
  let height = 0;
  for (let i = 0; i < count; ++i) {
    u3 += zigZagDecode(uBuffer[i]);
    v3 += zigZagDecode(vBuffer[i]);
    uBuffer[i] = u3;
    vBuffer[i] = v3;
    if (defined_default(heightBuffer)) {
      height += zigZagDecode(heightBuffer[i]);
      heightBuffer[i] = height;
    }
  }
};
AttributeCompression.dequantize = function(typedArray, componentDatatype, type2, count) {
  Check_default.defined("typedArray", typedArray);
  Check_default.defined("componentDatatype", componentDatatype);
  Check_default.defined("type", type2);
  Check_default.defined("count", count);
  const componentsPerAttribute = AttributeType_default.getNumberOfComponents(type2);
  let divisor;
  switch (componentDatatype) {
    case ComponentDatatype_default.BYTE:
      divisor = 127;
      break;
    case ComponentDatatype_default.UNSIGNED_BYTE:
      divisor = 255;
      break;
    case ComponentDatatype_default.SHORT:
      divisor = 32767;
      break;
    case ComponentDatatype_default.UNSIGNED_SHORT:
      divisor = 65535;
      break;
    case ComponentDatatype_default.INT:
      divisor = 2147483647;
      break;
    case ComponentDatatype_default.UNSIGNED_INT:
      divisor = 4294967295;
      break;
    default:
      throw new DeveloperError_default(
        `Cannot dequantize component datatype: ${componentDatatype}`
      );
  }
  const dequantizedTypedArray = new Float32Array(
    count * componentsPerAttribute
  );
  for (let i = 0; i < count; i++) {
    for (let j = 0; j < componentsPerAttribute; j++) {
      const index = i * componentsPerAttribute + j;
      dequantizedTypedArray[index] = Math.max(
        typedArray[index] / divisor,
        -1
      );
    }
  }
  return dequantizedTypedArray;
};
AttributeCompression.decodeRGB565 = function(typedArray, result) {
  Check_default.defined("typedArray", typedArray);
  const expectedLength = typedArray.length * 3;
  if (defined_default(result)) {
    Check_default.typeOf.number.equals(
      "result.length",
      "typedArray.length * 3",
      result.length,
      expectedLength
    );
  }
  const count = typedArray.length;
  if (!defined_default(result)) {
    result = new Float32Array(count * 3);
  }
  const mask5 = (1 << 5) - 1;
  const mask6 = (1 << 6) - 1;
  const normalize5 = 1 / 31;
  const normalize6 = 1 / 63;
  for (let i = 0; i < count; i++) {
    const value = typedArray[i];
    const red = value >> 11;
    const green = value >> 5 & mask6;
    const blue = value & mask5;
    const offset = 3 * i;
    result[offset] = red * normalize5;
    result[offset + 1] = green * normalize6;
    result[offset + 2] = blue * normalize5;
  }
  return result;
};
var AttributeCompression_default = AttributeCompression;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/barycentricCoordinates.js
var scratchCartesian12 = new Cartesian3_default();
var scratchCartesian22 = new Cartesian3_default();
var scratchCartesian33 = new Cartesian3_default();
function barycentricCoordinates(point, p0, p1, p2, result) {
  Check_default.defined("point", point);
  Check_default.defined("p0", p0);
  Check_default.defined("p1", p1);
  Check_default.defined("p2", p2);
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  let v02;
  let v12;
  let v22;
  let dot00;
  let dot01;
  let dot02;
  let dot11;
  let dot12;
  if (!defined_default(p0.z)) {
    if (Cartesian2_default.equalsEpsilon(point, p0, Math_default.EPSILON14)) {
      return Cartesian3_default.clone(Cartesian3_default.UNIT_X, result);
    }
    if (Cartesian2_default.equalsEpsilon(point, p1, Math_default.EPSILON14)) {
      return Cartesian3_default.clone(Cartesian3_default.UNIT_Y, result);
    }
    if (Cartesian2_default.equalsEpsilon(point, p2, Math_default.EPSILON14)) {
      return Cartesian3_default.clone(Cartesian3_default.UNIT_Z, result);
    }
    v02 = Cartesian2_default.subtract(p1, p0, scratchCartesian12);
    v12 = Cartesian2_default.subtract(p2, p0, scratchCartesian22);
    v22 = Cartesian2_default.subtract(point, p0, scratchCartesian33);
    dot00 = Cartesian2_default.dot(v02, v02);
    dot01 = Cartesian2_default.dot(v02, v12);
    dot02 = Cartesian2_default.dot(v02, v22);
    dot11 = Cartesian2_default.dot(v12, v12);
    dot12 = Cartesian2_default.dot(v12, v22);
  } else {
    if (Cartesian3_default.equalsEpsilon(point, p0, Math_default.EPSILON14)) {
      return Cartesian3_default.clone(Cartesian3_default.UNIT_X, result);
    }
    if (Cartesian3_default.equalsEpsilon(point, p1, Math_default.EPSILON14)) {
      return Cartesian3_default.clone(Cartesian3_default.UNIT_Y, result);
    }
    if (Cartesian3_default.equalsEpsilon(point, p2, Math_default.EPSILON14)) {
      return Cartesian3_default.clone(Cartesian3_default.UNIT_Z, result);
    }
    v02 = Cartesian3_default.subtract(p1, p0, scratchCartesian12);
    v12 = Cartesian3_default.subtract(p2, p0, scratchCartesian22);
    v22 = Cartesian3_default.subtract(point, p0, scratchCartesian33);
    dot00 = Cartesian3_default.dot(v02, v02);
    dot01 = Cartesian3_default.dot(v02, v12);
    dot02 = Cartesian3_default.dot(v02, v22);
    dot11 = Cartesian3_default.dot(v12, v12);
    dot12 = Cartesian3_default.dot(v12, v22);
  }
  result.y = dot11 * dot02 - dot01 * dot12;
  result.z = dot00 * dot12 - dot01 * dot02;
  const q = dot00 * dot11 - dot01 * dot01;
  if (q === 0) {
    return void 0;
  }
  result.y /= q;
  result.z /= q;
  result.x = 1 - result.y - result.z;
  return result;
}
var barycentricCoordinates_default = barycentricCoordinates;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/Tipsify.js
var Tipsify = {};
Tipsify.calculateACMR = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const indices = options.indices;
  let maximumIndex = options.maximumIndex;
  const cacheSize = defaultValue_default(options.cacheSize, 24);
  if (!defined_default(indices)) {
    throw new DeveloperError_default("indices is required.");
  }
  const numIndices = indices.length;
  if (numIndices < 3 || numIndices % 3 !== 0) {
    throw new DeveloperError_default("indices length must be a multiple of three.");
  }
  if (maximumIndex <= 0) {
    throw new DeveloperError_default("maximumIndex must be greater than zero.");
  }
  if (cacheSize < 3) {
    throw new DeveloperError_default("cacheSize must be greater than two.");
  }
  if (!defined_default(maximumIndex)) {
    maximumIndex = 0;
    let currentIndex = 0;
    let intoIndices = indices[currentIndex];
    while (currentIndex < numIndices) {
      if (intoIndices > maximumIndex) {
        maximumIndex = intoIndices;
      }
      ++currentIndex;
      intoIndices = indices[currentIndex];
    }
  }
  const vertexTimeStamps = [];
  for (let i = 0; i < maximumIndex + 1; i++) {
    vertexTimeStamps[i] = 0;
  }
  let s = cacheSize + 1;
  for (let j = 0; j < numIndices; ++j) {
    if (s - vertexTimeStamps[indices[j]] > cacheSize) {
      vertexTimeStamps[indices[j]] = s;
      ++s;
    }
  }
  return (s - cacheSize + 1) / (numIndices / 3);
};
Tipsify.tipsify = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const indices = options.indices;
  const maximumIndex = options.maximumIndex;
  const cacheSize = defaultValue_default(options.cacheSize, 24);
  let cursor;
  function skipDeadEnd(vertices2, deadEnd2, indices2, maximumIndexPlusOne2) {
    while (deadEnd2.length >= 1) {
      const d = deadEnd2[deadEnd2.length - 1];
      deadEnd2.splice(deadEnd2.length - 1, 1);
      if (vertices2[d].numLiveTriangles > 0) {
        return d;
      }
    }
    while (cursor < maximumIndexPlusOne2) {
      if (vertices2[cursor].numLiveTriangles > 0) {
        ++cursor;
        return cursor - 1;
      }
      ++cursor;
    }
    return -1;
  }
  function getNextVertex(indices2, cacheSize2, oneRing2, vertices2, s2, deadEnd2, maximumIndexPlusOne2) {
    let n = -1;
    let p;
    let m = -1;
    let itOneRing = 0;
    while (itOneRing < oneRing2.length) {
      const index2 = oneRing2[itOneRing];
      if (vertices2[index2].numLiveTriangles) {
        p = 0;
        if (s2 - vertices2[index2].timeStamp + 2 * vertices2[index2].numLiveTriangles <= cacheSize2) {
          p = s2 - vertices2[index2].timeStamp;
        }
        if (p > m || m === -1) {
          m = p;
          n = index2;
        }
      }
      ++itOneRing;
    }
    if (n === -1) {
      return skipDeadEnd(vertices2, deadEnd2, indices2, maximumIndexPlusOne2);
    }
    return n;
  }
  if (!defined_default(indices)) {
    throw new DeveloperError_default("indices is required.");
  }
  const numIndices = indices.length;
  if (numIndices < 3 || numIndices % 3 !== 0) {
    throw new DeveloperError_default("indices length must be a multiple of three.");
  }
  if (maximumIndex <= 0) {
    throw new DeveloperError_default("maximumIndex must be greater than zero.");
  }
  if (cacheSize < 3) {
    throw new DeveloperError_default("cacheSize must be greater than two.");
  }
  let maximumIndexPlusOne = 0;
  let currentIndex = 0;
  let intoIndices = indices[currentIndex];
  const endIndex = numIndices;
  if (defined_default(maximumIndex)) {
    maximumIndexPlusOne = maximumIndex + 1;
  } else {
    while (currentIndex < endIndex) {
      if (intoIndices > maximumIndexPlusOne) {
        maximumIndexPlusOne = intoIndices;
      }
      ++currentIndex;
      intoIndices = indices[currentIndex];
    }
    if (maximumIndexPlusOne === -1) {
      return 0;
    }
    ++maximumIndexPlusOne;
  }
  const vertices = [];
  let i;
  for (i = 0; i < maximumIndexPlusOne; i++) {
    vertices[i] = {
      numLiveTriangles: 0,
      timeStamp: 0,
      vertexTriangles: []
    };
  }
  currentIndex = 0;
  let triangle = 0;
  while (currentIndex < endIndex) {
    vertices[indices[currentIndex]].vertexTriangles.push(triangle);
    ++vertices[indices[currentIndex]].numLiveTriangles;
    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);
    ++vertices[indices[currentIndex + 1]].numLiveTriangles;
    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);
    ++vertices[indices[currentIndex + 2]].numLiveTriangles;
    ++triangle;
    currentIndex += 3;
  }
  let f = 0;
  let s = cacheSize + 1;
  cursor = 1;
  let oneRing = [];
  const deadEnd = [];
  let vertex;
  let intoVertices;
  let currentOutputIndex = 0;
  const outputIndices = [];
  const numTriangles = numIndices / 3;
  const triangleEmitted = [];
  for (i = 0; i < numTriangles; i++) {
    triangleEmitted[i] = false;
  }
  let index;
  let limit;
  while (f !== -1) {
    oneRing = [];
    intoVertices = vertices[f];
    limit = intoVertices.vertexTriangles.length;
    for (let k = 0; k < limit; ++k) {
      triangle = intoVertices.vertexTriangles[k];
      if (!triangleEmitted[triangle]) {
        triangleEmitted[triangle] = true;
        currentIndex = triangle + triangle + triangle;
        for (let j = 0; j < 3; ++j) {
          index = indices[currentIndex];
          oneRing.push(index);
          deadEnd.push(index);
          outputIndices[currentOutputIndex] = index;
          ++currentOutputIndex;
          vertex = vertices[index];
          --vertex.numLiveTriangles;
          if (s - vertex.timeStamp > cacheSize) {
            vertex.timeStamp = s;
            ++s;
          }
          ++currentIndex;
        }
      }
    }
    f = getNextVertex(
      indices,
      cacheSize,
      oneRing,
      vertices,
      s,
      deadEnd,
      maximumIndexPlusOne
    );
  }
  return outputIndices;
};
var Tipsify_default = Tipsify;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeometryPipeline.js
var GeometryPipeline = {};
function addTriangle(lines, index, i0, i1, i2) {
  lines[index++] = i0;
  lines[index++] = i1;
  lines[index++] = i1;
  lines[index++] = i2;
  lines[index++] = i2;
  lines[index] = i0;
}
function trianglesToLines(triangles) {
  const count = triangles.length;
  const size = count / 3 * 6;
  const lines = IndexDatatype_default.createTypedArray(count, size);
  let index = 0;
  for (let i = 0; i < count; i += 3, index += 6) {
    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);
  }
  return lines;
}
function triangleStripToLines(triangles) {
  const count = triangles.length;
  if (count >= 3) {
    const size = (count - 2) * 6;
    const lines = IndexDatatype_default.createTypedArray(count, size);
    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);
    let index = 6;
    for (let i = 3; i < count; ++i, index += 6) {
      addTriangle(
        lines,
        index,
        triangles[i - 1],
        triangles[i],
        triangles[i - 2]
      );
    }
    return lines;
  }
  return new Uint16Array();
}
function triangleFanToLines(triangles) {
  if (triangles.length > 0) {
    const count = triangles.length - 1;
    const size = (count - 1) * 6;
    const lines = IndexDatatype_default.createTypedArray(count, size);
    const base = triangles[0];
    let index = 0;
    for (let i = 1; i < count; ++i, index += 6) {
      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);
    }
    return lines;
  }
  return new Uint16Array();
}
GeometryPipeline.toWireframe = function(geometry) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  const indices = geometry.indices;
  if (defined_default(indices)) {
    switch (geometry.primitiveType) {
      case PrimitiveType_default.TRIANGLES:
        geometry.indices = trianglesToLines(indices);
        break;
      case PrimitiveType_default.TRIANGLE_STRIP:
        geometry.indices = triangleStripToLines(indices);
        break;
      case PrimitiveType_default.TRIANGLE_FAN:
        geometry.indices = triangleFanToLines(indices);
        break;
      default:
        throw new DeveloperError_default(
          "geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN."
        );
    }
    geometry.primitiveType = PrimitiveType_default.LINES;
  }
  return geometry;
};
GeometryPipeline.createLineSegmentsForVectors = function(geometry, attributeName, length) {
  attributeName = defaultValue_default(attributeName, "normal");
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  if (!defined_default(geometry.attributes.position)) {
    throw new DeveloperError_default("geometry.attributes.position is required.");
  }
  if (!defined_default(geometry.attributes[attributeName])) {
    throw new DeveloperError_default(
      `geometry.attributes must have an attribute with the same name as the attributeName parameter, ${attributeName}.`
    );
  }
  length = defaultValue_default(length, 1e4);
  const positions = geometry.attributes.position.values;
  const vectors = geometry.attributes[attributeName].values;
  const positionsLength = positions.length;
  const newPositions = new Float64Array(2 * positionsLength);
  let j = 0;
  for (let i = 0; i < positionsLength; i += 3) {
    newPositions[j++] = positions[i];
    newPositions[j++] = positions[i + 1];
    newPositions[j++] = positions[i + 2];
    newPositions[j++] = positions[i] + vectors[i] * length;
    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;
    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;
  }
  let newBoundingSphere;
  const bs = geometry.boundingSphere;
  if (defined_default(bs)) {
    newBoundingSphere = new BoundingSphere_default(bs.center, bs.radius + length);
  }
  return new Geometry_default({
    attributes: {
      position: new GeometryAttribute_default({
        componentDatatype: ComponentDatatype_default.DOUBLE,
        componentsPerAttribute: 3,
        values: newPositions
      })
    },
    primitiveType: PrimitiveType_default.LINES,
    boundingSphere: newBoundingSphere
  });
};
GeometryPipeline.createAttributeLocations = function(geometry) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  const semantics = [
    "position",
    "positionHigh",
    "positionLow",
    "position3DHigh",
    "position3DLow",
    "position2DHigh",
    "position2DLow",
    "pickColor",
    "normal",
    "st",
    "tangent",
    "bitangent",
    "extrudeDirection",
    "compressedAttributes"
  ];
  const attributes = geometry.attributes;
  const indices = {};
  let j = 0;
  let i;
  const len = semantics.length;
  for (i = 0; i < len; ++i) {
    const semantic = semantics[i];
    if (defined_default(attributes[semantic])) {
      indices[semantic] = j++;
    }
  }
  for (const name in attributes) {
    if (attributes.hasOwnProperty(name) && !defined_default(indices[name])) {
      indices[name] = j++;
    }
  }
  return indices;
};
GeometryPipeline.reorderForPreVertexCache = function(geometry) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  const numVertices = Geometry_default.computeNumberOfVertices(geometry);
  const indices = geometry.indices;
  if (defined_default(indices)) {
    const indexCrossReferenceOldToNew = new Int32Array(numVertices);
    for (let i = 0; i < numVertices; i++) {
      indexCrossReferenceOldToNew[i] = -1;
    }
    const indicesIn = indices;
    const numIndices = indicesIn.length;
    const indicesOut = IndexDatatype_default.createTypedArray(numVertices, numIndices);
    let intoIndicesIn = 0;
    let intoIndicesOut = 0;
    let nextIndex = 0;
    let tempIndex;
    while (intoIndicesIn < numIndices) {
      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];
      if (tempIndex !== -1) {
        indicesOut[intoIndicesOut] = tempIndex;
      } else {
        tempIndex = indicesIn[intoIndicesIn];
        indexCrossReferenceOldToNew[tempIndex] = nextIndex;
        indicesOut[intoIndicesOut] = nextIndex;
        ++nextIndex;
      }
      ++intoIndicesIn;
      ++intoIndicesOut;
    }
    geometry.indices = indicesOut;
    const attributes = geometry.attributes;
    for (const property in attributes) {
      if (attributes.hasOwnProperty(property) && defined_default(attributes[property]) && defined_default(attributes[property].values)) {
        const attribute = attributes[property];
        const elementsIn = attribute.values;
        let intoElementsIn = 0;
        const numComponents = attribute.componentsPerAttribute;
        const elementsOut = ComponentDatatype_default.createTypedArray(
          attribute.componentDatatype,
          nextIndex * numComponents
        );
        while (intoElementsIn < numVertices) {
          const temp = indexCrossReferenceOldToNew[intoElementsIn];
          if (temp !== -1) {
            for (let j = 0; j < numComponents; j++) {
              elementsOut[numComponents * temp + j] = elementsIn[numComponents * intoElementsIn + j];
            }
          }
          ++intoElementsIn;
        }
        attribute.values = elementsOut;
      }
    }
  }
  return geometry;
};
GeometryPipeline.reorderForPostVertexCache = function(geometry, cacheCapacity) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  const indices = geometry.indices;
  if (geometry.primitiveType === PrimitiveType_default.TRIANGLES && defined_default(indices)) {
    const numIndices = indices.length;
    let maximumIndex = 0;
    for (let j = 0; j < numIndices; j++) {
      if (indices[j] > maximumIndex) {
        maximumIndex = indices[j];
      }
    }
    geometry.indices = Tipsify_default.tipsify({
      indices,
      maximumIndex,
      cacheSize: cacheCapacity
    });
  }
  return geometry;
};
function copyAttributesDescriptions(attributes) {
  const newAttributes = {};
  for (const attribute in attributes) {
    if (attributes.hasOwnProperty(attribute) && defined_default(attributes[attribute]) && defined_default(attributes[attribute].values)) {
      const attr = attributes[attribute];
      newAttributes[attribute] = new GeometryAttribute_default({
        componentDatatype: attr.componentDatatype,
        componentsPerAttribute: attr.componentsPerAttribute,
        normalize: attr.normalize,
        values: []
      });
    }
  }
  return newAttributes;
}
function copyVertex(destinationAttributes, sourceAttributes, index) {
  for (const attribute in sourceAttributes) {
    if (sourceAttributes.hasOwnProperty(attribute) && defined_default(sourceAttributes[attribute]) && defined_default(sourceAttributes[attribute].values)) {
      const attr = sourceAttributes[attribute];
      for (let k = 0; k < attr.componentsPerAttribute; ++k) {
        destinationAttributes[attribute].values.push(
          attr.values[index * attr.componentsPerAttribute + k]
        );
      }
    }
  }
}
GeometryPipeline.fitToUnsignedShortIndices = function(geometry) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  if (defined_default(geometry.indices) && geometry.primitiveType !== PrimitiveType_default.TRIANGLES && geometry.primitiveType !== PrimitiveType_default.LINES && geometry.primitiveType !== PrimitiveType_default.POINTS) {
    throw new DeveloperError_default(
      "geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS."
    );
  }
  const geometries = [];
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  if (defined_default(geometry.indices) && numberOfVertices >= Math_default.SIXTY_FOUR_KILOBYTES) {
    let oldToNewIndex = [];
    let newIndices = [];
    let currentIndex = 0;
    let newAttributes = copyAttributesDescriptions(geometry.attributes);
    const originalIndices = geometry.indices;
    const numberOfIndices = originalIndices.length;
    let indicesPerPrimitive;
    if (geometry.primitiveType === PrimitiveType_default.TRIANGLES) {
      indicesPerPrimitive = 3;
    } else if (geometry.primitiveType === PrimitiveType_default.LINES) {
      indicesPerPrimitive = 2;
    } else if (geometry.primitiveType === PrimitiveType_default.POINTS) {
      indicesPerPrimitive = 1;
    }
    for (let j = 0; j < numberOfIndices; j += indicesPerPrimitive) {
      for (let k = 0; k < indicesPerPrimitive; ++k) {
        const x = originalIndices[j + k];
        let i = oldToNewIndex[x];
        if (!defined_default(i)) {
          i = currentIndex++;
          oldToNewIndex[x] = i;
          copyVertex(newAttributes, geometry.attributes, x);
        }
        newIndices.push(i);
      }
      if (currentIndex + indicesPerPrimitive >= Math_default.SIXTY_FOUR_KILOBYTES) {
        geometries.push(
          new Geometry_default({
            attributes: newAttributes,
            indices: newIndices,
            primitiveType: geometry.primitiveType,
            boundingSphere: geometry.boundingSphere,
            boundingSphereCV: geometry.boundingSphereCV
          })
        );
        oldToNewIndex = [];
        newIndices = [];
        currentIndex = 0;
        newAttributes = copyAttributesDescriptions(geometry.attributes);
      }
    }
    if (newIndices.length !== 0) {
      geometries.push(
        new Geometry_default({
          attributes: newAttributes,
          indices: newIndices,
          primitiveType: geometry.primitiveType,
          boundingSphere: geometry.boundingSphere,
          boundingSphereCV: geometry.boundingSphereCV
        })
      );
    }
  } else {
    geometries.push(geometry);
  }
  return geometries;
};
var scratchProjectTo2DCartesian3 = new Cartesian3_default();
var scratchProjectTo2DCartographic = new Cartographic_default();
GeometryPipeline.projectTo2D = function(geometry, attributeName, attributeName3D, attributeName2D, projection) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  if (!defined_default(attributeName)) {
    throw new DeveloperError_default("attributeName is required.");
  }
  if (!defined_default(attributeName3D)) {
    throw new DeveloperError_default("attributeName3D is required.");
  }
  if (!defined_default(attributeName2D)) {
    throw new DeveloperError_default("attributeName2D is required.");
  }
  if (!defined_default(geometry.attributes[attributeName])) {
    throw new DeveloperError_default(
      `geometry must have attribute matching the attributeName argument: ${attributeName}.`
    );
  }
  if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype_default.DOUBLE) {
    throw new DeveloperError_default(
      "The attribute componentDatatype must be ComponentDatatype.DOUBLE."
    );
  }
  const attribute = geometry.attributes[attributeName];
  projection = defined_default(projection) ? projection : new GeographicProjection_default();
  const ellipsoid = projection.ellipsoid;
  const values3D = attribute.values;
  const projectedValues = new Float64Array(values3D.length);
  let index = 0;
  for (let i = 0; i < values3D.length; i += 3) {
    const value = Cartesian3_default.fromArray(
      values3D,
      i,
      scratchProjectTo2DCartesian3
    );
    const lonLat = ellipsoid.cartesianToCartographic(
      value,
      scratchProjectTo2DCartographic
    );
    if (!defined_default(lonLat)) {
      throw new DeveloperError_default(
        `Could not project point (${value.x}, ${value.y}, ${value.z}) to 2D.`
      );
    }
    const projectedLonLat = projection.project(
      lonLat,
      scratchProjectTo2DCartesian3
    );
    projectedValues[index++] = projectedLonLat.x;
    projectedValues[index++] = projectedLonLat.y;
    projectedValues[index++] = projectedLonLat.z;
  }
  geometry.attributes[attributeName3D] = attribute;
  geometry.attributes[attributeName2D] = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.DOUBLE,
    componentsPerAttribute: 3,
    values: projectedValues
  });
  delete geometry.attributes[attributeName];
  return geometry;
};
var encodedResult = {
  high: 0,
  low: 0
};
GeometryPipeline.encodeAttribute = function(geometry, attributeName, attributeHighName, attributeLowName) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  if (!defined_default(attributeName)) {
    throw new DeveloperError_default("attributeName is required.");
  }
  if (!defined_default(attributeHighName)) {
    throw new DeveloperError_default("attributeHighName is required.");
  }
  if (!defined_default(attributeLowName)) {
    throw new DeveloperError_default("attributeLowName is required.");
  }
  if (!defined_default(geometry.attributes[attributeName])) {
    throw new DeveloperError_default(
      `geometry must have attribute matching the attributeName argument: ${attributeName}.`
    );
  }
  if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype_default.DOUBLE) {
    throw new DeveloperError_default(
      "The attribute componentDatatype must be ComponentDatatype.DOUBLE."
    );
  }
  const attribute = geometry.attributes[attributeName];
  const values = attribute.values;
  const length = values.length;
  const highValues = new Float32Array(length);
  const lowValues = new Float32Array(length);
  for (let i = 0; i < length; ++i) {
    EncodedCartesian3_default.encode(values[i], encodedResult);
    highValues[i] = encodedResult.high;
    lowValues[i] = encodedResult.low;
  }
  const componentsPerAttribute = attribute.componentsPerAttribute;
  geometry.attributes[attributeHighName] = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute,
    values: highValues
  });
  geometry.attributes[attributeLowName] = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute,
    values: lowValues
  });
  delete geometry.attributes[attributeName];
  return geometry;
};
var scratchCartesian34 = new Cartesian3_default();
function transformPoint(matrix, attribute) {
  if (defined_default(attribute)) {
    const values = attribute.values;
    const length = values.length;
    for (let i = 0; i < length; i += 3) {
      Cartesian3_default.unpack(values, i, scratchCartesian34);
      Matrix4_default.multiplyByPoint(matrix, scratchCartesian34, scratchCartesian34);
      Cartesian3_default.pack(scratchCartesian34, values, i);
    }
  }
}
function transformVector(matrix, attribute) {
  if (defined_default(attribute)) {
    const values = attribute.values;
    const length = values.length;
    for (let i = 0; i < length; i += 3) {
      Cartesian3_default.unpack(values, i, scratchCartesian34);
      Matrix3_default.multiplyByVector(matrix, scratchCartesian34, scratchCartesian34);
      scratchCartesian34 = Cartesian3_default.normalize(
        scratchCartesian34,
        scratchCartesian34
      );
      Cartesian3_default.pack(scratchCartesian34, values, i);
    }
  }
}
var inverseTranspose = new Matrix4_default();
var normalMatrix = new Matrix3_default();
GeometryPipeline.transformToWorldCoordinates = function(instance) {
  if (!defined_default(instance)) {
    throw new DeveloperError_default("instance is required.");
  }
  const modelMatrix = instance.modelMatrix;
  if (Matrix4_default.equals(modelMatrix, Matrix4_default.IDENTITY)) {
    return instance;
  }
  const attributes = instance.geometry.attributes;
  transformPoint(modelMatrix, attributes.position);
  transformPoint(modelMatrix, attributes.prevPosition);
  transformPoint(modelMatrix, attributes.nextPosition);
  if (defined_default(attributes.normal) || defined_default(attributes.tangent) || defined_default(attributes.bitangent)) {
    Matrix4_default.inverse(modelMatrix, inverseTranspose);
    Matrix4_default.transpose(inverseTranspose, inverseTranspose);
    Matrix4_default.getMatrix3(inverseTranspose, normalMatrix);
    transformVector(normalMatrix, attributes.normal);
    transformVector(normalMatrix, attributes.tangent);
    transformVector(normalMatrix, attributes.bitangent);
  }
  const boundingSphere = instance.geometry.boundingSphere;
  if (defined_default(boundingSphere)) {
    instance.geometry.boundingSphere = BoundingSphere_default.transform(
      boundingSphere,
      modelMatrix,
      boundingSphere
    );
  }
  instance.modelMatrix = Matrix4_default.clone(Matrix4_default.IDENTITY);
  return instance;
};
function findAttributesInAllGeometries(instances, propertyName) {
  const length = instances.length;
  const attributesInAllGeometries = {};
  const attributes0 = instances[0][propertyName].attributes;
  let name;
  for (name in attributes0) {
    if (attributes0.hasOwnProperty(name) && defined_default(attributes0[name]) && defined_default(attributes0[name].values)) {
      const attribute = attributes0[name];
      let numberOfComponents = attribute.values.length;
      let inAllGeometries = true;
      for (let i = 1; i < length; ++i) {
        const otherAttribute = instances[i][propertyName].attributes[name];
        if (!defined_default(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {
          inAllGeometries = false;
          break;
        }
        numberOfComponents += otherAttribute.values.length;
      }
      if (inAllGeometries) {
        attributesInAllGeometries[name] = new GeometryAttribute_default({
          componentDatatype: attribute.componentDatatype,
          componentsPerAttribute: attribute.componentsPerAttribute,
          normalize: attribute.normalize,
          values: ComponentDatatype_default.createTypedArray(
            attribute.componentDatatype,
            numberOfComponents
          )
        });
      }
    }
  }
  return attributesInAllGeometries;
}
var tempScratch = new Cartesian3_default();
function combineGeometries(instances, propertyName) {
  const length = instances.length;
  let name;
  let i;
  let j;
  let k;
  const m = instances[0].modelMatrix;
  const haveIndices = defined_default(instances[0][propertyName].indices);
  const primitiveType = instances[0][propertyName].primitiveType;
  for (i = 1; i < length; ++i) {
    if (!Matrix4_default.equals(instances[i].modelMatrix, m)) {
      throw new DeveloperError_default("All instances must have the same modelMatrix.");
    }
    if (defined_default(instances[i][propertyName].indices) !== haveIndices) {
      throw new DeveloperError_default(
        "All instance geometries must have an indices or not have one."
      );
    }
    if (instances[i][propertyName].primitiveType !== primitiveType) {
      throw new DeveloperError_default(
        "All instance geometries must have the same primitiveType."
      );
    }
  }
  const attributes = findAttributesInAllGeometries(instances, propertyName);
  let values;
  let sourceValues;
  let sourceValuesLength;
  for (name in attributes) {
    if (attributes.hasOwnProperty(name)) {
      values = attributes[name].values;
      k = 0;
      for (i = 0; i < length; ++i) {
        sourceValues = instances[i][propertyName].attributes[name].values;
        sourceValuesLength = sourceValues.length;
        for (j = 0; j < sourceValuesLength; ++j) {
          values[k++] = sourceValues[j];
        }
      }
    }
  }
  let indices;
  if (haveIndices) {
    let numberOfIndices = 0;
    for (i = 0; i < length; ++i) {
      numberOfIndices += instances[i][propertyName].indices.length;
    }
    const numberOfVertices = Geometry_default.computeNumberOfVertices(
      new Geometry_default({
        attributes,
        primitiveType: PrimitiveType_default.POINTS
      })
    );
    const destIndices = IndexDatatype_default.createTypedArray(
      numberOfVertices,
      numberOfIndices
    );
    let destOffset = 0;
    let offset = 0;
    for (i = 0; i < length; ++i) {
      const sourceIndices = instances[i][propertyName].indices;
      const sourceIndicesLen = sourceIndices.length;
      for (k = 0; k < sourceIndicesLen; ++k) {
        destIndices[destOffset++] = offset + sourceIndices[k];
      }
      offset += Geometry_default.computeNumberOfVertices(instances[i][propertyName]);
    }
    indices = destIndices;
  }
  let center = new Cartesian3_default();
  let radius = 0;
  let bs;
  for (i = 0; i < length; ++i) {
    bs = instances[i][propertyName].boundingSphere;
    if (!defined_default(bs)) {
      center = void 0;
      break;
    }
    Cartesian3_default.add(bs.center, center, center);
  }
  if (defined_default(center)) {
    Cartesian3_default.divideByScalar(center, length, center);
    for (i = 0; i < length; ++i) {
      bs = instances[i][propertyName].boundingSphere;
      const tempRadius = Cartesian3_default.magnitude(
        Cartesian3_default.subtract(bs.center, center, tempScratch)
      ) + bs.radius;
      if (tempRadius > radius) {
        radius = tempRadius;
      }
    }
  }
  return new Geometry_default({
    attributes,
    indices,
    primitiveType,
    boundingSphere: defined_default(center) ? new BoundingSphere_default(center, radius) : void 0
  });
}
GeometryPipeline.combineInstances = function(instances) {
  if (!defined_default(instances) || instances.length < 1) {
    throw new DeveloperError_default(
      "instances is required and must have length greater than zero."
    );
  }
  const instanceGeometry = [];
  const instanceSplitGeometry = [];
  const length = instances.length;
  for (let i = 0; i < length; ++i) {
    const instance = instances[i];
    if (defined_default(instance.geometry)) {
      instanceGeometry.push(instance);
    } else if (defined_default(instance.westHemisphereGeometry) && defined_default(instance.eastHemisphereGeometry)) {
      instanceSplitGeometry.push(instance);
    }
  }
  const geometries = [];
  if (instanceGeometry.length > 0) {
    geometries.push(combineGeometries(instanceGeometry, "geometry"));
  }
  if (instanceSplitGeometry.length > 0) {
    geometries.push(
      combineGeometries(instanceSplitGeometry, "westHemisphereGeometry")
    );
    geometries.push(
      combineGeometries(instanceSplitGeometry, "eastHemisphereGeometry")
    );
  }
  return geometries;
};
var normal = new Cartesian3_default();
var v0 = new Cartesian3_default();
var v1 = new Cartesian3_default();
var v2 = new Cartesian3_default();
GeometryPipeline.computeNormal = function(geometry) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  if (!defined_default(geometry.attributes.position) || !defined_default(geometry.attributes.position.values)) {
    throw new DeveloperError_default(
      "geometry.attributes.position.values is required."
    );
  }
  if (!defined_default(geometry.indices)) {
    throw new DeveloperError_default("geometry.indices is required.");
  }
  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {
    throw new DeveloperError_default(
      "geometry.indices length must be greater than 0 and be a multiple of 3."
    );
  }
  if (geometry.primitiveType !== PrimitiveType_default.TRIANGLES) {
    throw new DeveloperError_default(
      "geometry.primitiveType must be PrimitiveType.TRIANGLES."
    );
  }
  const indices = geometry.indices;
  const attributes = geometry.attributes;
  const vertices = attributes.position.values;
  const numVertices = attributes.position.values.length / 3;
  const numIndices = indices.length;
  const normalsPerVertex = new Array(numVertices);
  const normalsPerTriangle = new Array(numIndices / 3);
  const normalIndices = new Array(numIndices);
  let i;
  for (i = 0; i < numVertices; i++) {
    normalsPerVertex[i] = {
      indexOffset: 0,
      count: 0,
      currentCount: 0
    };
  }
  let j = 0;
  for (i = 0; i < numIndices; i += 3) {
    const i0 = indices[i];
    const i1 = indices[i + 1];
    const i2 = indices[i + 2];
    const i03 = i0 * 3;
    const i13 = i1 * 3;
    const i23 = i2 * 3;
    v0.x = vertices[i03];
    v0.y = vertices[i03 + 1];
    v0.z = vertices[i03 + 2];
    v1.x = vertices[i13];
    v1.y = vertices[i13 + 1];
    v1.z = vertices[i13 + 2];
    v2.x = vertices[i23];
    v2.y = vertices[i23 + 1];
    v2.z = vertices[i23 + 2];
    normalsPerVertex[i0].count++;
    normalsPerVertex[i1].count++;
    normalsPerVertex[i2].count++;
    Cartesian3_default.subtract(v1, v0, v1);
    Cartesian3_default.subtract(v2, v0, v2);
    normalsPerTriangle[j] = Cartesian3_default.cross(v1, v2, new Cartesian3_default());
    j++;
  }
  let indexOffset = 0;
  for (i = 0; i < numVertices; i++) {
    normalsPerVertex[i].indexOffset += indexOffset;
    indexOffset += normalsPerVertex[i].count;
  }
  j = 0;
  let vertexNormalData;
  for (i = 0; i < numIndices; i += 3) {
    vertexNormalData = normalsPerVertex[indices[i]];
    let index = vertexNormalData.indexOffset + vertexNormalData.currentCount;
    normalIndices[index] = j;
    vertexNormalData.currentCount++;
    vertexNormalData = normalsPerVertex[indices[i + 1]];
    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;
    normalIndices[index] = j;
    vertexNormalData.currentCount++;
    vertexNormalData = normalsPerVertex[indices[i + 2]];
    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;
    normalIndices[index] = j;
    vertexNormalData.currentCount++;
    j++;
  }
  const normalValues = new Float32Array(numVertices * 3);
  for (i = 0; i < numVertices; i++) {
    const i3 = i * 3;
    vertexNormalData = normalsPerVertex[i];
    Cartesian3_default.clone(Cartesian3_default.ZERO, normal);
    if (vertexNormalData.count > 0) {
      for (j = 0; j < vertexNormalData.count; j++) {
        Cartesian3_default.add(
          normal,
          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]],
          normal
        );
      }
      if (Cartesian3_default.equalsEpsilon(Cartesian3_default.ZERO, normal, Math_default.EPSILON10)) {
        Cartesian3_default.clone(
          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]],
          normal
        );
      }
    }
    if (Cartesian3_default.equalsEpsilon(Cartesian3_default.ZERO, normal, Math_default.EPSILON10)) {
      normal.z = 1;
    }
    Cartesian3_default.normalize(normal, normal);
    normalValues[i3] = normal.x;
    normalValues[i3 + 1] = normal.y;
    normalValues[i3 + 2] = normal.z;
  }
  geometry.attributes.normal = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    values: normalValues
  });
  return geometry;
};
var normalScratch2 = new Cartesian3_default();
var normalScale = new Cartesian3_default();
var tScratch = new Cartesian3_default();
GeometryPipeline.computeTangentAndBitangent = function(geometry) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  const attributes = geometry.attributes;
  const indices = geometry.indices;
  if (!defined_default(attributes.position) || !defined_default(attributes.position.values)) {
    throw new DeveloperError_default(
      "geometry.attributes.position.values is required."
    );
  }
  if (!defined_default(attributes.normal) || !defined_default(attributes.normal.values)) {
    throw new DeveloperError_default("geometry.attributes.normal.values is required.");
  }
  if (!defined_default(attributes.st) || !defined_default(attributes.st.values)) {
    throw new DeveloperError_default("geometry.attributes.st.values is required.");
  }
  if (!defined_default(indices)) {
    throw new DeveloperError_default("geometry.indices is required.");
  }
  if (indices.length < 2 || indices.length % 3 !== 0) {
    throw new DeveloperError_default(
      "geometry.indices length must be greater than 0 and be a multiple of 3."
    );
  }
  if (geometry.primitiveType !== PrimitiveType_default.TRIANGLES) {
    throw new DeveloperError_default(
      "geometry.primitiveType must be PrimitiveType.TRIANGLES."
    );
  }
  const vertices = geometry.attributes.position.values;
  const normals = geometry.attributes.normal.values;
  const st = geometry.attributes.st.values;
  const numVertices = geometry.attributes.position.values.length / 3;
  const numIndices = indices.length;
  const tan1 = new Array(numVertices * 3);
  let i;
  for (i = 0; i < tan1.length; i++) {
    tan1[i] = 0;
  }
  let i03;
  let i13;
  let i23;
  for (i = 0; i < numIndices; i += 3) {
    const i0 = indices[i];
    const i1 = indices[i + 1];
    const i2 = indices[i + 2];
    i03 = i0 * 3;
    i13 = i1 * 3;
    i23 = i2 * 3;
    const i02 = i0 * 2;
    const i12 = i1 * 2;
    const i22 = i2 * 2;
    const ux = vertices[i03];
    const uy = vertices[i03 + 1];
    const uz = vertices[i03 + 2];
    const wx = st[i02];
    const wy = st[i02 + 1];
    const t1 = st[i12 + 1] - wy;
    const t2 = st[i22 + 1] - wy;
    const r = 1 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);
    const sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;
    const sdiry = (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;
    const sdirz = (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;
    tan1[i03] += sdirx;
    tan1[i03 + 1] += sdiry;
    tan1[i03 + 2] += sdirz;
    tan1[i13] += sdirx;
    tan1[i13 + 1] += sdiry;
    tan1[i13 + 2] += sdirz;
    tan1[i23] += sdirx;
    tan1[i23 + 1] += sdiry;
    tan1[i23 + 2] += sdirz;
  }
  const tangentValues = new Float32Array(numVertices * 3);
  const bitangentValues = new Float32Array(numVertices * 3);
  for (i = 0; i < numVertices; i++) {
    i03 = i * 3;
    i13 = i03 + 1;
    i23 = i03 + 2;
    const n = Cartesian3_default.fromArray(normals, i03, normalScratch2);
    const t = Cartesian3_default.fromArray(tan1, i03, tScratch);
    const scalar = Cartesian3_default.dot(n, t);
    Cartesian3_default.multiplyByScalar(n, scalar, normalScale);
    Cartesian3_default.normalize(Cartesian3_default.subtract(t, normalScale, t), t);
    tangentValues[i03] = t.x;
    tangentValues[i13] = t.y;
    tangentValues[i23] = t.z;
    Cartesian3_default.normalize(Cartesian3_default.cross(n, t, t), t);
    bitangentValues[i03] = t.x;
    bitangentValues[i13] = t.y;
    bitangentValues[i23] = t.z;
  }
  geometry.attributes.tangent = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    values: tangentValues
  });
  geometry.attributes.bitangent = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    values: bitangentValues
  });
  return geometry;
};
var scratchCartesian23 = new Cartesian2_default();
var toEncode1 = new Cartesian3_default();
var toEncode2 = new Cartesian3_default();
var toEncode3 = new Cartesian3_default();
var encodeResult2 = new Cartesian2_default();
GeometryPipeline.compressVertices = function(geometry) {
  if (!defined_default(geometry)) {
    throw new DeveloperError_default("geometry is required.");
  }
  const extrudeAttribute = geometry.attributes.extrudeDirection;
  let i;
  let numVertices;
  if (defined_default(extrudeAttribute)) {
    const extrudeDirections = extrudeAttribute.values;
    numVertices = extrudeDirections.length / 3;
    const compressedDirections = new Float32Array(numVertices * 2);
    let i2 = 0;
    for (i = 0; i < numVertices; ++i) {
      Cartesian3_default.fromArray(extrudeDirections, i * 3, toEncode1);
      if (Cartesian3_default.equals(toEncode1, Cartesian3_default.ZERO)) {
        i2 += 2;
        continue;
      }
      encodeResult2 = AttributeCompression_default.octEncodeInRange(
        toEncode1,
        65535,
        encodeResult2
      );
      compressedDirections[i2++] = encodeResult2.x;
      compressedDirections[i2++] = encodeResult2.y;
    }
    geometry.attributes.compressedAttributes = new GeometryAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 2,
      values: compressedDirections
    });
    delete geometry.attributes.extrudeDirection;
    return geometry;
  }
  const normalAttribute = geometry.attributes.normal;
  const stAttribute = geometry.attributes.st;
  const hasNormal = defined_default(normalAttribute);
  const hasSt = defined_default(stAttribute);
  if (!hasNormal && !hasSt) {
    return geometry;
  }
  const tangentAttribute = geometry.attributes.tangent;
  const bitangentAttribute = geometry.attributes.bitangent;
  const hasTangent = defined_default(tangentAttribute);
  const hasBitangent = defined_default(bitangentAttribute);
  let normals;
  let st;
  let tangents;
  let bitangents;
  if (hasNormal) {
    normals = normalAttribute.values;
  }
  if (hasSt) {
    st = stAttribute.values;
  }
  if (hasTangent) {
    tangents = tangentAttribute.values;
  }
  if (hasBitangent) {
    bitangents = bitangentAttribute.values;
  }
  const length = hasNormal ? normals.length : st.length;
  const numComponents = hasNormal ? 3 : 2;
  numVertices = length / numComponents;
  let compressedLength = numVertices;
  let numCompressedComponents = hasSt && hasNormal ? 2 : 1;
  numCompressedComponents += hasTangent || hasBitangent ? 1 : 0;
  compressedLength *= numCompressedComponents;
  const compressedAttributes = new Float32Array(compressedLength);
  let normalIndex = 0;
  for (i = 0; i < numVertices; ++i) {
    if (hasSt) {
      Cartesian2_default.fromArray(st, i * 2, scratchCartesian23);
      compressedAttributes[normalIndex++] = AttributeCompression_default.compressTextureCoordinates(scratchCartesian23);
    }
    const index = i * 3;
    if (hasNormal && defined_default(tangents) && defined_default(bitangents)) {
      Cartesian3_default.fromArray(normals, index, toEncode1);
      Cartesian3_default.fromArray(tangents, index, toEncode2);
      Cartesian3_default.fromArray(bitangents, index, toEncode3);
      AttributeCompression_default.octPack(
        toEncode1,
        toEncode2,
        toEncode3,
        scratchCartesian23
      );
      compressedAttributes[normalIndex++] = scratchCartesian23.x;
      compressedAttributes[normalIndex++] = scratchCartesian23.y;
    } else {
      if (hasNormal) {
        Cartesian3_default.fromArray(normals, index, toEncode1);
        compressedAttributes[normalIndex++] = AttributeCompression_default.octEncodeFloat(toEncode1);
      }
      if (hasTangent) {
        Cartesian3_default.fromArray(tangents, index, toEncode1);
        compressedAttributes[normalIndex++] = AttributeCompression_default.octEncodeFloat(toEncode1);
      }
      if (hasBitangent) {
        Cartesian3_default.fromArray(bitangents, index, toEncode1);
        compressedAttributes[normalIndex++] = AttributeCompression_default.octEncodeFloat(toEncode1);
      }
    }
  }
  geometry.attributes.compressedAttributes = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: numCompressedComponents,
    values: compressedAttributes
  });
  if (hasNormal) {
    delete geometry.attributes.normal;
  }
  if (hasSt) {
    delete geometry.attributes.st;
  }
  if (hasBitangent) {
    delete geometry.attributes.bitangent;
  }
  if (hasTangent) {
    delete geometry.attributes.tangent;
  }
  return geometry;
};
function indexTriangles(geometry) {
  if (defined_default(geometry.indices)) {
    return geometry;
  }
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  if (numberOfVertices < 3) {
    throw new DeveloperError_default("The number of vertices must be at least three.");
  }
  if (numberOfVertices % 3 !== 0) {
    throw new DeveloperError_default(
      "The number of vertices must be a multiple of three."
    );
  }
  const indices = IndexDatatype_default.createTypedArray(
    numberOfVertices,
    numberOfVertices
  );
  for (let i = 0; i < numberOfVertices; ++i) {
    indices[i] = i;
  }
  geometry.indices = indices;
  return geometry;
}
function indexTriangleFan(geometry) {
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  if (numberOfVertices < 3) {
    throw new DeveloperError_default("The number of vertices must be at least three.");
  }
  const indices = IndexDatatype_default.createTypedArray(
    numberOfVertices,
    (numberOfVertices - 2) * 3
  );
  indices[0] = 1;
  indices[1] = 0;
  indices[2] = 2;
  let indicesIndex = 3;
  for (let i = 3; i < numberOfVertices; ++i) {
    indices[indicesIndex++] = i - 1;
    indices[indicesIndex++] = 0;
    indices[indicesIndex++] = i;
  }
  geometry.indices = indices;
  geometry.primitiveType = PrimitiveType_default.TRIANGLES;
  return geometry;
}
function indexTriangleStrip(geometry) {
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  if (numberOfVertices < 3) {
    throw new DeveloperError_default("The number of vertices must be at least 3.");
  }
  const indices = IndexDatatype_default.createTypedArray(
    numberOfVertices,
    (numberOfVertices - 2) * 3
  );
  indices[0] = 0;
  indices[1] = 1;
  indices[2] = 2;
  if (numberOfVertices > 3) {
    indices[3] = 0;
    indices[4] = 2;
    indices[5] = 3;
  }
  let indicesIndex = 6;
  for (let i = 3; i < numberOfVertices - 1; i += 2) {
    indices[indicesIndex++] = i;
    indices[indicesIndex++] = i - 1;
    indices[indicesIndex++] = i + 1;
    if (i + 2 < numberOfVertices) {
      indices[indicesIndex++] = i;
      indices[indicesIndex++] = i + 1;
      indices[indicesIndex++] = i + 2;
    }
  }
  geometry.indices = indices;
  geometry.primitiveType = PrimitiveType_default.TRIANGLES;
  return geometry;
}
function indexLines(geometry) {
  if (defined_default(geometry.indices)) {
    return geometry;
  }
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  if (numberOfVertices < 2) {
    throw new DeveloperError_default("The number of vertices must be at least two.");
  }
  if (numberOfVertices % 2 !== 0) {
    throw new DeveloperError_default("The number of vertices must be a multiple of 2.");
  }
  const indices = IndexDatatype_default.createTypedArray(
    numberOfVertices,
    numberOfVertices
  );
  for (let i = 0; i < numberOfVertices; ++i) {
    indices[i] = i;
  }
  geometry.indices = indices;
  return geometry;
}
function indexLineStrip(geometry) {
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  if (numberOfVertices < 2) {
    throw new DeveloperError_default("The number of vertices must be at least two.");
  }
  const indices = IndexDatatype_default.createTypedArray(
    numberOfVertices,
    (numberOfVertices - 1) * 2
  );
  indices[0] = 0;
  indices[1] = 1;
  let indicesIndex = 2;
  for (let i = 2; i < numberOfVertices; ++i) {
    indices[indicesIndex++] = i - 1;
    indices[indicesIndex++] = i;
  }
  geometry.indices = indices;
  geometry.primitiveType = PrimitiveType_default.LINES;
  return geometry;
}
function indexLineLoop(geometry) {
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  if (numberOfVertices < 2) {
    throw new DeveloperError_default("The number of vertices must be at least two.");
  }
  const indices = IndexDatatype_default.createTypedArray(
    numberOfVertices,
    numberOfVertices * 2
  );
  indices[0] = 0;
  indices[1] = 1;
  let indicesIndex = 2;
  for (let i = 2; i < numberOfVertices; ++i) {
    indices[indicesIndex++] = i - 1;
    indices[indicesIndex++] = i;
  }
  indices[indicesIndex++] = numberOfVertices - 1;
  indices[indicesIndex] = 0;
  geometry.indices = indices;
  geometry.primitiveType = PrimitiveType_default.LINES;
  return geometry;
}
function indexPrimitive(geometry) {
  switch (geometry.primitiveType) {
    case PrimitiveType_default.TRIANGLE_FAN:
      return indexTriangleFan(geometry);
    case PrimitiveType_default.TRIANGLE_STRIP:
      return indexTriangleStrip(geometry);
    case PrimitiveType_default.TRIANGLES:
      return indexTriangles(geometry);
    case PrimitiveType_default.LINE_STRIP:
      return indexLineStrip(geometry);
    case PrimitiveType_default.LINE_LOOP:
      return indexLineLoop(geometry);
    case PrimitiveType_default.LINES:
      return indexLines(geometry);
  }
  return geometry;
}
function offsetPointFromXZPlane(p, isBehind) {
  if (Math.abs(p.y) < Math_default.EPSILON6) {
    if (isBehind) {
      p.y = -Math_default.EPSILON6;
    } else {
      p.y = Math_default.EPSILON6;
    }
  }
}
function offsetTriangleFromXZPlane(p0, p1, p2) {
  if (p0.y !== 0 && p1.y !== 0 && p2.y !== 0) {
    offsetPointFromXZPlane(p0, p0.y < 0);
    offsetPointFromXZPlane(p1, p1.y < 0);
    offsetPointFromXZPlane(p2, p2.y < 0);
    return;
  }
  const p0y = Math.abs(p0.y);
  const p1y = Math.abs(p1.y);
  const p2y = Math.abs(p2.y);
  let sign2;
  if (p0y > p1y) {
    if (p0y > p2y) {
      sign2 = Math_default.sign(p0.y);
    } else {
      sign2 = Math_default.sign(p2.y);
    }
  } else if (p1y > p2y) {
    sign2 = Math_default.sign(p1.y);
  } else {
    sign2 = Math_default.sign(p2.y);
  }
  const isBehind = sign2 < 0;
  offsetPointFromXZPlane(p0, isBehind);
  offsetPointFromXZPlane(p1, isBehind);
  offsetPointFromXZPlane(p2, isBehind);
}
var c3 = new Cartesian3_default();
function getXZIntersectionOffsetPoints(p, p1, u12, v12) {
  Cartesian3_default.add(
    p,
    Cartesian3_default.multiplyByScalar(
      Cartesian3_default.subtract(p1, p, c3),
      p.y / (p.y - p1.y),
      c3
    ),
    u12
  );
  Cartesian3_default.clone(u12, v12);
  offsetPointFromXZPlane(u12, true);
  offsetPointFromXZPlane(v12, false);
}
var u1 = new Cartesian3_default();
var u2 = new Cartesian3_default();
var q1 = new Cartesian3_default();
var q2 = new Cartesian3_default();
var splitTriangleResult = {
  positions: new Array(7),
  indices: new Array(3 * 3)
};
function splitTriangle(p0, p1, p2) {
  if (p0.x >= 0 || p1.x >= 0 || p2.x >= 0) {
    return void 0;
  }
  offsetTriangleFromXZPlane(p0, p1, p2);
  const p0Behind = p0.y < 0;
  const p1Behind = p1.y < 0;
  const p2Behind = p2.y < 0;
  let numBehind = 0;
  numBehind += p0Behind ? 1 : 0;
  numBehind += p1Behind ? 1 : 0;
  numBehind += p2Behind ? 1 : 0;
  const indices = splitTriangleResult.indices;
  if (numBehind === 1) {
    indices[1] = 3;
    indices[2] = 4;
    indices[5] = 6;
    indices[7] = 6;
    indices[8] = 5;
    if (p0Behind) {
      getXZIntersectionOffsetPoints(p0, p1, u1, q1);
      getXZIntersectionOffsetPoints(p0, p2, u2, q2);
      indices[0] = 0;
      indices[3] = 1;
      indices[4] = 2;
      indices[6] = 1;
    } else if (p1Behind) {
      getXZIntersectionOffsetPoints(p1, p2, u1, q1);
      getXZIntersectionOffsetPoints(p1, p0, u2, q2);
      indices[0] = 1;
      indices[3] = 2;
      indices[4] = 0;
      indices[6] = 2;
    } else if (p2Behind) {
      getXZIntersectionOffsetPoints(p2, p0, u1, q1);
      getXZIntersectionOffsetPoints(p2, p1, u2, q2);
      indices[0] = 2;
      indices[3] = 0;
      indices[4] = 1;
      indices[6] = 0;
    }
  } else if (numBehind === 2) {
    indices[2] = 4;
    indices[4] = 4;
    indices[5] = 3;
    indices[7] = 5;
    indices[8] = 6;
    if (!p0Behind) {
      getXZIntersectionOffsetPoints(p0, p1, u1, q1);
      getXZIntersectionOffsetPoints(p0, p2, u2, q2);
      indices[0] = 1;
      indices[1] = 2;
      indices[3] = 1;
      indices[6] = 0;
    } else if (!p1Behind) {
      getXZIntersectionOffsetPoints(p1, p2, u1, q1);
      getXZIntersectionOffsetPoints(p1, p0, u2, q2);
      indices[0] = 2;
      indices[1] = 0;
      indices[3] = 2;
      indices[6] = 1;
    } else if (!p2Behind) {
      getXZIntersectionOffsetPoints(p2, p0, u1, q1);
      getXZIntersectionOffsetPoints(p2, p1, u2, q2);
      indices[0] = 0;
      indices[1] = 1;
      indices[3] = 0;
      indices[6] = 2;
    }
  }
  const positions = splitTriangleResult.positions;
  positions[0] = p0;
  positions[1] = p1;
  positions[2] = p2;
  positions.length = 3;
  if (numBehind === 1 || numBehind === 2) {
    positions[3] = u1;
    positions[4] = u2;
    positions[5] = q1;
    positions[6] = q2;
    positions.length = 7;
  }
  return splitTriangleResult;
}
function updateGeometryAfterSplit(geometry, computeBoundingSphere) {
  const attributes = geometry.attributes;
  if (attributes.position.values.length === 0) {
    return void 0;
  }
  for (const property in attributes) {
    if (attributes.hasOwnProperty(property) && defined_default(attributes[property]) && defined_default(attributes[property].values)) {
      const attribute = attributes[property];
      attribute.values = ComponentDatatype_default.createTypedArray(
        attribute.componentDatatype,
        attribute.values
      );
    }
  }
  const numberOfVertices = Geometry_default.computeNumberOfVertices(geometry);
  geometry.indices = IndexDatatype_default.createTypedArray(
    numberOfVertices,
    geometry.indices
  );
  if (computeBoundingSphere) {
    geometry.boundingSphere = BoundingSphere_default.fromVertices(
      attributes.position.values
    );
  }
  return geometry;
}
function copyGeometryForSplit(geometry) {
  const attributes = geometry.attributes;
  const copiedAttributes = {};
  for (const property in attributes) {
    if (attributes.hasOwnProperty(property) && defined_default(attributes[property]) && defined_default(attributes[property].values)) {
      const attribute = attributes[property];
      copiedAttributes[property] = new GeometryAttribute_default({
        componentDatatype: attribute.componentDatatype,
        componentsPerAttribute: attribute.componentsPerAttribute,
        normalize: attribute.normalize,
        values: []
      });
    }
  }
  return new Geometry_default({
    attributes: copiedAttributes,
    indices: [],
    primitiveType: geometry.primitiveType
  });
}
function updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {
  const computeBoundingSphere = defined_default(instance.geometry.boundingSphere);
  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);
  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);
  if (defined_default(eastGeometry) && !defined_default(westGeometry)) {
    instance.geometry = eastGeometry;
  } else if (!defined_default(eastGeometry) && defined_default(westGeometry)) {
    instance.geometry = westGeometry;
  } else {
    instance.westHemisphereGeometry = westGeometry;
    instance.eastHemisphereGeometry = eastGeometry;
    instance.geometry = void 0;
  }
}
function generateBarycentricInterpolateFunction(CartesianType, numberOfComponents) {
  const v0Scratch = new CartesianType();
  const v1Scratch = new CartesianType();
  const v2Scratch = new CartesianType();
  return function(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, normalize) {
    const v02 = CartesianType.fromArray(
      sourceValues,
      i0 * numberOfComponents,
      v0Scratch
    );
    const v12 = CartesianType.fromArray(
      sourceValues,
      i1 * numberOfComponents,
      v1Scratch
    );
    const v22 = CartesianType.fromArray(
      sourceValues,
      i2 * numberOfComponents,
      v2Scratch
    );
    CartesianType.multiplyByScalar(v02, coords.x, v02);
    CartesianType.multiplyByScalar(v12, coords.y, v12);
    CartesianType.multiplyByScalar(v22, coords.z, v22);
    const value = CartesianType.add(v02, v12, v02);
    CartesianType.add(value, v22, value);
    if (normalize) {
      CartesianType.normalize(value, value);
    }
    CartesianType.pack(
      value,
      currentValues,
      insertedIndex * numberOfComponents
    );
  };
}
var interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(
  Cartesian4_default,
  4
);
var interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(
  Cartesian3_default,
  3
);
var interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(
  Cartesian2_default,
  2
);
var interpolateAndPackBoolean = function(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex) {
  const v12 = sourceValues[i0] * coords.x;
  const v22 = sourceValues[i1] * coords.y;
  const v3 = sourceValues[i2] * coords.z;
  currentValues[insertedIndex] = v12 + v22 + v3 > Math_default.EPSILON6 ? 1 : 0;
};
var p0Scratch = new Cartesian3_default();
var p1Scratch = new Cartesian3_default();
var p2Scratch = new Cartesian3_default();
var barycentricScratch = new Cartesian3_default();
function computeTriangleAttributes(i0, i1, i2, point, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, allAttributes, insertedIndex) {
  if (!defined_default(normals) && !defined_default(tangents) && !defined_default(bitangents) && !defined_default(texCoords) && !defined_default(extrudeDirections) && customAttributesLength === 0) {
    return;
  }
  const p0 = Cartesian3_default.fromArray(positions, i0 * 3, p0Scratch);
  const p1 = Cartesian3_default.fromArray(positions, i1 * 3, p1Scratch);
  const p2 = Cartesian3_default.fromArray(positions, i2 * 3, p2Scratch);
  const coords = barycentricCoordinates_default(point, p0, p1, p2, barycentricScratch);
  if (!defined_default(coords)) {
    return;
  }
  if (defined_default(normals)) {
    interpolateAndPackCartesian3(
      i0,
      i1,
      i2,
      coords,
      normals,
      currentAttributes.normal.values,
      insertedIndex,
      true
    );
  }
  if (defined_default(extrudeDirections)) {
    const d0 = Cartesian3_default.fromArray(extrudeDirections, i0 * 3, p0Scratch);
    const d1 = Cartesian3_default.fromArray(extrudeDirections, i1 * 3, p1Scratch);
    const d2 = Cartesian3_default.fromArray(extrudeDirections, i2 * 3, p2Scratch);
    Cartesian3_default.multiplyByScalar(d0, coords.x, d0);
    Cartesian3_default.multiplyByScalar(d1, coords.y, d1);
    Cartesian3_default.multiplyByScalar(d2, coords.z, d2);
    let direction2;
    if (!Cartesian3_default.equals(d0, Cartesian3_default.ZERO) || !Cartesian3_default.equals(d1, Cartesian3_default.ZERO) || !Cartesian3_default.equals(d2, Cartesian3_default.ZERO)) {
      direction2 = Cartesian3_default.add(d0, d1, d0);
      Cartesian3_default.add(direction2, d2, direction2);
      Cartesian3_default.normalize(direction2, direction2);
    } else {
      direction2 = p0Scratch;
      direction2.x = 0;
      direction2.y = 0;
      direction2.z = 0;
    }
    Cartesian3_default.pack(
      direction2,
      currentAttributes.extrudeDirection.values,
      insertedIndex * 3
    );
  }
  if (defined_default(applyOffset)) {
    interpolateAndPackBoolean(
      i0,
      i1,
      i2,
      coords,
      applyOffset,
      currentAttributes.applyOffset.values,
      insertedIndex
    );
  }
  if (defined_default(tangents)) {
    interpolateAndPackCartesian3(
      i0,
      i1,
      i2,
      coords,
      tangents,
      currentAttributes.tangent.values,
      insertedIndex,
      true
    );
  }
  if (defined_default(bitangents)) {
    interpolateAndPackCartesian3(
      i0,
      i1,
      i2,
      coords,
      bitangents,
      currentAttributes.bitangent.values,
      insertedIndex,
      true
    );
  }
  if (defined_default(texCoords)) {
    interpolateAndPackCartesian2(
      i0,
      i1,
      i2,
      coords,
      texCoords,
      currentAttributes.st.values,
      insertedIndex
    );
  }
  if (customAttributesLength > 0) {
    for (let i = 0; i < customAttributesLength; i++) {
      const attributeName = customAttributeNames[i];
      genericInterpolate(
        i0,
        i1,
        i2,
        coords,
        insertedIndex,
        allAttributes[attributeName],
        currentAttributes[attributeName]
      );
    }
  }
}
function genericInterpolate(i0, i1, i2, coords, insertedIndex, sourceAttribute, currentAttribute) {
  const componentsPerAttribute = sourceAttribute.componentsPerAttribute;
  const sourceValues = sourceAttribute.values;
  const currentValues = currentAttribute.values;
  switch (componentsPerAttribute) {
    case 4:
      interpolateAndPackCartesian4(
        i0,
        i1,
        i2,
        coords,
        sourceValues,
        currentValues,
        insertedIndex,
        false
      );
      break;
    case 3:
      interpolateAndPackCartesian3(
        i0,
        i1,
        i2,
        coords,
        sourceValues,
        currentValues,
        insertedIndex,
        false
      );
      break;
    case 2:
      interpolateAndPackCartesian2(
        i0,
        i1,
        i2,
        coords,
        sourceValues,
        currentValues,
        insertedIndex,
        false
      );
      break;
    default:
      currentValues[insertedIndex] = sourceValues[i0] * coords.x + sourceValues[i1] * coords.y + sourceValues[i2] * coords.z;
  }
}
function insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, currentIndex, point) {
  const insertIndex = currentAttributes.position.values.length / 3;
  if (currentIndex !== -1) {
    const prevIndex = indices[currentIndex];
    const newIndex = currentIndexMap[prevIndex];
    if (newIndex === -1) {
      currentIndexMap[prevIndex] = insertIndex;
      currentAttributes.position.values.push(point.x, point.y, point.z);
      currentIndices.push(insertIndex);
      return insertIndex;
    }
    currentIndices.push(newIndex);
    return newIndex;
  }
  currentAttributes.position.values.push(point.x, point.y, point.z);
  currentIndices.push(insertIndex);
  return insertIndex;
}
var NAMED_ATTRIBUTES = {
  position: true,
  normal: true,
  bitangent: true,
  tangent: true,
  st: true,
  extrudeDirection: true,
  applyOffset: true
};
function splitLongitudeTriangles(instance) {
  const geometry = instance.geometry;
  const attributes = geometry.attributes;
  const positions = attributes.position.values;
  const normals = defined_default(attributes.normal) ? attributes.normal.values : void 0;
  const bitangents = defined_default(attributes.bitangent) ? attributes.bitangent.values : void 0;
  const tangents = defined_default(attributes.tangent) ? attributes.tangent.values : void 0;
  const texCoords = defined_default(attributes.st) ? attributes.st.values : void 0;
  const extrudeDirections = defined_default(attributes.extrudeDirection) ? attributes.extrudeDirection.values : void 0;
  const applyOffset = defined_default(attributes.applyOffset) ? attributes.applyOffset.values : void 0;
  const indices = geometry.indices;
  const customAttributeNames = [];
  for (const attributeName in attributes) {
    if (attributes.hasOwnProperty(attributeName) && !NAMED_ATTRIBUTES[attributeName] && defined_default(attributes[attributeName])) {
      customAttributeNames.push(attributeName);
    }
  }
  const customAttributesLength = customAttributeNames.length;
  const eastGeometry = copyGeometryForSplit(geometry);
  const westGeometry = copyGeometryForSplit(geometry);
  let currentAttributes;
  let currentIndices;
  let currentIndexMap;
  let insertedIndex;
  let i;
  const westGeometryIndexMap = [];
  westGeometryIndexMap.length = positions.length / 3;
  const eastGeometryIndexMap = [];
  eastGeometryIndexMap.length = positions.length / 3;
  for (i = 0; i < westGeometryIndexMap.length; ++i) {
    westGeometryIndexMap[i] = -1;
    eastGeometryIndexMap[i] = -1;
  }
  const len = indices.length;
  for (i = 0; i < len; i += 3) {
    const i0 = indices[i];
    const i1 = indices[i + 1];
    const i2 = indices[i + 2];
    let p0 = Cartesian3_default.fromArray(positions, i0 * 3);
    let p1 = Cartesian3_default.fromArray(positions, i1 * 3);
    let p2 = Cartesian3_default.fromArray(positions, i2 * 3);
    const result = splitTriangle(p0, p1, p2);
    if (defined_default(result) && result.positions.length > 3) {
      const resultPositions = result.positions;
      const resultIndices = result.indices;
      const resultLength = resultIndices.length;
      for (let j = 0; j < resultLength; ++j) {
        const resultIndex = resultIndices[j];
        const point = resultPositions[resultIndex];
        if (point.y < 0) {
          currentAttributes = westGeometry.attributes;
          currentIndices = westGeometry.indices;
          currentIndexMap = westGeometryIndexMap;
        } else {
          currentAttributes = eastGeometry.attributes;
          currentIndices = eastGeometry.indices;
          currentIndexMap = eastGeometryIndexMap;
        }
        insertedIndex = insertSplitPoint(
          currentAttributes,
          currentIndices,
          currentIndexMap,
          indices,
          resultIndex < 3 ? i + resultIndex : -1,
          point
        );
        computeTriangleAttributes(
          i0,
          i1,
          i2,
          point,
          positions,
          normals,
          tangents,
          bitangents,
          texCoords,
          extrudeDirections,
          applyOffset,
          currentAttributes,
          customAttributeNames,
          customAttributesLength,
          attributes,
          insertedIndex
        );
      }
    } else {
      if (defined_default(result)) {
        p0 = result.positions[0];
        p1 = result.positions[1];
        p2 = result.positions[2];
      }
      if (p0.y < 0) {
        currentAttributes = westGeometry.attributes;
        currentIndices = westGeometry.indices;
        currentIndexMap = westGeometryIndexMap;
      } else {
        currentAttributes = eastGeometry.attributes;
        currentIndices = eastGeometry.indices;
        currentIndexMap = eastGeometryIndexMap;
      }
      insertedIndex = insertSplitPoint(
        currentAttributes,
        currentIndices,
        currentIndexMap,
        indices,
        i,
        p0
      );
      computeTriangleAttributes(
        i0,
        i1,
        i2,
        p0,
        positions,
        normals,
        tangents,
        bitangents,
        texCoords,
        extrudeDirections,
        applyOffset,
        currentAttributes,
        customAttributeNames,
        customAttributesLength,
        attributes,
        insertedIndex
      );
      insertedIndex = insertSplitPoint(
        currentAttributes,
        currentIndices,
        currentIndexMap,
        indices,
        i + 1,
        p1
      );
      computeTriangleAttributes(
        i0,
        i1,
        i2,
        p1,
        positions,
        normals,
        tangents,
        bitangents,
        texCoords,
        extrudeDirections,
        applyOffset,
        currentAttributes,
        customAttributeNames,
        customAttributesLength,
        attributes,
        insertedIndex
      );
      insertedIndex = insertSplitPoint(
        currentAttributes,
        currentIndices,
        currentIndexMap,
        indices,
        i + 2,
        p2
      );
      computeTriangleAttributes(
        i0,
        i1,
        i2,
        p2,
        positions,
        normals,
        tangents,
        bitangents,
        texCoords,
        extrudeDirections,
        applyOffset,
        currentAttributes,
        customAttributeNames,
        customAttributesLength,
        attributes,
        insertedIndex
      );
    }
  }
  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);
}
var xzPlane = Plane_default.fromPointNormal(Cartesian3_default.ZERO, Cartesian3_default.UNIT_Y);
var offsetScratch = new Cartesian3_default();
var offsetPointScratch = new Cartesian3_default();
function computeLineAttributes(i0, i1, point, positions, insertIndex, currentAttributes, applyOffset) {
  if (!defined_default(applyOffset)) {
    return;
  }
  const p0 = Cartesian3_default.fromArray(positions, i0 * 3, p0Scratch);
  if (Cartesian3_default.equalsEpsilon(p0, point, Math_default.EPSILON10)) {
    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];
  } else {
    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];
  }
}
function splitLongitudeLines(instance) {
  const geometry = instance.geometry;
  const attributes = geometry.attributes;
  const positions = attributes.position.values;
  const applyOffset = defined_default(attributes.applyOffset) ? attributes.applyOffset.values : void 0;
  const indices = geometry.indices;
  const eastGeometry = copyGeometryForSplit(geometry);
  const westGeometry = copyGeometryForSplit(geometry);
  let i;
  const length = indices.length;
  const westGeometryIndexMap = [];
  westGeometryIndexMap.length = positions.length / 3;
  const eastGeometryIndexMap = [];
  eastGeometryIndexMap.length = positions.length / 3;
  for (i = 0; i < westGeometryIndexMap.length; ++i) {
    westGeometryIndexMap[i] = -1;
    eastGeometryIndexMap[i] = -1;
  }
  for (i = 0; i < length; i += 2) {
    const i0 = indices[i];
    const i1 = indices[i + 1];
    const p0 = Cartesian3_default.fromArray(positions, i0 * 3, p0Scratch);
    const p1 = Cartesian3_default.fromArray(positions, i1 * 3, p1Scratch);
    let insertIndex;
    if (Math.abs(p0.y) < Math_default.EPSILON6) {
      if (p0.y < 0) {
        p0.y = -Math_default.EPSILON6;
      } else {
        p0.y = Math_default.EPSILON6;
      }
    }
    if (Math.abs(p1.y) < Math_default.EPSILON6) {
      if (p1.y < 0) {
        p1.y = -Math_default.EPSILON6;
      } else {
        p1.y = Math_default.EPSILON6;
      }
    }
    let p0Attributes = eastGeometry.attributes;
    let p0Indices = eastGeometry.indices;
    let p0IndexMap = eastGeometryIndexMap;
    let p1Attributes = westGeometry.attributes;
    let p1Indices = westGeometry.indices;
    let p1IndexMap = westGeometryIndexMap;
    const intersection = IntersectionTests_default.lineSegmentPlane(
      p0,
      p1,
      xzPlane,
      p2Scratch
    );
    if (defined_default(intersection)) {
      const offset = Cartesian3_default.multiplyByScalar(
        Cartesian3_default.UNIT_Y,
        5 * Math_default.EPSILON9,
        offsetScratch
      );
      if (p0.y < 0) {
        Cartesian3_default.negate(offset, offset);
        p0Attributes = westGeometry.attributes;
        p0Indices = westGeometry.indices;
        p0IndexMap = westGeometryIndexMap;
        p1Attributes = eastGeometry.attributes;
        p1Indices = eastGeometry.indices;
        p1IndexMap = eastGeometryIndexMap;
      }
      const offsetPoint = Cartesian3_default.add(
        intersection,
        offset,
        offsetPointScratch
      );
      insertIndex = insertSplitPoint(
        p0Attributes,
        p0Indices,
        p0IndexMap,
        indices,
        i,
        p0
      );
      computeLineAttributes(
        i0,
        i1,
        p0,
        positions,
        insertIndex,
        p0Attributes,
        applyOffset
      );
      insertIndex = insertSplitPoint(
        p0Attributes,
        p0Indices,
        p0IndexMap,
        indices,
        -1,
        offsetPoint
      );
      computeLineAttributes(
        i0,
        i1,
        offsetPoint,
        positions,
        insertIndex,
        p0Attributes,
        applyOffset
      );
      Cartesian3_default.negate(offset, offset);
      Cartesian3_default.add(intersection, offset, offsetPoint);
      insertIndex = insertSplitPoint(
        p1Attributes,
        p1Indices,
        p1IndexMap,
        indices,
        -1,
        offsetPoint
      );
      computeLineAttributes(
        i0,
        i1,
        offsetPoint,
        positions,
        insertIndex,
        p1Attributes,
        applyOffset
      );
      insertIndex = insertSplitPoint(
        p1Attributes,
        p1Indices,
        p1IndexMap,
        indices,
        i + 1,
        p1
      );
      computeLineAttributes(
        i0,
        i1,
        p1,
        positions,
        insertIndex,
        p1Attributes,
        applyOffset
      );
    } else {
      let currentAttributes;
      let currentIndices;
      let currentIndexMap;
      if (p0.y < 0) {
        currentAttributes = westGeometry.attributes;
        currentIndices = westGeometry.indices;
        currentIndexMap = westGeometryIndexMap;
      } else {
        currentAttributes = eastGeometry.attributes;
        currentIndices = eastGeometry.indices;
        currentIndexMap = eastGeometryIndexMap;
      }
      insertIndex = insertSplitPoint(
        currentAttributes,
        currentIndices,
        currentIndexMap,
        indices,
        i,
        p0
      );
      computeLineAttributes(
        i0,
        i1,
        p0,
        positions,
        insertIndex,
        currentAttributes,
        applyOffset
      );
      insertIndex = insertSplitPoint(
        currentAttributes,
        currentIndices,
        currentIndexMap,
        indices,
        i + 1,
        p1
      );
      computeLineAttributes(
        i0,
        i1,
        p1,
        positions,
        insertIndex,
        currentAttributes,
        applyOffset
      );
    }
  }
  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);
}
var cartesian2Scratch0 = new Cartesian2_default();
var cartesian2Scratch1 = new Cartesian2_default();
var cartesian3Scratch0 = new Cartesian3_default();
var cartesian3Scratch2 = new Cartesian3_default();
var cartesian3Scratch3 = new Cartesian3_default();
var cartesian3Scratch4 = new Cartesian3_default();
var cartesian3Scratch5 = new Cartesian3_default();
var cartesian3Scratch6 = new Cartesian3_default();
var cartesian4Scratch0 = new Cartesian4_default();
function updateAdjacencyAfterSplit(geometry) {
  const attributes = geometry.attributes;
  const positions = attributes.position.values;
  const prevPositions = attributes.prevPosition.values;
  const nextPositions = attributes.nextPosition.values;
  const length = positions.length;
  for (let j = 0; j < length; j += 3) {
    const position = Cartesian3_default.unpack(positions, j, cartesian3Scratch0);
    if (position.x > 0) {
      continue;
    }
    const prevPosition = Cartesian3_default.unpack(
      prevPositions,
      j,
      cartesian3Scratch2
    );
    if (position.y < 0 && prevPosition.y > 0 || position.y > 0 && prevPosition.y < 0) {
      if (j - 3 > 0) {
        prevPositions[j] = positions[j - 3];
        prevPositions[j + 1] = positions[j - 2];
        prevPositions[j + 2] = positions[j - 1];
      } else {
        Cartesian3_default.pack(position, prevPositions, j);
      }
    }
    const nextPosition = Cartesian3_default.unpack(
      nextPositions,
      j,
      cartesian3Scratch3
    );
    if (position.y < 0 && nextPosition.y > 0 || position.y > 0 && nextPosition.y < 0) {
      if (j + 3 < length) {
        nextPositions[j] = positions[j + 3];
        nextPositions[j + 1] = positions[j + 4];
        nextPositions[j + 2] = positions[j + 5];
      } else {
        Cartesian3_default.pack(position, nextPositions, j);
      }
    }
  }
}
var offsetScalar = 5 * Math_default.EPSILON9;
var coplanarOffset = Math_default.EPSILON6;
function splitLongitudePolyline(instance) {
  const geometry = instance.geometry;
  const attributes = geometry.attributes;
  const positions = attributes.position.values;
  const prevPositions = attributes.prevPosition.values;
  const nextPositions = attributes.nextPosition.values;
  const expandAndWidths = attributes.expandAndWidth.values;
  const texCoords = defined_default(attributes.st) ? attributes.st.values : void 0;
  const colors = defined_default(attributes.color) ? attributes.color.values : void 0;
  const eastGeometry = copyGeometryForSplit(geometry);
  const westGeometry = copyGeometryForSplit(geometry);
  let i;
  let j;
  let index;
  let intersectionFound = false;
  const length = positions.length / 3;
  for (i = 0; i < length; i += 4) {
    const i0 = i;
    const i2 = i + 2;
    const p0 = Cartesian3_default.fromArray(positions, i0 * 3, cartesian3Scratch0);
    const p2 = Cartesian3_default.fromArray(positions, i2 * 3, cartesian3Scratch2);
    if (Math.abs(p0.y) < coplanarOffset) {
      p0.y = coplanarOffset * (p2.y < 0 ? -1 : 1);
      positions[i * 3 + 1] = p0.y;
      positions[(i + 1) * 3 + 1] = p0.y;
      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {
        prevPositions[j] = positions[i * 3];
        prevPositions[j + 1] = positions[i * 3 + 1];
        prevPositions[j + 2] = positions[i * 3 + 2];
      }
    }
    if (Math.abs(p2.y) < coplanarOffset) {
      p2.y = coplanarOffset * (p0.y < 0 ? -1 : 1);
      positions[(i + 2) * 3 + 1] = p2.y;
      positions[(i + 3) * 3 + 1] = p2.y;
      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {
        nextPositions[j] = positions[(i + 2) * 3];
        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];
        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];
      }
    }
    let p0Attributes = eastGeometry.attributes;
    let p0Indices = eastGeometry.indices;
    let p2Attributes = westGeometry.attributes;
    let p2Indices = westGeometry.indices;
    const intersection = IntersectionTests_default.lineSegmentPlane(
      p0,
      p2,
      xzPlane,
      cartesian3Scratch4
    );
    if (defined_default(intersection)) {
      intersectionFound = true;
      const offset = Cartesian3_default.multiplyByScalar(
        Cartesian3_default.UNIT_Y,
        offsetScalar,
        cartesian3Scratch5
      );
      if (p0.y < 0) {
        Cartesian3_default.negate(offset, offset);
        p0Attributes = westGeometry.attributes;
        p0Indices = westGeometry.indices;
        p2Attributes = eastGeometry.attributes;
        p2Indices = eastGeometry.indices;
      }
      const offsetPoint = Cartesian3_default.add(
        intersection,
        offset,
        cartesian3Scratch6
      );
      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);
      p0Attributes.position.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p0Attributes.position.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p0Attributes.prevPosition.values.push(
        prevPositions[i0 * 3],
        prevPositions[i0 * 3 + 1],
        prevPositions[i0 * 3 + 2]
      );
      p0Attributes.prevPosition.values.push(
        prevPositions[i0 * 3 + 3],
        prevPositions[i0 * 3 + 4],
        prevPositions[i0 * 3 + 5]
      );
      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);
      p0Attributes.nextPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p0Attributes.nextPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p0Attributes.nextPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p0Attributes.nextPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      Cartesian3_default.negate(offset, offset);
      Cartesian3_default.add(intersection, offset, offsetPoint);
      p2Attributes.position.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p2Attributes.position.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
      p2Attributes.prevPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p2Attributes.prevPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p2Attributes.prevPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p2Attributes.prevPosition.values.push(
        offsetPoint.x,
        offsetPoint.y,
        offsetPoint.z
      );
      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
      p2Attributes.nextPosition.values.push(
        nextPositions[i2 * 3],
        nextPositions[i2 * 3 + 1],
        nextPositions[i2 * 3 + 2]
      );
      p2Attributes.nextPosition.values.push(
        nextPositions[i2 * 3 + 3],
        nextPositions[i2 * 3 + 4],
        nextPositions[i2 * 3 + 5]
      );
      const ew0 = Cartesian2_default.fromArray(
        expandAndWidths,
        i0 * 2,
        cartesian2Scratch0
      );
      const width = Math.abs(ew0.y);
      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);
      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);
      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);
      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);
      let t = Cartesian3_default.magnitudeSquared(
        Cartesian3_default.subtract(intersection, p0, cartesian3Scratch3)
      );
      t /= Cartesian3_default.magnitudeSquared(
        Cartesian3_default.subtract(p2, p0, cartesian3Scratch3)
      );
      if (defined_default(colors)) {
        const c0 = Cartesian4_default.fromArray(colors, i0 * 4, cartesian4Scratch0);
        const c2 = Cartesian4_default.fromArray(colors, i2 * 4, cartesian4Scratch0);
        const r = Math_default.lerp(c0.x, c2.x, t);
        const g = Math_default.lerp(c0.y, c2.y, t);
        const b = Math_default.lerp(c0.z, c2.z, t);
        const a3 = Math_default.lerp(c0.w, c2.w, t);
        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {
          p0Attributes.color.values.push(colors[j]);
        }
        p0Attributes.color.values.push(r, g, b, a3);
        p0Attributes.color.values.push(r, g, b, a3);
        p2Attributes.color.values.push(r, g, b, a3);
        p2Attributes.color.values.push(r, g, b, a3);
        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {
          p2Attributes.color.values.push(colors[j]);
        }
      }
      if (defined_default(texCoords)) {
        const s0 = Cartesian2_default.fromArray(texCoords, i0 * 2, cartesian2Scratch0);
        const s3 = Cartesian2_default.fromArray(
          texCoords,
          (i + 3) * 2,
          cartesian2Scratch1
        );
        const sx = Math_default.lerp(s0.x, s3.x, t);
        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {
          p0Attributes.st.values.push(texCoords[j]);
        }
        p0Attributes.st.values.push(sx, s0.y);
        p0Attributes.st.values.push(sx, s3.y);
        p2Attributes.st.values.push(sx, s0.y);
        p2Attributes.st.values.push(sx, s3.y);
        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {
          p2Attributes.st.values.push(texCoords[j]);
        }
      }
      index = p0Attributes.position.values.length / 3 - 4;
      p0Indices.push(index, index + 2, index + 1);
      p0Indices.push(index + 1, index + 2, index + 3);
      index = p2Attributes.position.values.length / 3 - 4;
      p2Indices.push(index, index + 2, index + 1);
      p2Indices.push(index + 1, index + 2, index + 3);
    } else {
      let currentAttributes;
      let currentIndices;
      if (p0.y < 0) {
        currentAttributes = westGeometry.attributes;
        currentIndices = westGeometry.indices;
      } else {
        currentAttributes = eastGeometry.attributes;
        currentIndices = eastGeometry.indices;
      }
      currentAttributes.position.values.push(p0.x, p0.y, p0.z);
      currentAttributes.position.values.push(p0.x, p0.y, p0.z);
      currentAttributes.position.values.push(p2.x, p2.y, p2.z);
      currentAttributes.position.values.push(p2.x, p2.y, p2.z);
      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {
        currentAttributes.prevPosition.values.push(prevPositions[j]);
        currentAttributes.nextPosition.values.push(nextPositions[j]);
      }
      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {
        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);
        if (defined_default(texCoords)) {
          currentAttributes.st.values.push(texCoords[j]);
        }
      }
      if (defined_default(colors)) {
        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {
          currentAttributes.color.values.push(colors[j]);
        }
      }
      index = currentAttributes.position.values.length / 3 - 4;
      currentIndices.push(index, index + 2, index + 1);
      currentIndices.push(index + 1, index + 2, index + 3);
    }
  }
  if (intersectionFound) {
    updateAdjacencyAfterSplit(westGeometry);
    updateAdjacencyAfterSplit(eastGeometry);
  }
  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);
}
GeometryPipeline.splitLongitude = function(instance) {
  if (!defined_default(instance)) {
    throw new DeveloperError_default("instance is required.");
  }
  const geometry = instance.geometry;
  const boundingSphere = geometry.boundingSphere;
  if (defined_default(boundingSphere)) {
    const minX = boundingSphere.center.x - boundingSphere.radius;
    if (minX > 0 || BoundingSphere_default.intersectPlane(boundingSphere, Plane_default.ORIGIN_ZX_PLANE) !== Intersect_default.INTERSECTING) {
      return instance;
    }
  }
  if (geometry.geometryType !== GeometryType_default.NONE) {
    switch (geometry.geometryType) {
      case GeometryType_default.POLYLINES:
        splitLongitudePolyline(instance);
        break;
      case GeometryType_default.TRIANGLES:
        splitLongitudeTriangles(instance);
        break;
      case GeometryType_default.LINES:
        splitLongitudeLines(instance);
        break;
    }
  } else {
    indexPrimitive(geometry);
    if (geometry.primitiveType === PrimitiveType_default.TRIANGLES) {
      splitLongitudeTriangles(instance);
    } else if (geometry.primitiveType === PrimitiveType_default.LINES) {
      splitLongitudeLines(instance);
    }
  }
  return instance;
};
var GeometryPipeline_default = GeometryPipeline;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/WebMercatorProjection.js
function WebMercatorProjection(ellipsoid) {
  this._ellipsoid = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  this._semimajorAxis = this._ellipsoid.maximumRadius;
  this._oneOverSemimajorAxis = 1 / this._semimajorAxis;
}
Object.defineProperties(WebMercatorProjection.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  }
});
WebMercatorProjection.mercatorAngleToGeodeticLatitude = function(mercatorAngle) {
  return Math_default.PI_OVER_TWO - 2 * Math.atan(Math.exp(-mercatorAngle));
};
WebMercatorProjection.geodeticLatitudeToMercatorAngle = function(latitude) {
  if (latitude > WebMercatorProjection.MaximumLatitude) {
    latitude = WebMercatorProjection.MaximumLatitude;
  } else if (latitude < -WebMercatorProjection.MaximumLatitude) {
    latitude = -WebMercatorProjection.MaximumLatitude;
  }
  const sinLatitude = Math.sin(latitude);
  return 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));
};
WebMercatorProjection.MaximumLatitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(
  Math.PI
);
WebMercatorProjection.prototype.project = function(cartographic, result) {
  const semimajorAxis = this._semimajorAxis;
  const x = cartographic.longitude * semimajorAxis;
  const y = WebMercatorProjection.geodeticLatitudeToMercatorAngle(
    cartographic.latitude
  ) * semimajorAxis;
  const z = cartographic.height;
  if (!defined_default(result)) {
    return new Cartesian3_default(x, y, z);
  }
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
};
WebMercatorProjection.prototype.unproject = function(cartesian, result) {
  if (!defined_default(cartesian)) {
    throw new DeveloperError_default("cartesian is required");
  }
  const oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
  const longitude = cartesian.x * oneOverEarthSemimajorAxis;
  const latitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(
    cartesian.y * oneOverEarthSemimajorAxis
  );
  const height = cartesian.z;
  if (!defined_default(result)) {
    return new Cartographic_default(longitude, latitude, height);
  }
  result.longitude = longitude;
  result.latitude = latitude;
  result.height = height;
  return result;
};
var WebMercatorProjection_default = WebMercatorProjection;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/PrimitivePipeline.js
function transformToWorldCoordinates(instances, primitiveModelMatrix, scene3DOnly) {
  let toWorld = !scene3DOnly;
  const length = instances.length;
  let i;
  if (!toWorld && length > 1) {
    const modelMatrix = instances[0].modelMatrix;
    for (i = 1; i < length; ++i) {
      if (!Matrix4_default.equals(modelMatrix, instances[i].modelMatrix)) {
        toWorld = true;
        break;
      }
    }
  }
  if (toWorld) {
    for (i = 0; i < length; ++i) {
      if (defined_default(instances[i].geometry)) {
        GeometryPipeline_default.transformToWorldCoordinates(instances[i]);
      }
    }
  } else {
    Matrix4_default.multiplyTransformation(
      primitiveModelMatrix,
      instances[0].modelMatrix,
      primitiveModelMatrix
    );
  }
}
function addGeometryBatchId(geometry, batchId) {
  const attributes = geometry.attributes;
  const positionAttr = attributes.position;
  const numberOfComponents = positionAttr.values.length / positionAttr.componentsPerAttribute;
  attributes.batchId = new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 1,
    values: new Float32Array(numberOfComponents)
  });
  const values = attributes.batchId.values;
  for (let j = 0; j < numberOfComponents; ++j) {
    values[j] = batchId;
  }
}
function addBatchIds(instances) {
  const length = instances.length;
  for (let i = 0; i < length; ++i) {
    const instance = instances[i];
    if (defined_default(instance.geometry)) {
      addGeometryBatchId(instance.geometry, i);
    } else if (defined_default(instance.westHemisphereGeometry) && defined_default(instance.eastHemisphereGeometry)) {
      addGeometryBatchId(instance.westHemisphereGeometry, i);
      addGeometryBatchId(instance.eastHemisphereGeometry, i);
    }
  }
}
function geometryPipeline(parameters) {
  const instances = parameters.instances;
  const projection = parameters.projection;
  const uintIndexSupport = parameters.elementIndexUintSupported;
  const scene3DOnly = parameters.scene3DOnly;
  const vertexCacheOptimize = parameters.vertexCacheOptimize;
  const compressVertices = parameters.compressVertices;
  const modelMatrix = parameters.modelMatrix;
  let i;
  let geometry;
  let primitiveType;
  let length = instances.length;
  for (i = 0; i < length; ++i) {
    if (defined_default(instances[i].geometry)) {
      primitiveType = instances[i].geometry.primitiveType;
      break;
    }
  }
  for (i = 1; i < length; ++i) {
    if (defined_default(instances[i].geometry) && instances[i].geometry.primitiveType !== primitiveType) {
      throw new DeveloperError_default(
        "All instance geometries must have the same primitiveType."
      );
    }
  }
  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);
  if (!scene3DOnly) {
    for (i = 0; i < length; ++i) {
      if (defined_default(instances[i].geometry)) {
        GeometryPipeline_default.splitLongitude(instances[i]);
      }
    }
  }
  addBatchIds(instances);
  if (vertexCacheOptimize) {
    for (i = 0; i < length; ++i) {
      const instance = instances[i];
      if (defined_default(instance.geometry)) {
        GeometryPipeline_default.reorderForPostVertexCache(instance.geometry);
        GeometryPipeline_default.reorderForPreVertexCache(instance.geometry);
      } else if (defined_default(instance.westHemisphereGeometry) && defined_default(instance.eastHemisphereGeometry)) {
        GeometryPipeline_default.reorderForPostVertexCache(
          instance.westHemisphereGeometry
        );
        GeometryPipeline_default.reorderForPreVertexCache(
          instance.westHemisphereGeometry
        );
        GeometryPipeline_default.reorderForPostVertexCache(
          instance.eastHemisphereGeometry
        );
        GeometryPipeline_default.reorderForPreVertexCache(
          instance.eastHemisphereGeometry
        );
      }
    }
  }
  let geometries = GeometryPipeline_default.combineInstances(instances);
  length = geometries.length;
  for (i = 0; i < length; ++i) {
    geometry = geometries[i];
    const attributes = geometry.attributes;
    if (!scene3DOnly) {
      for (const name in attributes) {
        if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype_default.DOUBLE) {
          const name3D = `${name}3D`;
          const name2D = `${name}2D`;
          GeometryPipeline_default.projectTo2D(
            geometry,
            name,
            name3D,
            name2D,
            projection
          );
          if (defined_default(geometry.boundingSphere) && name === "position") {
            geometry.boundingSphereCV = BoundingSphere_default.fromVertices(
              geometry.attributes.position2D.values
            );
          }
          GeometryPipeline_default.encodeAttribute(
            geometry,
            name3D,
            `${name3D}High`,
            `${name3D}Low`
          );
          GeometryPipeline_default.encodeAttribute(
            geometry,
            name2D,
            `${name2D}High`,
            `${name2D}Low`
          );
        }
      }
    } else {
      for (const name in attributes) {
        if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype_default.DOUBLE) {
          GeometryPipeline_default.encodeAttribute(
            geometry,
            name,
            `${name}3DHigh`,
            `${name}3DLow`
          );
        }
      }
    }
    if (compressVertices) {
      GeometryPipeline_default.compressVertices(geometry);
    }
  }
  if (!uintIndexSupport) {
    let splitGeometries = [];
    length = geometries.length;
    for (i = 0; i < length; ++i) {
      geometry = geometries[i];
      splitGeometries = splitGeometries.concat(
        GeometryPipeline_default.fitToUnsignedShortIndices(geometry)
      );
    }
    geometries = splitGeometries;
  }
  return geometries;
}
function createPickOffsets(instances, geometryName, geometries, pickOffsets) {
  let offset;
  let indexCount;
  let geometryIndex;
  const offsetIndex = pickOffsets.length - 1;
  if (offsetIndex >= 0) {
    const pickOffset = pickOffsets[offsetIndex];
    offset = pickOffset.offset + pickOffset.count;
    geometryIndex = pickOffset.index;
    indexCount = geometries[geometryIndex].indices.length;
  } else {
    offset = 0;
    geometryIndex = 0;
    indexCount = geometries[geometryIndex].indices.length;
  }
  const length = instances.length;
  for (let i = 0; i < length; ++i) {
    const instance = instances[i];
    const geometry = instance[geometryName];
    if (!defined_default(geometry)) {
      continue;
    }
    const count = geometry.indices.length;
    if (offset + count > indexCount) {
      offset = 0;
      indexCount = geometries[++geometryIndex].indices.length;
    }
    pickOffsets.push({
      index: geometryIndex,
      offset,
      count
    });
    offset += count;
  }
}
function createInstancePickOffsets(instances, geometries) {
  const pickOffsets = [];
  createPickOffsets(instances, "geometry", geometries, pickOffsets);
  createPickOffsets(
    instances,
    "westHemisphereGeometry",
    geometries,
    pickOffsets
  );
  createPickOffsets(
    instances,
    "eastHemisphereGeometry",
    geometries,
    pickOffsets
  );
  return pickOffsets;
}
var PrimitivePipeline = {};
PrimitivePipeline.combineGeometry = function(parameters) {
  let geometries;
  let attributeLocations;
  const instances = parameters.instances;
  const length = instances.length;
  let pickOffsets;
  let offsetInstanceExtend;
  let hasOffset = false;
  if (length > 0) {
    geometries = geometryPipeline(parameters);
    if (geometries.length > 0) {
      attributeLocations = GeometryPipeline_default.createAttributeLocations(
        geometries[0]
      );
      if (parameters.createPickOffsets) {
        pickOffsets = createInstancePickOffsets(instances, geometries);
      }
    }
    if (defined_default(instances[0].attributes) && defined_default(instances[0].attributes.offset)) {
      offsetInstanceExtend = new Array(length);
      hasOffset = true;
    }
  }
  const boundingSpheres = new Array(length);
  const boundingSpheresCV = new Array(length);
  for (let i = 0; i < length; ++i) {
    const instance = instances[i];
    const geometry = instance.geometry;
    if (defined_default(geometry)) {
      boundingSpheres[i] = geometry.boundingSphere;
      boundingSpheresCV[i] = geometry.boundingSphereCV;
      if (hasOffset) {
        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;
      }
    }
    const eastHemisphereGeometry = instance.eastHemisphereGeometry;
    const westHemisphereGeometry = instance.westHemisphereGeometry;
    if (defined_default(eastHemisphereGeometry) && defined_default(westHemisphereGeometry)) {
      if (defined_default(eastHemisphereGeometry.boundingSphere) && defined_default(westHemisphereGeometry.boundingSphere)) {
        boundingSpheres[i] = BoundingSphere_default.union(
          eastHemisphereGeometry.boundingSphere,
          westHemisphereGeometry.boundingSphere
        );
      }
      if (defined_default(eastHemisphereGeometry.boundingSphereCV) && defined_default(westHemisphereGeometry.boundingSphereCV)) {
        boundingSpheresCV[i] = BoundingSphere_default.union(
          eastHemisphereGeometry.boundingSphereCV,
          westHemisphereGeometry.boundingSphereCV
        );
      }
    }
  }
  return {
    geometries,
    modelMatrix: parameters.modelMatrix,
    attributeLocations,
    pickOffsets,
    offsetInstanceExtend,
    boundingSpheres,
    boundingSpheresCV
  };
};
function transferGeometry(geometry, transferableObjects) {
  const attributes = geometry.attributes;
  for (const name in attributes) {
    if (attributes.hasOwnProperty(name)) {
      const attribute = attributes[name];
      if (defined_default(attribute) && defined_default(attribute.values)) {
        transferableObjects.push(attribute.values.buffer);
      }
    }
  }
  if (defined_default(geometry.indices)) {
    transferableObjects.push(geometry.indices.buffer);
  }
}
function transferGeometries(geometries, transferableObjects) {
  const length = geometries.length;
  for (let i = 0; i < length; ++i) {
    transferGeometry(geometries[i], transferableObjects);
  }
}
function countCreateGeometryResults(items) {
  let count = 1;
  const length = items.length;
  for (let i = 0; i < length; i++) {
    const geometry = items[i];
    ++count;
    if (!defined_default(geometry)) {
      continue;
    }
    const attributes = geometry.attributes;
    count += 7 + 2 * BoundingSphere_default.packedLength + (defined_default(geometry.indices) ? geometry.indices.length : 0);
    for (const property in attributes) {
      if (attributes.hasOwnProperty(property) && defined_default(attributes[property])) {
        const attribute = attributes[property];
        count += 5 + attribute.values.length;
      }
    }
  }
  return count;
}
PrimitivePipeline.packCreateGeometryResults = function(items, transferableObjects) {
  const packedData = new Float64Array(countCreateGeometryResults(items));
  const stringTable = [];
  const stringHash = {};
  const length = items.length;
  let count = 0;
  packedData[count++] = length;
  for (let i = 0; i < length; i++) {
    const geometry = items[i];
    const validGeometry = defined_default(geometry);
    packedData[count++] = validGeometry ? 1 : 0;
    if (!validGeometry) {
      continue;
    }
    packedData[count++] = geometry.primitiveType;
    packedData[count++] = geometry.geometryType;
    packedData[count++] = defaultValue_default(geometry.offsetAttribute, -1);
    const validBoundingSphere = defined_default(geometry.boundingSphere) ? 1 : 0;
    packedData[count++] = validBoundingSphere;
    if (validBoundingSphere) {
      BoundingSphere_default.pack(geometry.boundingSphere, packedData, count);
    }
    count += BoundingSphere_default.packedLength;
    const validBoundingSphereCV = defined_default(geometry.boundingSphereCV) ? 1 : 0;
    packedData[count++] = validBoundingSphereCV;
    if (validBoundingSphereCV) {
      BoundingSphere_default.pack(geometry.boundingSphereCV, packedData, count);
    }
    count += BoundingSphere_default.packedLength;
    const attributes = geometry.attributes;
    const attributesToWrite = [];
    for (const property in attributes) {
      if (attributes.hasOwnProperty(property) && defined_default(attributes[property])) {
        attributesToWrite.push(property);
        if (!defined_default(stringHash[property])) {
          stringHash[property] = stringTable.length;
          stringTable.push(property);
        }
      }
    }
    packedData[count++] = attributesToWrite.length;
    for (let q = 0; q < attributesToWrite.length; q++) {
      const name = attributesToWrite[q];
      const attribute = attributes[name];
      packedData[count++] = stringHash[name];
      packedData[count++] = attribute.componentDatatype;
      packedData[count++] = attribute.componentsPerAttribute;
      packedData[count++] = attribute.normalize ? 1 : 0;
      packedData[count++] = attribute.values.length;
      packedData.set(attribute.values, count);
      count += attribute.values.length;
    }
    const indicesLength = defined_default(geometry.indices) ? geometry.indices.length : 0;
    packedData[count++] = indicesLength;
    if (indicesLength > 0) {
      packedData.set(geometry.indices, count);
      count += indicesLength;
    }
  }
  transferableObjects.push(packedData.buffer);
  return {
    stringTable,
    packedData
  };
};
PrimitivePipeline.unpackCreateGeometryResults = function(createGeometryResult) {
  const stringTable = createGeometryResult.stringTable;
  const packedGeometry = createGeometryResult.packedData;
  let i;
  const result = new Array(packedGeometry[0]);
  let resultIndex = 0;
  let packedGeometryIndex = 1;
  while (packedGeometryIndex < packedGeometry.length) {
    const valid = packedGeometry[packedGeometryIndex++] === 1;
    if (!valid) {
      result[resultIndex++] = void 0;
      continue;
    }
    const primitiveType = packedGeometry[packedGeometryIndex++];
    const geometryType = packedGeometry[packedGeometryIndex++];
    let offsetAttribute = packedGeometry[packedGeometryIndex++];
    if (offsetAttribute === -1) {
      offsetAttribute = void 0;
    }
    let boundingSphere;
    let boundingSphereCV;
    const validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1;
    if (validBoundingSphere) {
      boundingSphere = BoundingSphere_default.unpack(
        packedGeometry,
        packedGeometryIndex
      );
    }
    packedGeometryIndex += BoundingSphere_default.packedLength;
    const validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1;
    if (validBoundingSphereCV) {
      boundingSphereCV = BoundingSphere_default.unpack(
        packedGeometry,
        packedGeometryIndex
      );
    }
    packedGeometryIndex += BoundingSphere_default.packedLength;
    let length;
    let values;
    let componentsPerAttribute;
    const attributes = new GeometryAttributes_default();
    const numAttributes = packedGeometry[packedGeometryIndex++];
    for (i = 0; i < numAttributes; i++) {
      const name = stringTable[packedGeometry[packedGeometryIndex++]];
      const componentDatatype = packedGeometry[packedGeometryIndex++];
      componentsPerAttribute = packedGeometry[packedGeometryIndex++];
      const normalize = packedGeometry[packedGeometryIndex++] !== 0;
      length = packedGeometry[packedGeometryIndex++];
      values = ComponentDatatype_default.createTypedArray(componentDatatype, length);
      for (let valuesIndex = 0; valuesIndex < length; valuesIndex++) {
        values[valuesIndex] = packedGeometry[packedGeometryIndex++];
      }
      attributes[name] = new GeometryAttribute_default({
        componentDatatype,
        componentsPerAttribute,
        normalize,
        values
      });
    }
    let indices;
    length = packedGeometry[packedGeometryIndex++];
    if (length > 0) {
      const numberOfVertices = values.length / componentsPerAttribute;
      indices = IndexDatatype_default.createTypedArray(numberOfVertices, length);
      for (i = 0; i < length; i++) {
        indices[i] = packedGeometry[packedGeometryIndex++];
      }
    }
    result[resultIndex++] = new Geometry_default({
      primitiveType,
      geometryType,
      boundingSphere,
      boundingSphereCV,
      indices,
      attributes,
      offsetAttribute
    });
  }
  return result;
};
function packInstancesForCombine(instances, transferableObjects) {
  const length = instances.length;
  const packedData = new Float64Array(1 + length * 19);
  let count = 0;
  packedData[count++] = length;
  for (let i = 0; i < length; i++) {
    const instance = instances[i];
    Matrix4_default.pack(instance.modelMatrix, packedData, count);
    count += Matrix4_default.packedLength;
    if (defined_default(instance.attributes) && defined_default(instance.attributes.offset)) {
      const values = instance.attributes.offset.value;
      packedData[count] = values[0];
      packedData[count + 1] = values[1];
      packedData[count + 2] = values[2];
    }
    count += 3;
  }
  transferableObjects.push(packedData.buffer);
  return packedData;
}
function unpackInstancesForCombine(data) {
  const packedInstances = data;
  const result = new Array(packedInstances[0]);
  let count = 0;
  let i = 1;
  while (i < packedInstances.length) {
    const modelMatrix = Matrix4_default.unpack(packedInstances, i);
    let attributes;
    i += Matrix4_default.packedLength;
    if (defined_default(packedInstances[i])) {
      attributes = {
        offset: new OffsetGeometryInstanceAttribute_default(
          packedInstances[i],
          packedInstances[i + 1],
          packedInstances[i + 2]
        )
      };
    }
    i += 3;
    result[count++] = {
      modelMatrix,
      attributes
    };
  }
  return result;
}
PrimitivePipeline.packCombineGeometryParameters = function(parameters, transferableObjects) {
  const createGeometryResults = parameters.createGeometryResults;
  const length = createGeometryResults.length;
  for (let i = 0; i < length; i++) {
    transferableObjects.push(createGeometryResults[i].packedData.buffer);
  }
  return {
    createGeometryResults: parameters.createGeometryResults,
    packedInstances: packInstancesForCombine(
      parameters.instances,
      transferableObjects
    ),
    ellipsoid: parameters.ellipsoid,
    isGeographic: parameters.projection instanceof GeographicProjection_default,
    elementIndexUintSupported: parameters.elementIndexUintSupported,
    scene3DOnly: parameters.scene3DOnly,
    vertexCacheOptimize: parameters.vertexCacheOptimize,
    compressVertices: parameters.compressVertices,
    modelMatrix: parameters.modelMatrix,
    createPickOffsets: parameters.createPickOffsets
  };
};
PrimitivePipeline.unpackCombineGeometryParameters = function(packedParameters) {
  const instances = unpackInstancesForCombine(packedParameters.packedInstances);
  const createGeometryResults = packedParameters.createGeometryResults;
  const length = createGeometryResults.length;
  let instanceIndex = 0;
  for (let resultIndex = 0; resultIndex < length; resultIndex++) {
    const geometries = PrimitivePipeline.unpackCreateGeometryResults(
      createGeometryResults[resultIndex]
    );
    const geometriesLength = geometries.length;
    for (let geometryIndex = 0; geometryIndex < geometriesLength; geometryIndex++) {
      const geometry = geometries[geometryIndex];
      const instance = instances[instanceIndex];
      instance.geometry = geometry;
      ++instanceIndex;
    }
  }
  const ellipsoid = Ellipsoid_default.clone(packedParameters.ellipsoid);
  const projection = packedParameters.isGeographic ? new GeographicProjection_default(ellipsoid) : new WebMercatorProjection_default(ellipsoid);
  return {
    instances,
    ellipsoid,
    projection,
    elementIndexUintSupported: packedParameters.elementIndexUintSupported,
    scene3DOnly: packedParameters.scene3DOnly,
    vertexCacheOptimize: packedParameters.vertexCacheOptimize,
    compressVertices: packedParameters.compressVertices,
    modelMatrix: Matrix4_default.clone(packedParameters.modelMatrix),
    createPickOffsets: packedParameters.createPickOffsets
  };
};
function packBoundingSpheres(boundingSpheres) {
  const length = boundingSpheres.length;
  const bufferLength = 1 + (BoundingSphere_default.packedLength + 1) * length;
  const buffer = new Float32Array(bufferLength);
  let bufferIndex = 0;
  buffer[bufferIndex++] = length;
  for (let i = 0; i < length; ++i) {
    const bs = boundingSpheres[i];
    if (!defined_default(bs)) {
      buffer[bufferIndex++] = 0;
    } else {
      buffer[bufferIndex++] = 1;
      BoundingSphere_default.pack(boundingSpheres[i], buffer, bufferIndex);
    }
    bufferIndex += BoundingSphere_default.packedLength;
  }
  return buffer;
}
function unpackBoundingSpheres(buffer) {
  const result = new Array(buffer[0]);
  let count = 0;
  let i = 1;
  while (i < buffer.length) {
    if (buffer[i++] === 1) {
      result[count] = BoundingSphere_default.unpack(buffer, i);
    }
    ++count;
    i += BoundingSphere_default.packedLength;
  }
  return result;
}
PrimitivePipeline.packCombineGeometryResults = function(results, transferableObjects) {
  if (defined_default(results.geometries)) {
    transferGeometries(results.geometries, transferableObjects);
  }
  const packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);
  const packedBoundingSpheresCV = packBoundingSpheres(
    results.boundingSpheresCV
  );
  transferableObjects.push(
    packedBoundingSpheres.buffer,
    packedBoundingSpheresCV.buffer
  );
  return {
    geometries: results.geometries,
    attributeLocations: results.attributeLocations,
    modelMatrix: results.modelMatrix,
    pickOffsets: results.pickOffsets,
    offsetInstanceExtend: results.offsetInstanceExtend,
    boundingSpheres: packedBoundingSpheres,
    boundingSpheresCV: packedBoundingSpheresCV
  };
};
PrimitivePipeline.unpackCombineGeometryResults = function(packedResult) {
  return {
    geometries: packedResult.geometries,
    attributeLocations: packedResult.attributeLocations,
    modelMatrix: packedResult.modelMatrix,
    pickOffsets: packedResult.pickOffsets,
    offsetInstanceExtend: packedResult.offsetInstanceExtend,
    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),
    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV)
  };
};
var PrimitivePipeline_default = PrimitivePipeline;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/PrimitiveState.js
var PrimitiveState = {
  READY: 0,
  CREATING: 1,
  CREATED: 2,
  COMBINING: 3,
  COMBINED: 4,
  COMPLETE: 5,
  FAILED: 6
};
var PrimitiveState_default = Object.freeze(PrimitiveState);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/ShadowMode.js
var ShadowMode = {
  DISABLED: 0,
  ENABLED: 1,
  CAST_ONLY: 2,
  RECEIVE_ONLY: 3
};
ShadowMode.NUMBER_OF_SHADOW_MODES = 4;
ShadowMode.castShadows = function(shadowMode) {
  return shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.CAST_ONLY;
};
ShadowMode.receiveShadows = function(shadowMode) {
  return shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.RECEIVE_ONLY;
};
ShadowMode.fromCastReceive = function(castShadows, receiveShadows) {
  if (castShadows && receiveShadows) {
    return ShadowMode.ENABLED;
  } else if (castShadows) {
    return ShadowMode.CAST_ONLY;
  } else if (receiveShadows) {
    return ShadowMode.RECEIVE_ONLY;
  }
  return ShadowMode.DISABLED;
};
var ShadowMode_default = Object.freeze(ShadowMode);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/Primitive.js
function Primitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.geometryInstances = options.geometryInstances;
  this.appearance = options.appearance;
  this._appearance = void 0;
  this._material = void 0;
  this.depthFailAppearance = options.depthFailAppearance;
  this._depthFailAppearance = void 0;
  this._depthFailMaterial = void 0;
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this._modelMatrix = new Matrix4_default();
  this.show = defaultValue_default(options.show, true);
  this._vertexCacheOptimize = defaultValue_default(options.vertexCacheOptimize, false);
  this._interleave = defaultValue_default(options.interleave, false);
  this._releaseGeometryInstances = defaultValue_default(
    options.releaseGeometryInstances,
    true
  );
  this._allowPicking = defaultValue_default(options.allowPicking, true);
  this._asynchronous = defaultValue_default(options.asynchronous, true);
  this._compressVertices = defaultValue_default(options.compressVertices, true);
  this.cull = defaultValue_default(options.cull, true);
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.rtcCenter = options.rtcCenter;
  if (defined_default(this.rtcCenter) && (!defined_default(this.geometryInstances) || Array.isArray(this.geometryInstances) && this.geometryInstances.length !== 1)) {
    throw new DeveloperError_default(
      "Relative-to-center rendering only supports one geometry instance."
    );
  }
  this.shadows = defaultValue_default(options.shadows, ShadowMode_default.DISABLED);
  this._translucent = void 0;
  this._state = PrimitiveState_default.READY;
  this._geometries = [];
  this._error = void 0;
  this._numberOfInstances = 0;
  this._boundingSpheres = [];
  this._boundingSphereWC = [];
  this._boundingSphereCV = [];
  this._boundingSphere2D = [];
  this._boundingSphereMorph = [];
  this._perInstanceAttributeCache = [];
  this._instanceIds = [];
  this._lastPerInstanceAttributeIndex = 0;
  this._va = [];
  this._attributeLocations = void 0;
  this._primitiveType = void 0;
  this._frontFaceRS = void 0;
  this._backFaceRS = void 0;
  this._sp = void 0;
  this._depthFailAppearance = void 0;
  this._spDepthFail = void 0;
  this._frontFaceDepthFailRS = void 0;
  this._backFaceDepthFailRS = void 0;
  this._pickIds = [];
  this._colorCommands = [];
  this._pickCommands = [];
  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;
  this._createRenderStatesFunction = options._createRenderStatesFunction;
  this._createShaderProgramFunction = options._createShaderProgramFunction;
  this._createCommandsFunction = options._createCommandsFunction;
  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;
  this._createPickOffsets = options._createPickOffsets;
  this._pickOffsets = void 0;
  this._createGeometryResults = void 0;
  this._ready = false;
  const primitive = this;
  this._readyPromise = new Promise((resolve, reject) => {
    primitive._completeLoad = (frameState, state, error) => {
      this._error = error;
      this._state = state;
      frameState.afterRender.push(function() {
        primitive._ready = primitive._state === PrimitiveState_default.COMPLETE || primitive._state === PrimitiveState_default.FAILED;
        if (!defined_default(error)) {
          resolve(primitive);
          return true;
        }
        reject(error);
      });
    };
  });
  this._batchTable = void 0;
  this._batchTableAttributeIndices = void 0;
  this._offsetInstanceExtend = void 0;
  this._batchTableOffsetAttribute2DIndex = void 0;
  this._batchTableOffsetsUpdated = false;
  this._instanceBoundingSpheres = void 0;
  this._instanceBoundingSpheresCV = void 0;
  this._tempBoundingSpheres = void 0;
  this._recomputeBoundingSpheres = false;
  this._batchTableBoundingSpheresUpdated = false;
  this._batchTableBoundingSphereAttributeIndices = void 0;
}
Object.defineProperties(Primitive.prototype, {
  vertexCacheOptimize: {
    get: function() {
      return this._vertexCacheOptimize;
    }
  },
  interleave: {
    get: function() {
      return this._interleave;
    }
  },
  releaseGeometryInstances: {
    get: function() {
      return this._releaseGeometryInstances;
    }
  },
  allowPicking: {
    get: function() {
      return this._allowPicking;
    }
  },
  asynchronous: {
    get: function() {
      return this._asynchronous;
    }
  },
  compressVertices: {
    get: function() {
      return this._compressVertices;
    }
  },
  ready: {
    get: function() {
      return this._ready;
    }
  },
  readyPromise: {
    get: function() {
      return this._readyPromise;
    }
  }
});
function getCommonPerInstanceAttributeNames(instances) {
  const length = instances.length;
  const attributesInAllInstances = [];
  const attributes0 = instances[0].attributes;
  let name;
  for (name in attributes0) {
    if (attributes0.hasOwnProperty(name) && defined_default(attributes0[name])) {
      const attribute = attributes0[name];
      let inAllInstances = true;
      for (let i = 1; i < length; ++i) {
        const otherAttribute = instances[i].attributes[name];
        if (!defined_default(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {
          inAllInstances = false;
          break;
        }
      }
      if (inAllInstances) {
        attributesInAllInstances.push(name);
      }
    }
  }
  return attributesInAllInstances;
}
var scratchGetAttributeCartesian2 = new Cartesian2_default();
var scratchGetAttributeCartesian3 = new Cartesian3_default();
var scratchGetAttributeCartesian42 = new Cartesian4_default();
function getAttributeValue(value) {
  const componentsPerAttribute = value.length;
  if (componentsPerAttribute === 1) {
    return value[0];
  } else if (componentsPerAttribute === 2) {
    return Cartesian2_default.unpack(value, 0, scratchGetAttributeCartesian2);
  } else if (componentsPerAttribute === 3) {
    return Cartesian3_default.unpack(value, 0, scratchGetAttributeCartesian3);
  } else if (componentsPerAttribute === 4) {
    return Cartesian4_default.unpack(value, 0, scratchGetAttributeCartesian42);
  }
}
function createBatchTable(primitive, context) {
  const geometryInstances = primitive.geometryInstances;
  const instances = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];
  const numberOfInstances = instances.length;
  if (numberOfInstances === 0) {
    return;
  }
  const names = getCommonPerInstanceAttributeNames(instances);
  const length = names.length;
  const attributes = [];
  const attributeIndices = {};
  const boundingSphereAttributeIndices = {};
  let offset2DIndex;
  const firstInstance = instances[0];
  let instanceAttributes = firstInstance.attributes;
  let i;
  let name;
  let attribute;
  for (i = 0; i < length; ++i) {
    name = names[i];
    attribute = instanceAttributes[name];
    attributeIndices[name] = i;
    attributes.push({
      functionName: `czm_batchTable_${name}`,
      componentDatatype: attribute.componentDatatype,
      componentsPerAttribute: attribute.componentsPerAttribute,
      normalize: attribute.normalize
    });
  }
  if (names.indexOf("distanceDisplayCondition") !== -1) {
    attributes.push(
      {
        functionName: "czm_batchTable_boundingSphereCenter3DHigh",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter3DLow",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter2DHigh",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter2DLow",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereRadius",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 1
      }
    );
    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;
    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;
    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;
    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;
    boundingSphereAttributeIndices.radius = attributes.length - 1;
  }
  if (names.indexOf("offset") !== -1) {
    attributes.push({
      functionName: "czm_batchTable_offset2D",
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 3
    });
    offset2DIndex = attributes.length - 1;
  }
  attributes.push({
    functionName: "czm_batchTable_pickColor",
    componentDatatype: ComponentDatatype_default.UNSIGNED_BYTE,
    componentsPerAttribute: 4,
    normalize: true
  });
  const attributesLength = attributes.length;
  const batchTable = new BatchTable_default(context, attributes, numberOfInstances);
  for (i = 0; i < numberOfInstances; ++i) {
    const instance = instances[i];
    instanceAttributes = instance.attributes;
    for (let j = 0; j < length; ++j) {
      name = names[j];
      attribute = instanceAttributes[name];
      const value = getAttributeValue(attribute.value);
      const attributeIndex = attributeIndices[name];
      batchTable.setBatchedAttribute(i, attributeIndex, value);
    }
    const pickObject = {
      primitive: defaultValue_default(instance.pickPrimitive, primitive)
    };
    if (defined_default(instance.id)) {
      pickObject.id = instance.id;
    }
    const pickId = context.createPickId(pickObject);
    primitive._pickIds.push(pickId);
    const pickColor = pickId.color;
    const color = scratchGetAttributeCartesian42;
    color.x = Color_default.floatToByte(pickColor.red);
    color.y = Color_default.floatToByte(pickColor.green);
    color.z = Color_default.floatToByte(pickColor.blue);
    color.w = Color_default.floatToByte(pickColor.alpha);
    batchTable.setBatchedAttribute(i, attributesLength - 1, color);
  }
  primitive._batchTable = batchTable;
  primitive._batchTableAttributeIndices = attributeIndices;
  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;
  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;
}
function cloneAttribute(attribute) {
  let clonedValues;
  if (Array.isArray(attribute.values)) {
    clonedValues = attribute.values.slice(0);
  } else {
    clonedValues = new attribute.values.constructor(attribute.values);
  }
  return new GeometryAttribute_default({
    componentDatatype: attribute.componentDatatype,
    componentsPerAttribute: attribute.componentsPerAttribute,
    normalize: attribute.normalize,
    values: clonedValues
  });
}
function cloneGeometry(geometry) {
  const attributes = geometry.attributes;
  const newAttributes = new GeometryAttributes_default();
  for (const property in attributes) {
    if (attributes.hasOwnProperty(property) && defined_default(attributes[property])) {
      newAttributes[property] = cloneAttribute(attributes[property]);
    }
  }
  let indices;
  if (defined_default(geometry.indices)) {
    const sourceValues = geometry.indices;
    if (Array.isArray(sourceValues)) {
      indices = sourceValues.slice(0);
    } else {
      indices = new sourceValues.constructor(sourceValues);
    }
  }
  return new Geometry_default({
    attributes: newAttributes,
    indices,
    primitiveType: geometry.primitiveType,
    boundingSphere: BoundingSphere_default.clone(geometry.boundingSphere)
  });
}
function cloneInstance(instance, geometry) {
  return {
    geometry,
    attributes: instance.attributes,
    modelMatrix: Matrix4_default.clone(instance.modelMatrix),
    pickPrimitive: instance.pickPrimitive,
    id: instance.id
  };
}
var positionRegex = /attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g;
Primitive._modifyShaderPosition = function(primitive, vertexShaderSource, scene3DOnly) {
  let match;
  let forwardDecl = "";
  let attributes = "";
  let computeFunctions = "";
  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {
    const name = match[1];
    const functionName = `vec4 czm_compute${name[0].toUpperCase()}${name.substr(
      1
    )}()`;
    if (functionName !== "vec4 czm_computePosition()") {
      forwardDecl += `${functionName};
`;
    }
    if (!defined_default(primitive.rtcCenter)) {
      if (!scene3DOnly) {
        attributes += `attribute vec3 ${name}2DHigh;
attribute vec3 ${name}2DLow;
`;
        computeFunctions += `${functionName}
{
    vec4 p;
    if (czm_morphTime == 1.0)
    {
        p = czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);
    }
    else if (czm_morphTime == 0.0)
    {
        p = czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy);
    }
    else
    {
        p = czm_columbusViewMorph(
                czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy),
                czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow),
                czm_morphTime);
    }
    return p;
}

`;
      } else {
        computeFunctions += `${functionName}
{
    return czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);
}

`;
      }
    } else {
      vertexShaderSource = vertexShaderSource.replace(
        /attribute\s+vec(?:3|4)\s+position3DHigh;/g,
        ""
      );
      vertexShaderSource = vertexShaderSource.replace(
        /attribute\s+vec(?:3|4)\s+position3DLow;/g,
        ""
      );
      forwardDecl += "uniform mat4 u_modifiedModelView;\n";
      attributes += "attribute vec4 position;\n";
      computeFunctions += `${functionName}
{
    return u_modifiedModelView * position;
}

`;
      vertexShaderSource = vertexShaderSource.replace(
        /czm_modelViewRelativeToEye\s+\*\s+/g,
        ""
      );
      vertexShaderSource = vertexShaderSource.replace(
        /czm_modelViewProjectionRelativeToEye/g,
        "czm_projection"
      );
    }
  }
  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(
    "\n"
  );
};
Primitive._appendShowToShader = function(primitive, vertexShaderSource) {
  if (!defined_default(primitive._batchTableAttributeIndices.show)) {
    return vertexShaderSource;
  }
  const renamedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_show_main"
  );
  const showMain = "void main() \n{ \n    czm_non_show_main(); \n    gl_Position *= czm_batchTable_show(batchId); \n}";
  return `${renamedVS}
${showMain}`;
};
Primitive._updateColorAttribute = function(primitive, vertexShaderSource, isDepthFail) {
  if (!defined_default(primitive._batchTableAttributeIndices.color) && !defined_default(primitive._batchTableAttributeIndices.depthFailColor)) {
    return vertexShaderSource;
  }
  if (vertexShaderSource.search(/attribute\s+vec4\s+color;/g) === -1) {
    return vertexShaderSource;
  }
  if (isDepthFail && !defined_default(primitive._batchTableAttributeIndices.depthFailColor)) {
    throw new DeveloperError_default(
      "A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute."
    );
  }
  let modifiedVS = vertexShaderSource;
  modifiedVS = modifiedVS.replace(/attribute\s+vec4\s+color;/g, "");
  if (!isDepthFail) {
    modifiedVS = modifiedVS.replace(
      /(\b)color(\b)/g,
      "$1czm_batchTable_color(batchId)$2"
    );
  } else {
    modifiedVS = modifiedVS.replace(
      /(\b)color(\b)/g,
      "$1czm_batchTable_depthFailColor(batchId)$2"
    );
  }
  return modifiedVS;
};
function appendPickToVertexShader(source) {
  const renamedVS = ShaderSource_default.replaceMain(source, "czm_non_pick_main");
  const pickMain = "varying vec4 v_pickColor; \nvoid main() \n{ \n    czm_non_pick_main(); \n    v_pickColor = czm_batchTable_pickColor(batchId); \n}";
  return `${renamedVS}
${pickMain}`;
}
function appendPickToFragmentShader(source) {
  return `varying vec4 v_pickColor;
${source}`;
}
Primitive._updatePickColorAttribute = function(source) {
  let vsPick = source.replace(/attribute\s+vec4\s+pickColor;/g, "");
  vsPick = vsPick.replace(
    /(\b)pickColor(\b)/g,
    "$1czm_batchTable_pickColor(batchId)$2"
  );
  return vsPick;
};
Primitive._appendOffsetToShader = function(primitive, vertexShaderSource) {
  if (!defined_default(primitive._batchTableAttributeIndices.offset)) {
    return vertexShaderSource;
  }
  let attr = "attribute float batchId;\n";
  attr += "attribute float applyOffset;";
  let modifiedShader = vertexShaderSource.replace(
    /attribute\s+float\s+batchId;/g,
    attr
  );
  let str = "vec4 $1 = czm_computePosition();\n";
  str += "    if (czm_sceneMode == czm_sceneMode3D)\n";
  str += "    {\n";
  str += "        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);";
  str += "    }\n";
  str += "    else\n";
  str += "    {\n";
  str += "        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);";
  str += "    }\n";
  modifiedShader = modifiedShader.replace(
    /vec4\s+([A-Za-z0-9_]+)\s+=\s+czm_computePosition\(\);/g,
    str
  );
  return modifiedShader;
};
Primitive._appendDistanceDisplayConditionToShader = function(primitive, vertexShaderSource, scene3DOnly) {
  if (!defined_default(primitive._batchTableAttributeIndices.distanceDisplayCondition)) {
    return vertexShaderSource;
  }
  const renamedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_distanceDisplayCondition_main"
  );
  let distanceDisplayConditionMain = "void main() \n{ \n    czm_non_distanceDisplayCondition_main(); \n    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\n    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\n    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\n    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\n";
  if (!scene3DOnly) {
    distanceDisplayConditionMain += "    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\n    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\n    vec4 centerRTE;\n    if (czm_morphTime == 1.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\n    }\n    else\n    {\n        centerRTE = czm_columbusViewMorph(\n                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\n                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\n                czm_morphTime);\n    }\n";
  } else {
    distanceDisplayConditionMain += "    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n";
  }
  distanceDisplayConditionMain += "    float radiusSq = boundingSphereRadius * boundingSphereRadius; \n    float distanceSq; \n    if (czm_sceneMode == czm_sceneMode2D) \n    { \n        distanceSq = czm_eyeHeight2D.y - radiusSq; \n    } \n    else \n    { \n        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \n    } \n    distanceSq = max(distanceSq, 0.0); \n    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \n    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \n    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \n    gl_Position *= show; \n}";
  return `${renamedVS}
${distanceDisplayConditionMain}`;
};
function modifyForEncodedNormals(primitive, vertexShaderSource) {
  if (!primitive.compressVertices) {
    return vertexShaderSource;
  }
  const containsNormal = vertexShaderSource.search(/attribute\s+vec3\s+normal;/g) !== -1;
  const containsSt = vertexShaderSource.search(/attribute\s+vec2\s+st;/g) !== -1;
  if (!containsNormal && !containsSt) {
    return vertexShaderSource;
  }
  const containsTangent = vertexShaderSource.search(/attribute\s+vec3\s+tangent;/g) !== -1;
  const containsBitangent = vertexShaderSource.search(/attribute\s+vec3\s+bitangent;/g) !== -1;
  let numComponents = containsSt && containsNormal ? 2 : 1;
  numComponents += containsTangent || containsBitangent ? 1 : 0;
  const type2 = numComponents > 1 ? `vec${numComponents}` : "float";
  const attributeName = "compressedAttributes";
  const attributeDecl = `attribute ${type2} ${attributeName};`;
  let globalDecl = "";
  let decode = "";
  if (containsSt) {
    globalDecl += "vec2 st;\n";
    const stComponent = numComponents > 1 ? `${attributeName}.x` : attributeName;
    decode += `    st = czm_decompressTextureCoordinates(${stComponent});
`;
  }
  if (containsNormal && containsTangent && containsBitangent) {
    globalDecl += "vec3 normal;\nvec3 tangent;\nvec3 bitangent;\n";
    decode += `    czm_octDecode(${attributeName}.${containsSt ? "yz" : "xy"}, normal, tangent, bitangent);
`;
  } else {
    if (containsNormal) {
      globalDecl += "vec3 normal;\n";
      decode += `    normal = czm_octDecode(${attributeName}${numComponents > 1 ? `.${containsSt ? "y" : "x"}` : ""});
`;
    }
    if (containsTangent) {
      globalDecl += "vec3 tangent;\n";
      decode += `    tangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? "z" : "y"});
`;
    }
    if (containsBitangent) {
      globalDecl += "vec3 bitangent;\n";
      decode += `    bitangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? "z" : "y"});
`;
    }
  }
  let modifiedVS = vertexShaderSource;
  modifiedVS = modifiedVS.replace(/attribute\s+vec3\s+normal;/g, "");
  modifiedVS = modifiedVS.replace(/attribute\s+vec2\s+st;/g, "");
  modifiedVS = modifiedVS.replace(/attribute\s+vec3\s+tangent;/g, "");
  modifiedVS = modifiedVS.replace(/attribute\s+vec3\s+bitangent;/g, "");
  modifiedVS = ShaderSource_default.replaceMain(modifiedVS, "czm_non_compressed_main");
  const compressedMain = `${"void main() \n{ \n"}${decode}    czm_non_compressed_main(); 
}`;
  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join("\n");
}
function depthClampVS(vertexShaderSource) {
  let modifiedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_depth_clamp_main"
  );
  modifiedVS += "void main() {\n    czm_non_depth_clamp_main();\n    gl_Position = czm_depthClamp(gl_Position);}\n";
  return modifiedVS;
}
function depthClampFS(fragmentShaderSource) {
  let modifiedFS = ShaderSource_default.replaceMain(
    fragmentShaderSource,
    "czm_non_depth_clamp_main"
  );
  modifiedFS += "void main() {\n    czm_non_depth_clamp_main();\n#if defined(GL_EXT_frag_depth)\n    #if defined(LOG_DEPTH)\n        czm_writeLogDepth();\n    #else\n        czm_writeDepthClamp();\n    #endif\n#endif\n}\n";
  modifiedFS = `${"#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n"}${modifiedFS}`;
  return modifiedFS;
}
function validateShaderMatching(shaderProgram, attributeLocations) {
  const shaderAttributes = shaderProgram.vertexAttributes;
  for (const name in shaderAttributes) {
    if (shaderAttributes.hasOwnProperty(name)) {
      if (!defined_default(attributeLocations[name])) {
        throw new DeveloperError_default(
          `Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${name}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`
        );
      }
    }
  }
}
function getUniformFunction(uniforms, name) {
  return function() {
    return uniforms[name];
  };
}
var numberOfCreationWorkers = Math.max(
  FeatureDetection_default.hardwareConcurrency - 1,
  1
);
var createGeometryTaskProcessors;
var combineGeometryTaskProcessor = new TaskProcessor_default("combineGeometry");
function loadAsynchronous(primitive, frameState) {
  let instances;
  let geometry;
  let i;
  let j;
  const instanceIds = primitive._instanceIds;
  if (primitive._state === PrimitiveState_default.READY) {
    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
    const length = primitive._numberOfInstances = instances.length;
    const promises = [];
    let subTasks = [];
    for (i = 0; i < length; ++i) {
      geometry = instances[i].geometry;
      instanceIds.push(instances[i].id);
      if (!defined_default(geometry._workerName)) {
        throw new DeveloperError_default(
          "_workerName must be defined for asynchronous geometry."
        );
      }
      subTasks.push({
        moduleName: geometry._workerName,
        geometry
      });
    }
    if (!defined_default(createGeometryTaskProcessors)) {
      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);
      for (i = 0; i < numberOfCreationWorkers; i++) {
        createGeometryTaskProcessors[i] = new TaskProcessor_default("createGeometry");
      }
    }
    let subTask;
    subTasks = subdivideArray_default(subTasks, numberOfCreationWorkers);
    for (i = 0; i < subTasks.length; i++) {
      let packedLength = 0;
      const workerSubTasks = subTasks[i];
      const workerSubTasksLength = workerSubTasks.length;
      for (j = 0; j < workerSubTasksLength; ++j) {
        subTask = workerSubTasks[j];
        geometry = subTask.geometry;
        if (defined_default(geometry.constructor.pack)) {
          subTask.offset = packedLength;
          packedLength += defaultValue_default(
            geometry.constructor.packedLength,
            geometry.packedLength
          );
        }
      }
      let subTaskTransferableObjects;
      if (packedLength > 0) {
        const array = new Float64Array(packedLength);
        subTaskTransferableObjects = [array.buffer];
        for (j = 0; j < workerSubTasksLength; ++j) {
          subTask = workerSubTasks[j];
          geometry = subTask.geometry;
          if (defined_default(geometry.constructor.pack)) {
            geometry.constructor.pack(geometry, array, subTask.offset);
            subTask.geometry = array;
          }
        }
      }
      promises.push(
        createGeometryTaskProcessors[i].scheduleTask(
          {
            subTasks: subTasks[i]
          },
          subTaskTransferableObjects
        )
      );
    }
    primitive._state = PrimitiveState_default.CREATING;
    Promise.all(promises).then(function(results) {
      primitive._createGeometryResults = results;
      primitive._state = PrimitiveState_default.CREATED;
    }).catch(function(error) {
      setReady(primitive, frameState, PrimitiveState_default.FAILED, error);
    });
  } else if (primitive._state === PrimitiveState_default.CREATED) {
    const transferableObjects = [];
    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
    const scene3DOnly = frameState.scene3DOnly;
    const projection = frameState.mapProjection;
    const promise = combineGeometryTaskProcessor.scheduleTask(
      PrimitivePipeline_default.packCombineGeometryParameters(
        {
          createGeometryResults: primitive._createGeometryResults,
          instances,
          ellipsoid: projection.ellipsoid,
          projection,
          elementIndexUintSupported: frameState.context.elementIndexUint,
          scene3DOnly,
          vertexCacheOptimize: primitive.vertexCacheOptimize,
          compressVertices: primitive.compressVertices,
          modelMatrix: primitive.modelMatrix,
          createPickOffsets: primitive._createPickOffsets
        },
        transferableObjects
      ),
      transferableObjects
    );
    primitive._createGeometryResults = void 0;
    primitive._state = PrimitiveState_default.COMBINING;
    Promise.resolve(promise).then(function(packedResult) {
      const result = PrimitivePipeline_default.unpackCombineGeometryResults(
        packedResult
      );
      primitive._geometries = result.geometries;
      primitive._attributeLocations = result.attributeLocations;
      primitive.modelMatrix = Matrix4_default.clone(
        result.modelMatrix,
        primitive.modelMatrix
      );
      primitive._pickOffsets = result.pickOffsets;
      primitive._offsetInstanceExtend = result.offsetInstanceExtend;
      primitive._instanceBoundingSpheres = result.boundingSpheres;
      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
      if (defined_default(primitive._geometries) && primitive._geometries.length > 0) {
        primitive._recomputeBoundingSpheres = true;
        primitive._state = PrimitiveState_default.COMBINED;
      } else {
        setReady(primitive, frameState, PrimitiveState_default.FAILED, void 0);
      }
    }).catch(function(error) {
      setReady(primitive, frameState, PrimitiveState_default.FAILED, error);
    });
  }
}
function loadSynchronous(primitive, frameState) {
  const instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
  const length = primitive._numberOfInstances = instances.length;
  const clonedInstances = new Array(length);
  const instanceIds = primitive._instanceIds;
  let instance;
  let i;
  let geometryIndex = 0;
  for (i = 0; i < length; i++) {
    instance = instances[i];
    const geometry = instance.geometry;
    let createdGeometry;
    if (defined_default(geometry.attributes) && defined_default(geometry.primitiveType)) {
      createdGeometry = cloneGeometry(geometry);
    } else {
      createdGeometry = geometry.constructor.createGeometry(geometry);
    }
    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);
    instanceIds.push(instance.id);
  }
  clonedInstances.length = geometryIndex;
  const scene3DOnly = frameState.scene3DOnly;
  const projection = frameState.mapProjection;
  const result = PrimitivePipeline_default.combineGeometry({
    instances: clonedInstances,
    ellipsoid: projection.ellipsoid,
    projection,
    elementIndexUintSupported: frameState.context.elementIndexUint,
    scene3DOnly,
    vertexCacheOptimize: primitive.vertexCacheOptimize,
    compressVertices: primitive.compressVertices,
    modelMatrix: primitive.modelMatrix,
    createPickOffsets: primitive._createPickOffsets
  });
  primitive._geometries = result.geometries;
  primitive._attributeLocations = result.attributeLocations;
  primitive.modelMatrix = Matrix4_default.clone(
    result.modelMatrix,
    primitive.modelMatrix
  );
  primitive._pickOffsets = result.pickOffsets;
  primitive._offsetInstanceExtend = result.offsetInstanceExtend;
  primitive._instanceBoundingSpheres = result.boundingSpheres;
  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
  if (defined_default(primitive._geometries) && primitive._geometries.length > 0) {
    primitive._recomputeBoundingSpheres = true;
    primitive._state = PrimitiveState_default.COMBINED;
  } else {
    setReady(primitive, frameState, PrimitiveState_default.FAILED, void 0);
  }
}
function recomputeBoundingSpheres(primitive, frameState) {
  const offsetIndex = primitive._batchTableAttributeIndices.offset;
  if (!primitive._recomputeBoundingSpheres || !defined_default(offsetIndex)) {
    primitive._recomputeBoundingSpheres = false;
    return;
  }
  let i;
  const offsetInstanceExtend = primitive._offsetInstanceExtend;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  let newBoundingSpheres = primitive._tempBoundingSpheres;
  if (!defined_default(newBoundingSpheres)) {
    newBoundingSpheres = new Array(length);
    for (i = 0; i < length; i++) {
      newBoundingSpheres[i] = new BoundingSphere_default();
    }
    primitive._tempBoundingSpheres = newBoundingSpheres;
  }
  for (i = 0; i < length; ++i) {
    let newBS = newBoundingSpheres[i];
    const offset = primitive._batchTable.getBatchedAttribute(
      i,
      offsetIndex,
      new Cartesian3_default()
    );
    newBS = boundingSpheres[i].clone(newBS);
    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);
  }
  const combinedBS = [];
  const combinedWestBS = [];
  const combinedEastBS = [];
  for (i = 0; i < length; ++i) {
    const bs = newBoundingSpheres[i];
    const minX = bs.center.x - bs.radius;
    if (minX > 0 || BoundingSphere_default.intersectPlane(bs, Plane_default.ORIGIN_ZX_PLANE) !== Intersect_default.INTERSECTING) {
      combinedBS.push(bs);
    } else {
      combinedWestBS.push(bs);
      combinedEastBS.push(bs);
    }
  }
  let resultBS1 = combinedBS[0];
  let resultBS2 = combinedEastBS[0];
  let resultBS3 = combinedWestBS[0];
  for (i = 1; i < combinedBS.length; i++) {
    resultBS1 = BoundingSphere_default.union(resultBS1, combinedBS[i]);
  }
  for (i = 1; i < combinedEastBS.length; i++) {
    resultBS2 = BoundingSphere_default.union(resultBS2, combinedEastBS[i]);
  }
  for (i = 1; i < combinedWestBS.length; i++) {
    resultBS3 = BoundingSphere_default.union(resultBS3, combinedWestBS[i]);
  }
  const result = [];
  if (defined_default(resultBS1)) {
    result.push(resultBS1);
  }
  if (defined_default(resultBS2)) {
    result.push(resultBS2);
  }
  if (defined_default(resultBS3)) {
    result.push(resultBS3);
  }
  for (i = 0; i < result.length; i++) {
    const boundingSphere = result[i].clone(primitive._boundingSpheres[i]);
    primitive._boundingSpheres[i] = boundingSphere;
    primitive._boundingSphereCV[i] = BoundingSphere_default.projectTo2D(
      boundingSphere,
      frameState.mapProjection,
      primitive._boundingSphereCV[i]
    );
  }
  Primitive._updateBoundingVolumes(
    primitive,
    frameState,
    primitive.modelMatrix,
    true
  );
  primitive._recomputeBoundingSpheres = false;
}
var scratchBoundingSphereCenterEncoded = new EncodedCartesian3_default();
var scratchBoundingSphereCartographic = new Cartographic_default();
var scratchBoundingSphereCenter2D = new Cartesian3_default();
var scratchBoundingSphere3 = new BoundingSphere_default();
function updateBatchTableBoundingSpheres(primitive, frameState) {
  const hasDistanceDisplayCondition = defined_default(
    primitive._batchTableAttributeIndices.distanceDisplayCondition
  );
  if (!hasDistanceDisplayCondition || primitive._batchTableBoundingSpheresUpdated) {
    return;
  }
  const indices = primitive._batchTableBoundingSphereAttributeIndices;
  const center3DHighIndex = indices.center3DHigh;
  const center3DLowIndex = indices.center3DLow;
  const center2DHighIndex = indices.center2DHigh;
  const center2DLowIndex = indices.center2DLow;
  const radiusIndex = indices.radius;
  const projection = frameState.mapProjection;
  const ellipsoid = projection.ellipsoid;
  const batchTable = primitive._batchTable;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  for (let i = 0; i < length; ++i) {
    let boundingSphere = boundingSpheres[i];
    if (!defined_default(boundingSphere)) {
      continue;
    }
    const modelMatrix = primitive.modelMatrix;
    if (defined_default(modelMatrix)) {
      boundingSphere = BoundingSphere_default.transform(
        boundingSphere,
        modelMatrix,
        scratchBoundingSphere3
      );
    }
    const center = boundingSphere.center;
    const radius = boundingSphere.radius;
    let encodedCenter = EncodedCartesian3_default.fromCartesian(
      center,
      scratchBoundingSphereCenterEncoded
    );
    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);
    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);
    if (!frameState.scene3DOnly) {
      const cartographic = ellipsoid.cartesianToCartographic(
        center,
        scratchBoundingSphereCartographic
      );
      const center2D = projection.project(
        cartographic,
        scratchBoundingSphereCenter2D
      );
      encodedCenter = EncodedCartesian3_default.fromCartesian(
        center2D,
        scratchBoundingSphereCenterEncoded
      );
      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);
      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);
    }
    batchTable.setBatchedAttribute(i, radiusIndex, radius);
  }
  primitive._batchTableBoundingSpheresUpdated = true;
}
var offsetScratchCartesian = new Cartesian3_default();
var offsetCenterScratch = new Cartesian3_default();
function updateBatchTableOffsets(primitive, frameState) {
  const hasOffset = defined_default(primitive._batchTableAttributeIndices.offset);
  if (!hasOffset || primitive._batchTableOffsetsUpdated || frameState.scene3DOnly) {
    return;
  }
  const index2D = primitive._batchTableOffsetAttribute2DIndex;
  const projection = frameState.mapProjection;
  const ellipsoid = projection.ellipsoid;
  const batchTable = primitive._batchTable;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  for (let i = 0; i < length; ++i) {
    let boundingSphere = boundingSpheres[i];
    if (!defined_default(boundingSphere)) {
      continue;
    }
    const offset = batchTable.getBatchedAttribute(
      i,
      primitive._batchTableAttributeIndices.offset
    );
    if (Cartesian3_default.equals(offset, Cartesian3_default.ZERO)) {
      batchTable.setBatchedAttribute(i, index2D, Cartesian3_default.ZERO);
      continue;
    }
    const modelMatrix = primitive.modelMatrix;
    if (defined_default(modelMatrix)) {
      boundingSphere = BoundingSphere_default.transform(
        boundingSphere,
        modelMatrix,
        scratchBoundingSphere3
      );
    }
    let center = boundingSphere.center;
    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);
    let cartographic = ellipsoid.cartesianToCartographic(
      center,
      scratchBoundingSphereCartographic
    );
    const center2D = projection.project(
      cartographic,
      scratchBoundingSphereCenter2D
    );
    const newPoint = Cartesian3_default.add(offset, center, offsetScratchCartesian);
    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);
    const newPointProjected = projection.project(
      cartographic,
      offsetScratchCartesian
    );
    const newVector = Cartesian3_default.subtract(
      newPointProjected,
      center2D,
      offsetScratchCartesian
    );
    const x = newVector.x;
    newVector.x = newVector.z;
    newVector.z = newVector.y;
    newVector.y = x;
    batchTable.setBatchedAttribute(i, index2D, newVector);
  }
  primitive._batchTableOffsetsUpdated = true;
}
function createVertexArray(primitive, frameState) {
  const attributeLocations = primitive._attributeLocations;
  const geometries = primitive._geometries;
  const scene3DOnly = frameState.scene3DOnly;
  const context = frameState.context;
  const va = [];
  const length = geometries.length;
  for (let i = 0; i < length; ++i) {
    const geometry = geometries[i];
    va.push(
      VertexArray_default.fromGeometry({
        context,
        geometry,
        attributeLocations,
        bufferUsage: BufferUsage_default.STATIC_DRAW,
        interleave: primitive._interleave
      })
    );
    if (defined_default(primitive._createBoundingVolumeFunction)) {
      primitive._createBoundingVolumeFunction(frameState, geometry);
    } else {
      primitive._boundingSpheres.push(
        BoundingSphere_default.clone(geometry.boundingSphere)
      );
      primitive._boundingSphereWC.push(new BoundingSphere_default());
      if (!scene3DOnly) {
        const center = geometry.boundingSphereCV.center;
        const x = center.x;
        const y = center.y;
        const z = center.z;
        center.x = z;
        center.y = x;
        center.z = y;
        primitive._boundingSphereCV.push(
          BoundingSphere_default.clone(geometry.boundingSphereCV)
        );
        primitive._boundingSphere2D.push(new BoundingSphere_default());
        primitive._boundingSphereMorph.push(new BoundingSphere_default());
      }
    }
  }
  primitive._va = va;
  primitive._primitiveType = geometries[0].primitiveType;
  if (primitive.releaseGeometryInstances) {
    primitive.geometryInstances = void 0;
  }
  primitive._geometries = void 0;
  setReady(primitive, frameState, PrimitiveState_default.COMPLETE, void 0);
}
function createRenderStates(primitive, context, appearance, twoPasses) {
  let renderState = appearance.getRenderState();
  let rs;
  if (twoPasses) {
    rs = clone_default(renderState, false);
    rs.cull = {
      enabled: true,
      face: CullFace_default.BACK
    };
    primitive._frontFaceRS = RenderState_default.fromCache(rs);
    rs.cull.face = CullFace_default.FRONT;
    primitive._backFaceRS = RenderState_default.fromCache(rs);
  } else {
    primitive._frontFaceRS = RenderState_default.fromCache(renderState);
    primitive._backFaceRS = primitive._frontFaceRS;
  }
  rs = clone_default(renderState, false);
  if (defined_default(primitive._depthFailAppearance)) {
    rs.depthTest.enabled = false;
  }
  if (defined_default(primitive._depthFailAppearance)) {
    renderState = primitive._depthFailAppearance.getRenderState();
    rs = clone_default(renderState, false);
    rs.depthTest.func = DepthFunction_default.GREATER;
    if (twoPasses) {
      rs.cull = {
        enabled: true,
        face: CullFace_default.BACK
      };
      primitive._frontFaceDepthFailRS = RenderState_default.fromCache(rs);
      rs.cull.face = CullFace_default.FRONT;
      primitive._backFaceDepthFailRS = RenderState_default.fromCache(rs);
    } else {
      primitive._frontFaceDepthFailRS = RenderState_default.fromCache(rs);
      primitive._backFaceDepthFailRS = primitive._frontFaceRS;
    }
  }
}
function createShaderProgram(primitive, frameState, appearance) {
  const context = frameState.context;
  const attributeLocations = primitive._attributeLocations;
  let vs = primitive._batchTable.getVertexShaderCallback()(
    appearance.vertexShaderSource
  );
  vs = Primitive._appendOffsetToShader(primitive, vs);
  vs = Primitive._appendShowToShader(primitive, vs);
  vs = Primitive._appendDistanceDisplayConditionToShader(
    primitive,
    vs,
    frameState.scene3DOnly
  );
  vs = appendPickToVertexShader(vs);
  vs = Primitive._updateColorAttribute(primitive, vs, false);
  vs = modifyForEncodedNormals(primitive, vs);
  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);
  let fs = appearance.getFragmentShaderSource();
  fs = appendPickToFragmentShader(fs);
  primitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vs,
    fragmentShaderSource: fs,
    attributeLocations
  });
  validateShaderMatching(primitive._sp, attributeLocations);
  if (defined_default(primitive._depthFailAppearance)) {
    vs = primitive._batchTable.getVertexShaderCallback()(
      primitive._depthFailAppearance.vertexShaderSource
    );
    vs = Primitive._appendShowToShader(primitive, vs);
    vs = Primitive._appendDistanceDisplayConditionToShader(
      primitive,
      vs,
      frameState.scene3DOnly
    );
    vs = appendPickToVertexShader(vs);
    vs = Primitive._updateColorAttribute(primitive, vs, true);
    vs = modifyForEncodedNormals(primitive, vs);
    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);
    vs = depthClampVS(vs);
    fs = primitive._depthFailAppearance.getFragmentShaderSource();
    fs = appendPickToFragmentShader(fs);
    fs = depthClampFS(fs);
    primitive._spDepthFail = ShaderProgram_default.replaceCache({
      context,
      shaderProgram: primitive._spDepthFail,
      vertexShaderSource: vs,
      fragmentShaderSource: fs,
      attributeLocations
    });
    validateShaderMatching(primitive._spDepthFail, attributeLocations);
  }
}
var modifiedModelViewScratch = new Matrix4_default();
var rtcScratch = new Cartesian3_default();
function getUniforms(primitive, appearance, material, frameState) {
  const materialUniformMap = defined_default(material) ? material._uniforms : void 0;
  const appearanceUniformMap = {};
  const appearanceUniforms = appearance.uniforms;
  if (defined_default(appearanceUniforms)) {
    for (const name in appearanceUniforms) {
      if (appearanceUniforms.hasOwnProperty(name)) {
        if (defined_default(materialUniformMap) && defined_default(materialUniformMap[name])) {
          throw new DeveloperError_default(
            `Appearance and material have a uniform with the same name: ${name}`
          );
        }
        appearanceUniformMap[name] = getUniformFunction(
          appearanceUniforms,
          name
        );
      }
    }
  }
  let uniforms = combine_default(appearanceUniformMap, materialUniformMap);
  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);
  if (defined_default(primitive.rtcCenter)) {
    uniforms.u_modifiedModelView = function() {
      const viewMatrix = frameState.context.uniformState.view;
      Matrix4_default.multiply(
        viewMatrix,
        primitive._modelMatrix,
        modifiedModelViewScratch
      );
      Matrix4_default.multiplyByPoint(
        modifiedModelViewScratch,
        primitive.rtcCenter,
        rtcScratch
      );
      Matrix4_default.setTranslation(
        modifiedModelViewScratch,
        rtcScratch,
        modifiedModelViewScratch
      );
      return modifiedModelViewScratch;
    };
  }
  return uniforms;
}
function createCommands(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands, frameState) {
  const uniforms = getUniforms(primitive, appearance, material, frameState);
  let depthFailUniforms;
  if (defined_default(primitive._depthFailAppearance)) {
    depthFailUniforms = getUniforms(
      primitive,
      primitive._depthFailAppearance,
      primitive._depthFailAppearance.material,
      frameState
    );
  }
  const pass = translucent ? Pass_default.TRANSLUCENT : Pass_default.OPAQUE;
  let multiplier = twoPasses ? 2 : 1;
  multiplier *= defined_default(primitive._depthFailAppearance) ? 2 : 1;
  colorCommands.length = primitive._va.length * multiplier;
  const length = colorCommands.length;
  let vaIndex = 0;
  for (let i = 0; i < length; ++i) {
    let colorCommand;
    if (twoPasses) {
      colorCommand = colorCommands[i];
      if (!defined_default(colorCommand)) {
        colorCommand = colorCommands[i] = new DrawCommand_default({
          owner: primitive,
          primitiveType: primitive._primitiveType
        });
      }
      colorCommand.vertexArray = primitive._va[vaIndex];
      colorCommand.renderState = primitive._backFaceRS;
      colorCommand.shaderProgram = primitive._sp;
      colorCommand.uniformMap = uniforms;
      colorCommand.pass = pass;
      ++i;
    }
    colorCommand = colorCommands[i];
    if (!defined_default(colorCommand)) {
      colorCommand = colorCommands[i] = new DrawCommand_default({
        owner: primitive,
        primitiveType: primitive._primitiveType
      });
    }
    colorCommand.vertexArray = primitive._va[vaIndex];
    colorCommand.renderState = primitive._frontFaceRS;
    colorCommand.shaderProgram = primitive._sp;
    colorCommand.uniformMap = uniforms;
    colorCommand.pass = pass;
    if (defined_default(primitive._depthFailAppearance)) {
      if (twoPasses) {
        ++i;
        colorCommand = colorCommands[i];
        if (!defined_default(colorCommand)) {
          colorCommand = colorCommands[i] = new DrawCommand_default({
            owner: primitive,
            primitiveType: primitive._primitiveType
          });
        }
        colorCommand.vertexArray = primitive._va[vaIndex];
        colorCommand.renderState = primitive._backFaceDepthFailRS;
        colorCommand.shaderProgram = primitive._spDepthFail;
        colorCommand.uniformMap = depthFailUniforms;
        colorCommand.pass = pass;
      }
      ++i;
      colorCommand = colorCommands[i];
      if (!defined_default(colorCommand)) {
        colorCommand = colorCommands[i] = new DrawCommand_default({
          owner: primitive,
          primitiveType: primitive._primitiveType
        });
      }
      colorCommand.vertexArray = primitive._va[vaIndex];
      colorCommand.renderState = primitive._frontFaceDepthFailRS;
      colorCommand.shaderProgram = primitive._spDepthFail;
      colorCommand.uniformMap = depthFailUniforms;
      colorCommand.pass = pass;
    }
    ++vaIndex;
  }
}
Primitive._updateBoundingVolumes = function(primitive, frameState, modelMatrix, forceUpdate) {
  let i;
  let length;
  let boundingSphere;
  if (forceUpdate || !Matrix4_default.equals(modelMatrix, primitive._modelMatrix)) {
    Matrix4_default.clone(modelMatrix, primitive._modelMatrix);
    length = primitive._boundingSpheres.length;
    for (i = 0; i < length; ++i) {
      boundingSphere = primitive._boundingSpheres[i];
      if (defined_default(boundingSphere)) {
        primitive._boundingSphereWC[i] = BoundingSphere_default.transform(
          boundingSphere,
          modelMatrix,
          primitive._boundingSphereWC[i]
        );
        if (!frameState.scene3DOnly) {
          primitive._boundingSphere2D[i] = BoundingSphere_default.clone(
            primitive._boundingSphereCV[i],
            primitive._boundingSphere2D[i]
          );
          primitive._boundingSphere2D[i].center.x = 0;
          primitive._boundingSphereMorph[i] = BoundingSphere_default.union(
            primitive._boundingSphereWC[i],
            primitive._boundingSphereCV[i]
          );
        }
      }
    }
  }
  const pixelSize = primitive.appearance.pixelSize;
  if (defined_default(pixelSize)) {
    length = primitive._boundingSpheres.length;
    for (i = 0; i < length; ++i) {
      boundingSphere = primitive._boundingSpheres[i];
      const boundingSphereWC = primitive._boundingSphereWC[i];
      const pixelSizeInMeters = frameState.camera.getPixelSize(
        boundingSphere,
        frameState.context.drawingBufferWidth,
        frameState.context.drawingBufferHeight
      );
      const sizeInMeters = pixelSizeInMeters * pixelSize;
      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;
    }
  }
};
function updateAndQueueCommands(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  if (frameState.mode !== SceneMode_default.SCENE3D && !Matrix4_default.equals(modelMatrix, Matrix4_default.IDENTITY)) {
    throw new DeveloperError_default(
      "Primitive.modelMatrix is only supported in 3D mode."
    );
  }
  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingSpheres;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingSpheres = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingSpheres = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingSpheres = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingSpheres = primitive._boundingSphereMorph;
  }
  const commandList = frameState.commandList;
  const passes = frameState.passes;
  if (passes.render || passes.pick) {
    const allowPicking = primitive.allowPicking;
    const castShadows = ShadowMode_default.castShadows(primitive.shadows);
    const receiveShadows = ShadowMode_default.receiveShadows(primitive.shadows);
    const colorLength = colorCommands.length;
    let factor = twoPasses ? 2 : 1;
    factor *= defined_default(primitive._depthFailAppearance) ? 2 : 1;
    for (let j = 0; j < colorLength; ++j) {
      const sphereIndex = Math.floor(j / factor);
      const colorCommand = colorCommands[j];
      colorCommand.modelMatrix = modelMatrix;
      colorCommand.boundingVolume = boundingSpheres[sphereIndex];
      colorCommand.cull = cull;
      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;
      colorCommand.castShadows = castShadows;
      colorCommand.receiveShadows = receiveShadows;
      if (allowPicking) {
        colorCommand.pickId = "v_pickColor";
      } else {
        colorCommand.pickId = void 0;
      }
      commandList.push(colorCommand);
    }
  }
}
Primitive.prototype.update = function(frameState) {
  if (!defined_default(this.geometryInstances) && this._va.length === 0 || defined_default(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !defined_default(this.appearance) || frameState.mode !== SceneMode_default.SCENE3D && frameState.scene3DOnly || !frameState.passes.render && !frameState.passes.pick) {
    return;
  }
  if (defined_default(this._error)) {
    throw this._error;
  }
  if (defined_default(this.rtcCenter) && !frameState.scene3DOnly) {
    throw new DeveloperError_default(
      "RTC rendering is only available for 3D only scenes."
    );
  }
  if (this._state === PrimitiveState_default.FAILED) {
    return;
  }
  const context = frameState.context;
  if (!defined_default(this._batchTable)) {
    createBatchTable(this, context);
  }
  if (this._batchTable.attributes.length > 0) {
    if (ContextLimits_default.maximumVertexTextureImageUnits === 0) {
      throw new RuntimeError_default(
        "Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero."
      );
    }
    this._batchTable.update(frameState);
  }
  if (this._state !== PrimitiveState_default.COMPLETE && this._state !== PrimitiveState_default.COMBINED) {
    if (this.asynchronous) {
      loadAsynchronous(this, frameState);
    } else {
      loadSynchronous(this, frameState);
    }
  }
  if (this._state === PrimitiveState_default.COMBINED) {
    updateBatchTableBoundingSpheres(this, frameState);
    updateBatchTableOffsets(this, frameState);
    createVertexArray(this, frameState);
  }
  if (!this.show || this._state !== PrimitiveState_default.COMPLETE) {
    return;
  }
  if (!this._batchTableOffsetsUpdated) {
    updateBatchTableOffsets(this, frameState);
  }
  if (this._recomputeBoundingSpheres) {
    recomputeBoundingSpheres(this, frameState);
  }
  const appearance = this.appearance;
  const material = appearance.material;
  let createRS = false;
  let createSP = false;
  if (this._appearance !== appearance) {
    this._appearance = appearance;
    this._material = material;
    createRS = true;
    createSP = true;
  } else if (this._material !== material) {
    this._material = material;
    createSP = true;
  }
  const depthFailAppearance = this.depthFailAppearance;
  const depthFailMaterial = defined_default(depthFailAppearance) ? depthFailAppearance.material : void 0;
  if (this._depthFailAppearance !== depthFailAppearance) {
    this._depthFailAppearance = depthFailAppearance;
    this._depthFailMaterial = depthFailMaterial;
    createRS = true;
    createSP = true;
  } else if (this._depthFailMaterial !== depthFailMaterial) {
    this._depthFailMaterial = depthFailMaterial;
    createSP = true;
  }
  const translucent = this._appearance.isTranslucent();
  if (this._translucent !== translucent) {
    this._translucent = translucent;
    createRS = true;
  }
  if (defined_default(this._material)) {
    this._material.update(context);
  }
  const twoPasses = appearance.closed && translucent;
  if (createRS) {
    const rsFunc = defaultValue_default(
      this._createRenderStatesFunction,
      createRenderStates
    );
    rsFunc(this, context, appearance, twoPasses);
  }
  if (createSP) {
    const spFunc = defaultValue_default(
      this._createShaderProgramFunction,
      createShaderProgram
    );
    spFunc(this, frameState, appearance);
  }
  if (createRS || createSP) {
    const commandFunc = defaultValue_default(
      this._createCommandsFunction,
      createCommands
    );
    commandFunc(
      this,
      appearance,
      material,
      translucent,
      twoPasses,
      this._colorCommands,
      this._pickCommands,
      frameState
    );
  }
  const updateAndQueueCommandsFunc = defaultValue_default(
    this._updateAndQueueCommandsFunction,
    updateAndQueueCommands
  );
  updateAndQueueCommandsFunc(
    this,
    frameState,
    this._colorCommands,
    this._pickCommands,
    this.modelMatrix,
    this.cull,
    this.debugShowBoundingVolume,
    twoPasses
  );
};
var offsetBoundingSphereScratch1 = new BoundingSphere_default();
var offsetBoundingSphereScratch2 = new BoundingSphere_default();
function transformBoundingSphere(boundingSphere, offset, offsetAttribute) {
  if (offsetAttribute === GeometryOffsetAttribute_default.TOP) {
    const origBS = BoundingSphere_default.clone(
      boundingSphere,
      offsetBoundingSphereScratch1
    );
    const offsetBS = BoundingSphere_default.clone(
      boundingSphere,
      offsetBoundingSphereScratch2
    );
    offsetBS.center = Cartesian3_default.add(offsetBS.center, offset, offsetBS.center);
    boundingSphere = BoundingSphere_default.union(origBS, offsetBS, boundingSphere);
  } else if (offsetAttribute === GeometryOffsetAttribute_default.ALL) {
    boundingSphere.center = Cartesian3_default.add(
      boundingSphere.center,
      offset,
      boundingSphere.center
    );
  }
  return boundingSphere;
}
function createGetFunction(batchTable, instanceIndex, attributeIndex) {
  return function() {
    const attributeValue = batchTable.getBatchedAttribute(
      instanceIndex,
      attributeIndex
    );
    const attribute = batchTable.attributes[attributeIndex];
    const componentsPerAttribute = attribute.componentsPerAttribute;
    const value = ComponentDatatype_default.createTypedArray(
      attribute.componentDatatype,
      componentsPerAttribute
    );
    if (defined_default(attributeValue.constructor.pack)) {
      attributeValue.constructor.pack(attributeValue, value, 0);
    } else {
      value[0] = attributeValue;
    }
    return value;
  };
}
function createSetFunction(batchTable, instanceIndex, attributeIndex, primitive, name) {
  return function(value) {
    if (!defined_default(value) || !defined_default(value.length) || value.length < 1 || value.length > 4) {
      throw new DeveloperError_default(
        "value must be and array with length between 1 and 4."
      );
    }
    const attributeValue = getAttributeValue(value);
    batchTable.setBatchedAttribute(
      instanceIndex,
      attributeIndex,
      attributeValue
    );
    if (name === "offset") {
      primitive._recomputeBoundingSpheres = true;
      primitive._batchTableOffsetsUpdated = false;
    }
  };
}
var offsetScratch2 = new Cartesian3_default();
function createBoundingSphereProperties(primitive, properties, index) {
  properties.boundingSphere = {
    get: function() {
      let boundingSphere = primitive._instanceBoundingSpheres[index];
      if (defined_default(boundingSphere)) {
        boundingSphere = boundingSphere.clone();
        const modelMatrix = primitive.modelMatrix;
        const offset = properties.offset;
        if (defined_default(offset)) {
          transformBoundingSphere(
            boundingSphere,
            Cartesian3_default.fromArray(offset.get(), 0, offsetScratch2),
            primitive._offsetInstanceExtend[index]
          );
        }
        if (defined_default(modelMatrix)) {
          boundingSphere = BoundingSphere_default.transform(
            boundingSphere,
            modelMatrix
          );
        }
      }
      return boundingSphere;
    }
  };
  properties.boundingSphereCV = {
    get: function() {
      return primitive._instanceBoundingSpheresCV[index];
    }
  };
}
function createPickIdProperty(primitive, properties, index) {
  properties.pickId = {
    get: function() {
      return primitive._pickIds[index];
    }
  };
}
Primitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required");
  }
  if (!defined_default(this._batchTable)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  let index = -1;
  const lastIndex = this._lastPerInstanceAttributeIndex;
  const ids = this._instanceIds;
  const length = ids.length;
  for (let i = 0; i < length; ++i) {
    const curIndex = (lastIndex + i) % length;
    if (id === ids[curIndex]) {
      index = curIndex;
      break;
    }
  }
  if (index === -1) {
    return void 0;
  }
  let attributes = this._perInstanceAttributeCache[index];
  if (defined_default(attributes)) {
    return attributes;
  }
  const batchTable = this._batchTable;
  const perInstanceAttributeIndices = this._batchTableAttributeIndices;
  attributes = {};
  const properties = {};
  for (const name in perInstanceAttributeIndices) {
    if (perInstanceAttributeIndices.hasOwnProperty(name)) {
      const attributeIndex = perInstanceAttributeIndices[name];
      properties[name] = {
        get: createGetFunction(batchTable, index, attributeIndex),
        set: createSetFunction(batchTable, index, attributeIndex, this, name)
      };
    }
  }
  createBoundingSphereProperties(this, properties, index);
  createPickIdProperty(this, properties, index);
  Object.defineProperties(attributes, properties);
  this._lastPerInstanceAttributeIndex = index;
  this._perInstanceAttributeCache[index] = attributes;
  return attributes;
};
Primitive.prototype.isDestroyed = function() {
  return false;
};
Primitive.prototype.destroy = function() {
  let length;
  let i;
  this._sp = this._sp && this._sp.destroy();
  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();
  const va = this._va;
  length = va.length;
  for (i = 0; i < length; ++i) {
    va[i].destroy();
  }
  this._va = void 0;
  const pickIds = this._pickIds;
  length = pickIds.length;
  for (i = 0; i < length; ++i) {
    pickIds[i].destroy();
  }
  this._pickIds = void 0;
  this._batchTable = this._batchTable && this._batchTable.destroy();
  this._instanceIds = void 0;
  this._perInstanceAttributeCache = void 0;
  this._attributeLocations = void 0;
  return destroyObject_default(this);
};
function setReady(primitive, frameState, state, error) {
  primitive._completeLoad(frameState, state, error);
}
var Primitive_default = Primitive;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GeometryInstanceAttribute.js
function GeometryInstanceAttribute(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (!defined_default(options.componentDatatype)) {
    throw new DeveloperError_default("options.componentDatatype is required.");
  }
  if (!defined_default(options.componentsPerAttribute)) {
    throw new DeveloperError_default("options.componentsPerAttribute is required.");
  }
  if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {
    throw new DeveloperError_default(
      "options.componentsPerAttribute must be between 1 and 4."
    );
  }
  if (!defined_default(options.value)) {
    throw new DeveloperError_default("options.value is required.");
  }
  this.componentDatatype = options.componentDatatype;
  this.componentsPerAttribute = options.componentsPerAttribute;
  this.normalize = defaultValue_default(options.normalize, false);
  this.value = options.value;
}
var GeometryInstanceAttribute_default = GeometryInstanceAttribute;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/ShadowVolumeAppearanceFS.js
var ShadowVolumeAppearanceFS_default = "#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nvarying vec4 v_sphericalExtents;\n#else // SPHERICAL\nvarying vec2 v_inversePlaneExtents;\nvarying vec4 v_westPlane;\nvarying vec4 v_southPlane;\n#endif // SPHERICAL\nvarying vec3 v_uvMinAndSphericalLongitudeRotation;\nvarying vec3 v_uMaxAndInverseDistance;\nvarying vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\nvarying vec4 v_color;\n#endif\n\n#ifdef NORMAL_EC\nvec3 getEyeCoordinate3FromWindowCoordinate(vec2 fragCoord, float logDepthOrDepth) {\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(fragCoord, logDepthOrDepth);\n    return eyeCoordinate.xyz / eyeCoordinate.w;\n}\n\nvec3 vectorFromOffset(vec4 eyeCoordinate, vec2 positiveOffset) {\n    vec2 glFragCoordXY = gl_FragCoord.xy;\n    // Sample depths at both offset and negative offset\n    float upOrRightLogDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, (glFragCoordXY + positiveOffset) / czm_viewport.zw));\n    float downOrLeftLogDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, (glFragCoordXY - positiveOffset) / czm_viewport.zw));\n    // Explicitly evaluate both paths\n    // Necessary for multifrustum and for edges of the screen\n    bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, czm_viewport.zw);\n    float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);\n    float useDownOrLeft = float(useUpOrRight == 0.0);\n    vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth);\n    vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth);\n    return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft;\n}\n#endif // NORMAL_EC\n\nvoid main(void)\n{\n#ifdef REQUIRES_EC\n    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n#endif\n\n#ifdef REQUIRES_WC\n    vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;\n    vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;\n#endif\n\n#ifdef TEXTURE_COORDINATES\n    vec2 uv;\n#ifdef SPHERICAL\n    // Treat world coords as a sphere normal for spherical coordinates\n    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate);\n    sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z;\n    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);\n    uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w;\n    uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z;\n#else // SPHERICAL\n    // Unpack planes and transform to eye space\n    uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x;\n    uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y;\n#endif // SPHERICAL\n#endif // TEXTURE_COORDINATES\n\n#ifdef PICK\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    // Check for logDepthOrDepth != 0.0 to make sure this should be classified.\n    if (0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0 || logDepthOrDepth != 0.0) {\n        gl_FragColor.a = 1.0; // 0.0 alpha leads to discard from ShaderSource.createPickFragmentShaderSource\n        czm_writeDepthClamp();\n    }\n#else // CULL_FRAGMENTS\n        gl_FragColor.a = 1.0;\n#endif // CULL_FRAGMENTS\n#else // PICK\n\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    if (uv.x <= 0.0 || 1.0 <= uv.x || uv.y <= 0.0 || 1.0 <= uv.y || logDepthOrDepth == 0.0) {\n        discard;\n    }\n#endif\n\n#ifdef NORMAL_EC\n    // Compute normal by sampling adjacent pixels in 2x2 block in screen space\n    vec3 downUp = vectorFromOffset(eyeCoordinate, vec2(0.0, 1.0));\n    vec3 leftRight = vectorFromOffset(eyeCoordinate, vec2(1.0, 0.0));\n    vec3 normalEC = normalize(cross(leftRight, downUp));\n#endif\n\n\n#ifdef PER_INSTANCE_COLOR\n\n    vec4 color = czm_gammaCorrect(v_color);\n#ifdef FLAT\n    gl_FragColor = color;\n#else // FLAT\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    gl_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    gl_FragColor.rgb *= gl_FragColor.a;\n\n#else // PER_INSTANCE_COLOR\n\n    // Material support.\n    // USES_ is distinct from REQUIRES_, because some things are dependencies of each other or\n    // dependencies for culling but might not actually be used by the material.\n\n    czm_materialInput materialInput;\n\n#ifdef USES_NORMAL_EC\n    materialInput.normalEC = normalEC;\n#endif\n\n#ifdef USES_POSITION_TO_EYE_EC\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n#endif\n\n#ifdef USES_TANGENT_TO_EYE\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(worldCoordinate, normalEC);\n#endif\n\n#ifdef USES_ST\n    // Remap texture coordinates from computed (approximately aligned with cartographic space) to the desired\n    // texture coordinate system, which typically forms a tight oriented bounding box around the geometry.\n    // Shader is provided a set of reference points for remapping.\n    materialInput.st.x = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_uMaxAndInverseDistance.xy, uv) * v_uMaxAndInverseDistance.z;\n    materialInput.st.y = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_vMaxAndInverseDistance.xy, uv) * v_vMaxAndInverseDistance.z;\n#endif\n\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else // FLAT\n    gl_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif // PER_INSTANCE_COLOR\n    czm_writeDepthClamp();\n#endif // PICK\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/ShadowVolumeAppearance.js
function ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {
  Check_default.typeOf.bool("extentsCulling", extentsCulling);
  Check_default.typeOf.bool("planarExtents", planarExtents);
  Check_default.typeOf.object("appearance", appearance);
  this._projectionExtentDefines = {
    eastMostYhighDefine: "",
    eastMostYlowDefine: "",
    westMostYhighDefine: "",
    westMostYlowDefine: ""
  };
  const colorShaderDependencies = new ShaderDependencies();
  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;
  colorShaderDependencies.requiresEC = !appearance.flat;
  const pickShaderDependencies = new ShaderDependencies();
  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;
  if (appearance instanceof PerInstanceColorAppearance_default) {
    colorShaderDependencies.requiresNormalEC = !appearance.flat;
  } else {
    const materialShaderSource = `${appearance.material.shaderSource}
${appearance.fragmentShaderSource}`;
    colorShaderDependencies.normalEC = materialShaderSource.indexOf("materialInput.normalEC") !== -1 || materialShaderSource.indexOf("czm_getDefaultMaterial") !== -1;
    colorShaderDependencies.positionToEyeEC = materialShaderSource.indexOf("materialInput.positionToEyeEC") !== -1;
    colorShaderDependencies.tangentToEyeMatrix = materialShaderSource.indexOf("materialInput.tangentToEyeMatrix") !== -1;
    colorShaderDependencies.st = materialShaderSource.indexOf("materialInput.st") !== -1;
  }
  this._colorShaderDependencies = colorShaderDependencies;
  this._pickShaderDependencies = pickShaderDependencies;
  this._appearance = appearance;
  this._extentsCulling = extentsCulling;
  this._planarExtents = planarExtents;
}
ShadowVolumeAppearance.prototype.createFragmentShader = function(columbusView2D) {
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  const appearance = this._appearance;
  const dependencies = this._colorShaderDependencies;
  const defines = [];
  if (!columbusView2D && !this._planarExtents) {
    defines.push("SPHERICAL");
  }
  if (dependencies.requiresEC) {
    defines.push("REQUIRES_EC");
  }
  if (dependencies.requiresWC) {
    defines.push("REQUIRES_WC");
  }
  if (dependencies.requiresTextureCoordinates) {
    defines.push("TEXTURE_COORDINATES");
  }
  if (this._extentsCulling) {
    defines.push("CULL_FRAGMENTS");
  }
  if (dependencies.requiresNormalEC) {
    defines.push("NORMAL_EC");
  }
  if (appearance instanceof PerInstanceColorAppearance_default) {
    defines.push("PER_INSTANCE_COLOR");
  }
  if (dependencies.normalEC) {
    defines.push("USES_NORMAL_EC");
  }
  if (dependencies.positionToEyeEC) {
    defines.push("USES_POSITION_TO_EYE_EC");
  }
  if (dependencies.tangentToEyeMatrix) {
    defines.push("USES_TANGENT_TO_EYE");
  }
  if (dependencies.st) {
    defines.push("USES_ST");
  }
  if (appearance.flat) {
    defines.push("FLAT");
  }
  let materialSource = "";
  if (!(appearance instanceof PerInstanceColorAppearance_default)) {
    materialSource = appearance.material.shaderSource;
  }
  return new ShaderSource_default({
    defines,
    sources: [materialSource, ShadowVolumeAppearanceFS_default]
  });
};
ShadowVolumeAppearance.prototype.createPickFragmentShader = function(columbusView2D) {
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  const dependencies = this._pickShaderDependencies;
  const defines = ["PICK"];
  if (!columbusView2D && !this._planarExtents) {
    defines.push("SPHERICAL");
  }
  if (dependencies.requiresEC) {
    defines.push("REQUIRES_EC");
  }
  if (dependencies.requiresWC) {
    defines.push("REQUIRES_WC");
  }
  if (dependencies.requiresTextureCoordinates) {
    defines.push("TEXTURE_COORDINATES");
  }
  if (this._extentsCulling) {
    defines.push("CULL_FRAGMENTS");
  }
  return new ShaderSource_default({
    defines,
    sources: [ShadowVolumeAppearanceFS_default],
    pickColorQualifier: "varying"
  });
};
ShadowVolumeAppearance.prototype.createVertexShader = function(defines, vertexShaderSource, columbusView2D, mapProjection) {
  Check_default.defined("defines", defines);
  Check_default.typeOf.string("vertexShaderSource", vertexShaderSource);
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  Check_default.defined("mapProjection", mapProjection);
  return createShadowVolumeAppearanceVS(
    this._colorShaderDependencies,
    this._planarExtents,
    columbusView2D,
    defines,
    vertexShaderSource,
    this._appearance,
    mapProjection,
    this._projectionExtentDefines
  );
};
ShadowVolumeAppearance.prototype.createPickVertexShader = function(defines, vertexShaderSource, columbusView2D, mapProjection) {
  Check_default.defined("defines", defines);
  Check_default.typeOf.string("vertexShaderSource", vertexShaderSource);
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  Check_default.defined("mapProjection", mapProjection);
  return createShadowVolumeAppearanceVS(
    this._pickShaderDependencies,
    this._planarExtents,
    columbusView2D,
    defines,
    vertexShaderSource,
    void 0,
    mapProjection,
    this._projectionExtentDefines
  );
};
var longitudeExtentsCartesianScratch = new Cartesian3_default();
var longitudeExtentsCartographicScratch = new Cartographic_default();
var longitudeExtentsEncodeScratch = {
  high: 0,
  low: 0
};
function createShadowVolumeAppearanceVS(shaderDependencies, planarExtents, columbusView2D, defines, vertexShaderSource, appearance, mapProjection, projectionExtentDefines) {
  const allDefines = defines.slice();
  if (projectionExtentDefines.eastMostYhighDefine === "") {
    const eastMostCartographic = longitudeExtentsCartographicScratch;
    eastMostCartographic.longitude = Math_default.PI;
    eastMostCartographic.latitude = 0;
    eastMostCartographic.height = 0;
    const eastMostCartesian = mapProjection.project(
      eastMostCartographic,
      longitudeExtentsCartesianScratch
    );
    let encoded = EncodedCartesian3_default.encode(
      eastMostCartesian.x,
      longitudeExtentsEncodeScratch
    );
    projectionExtentDefines.eastMostYhighDefine = `EAST_MOST_X_HIGH ${encoded.high.toFixed(
      `${encoded.high}`.length + 1
    )}`;
    projectionExtentDefines.eastMostYlowDefine = `EAST_MOST_X_LOW ${encoded.low.toFixed(
      `${encoded.low}`.length + 1
    )}`;
    const westMostCartographic = longitudeExtentsCartographicScratch;
    westMostCartographic.longitude = -Math_default.PI;
    westMostCartographic.latitude = 0;
    westMostCartographic.height = 0;
    const westMostCartesian = mapProjection.project(
      westMostCartographic,
      longitudeExtentsCartesianScratch
    );
    encoded = EncodedCartesian3_default.encode(
      westMostCartesian.x,
      longitudeExtentsEncodeScratch
    );
    projectionExtentDefines.westMostYhighDefine = `WEST_MOST_X_HIGH ${encoded.high.toFixed(
      `${encoded.high}`.length + 1
    )}`;
    projectionExtentDefines.westMostYlowDefine = `WEST_MOST_X_LOW ${encoded.low.toFixed(
      `${encoded.low}`.length + 1
    )}`;
  }
  if (columbusView2D) {
    allDefines.push(projectionExtentDefines.eastMostYhighDefine);
    allDefines.push(projectionExtentDefines.eastMostYlowDefine);
    allDefines.push(projectionExtentDefines.westMostYhighDefine);
    allDefines.push(projectionExtentDefines.westMostYlowDefine);
  }
  if (defined_default(appearance) && appearance instanceof PerInstanceColorAppearance_default) {
    allDefines.push("PER_INSTANCE_COLOR");
  }
  if (shaderDependencies.requiresTextureCoordinates) {
    allDefines.push("TEXTURE_COORDINATES");
    if (!(planarExtents || columbusView2D)) {
      allDefines.push("SPHERICAL");
    }
    if (columbusView2D) {
      allDefines.push("COLUMBUS_VIEW_2D");
    }
  }
  return new ShaderSource_default({
    defines: allDefines,
    sources: [vertexShaderSource]
  });
}
function ShaderDependencies() {
  this._requiresEC = false;
  this._requiresWC = false;
  this._requiresNormalEC = false;
  this._requiresTextureCoordinates = false;
  this._usesNormalEC = false;
  this._usesPositionToEyeEC = false;
  this._usesTangentToEyeMat = false;
  this._usesSt = false;
}
Object.defineProperties(ShaderDependencies.prototype, {
  requiresEC: {
    get: function() {
      return this._requiresEC;
    },
    set: function(value) {
      this._requiresEC = value || this._requiresEC;
    }
  },
  requiresWC: {
    get: function() {
      return this._requiresWC;
    },
    set: function(value) {
      this._requiresWC = value || this._requiresWC;
      this.requiresEC = this._requiresWC;
    }
  },
  requiresNormalEC: {
    get: function() {
      return this._requiresNormalEC;
    },
    set: function(value) {
      this._requiresNormalEC = value || this._requiresNormalEC;
      this.requiresEC = this._requiresNormalEC;
    }
  },
  requiresTextureCoordinates: {
    get: function() {
      return this._requiresTextureCoordinates;
    },
    set: function(value) {
      this._requiresTextureCoordinates = value || this._requiresTextureCoordinates;
      this.requiresWC = this._requiresTextureCoordinates;
    }
  },
  normalEC: {
    set: function(value) {
      this.requiresNormalEC = value;
      this._usesNormalEC = value;
    },
    get: function() {
      return this._usesNormalEC;
    }
  },
  tangentToEyeMatrix: {
    set: function(value) {
      this.requiresWC = value;
      this.requiresNormalEC = value;
      this._usesTangentToEyeMat = value;
    },
    get: function() {
      return this._usesTangentToEyeMat;
    }
  },
  positionToEyeEC: {
    set: function(value) {
      this.requiresEC = value;
      this._usesPositionToEyeEC = value;
    },
    get: function() {
      return this._usesPositionToEyeEC;
    }
  },
  st: {
    set: function(value) {
      this.requiresTextureCoordinates = value;
      this._usesSt = value;
    },
    get: function() {
      return this._usesSt;
    }
  }
});
function pointLineDistance(point1, point2, point) {
  return Math.abs(
    (point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x
  ) / Cartesian2_default.distance(point2, point1);
}
var points2DScratch2 = [
  new Cartesian2_default(),
  new Cartesian2_default(),
  new Cartesian2_default(),
  new Cartesian2_default()
];
function addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints) {
  const points2D = points2DScratch2;
  const minXYCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    0,
    points2D[0]
  );
  const maxYCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    2,
    points2D[1]
  );
  const maxXCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    4,
    points2D[2]
  );
  attributes.uMaxVmax = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y]
  });
  const inverseExtentX = 1 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);
  const inverseExtentY = 1 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);
  attributes.uvMinAndExtents = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY]
  });
}
var cartographicScratch = new Cartographic_default();
var cornerScratch = new Cartesian3_default();
var northWestScratch = new Cartesian3_default();
var southEastScratch = new Cartesian3_default();
var highLowScratch = { high: 0, low: 0 };
function add2DTextureCoordinateAttributes(rectangle, projection, attributes) {
  const carto = cartographicScratch;
  carto.height = 0;
  carto.longitude = rectangle.west;
  carto.latitude = rectangle.south;
  const southWestCorner = projection.project(carto, cornerScratch);
  carto.latitude = rectangle.north;
  const northWest = projection.project(carto, northWestScratch);
  carto.longitude = rectangle.east;
  carto.latitude = rectangle.south;
  const southEast = projection.project(carto, southEastScratch);
  const valuesHigh = [0, 0, 0, 0];
  const valuesLow = [0, 0, 0, 0];
  let encoded = EncodedCartesian3_default.encode(southWestCorner.x, highLowScratch);
  valuesHigh[0] = encoded.high;
  valuesLow[0] = encoded.low;
  encoded = EncodedCartesian3_default.encode(southWestCorner.y, highLowScratch);
  valuesHigh[1] = encoded.high;
  valuesLow[1] = encoded.low;
  encoded = EncodedCartesian3_default.encode(northWest.y, highLowScratch);
  valuesHigh[2] = encoded.high;
  valuesLow[2] = encoded.low;
  encoded = EncodedCartesian3_default.encode(southEast.x, highLowScratch);
  valuesHigh[3] = encoded.high;
  valuesLow[3] = encoded.low;
  attributes.planes2D_HIGH = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: valuesHigh
  });
  attributes.planes2D_LOW = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: valuesLow
  });
}
var enuMatrixScratch = new Matrix4_default();
var inverseEnuScratch = new Matrix4_default();
var rectanglePointCartesianScratch = new Cartesian3_default();
var rectangleCenterScratch2 = new Cartographic_default();
var pointsCartographicScratch = [
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default()
];
function computeRectangleBounds(rectangle, ellipsoid, height, southWestCornerResult, eastVectorResult, northVectorResult) {
  const centerCartographic = Rectangle_default.center(
    rectangle,
    rectangleCenterScratch2
  );
  centerCartographic.height = height;
  const centerCartesian = Cartographic_default.toCartesian(
    centerCartographic,
    ellipsoid,
    rectanglePointCartesianScratch
  );
  const enuMatrix = Transforms_default.eastNorthUpToFixedFrame(
    centerCartesian,
    ellipsoid,
    enuMatrixScratch
  );
  const inverseEnu = Matrix4_default.inverse(enuMatrix, inverseEnuScratch);
  const west = rectangle.west;
  const east = rectangle.east;
  const north = rectangle.north;
  const south = rectangle.south;
  const cartographics = pointsCartographicScratch;
  cartographics[0].latitude = south;
  cartographics[0].longitude = west;
  cartographics[1].latitude = north;
  cartographics[1].longitude = west;
  cartographics[2].latitude = north;
  cartographics[2].longitude = east;
  cartographics[3].latitude = south;
  cartographics[3].longitude = east;
  const longitudeCenter = (west + east) * 0.5;
  const latitudeCenter = (north + south) * 0.5;
  cartographics[4].latitude = south;
  cartographics[4].longitude = longitudeCenter;
  cartographics[5].latitude = north;
  cartographics[5].longitude = longitudeCenter;
  cartographics[6].latitude = latitudeCenter;
  cartographics[6].longitude = west;
  cartographics[7].latitude = latitudeCenter;
  cartographics[7].longitude = east;
  let minX = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < 8; i++) {
    cartographics[i].height = height;
    const pointCartesian = Cartographic_default.toCartesian(
      cartographics[i],
      ellipsoid,
      rectanglePointCartesianScratch
    );
    Matrix4_default.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);
    pointCartesian.z = 0;
    minX = Math.min(minX, pointCartesian.x);
    maxX = Math.max(maxX, pointCartesian.x);
    minY = Math.min(minY, pointCartesian.y);
    maxY = Math.max(maxY, pointCartesian.y);
  }
  const southWestCorner = southWestCornerResult;
  southWestCorner.x = minX;
  southWestCorner.y = minY;
  southWestCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);
  const southEastCorner = eastVectorResult;
  southEastCorner.x = maxX;
  southEastCorner.y = minY;
  southEastCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner);
  Cartesian3_default.subtract(southEastCorner, southWestCorner, eastVectorResult);
  const northWestCorner = northVectorResult;
  northWestCorner.x = minX;
  northWestCorner.y = maxY;
  northWestCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner);
  Cartesian3_default.subtract(northWestCorner, southWestCorner, northVectorResult);
}
var eastwardScratch = new Cartesian3_default();
var northwardScratch = new Cartesian3_default();
var encodeScratch = new EncodedCartesian3_default();
ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection, height) {
  Check_default.typeOf.object("boundingRectangle", boundingRectangle);
  Check_default.defined(
    "textureCoordinateRotationPoints",
    textureCoordinateRotationPoints
  );
  Check_default.typeOf.object("ellipsoid", ellipsoid);
  Check_default.typeOf.object("projection", projection);
  const corner = cornerScratch;
  const eastward = eastwardScratch;
  const northward = northwardScratch;
  computeRectangleBounds(
    boundingRectangle,
    ellipsoid,
    defaultValue_default(height, 0),
    corner,
    eastward,
    northward
  );
  const attributes = {};
  addTextureCoordinateRotationAttributes(
    attributes,
    textureCoordinateRotationPoints
  );
  const encoded = EncodedCartesian3_default.fromCartesian(corner, encodeScratch);
  attributes.southWest_HIGH = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(encoded.high, [0, 0, 0])
  });
  attributes.southWest_LOW = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(encoded.low, [0, 0, 0])
  });
  attributes.eastward = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(eastward, [0, 0, 0])
  });
  attributes.northward = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(northward, [0, 0, 0])
  });
  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);
  return attributes;
};
var spherePointScratch = new Cartesian3_default();
function latLongToSpherical(latitude, longitude, ellipsoid, result) {
  const cartographic = cartographicScratch;
  cartographic.latitude = latitude;
  cartographic.longitude = longitude;
  cartographic.height = 0;
  const spherePoint = Cartographic_default.toCartesian(
    cartographic,
    ellipsoid,
    spherePointScratch
  );
  const magXY = Math.sqrt(
    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y
  );
  const sphereLatitude = Math_default.fastApproximateAtan2(magXY, spherePoint.z);
  const sphereLongitude = Math_default.fastApproximateAtan2(
    spherePoint.x,
    spherePoint.y
  );
  result.x = sphereLatitude;
  result.y = sphereLongitude;
  return result;
}
var sphericalScratch = new Cartesian2_default();
ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection) {
  Check_default.typeOf.object("boundingRectangle", boundingRectangle);
  Check_default.defined(
    "textureCoordinateRotationPoints",
    textureCoordinateRotationPoints
  );
  Check_default.typeOf.object("ellipsoid", ellipsoid);
  Check_default.typeOf.object("projection", projection);
  const southWestExtents = latLongToSpherical(
    boundingRectangle.south,
    boundingRectangle.west,
    ellipsoid,
    sphericalScratch
  );
  let south = southWestExtents.x;
  let west = southWestExtents.y;
  const northEastExtents = latLongToSpherical(
    boundingRectangle.north,
    boundingRectangle.east,
    ellipsoid,
    sphericalScratch
  );
  let north = northEastExtents.x;
  let east = northEastExtents.y;
  let rotationRadians = 0;
  if (west > east) {
    rotationRadians = Math_default.PI - west;
    west = -Math_default.PI;
    east += rotationRadians;
  }
  south -= Math_default.EPSILON5;
  west -= Math_default.EPSILON5;
  north += Math_default.EPSILON5;
  east += Math_default.EPSILON5;
  const longitudeRangeInverse = 1 / (east - west);
  const latitudeRangeInverse = 1 / (north - south);
  const attributes = {
    sphericalExtents: new GeometryInstanceAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 4,
      normalize: false,
      value: [south, west, latitudeRangeInverse, longitudeRangeInverse]
    }),
    longitudeRotation: new GeometryInstanceAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 1,
      normalize: false,
      value: [rotationRadians]
    })
  };
  addTextureCoordinateRotationAttributes(
    attributes,
    textureCoordinateRotationPoints
  );
  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);
  return attributes;
};
ShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function(attributes) {
  return defined_default(attributes.southWest_HIGH) && defined_default(attributes.southWest_LOW) && defined_default(attributes.northward) && defined_default(attributes.eastward) && defined_default(attributes.planes2D_HIGH) && defined_default(attributes.planes2D_LOW) && defined_default(attributes.uMaxVmax) && defined_default(attributes.uvMinAndExtents);
};
ShadowVolumeAppearance.hasAttributesForSphericalExtents = function(attributes) {
  return defined_default(attributes.sphericalExtents) && defined_default(attributes.longitudeRotation) && defined_default(attributes.planes2D_HIGH) && defined_default(attributes.planes2D_LOW) && defined_default(attributes.uMaxVmax) && defined_default(attributes.uvMinAndExtents);
};
function shouldUseSpherical(rectangle) {
  return Math.max(rectangle.width, rectangle.height) > ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS;
}
ShadowVolumeAppearance.shouldUseSphericalCoordinates = function(rectangle) {
  Check_default.typeOf.object("rectangle", rectangle);
  return shouldUseSpherical(rectangle);
};
ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = Math_default.toRadians(1);
var ShadowVolumeAppearance_default = ShadowVolumeAppearance;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/StencilFunction.js
var StencilFunction = {
  NEVER: WebGLConstants_default.NEVER,
  LESS: WebGLConstants_default.LESS,
  EQUAL: WebGLConstants_default.EQUAL,
  LESS_OR_EQUAL: WebGLConstants_default.LEQUAL,
  GREATER: WebGLConstants_default.GREATER,
  NOT_EQUAL: WebGLConstants_default.NOTEQUAL,
  GREATER_OR_EQUAL: WebGLConstants_default.GEQUAL,
  ALWAYS: WebGLConstants_default.ALWAYS
};
var StencilFunction_default = Object.freeze(StencilFunction);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/StencilOperation.js
var StencilOperation = {
  ZERO: WebGLConstants_default.ZERO,
  KEEP: WebGLConstants_default.KEEP,
  REPLACE: WebGLConstants_default.REPLACE,
  INCREMENT: WebGLConstants_default.INCR,
  DECREMENT: WebGLConstants_default.DECR,
  INVERT: WebGLConstants_default.INVERT,
  INCREMENT_WRAP: WebGLConstants_default.INCR_WRAP,
  DECREMENT_WRAP: WebGLConstants_default.DECR_WRAP
};
var StencilOperation_default = Object.freeze(StencilOperation);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/StencilConstants.js
var StencilConstants = {
  CESIUM_3D_TILE_MASK: 128,
  SKIP_LOD_MASK: 112,
  SKIP_LOD_BIT_SHIFT: 4,
  CLASSIFICATION_MASK: 15
};
StencilConstants.setCesium3DTileBit = function() {
  return {
    enabled: true,
    frontFunction: StencilFunction_default.ALWAYS,
    frontOperation: {
      fail: StencilOperation_default.KEEP,
      zFail: StencilOperation_default.KEEP,
      zPass: StencilOperation_default.REPLACE
    },
    backFunction: StencilFunction_default.ALWAYS,
    backOperation: {
      fail: StencilOperation_default.KEEP,
      zFail: StencilOperation_default.KEEP,
      zPass: StencilOperation_default.REPLACE
    },
    reference: StencilConstants.CESIUM_3D_TILE_MASK,
    mask: StencilConstants.CESIUM_3D_TILE_MASK
  };
};
var StencilConstants_default = Object.freeze(StencilConstants);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/ClassificationPrimitive.js
function ClassificationPrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const geometryInstances = options.geometryInstances;
  this.geometryInstances = geometryInstances;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._debugShowShadowVolume = false;
  this._extruded = defaultValue_default(options._extruded, false);
  this._uniformMap = options._uniformMap;
  this._sp = void 0;
  this._spStencil = void 0;
  this._spPick = void 0;
  this._spColor = void 0;
  this._spPick2D = void 0;
  this._spColor2D = void 0;
  this._rsStencilDepthPass = void 0;
  this._rsStencilDepthPass3DTiles = void 0;
  this._rsColorPass = void 0;
  this._rsPickPass = void 0;
  this._commandsIgnoreShow = [];
  this._ready = false;
  const classificationPrimitive = this;
  this._readyPromise = new Promise((resolve, reject) => {
    classificationPrimitive._completeLoad = () => {
      if (this._ready) {
        return;
      }
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
      const error = this._error;
      if (!defined_default(error)) {
        resolve(this);
      } else {
        reject(error);
      }
    };
  });
  this._primitive = void 0;
  this._pickPrimitive = options._pickPrimitive;
  this._hasSphericalExtentsAttribute = false;
  this._hasPlanarExtentsAttributes = false;
  this._hasPerColorAttribute = false;
  this.appearance = options.appearance;
  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;
  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;
  this._usePickOffsets = false;
  this._primitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: defaultValue_default(options.vertexCacheOptimize, false),
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: defaultValue_default(options.compressVertices, true),
    _createBoundingVolumeFunction: void 0,
    _createRenderStatesFunction: void 0,
    _createShaderProgramFunction: void 0,
    _createCommandsFunction: void 0,
    _updateAndQueueCommandsFunction: void 0,
    _createPickOffsets: true
  };
}
Object.defineProperties(ClassificationPrimitive.prototype, {
  vertexCacheOptimize: {
    get: function() {
      return this._primitiveOptions.vertexCacheOptimize;
    }
  },
  interleave: {
    get: function() {
      return this._primitiveOptions.interleave;
    }
  },
  releaseGeometryInstances: {
    get: function() {
      return this._primitiveOptions.releaseGeometryInstances;
    }
  },
  allowPicking: {
    get: function() {
      return this._primitiveOptions.allowPicking;
    }
  },
  asynchronous: {
    get: function() {
      return this._primitiveOptions.asynchronous;
    }
  },
  compressVertices: {
    get: function() {
      return this._primitiveOptions.compressVertices;
    }
  },
  ready: {
    get: function() {
      return this._ready;
    }
  },
  readyPromise: {
    get: function() {
      return this._readyPromise;
    }
  },
  _needs2DShader: {
    get: function() {
      return this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute;
    }
  }
});
ClassificationPrimitive.isSupported = function(scene) {
  return scene.context.stencilBuffer;
};
function getStencilDepthRenderState(enableStencil, mask3DTiles) {
  const stencilFunction = mask3DTiles ? StencilFunction_default.EQUAL : StencilFunction_default.ALWAYS;
  return {
    colorMask: {
      red: false,
      green: false,
      blue: false,
      alpha: false
    },
    stencilTest: {
      enabled: enableStencil,
      frontFunction: stencilFunction,
      frontOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.DECREMENT_WRAP,
        zPass: StencilOperation_default.KEEP
      },
      backFunction: stencilFunction,
      backOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.INCREMENT_WRAP,
        zPass: StencilOperation_default.KEEP
      },
      reference: StencilConstants_default.CESIUM_3D_TILE_MASK,
      mask: StencilConstants_default.CESIUM_3D_TILE_MASK
    },
    stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
    depthTest: {
      enabled: true,
      func: DepthFunction_default.LESS_OR_EQUAL
    },
    depthMask: false
  };
}
function getColorRenderState(enableStencil) {
  return {
    stencilTest: {
      enabled: enableStencil,
      frontFunction: StencilFunction_default.NOT_EQUAL,
      frontOperation: {
        fail: StencilOperation_default.ZERO,
        zFail: StencilOperation_default.ZERO,
        zPass: StencilOperation_default.ZERO
      },
      backFunction: StencilFunction_default.NOT_EQUAL,
      backOperation: {
        fail: StencilOperation_default.ZERO,
        zFail: StencilOperation_default.ZERO,
        zPass: StencilOperation_default.ZERO
      },
      reference: 0,
      mask: StencilConstants_default.CLASSIFICATION_MASK
    },
    stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
    depthTest: {
      enabled: false
    },
    depthMask: false,
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND
  };
}
var pickRenderState = {
  stencilTest: {
    enabled: true,
    frontFunction: StencilFunction_default.NOT_EQUAL,
    frontOperation: {
      fail: StencilOperation_default.ZERO,
      zFail: StencilOperation_default.ZERO,
      zPass: StencilOperation_default.ZERO
    },
    backFunction: StencilFunction_default.NOT_EQUAL,
    backOperation: {
      fail: StencilOperation_default.ZERO,
      zFail: StencilOperation_default.ZERO,
      zPass: StencilOperation_default.ZERO
    },
    reference: 0,
    mask: StencilConstants_default.CLASSIFICATION_MASK
  },
  stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
  depthTest: {
    enabled: false
  },
  depthMask: false
};
function createRenderStates2(classificationPrimitive, context, appearance, twoPasses) {
  if (defined_default(classificationPrimitive._rsStencilDepthPass)) {
    return;
  }
  const stencilEnabled = !classificationPrimitive.debugShowShadowVolume;
  classificationPrimitive._rsStencilDepthPass = RenderState_default.fromCache(
    getStencilDepthRenderState(stencilEnabled, false)
  );
  classificationPrimitive._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
    getStencilDepthRenderState(stencilEnabled, true)
  );
  classificationPrimitive._rsColorPass = RenderState_default.fromCache(
    getColorRenderState(stencilEnabled, false)
  );
  classificationPrimitive._rsPickPass = RenderState_default.fromCache(pickRenderState);
}
function modifyForEncodedNormals2(primitive, vertexShaderSource) {
  if (!primitive.compressVertices) {
    return vertexShaderSource;
  }
  if (vertexShaderSource.search(/attribute\s+vec3\s+extrudeDirection;/g) !== -1) {
    const attributeName = "compressedAttributes";
    const attributeDecl = `attribute vec2 ${attributeName};`;
    const globalDecl = "vec3 extrudeDirection;\n";
    const decode = `    extrudeDirection = czm_octDecode(${attributeName}, 65535.0);
`;
    let modifiedVS = vertexShaderSource;
    modifiedVS = modifiedVS.replace(
      /attribute\s+vec3\s+extrudeDirection;/g,
      ""
    );
    modifiedVS = ShaderSource_default.replaceMain(
      modifiedVS,
      "czm_non_compressed_main"
    );
    const compressedMain = `${"void main() \n{ \n"}${decode}    czm_non_compressed_main(); 
}`;
    return [attributeDecl, globalDecl, modifiedVS, compressedMain].join("\n");
  }
}
function createShaderProgram2(classificationPrimitive, frameState) {
  const context = frameState.context;
  const primitive = classificationPrimitive._primitive;
  let vs = ShadowVolumeAppearanceVS_default;
  vs = classificationPrimitive._primitive._batchTable.getVertexShaderCallback()(
    vs
  );
  vs = Primitive_default._appendDistanceDisplayConditionToShader(primitive, vs);
  vs = Primitive_default._modifyShaderPosition(
    classificationPrimitive,
    vs,
    frameState.scene3DOnly
  );
  vs = Primitive_default._updateColorAttribute(primitive, vs);
  const planarExtents = classificationPrimitive._hasPlanarExtentsAttributes;
  const cullFragmentsUsingExtents = planarExtents || classificationPrimitive._hasSphericalExtentsAttribute;
  if (classificationPrimitive._extruded) {
    vs = modifyForEncodedNormals2(primitive, vs);
  }
  const extrudedDefine = classificationPrimitive._extruded ? "EXTRUDED_GEOMETRY" : "";
  let vsSource = new ShaderSource_default({
    defines: [extrudedDefine],
    sources: [vs]
  });
  const fsSource = new ShaderSource_default({
    sources: [ShadowVolumeFS_default]
  });
  const attributeLocations = classificationPrimitive._primitive._attributeLocations;
  const shadowVolumeAppearance = new ShadowVolumeAppearance_default(
    cullFragmentsUsingExtents,
    planarExtents,
    classificationPrimitive.appearance
  );
  classificationPrimitive._spStencil = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._spStencil,
    vertexShaderSource: vsSource,
    fragmentShaderSource: fsSource,
    attributeLocations
  });
  if (classificationPrimitive._primitive.allowPicking) {
    let vsPick = ShaderSource_default.createPickVertexShaderSource(vs);
    vsPick = Primitive_default._appendShowToShader(primitive, vsPick);
    vsPick = Primitive_default._updatePickColorAttribute(vsPick);
    const pickFS3D = shadowVolumeAppearance.createPickFragmentShader(false);
    const pickVS3D = shadowVolumeAppearance.createPickVertexShader(
      [extrudedDefine],
      vsPick,
      false,
      frameState.mapProjection
    );
    classificationPrimitive._spPick = ShaderProgram_default.replaceCache({
      context,
      shaderProgram: classificationPrimitive._spPick,
      vertexShaderSource: pickVS3D,
      fragmentShaderSource: pickFS3D,
      attributeLocations
    });
    if (cullFragmentsUsingExtents) {
      let pickProgram2D = context.shaderCache.getDerivedShaderProgram(
        classificationPrimitive._spPick,
        "2dPick"
      );
      if (!defined_default(pickProgram2D)) {
        const pickFS2D = shadowVolumeAppearance.createPickFragmentShader(true);
        const pickVS2D = shadowVolumeAppearance.createPickVertexShader(
          [extrudedDefine],
          vsPick,
          true,
          frameState.mapProjection
        );
        pickProgram2D = context.shaderCache.createDerivedShaderProgram(
          classificationPrimitive._spPick,
          "2dPick",
          {
            vertexShaderSource: pickVS2D,
            fragmentShaderSource: pickFS2D,
            attributeLocations
          }
        );
      }
      classificationPrimitive._spPick2D = pickProgram2D;
    }
  } else {
    classificationPrimitive._spPick = ShaderProgram_default.fromCache({
      context,
      vertexShaderSource: vsSource,
      fragmentShaderSource: fsSource,
      attributeLocations
    });
  }
  vs = Primitive_default._appendShowToShader(primitive, vs);
  vsSource = new ShaderSource_default({
    defines: [extrudedDefine],
    sources: [vs]
  });
  classificationPrimitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._sp,
    vertexShaderSource: vsSource,
    fragmentShaderSource: fsSource,
    attributeLocations
  });
  const fsColorSource = shadowVolumeAppearance.createFragmentShader(false);
  const vsColorSource = shadowVolumeAppearance.createVertexShader(
    [extrudedDefine],
    vs,
    false,
    frameState.mapProjection
  );
  classificationPrimitive._spColor = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._spColor,
    vertexShaderSource: vsColorSource,
    fragmentShaderSource: fsColorSource,
    attributeLocations
  });
  if (cullFragmentsUsingExtents) {
    let colorProgram2D = context.shaderCache.getDerivedShaderProgram(
      classificationPrimitive._spColor,
      "2dColor"
    );
    if (!defined_default(colorProgram2D)) {
      const fsColorSource2D = shadowVolumeAppearance.createFragmentShader(true);
      const vsColorSource2D = shadowVolumeAppearance.createVertexShader(
        [extrudedDefine],
        vs,
        true,
        frameState.mapProjection
      );
      colorProgram2D = context.shaderCache.createDerivedShaderProgram(
        classificationPrimitive._spColor,
        "2dColor",
        {
          vertexShaderSource: vsColorSource2D,
          fragmentShaderSource: fsColorSource2D,
          attributeLocations
        }
      );
    }
    classificationPrimitive._spColor2D = colorProgram2D;
  }
}
function createColorCommands(classificationPrimitive, colorCommands) {
  const primitive = classificationPrimitive._primitive;
  let length = primitive._va.length * 2;
  colorCommands.length = length;
  let i;
  let command;
  let derivedCommand;
  let vaIndex = 0;
  let uniformMap = primitive._batchTable.getUniformMapCallback()(
    classificationPrimitive._uniformMap
  );
  const needs2DShader = classificationPrimitive._needs2DShader;
  for (i = 0; i < length; i += 2) {
    const vertexArray = primitive._va[vaIndex++];
    command = colorCommands[i];
    if (!defined_default(command)) {
      command = colorCommands[i] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsStencilDepthPass;
    command.shaderProgram = classificationPrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    command = colorCommands[i + 1];
    if (!defined_default(command)) {
      command = colorCommands[i + 1] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsColorPass;
    command.shaderProgram = classificationPrimitive._spColor;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    const appearance = classificationPrimitive.appearance;
    const material = appearance.material;
    if (defined_default(material)) {
      uniformMap = combine_default(uniformMap, material._uniforms);
    }
    command.uniformMap = uniformMap;
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    if (needs2DShader) {
      let derived2DCommand = DrawCommand_default.shallowClone(
        command,
        command.derivedCommands.appearance2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;
      command.derivedCommands.appearance2D = derived2DCommand;
      derived2DCommand = DrawCommand_default.shallowClone(
        derivedCommand,
        derivedCommand.derivedCommands.appearance2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;
      derivedCommand.derivedCommands.appearance2D = derived2DCommand;
    }
  }
  const commandsIgnoreShow = classificationPrimitive._commandsIgnoreShow;
  const spStencil = classificationPrimitive._spStencil;
  let commandIndex = 0;
  length = commandsIgnoreShow.length = length / 2;
  for (let j = 0; j < length; ++j) {
    const commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand_default.shallowClone(
      colorCommands[commandIndex],
      commandsIgnoreShow[j]
    );
    commandIgnoreShow.shaderProgram = spStencil;
    commandIgnoreShow.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;
    commandIndex += 2;
  }
}
function createPickCommands(classificationPrimitive, pickCommands) {
  const usePickOffsets = classificationPrimitive._usePickOffsets;
  const primitive = classificationPrimitive._primitive;
  let length = primitive._va.length * 2;
  let pickOffsets;
  let pickIndex = 0;
  let pickOffset;
  if (usePickOffsets) {
    pickOffsets = primitive._pickOffsets;
    length = pickOffsets.length * 2;
  }
  pickCommands.length = length;
  let j;
  let command;
  let derivedCommand;
  let vaIndex = 0;
  const uniformMap = primitive._batchTable.getUniformMapCallback()(
    classificationPrimitive._uniformMap
  );
  const needs2DShader = classificationPrimitive._needs2DShader;
  for (j = 0; j < length; j += 2) {
    let vertexArray = primitive._va[vaIndex++];
    if (usePickOffsets) {
      pickOffset = pickOffsets[pickIndex++];
      vertexArray = primitive._va[pickOffset.index];
    }
    command = pickCommands[j];
    if (!defined_default(command)) {
      command = pickCommands[j] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType,
        pickOnly: true
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsStencilDepthPass;
    command.shaderProgram = classificationPrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    if (usePickOffsets) {
      command.offset = pickOffset.offset;
      command.count = pickOffset.count;
    }
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    command = pickCommands[j + 1];
    if (!defined_default(command)) {
      command = pickCommands[j + 1] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType,
        pickOnly: true
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsPickPass;
    command.shaderProgram = classificationPrimitive._spPick;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    if (usePickOffsets) {
      command.offset = pickOffset.offset;
      command.count = pickOffset.count;
    }
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    if (needs2DShader) {
      let derived2DCommand = DrawCommand_default.shallowClone(
        command,
        command.derivedCommands.pick2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;
      command.derivedCommands.pick2D = derived2DCommand;
      derived2DCommand = DrawCommand_default.shallowClone(
        derivedCommand,
        derivedCommand.derivedCommands.pick2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;
      derivedCommand.derivedCommands.pick2D = derived2DCommand;
    }
  }
}
function createCommands2(classificationPrimitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {
  createColorCommands(classificationPrimitive, colorCommands);
  createPickCommands(classificationPrimitive, pickCommands);
}
function boundingVolumeIndex(commandIndex, length) {
  return Math.floor(commandIndex % length / 2);
}
function updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume) {
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  frameState.commandList.push(command);
}
function updateAndQueueCommands2(classificationPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  const primitive = classificationPrimitive._primitive;
  Primitive_default._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingVolumes;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolumes = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingVolumes = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingVolumes = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingVolumes = primitive._boundingSphereMorph;
  }
  const classificationType = classificationPrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN;
  const passes = frameState.passes;
  let i;
  let boundingVolume;
  let command;
  if (passes.render) {
    const colorLength = colorCommands.length;
    for (i = 0; i < colorLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];
      if (queueTerrainCommands) {
        command = colorCommands[i];
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[i].derivedCommands.tileset;
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
    if (frameState.invertClassification) {
      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;
      const ignoreShowCommandsLength = ignoreShowCommands.length;
      for (i = 0; i < ignoreShowCommandsLength; ++i) {
        boundingVolume = boundingVolumes[i];
        command = ignoreShowCommands[i];
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
  if (passes.pick) {
    const pickLength = pickCommands.length;
    const pickOffsets = primitive._pickOffsets;
    for (i = 0; i < pickLength; ++i) {
      const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];
      boundingVolume = boundingVolumes[pickOffset.index];
      if (queueTerrainCommands) {
        command = pickCommands[i];
        updateAndQueuePickCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = pickCommands[i].derivedCommands.tileset;
        updateAndQueuePickCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
    }
  }
}
ClassificationPrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  let appearance = this.appearance;
  if (defined_default(appearance) && defined_default(appearance.material)) {
    appearance.material.update(frameState.context);
  }
  const that = this;
  const primitiveOptions = this._primitiveOptions;
  if (!defined_default(this._primitive)) {
    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const length = instances.length;
    let i;
    let instance;
    let attributes;
    let hasPerColorAttribute = false;
    let allColorsSame = true;
    let firstColor;
    let hasSphericalExtentsAttribute = false;
    let hasPlanarExtentsAttributes = false;
    if (length > 0) {
      attributes = instances[0].attributes;
      hasSphericalExtentsAttribute = ShadowVolumeAppearance_default.hasAttributesForSphericalExtents(
        attributes
      );
      hasPlanarExtentsAttributes = ShadowVolumeAppearance_default.hasAttributesForTextureCoordinatePlanes(
        attributes
      );
      firstColor = attributes.color;
    }
    for (i = 0; i < length; i++) {
      instance = instances[i];
      const color = instance.attributes.color;
      if (defined_default(color)) {
        hasPerColorAttribute = true;
      } else if (hasPerColorAttribute) {
        throw new DeveloperError_default(
          "All GeometryInstances must have color attributes to use per-instance color."
        );
      }
      allColorsSame = allColorsSame && defined_default(color) && ColorGeometryInstanceAttribute_default.equals(firstColor, color);
    }
    if (!allColorsSame && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {
      throw new DeveloperError_default(
        "All GeometryInstances must have the same color attribute except via GroundPrimitives"
      );
    }
    if (hasPerColorAttribute && !defined_default(appearance)) {
      appearance = new PerInstanceColorAppearance_default({
        flat: true
      });
      this.appearance = appearance;
    }
    if (!hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance_default) {
      throw new DeveloperError_default(
        "PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances"
      );
    }
    if (defined_default(appearance.material) && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {
      throw new DeveloperError_default(
        "Materials on ClassificationPrimitives are not supported except via GroundPrimitives"
      );
    }
    this._usePickOffsets = !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes;
    this._hasSphericalExtentsAttribute = hasSphericalExtentsAttribute;
    this._hasPlanarExtentsAttributes = hasPlanarExtentsAttributes;
    this._hasPerColorAttribute = hasPerColorAttribute;
    const geometryInstances = new Array(length);
    for (i = 0; i < length; ++i) {
      instance = instances[i];
      geometryInstances[i] = new GeometryInstance_default({
        geometry: instance.geometry,
        attributes: instance.attributes,
        modelMatrix: instance.modelMatrix,
        id: instance.id,
        pickPrimitive: defaultValue_default(this._pickPrimitive, that)
      });
    }
    primitiveOptions.appearance = appearance;
    primitiveOptions.geometryInstances = geometryInstances;
    if (defined_default(this._createBoundingVolumeFunction)) {
      primitiveOptions._createBoundingVolumeFunction = function(frameState2, geometry) {
        that._createBoundingVolumeFunction(frameState2, geometry);
      };
    }
    primitiveOptions._createRenderStatesFunction = function(primitive, context, appearance2, twoPasses) {
      createRenderStates2(that, context);
    };
    primitiveOptions._createShaderProgramFunction = function(primitive, frameState2, appearance2) {
      createShaderProgram2(that, frameState2);
    };
    primitiveOptions._createCommandsFunction = function(primitive, appearance2, material, translucent, twoPasses, colorCommands, pickCommands) {
      createCommands2(
        that,
        void 0,
        void 0,
        true,
        false,
        colorCommands,
        pickCommands
      );
    };
    if (defined_default(this._updateAndQueueCommandsFunction)) {
      primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
        that._updateAndQueueCommandsFunction(
          primitive,
          frameState2,
          colorCommands,
          pickCommands,
          modelMatrix,
          cull,
          debugShowBoundingVolume,
          twoPasses
        );
      };
    } else {
      primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
        updateAndQueueCommands2(
          that,
          frameState2,
          colorCommands,
          pickCommands,
          modelMatrix,
          cull,
          debugShowBoundingVolume,
          twoPasses
        );
      };
    }
    this._primitive = new Primitive_default(primitiveOptions);
  }
  if (this.debugShowShadowVolume && !this._debugShowShadowVolume && this._ready) {
    this._debugShowShadowVolume = true;
    this._rsStencilDepthPass = RenderState_default.fromCache(
      getStencilDepthRenderState(false, false)
    );
    this._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
      getStencilDepthRenderState(false, true)
    );
    this._rsColorPass = RenderState_default.fromCache(getColorRenderState(false));
  } else if (!this.debugShowShadowVolume && this._debugShowShadowVolume) {
    this._debugShowShadowVolume = false;
    this._rsStencilDepthPass = RenderState_default.fromCache(
      getStencilDepthRenderState(true, false)
    );
    this._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
      getStencilDepthRenderState(true, true)
    );
    this._rsColorPass = RenderState_default.fromCache(getColorRenderState(true));
  }
  if (this._primitive.appearance !== appearance) {
    if (!this._hasSphericalExtentsAttribute && !this._hasPlanarExtentsAttributes && defined_default(appearance.material)) {
      throw new DeveloperError_default(
        "Materials on ClassificationPrimitives are not supported except via GroundPrimitive"
      );
    }
    if (!this._hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance_default) {
      throw new DeveloperError_default(
        "PerInstanceColorAppearance requires color GeometryInstanceAttribute"
      );
    }
    this._primitive.appearance = appearance;
  }
  this._primitive.show = this.show;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (defined_default(this._primitive) && this._primitive.ready) {
      this._completeLoad();
    }
  });
};
ClassificationPrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
ClassificationPrimitive.prototype.isDestroyed = function() {
  return false;
};
ClassificationPrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._spPick = this._spPick && this._spPick.destroy();
  this._spColor = this._spColor && this._spColor.destroy();
  this._spPick2D = void 0;
  this._spColor2D = void 0;
  return destroyObject_default(this);
};
var ClassificationPrimitive_default = ClassificationPrimitive;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/GroundPrimitive.js
var GroundPrimitiveUniformMap = {
  u_globeMinimumAltitude: function() {
    return 55e3;
  }
};
function GroundPrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  let appearance = options.appearance;
  const geometryInstances = options.geometryInstances;
  if (!defined_default(appearance) && defined_default(geometryInstances)) {
    const geometryInstancesArray = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];
    const geometryInstanceCount = geometryInstancesArray.length;
    for (let i = 0; i < geometryInstanceCount; i++) {
      const attributes = geometryInstancesArray[i].attributes;
      if (defined_default(attributes) && defined_default(attributes.color)) {
        appearance = new PerInstanceColorAppearance_default({
          flat: true
        });
        break;
      }
    }
  }
  this.appearance = appearance;
  this.geometryInstances = options.geometryInstances;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._boundingVolumes = [];
  this._boundingVolumes2D = [];
  this._ready = false;
  const groundPrimitive = this;
  this._readyPromise = new Promise((resolve, reject) => {
    groundPrimitive._completeLoad = () => {
      if (this._ready) {
        return;
      }
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
      const error = this._error;
      if (!defined_default(error)) {
        resolve(this);
      } else {
        reject(error);
      }
    };
  });
  this._primitive = void 0;
  this._maxHeight = void 0;
  this._minHeight = void 0;
  this._maxTerrainHeight = ApproximateTerrainHeights_default._defaultMaxTerrainHeight;
  this._minTerrainHeight = ApproximateTerrainHeights_default._defaultMinTerrainHeight;
  this._boundingSpheresKeys = [];
  this._boundingSpheres = [];
  this._useFragmentCulling = false;
  this._zIndex = void 0;
  const that = this;
  this._classificationPrimitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: defaultValue_default(options.vertexCacheOptimize, false),
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: defaultValue_default(options.compressVertices, true),
    _createBoundingVolumeFunction: void 0,
    _updateAndQueueCommandsFunction: void 0,
    _pickPrimitive: that,
    _extruded: true,
    _uniformMap: GroundPrimitiveUniformMap
  };
}
Object.defineProperties(GroundPrimitive.prototype, {
  vertexCacheOptimize: {
    get: function() {
      return this._classificationPrimitiveOptions.vertexCacheOptimize;
    }
  },
  interleave: {
    get: function() {
      return this._classificationPrimitiveOptions.interleave;
    }
  },
  releaseGeometryInstances: {
    get: function() {
      return this._classificationPrimitiveOptions.releaseGeometryInstances;
    }
  },
  allowPicking: {
    get: function() {
      return this._classificationPrimitiveOptions.allowPicking;
    }
  },
  asynchronous: {
    get: function() {
      return this._classificationPrimitiveOptions.asynchronous;
    }
  },
  compressVertices: {
    get: function() {
      return this._classificationPrimitiveOptions.compressVertices;
    }
  },
  ready: {
    get: function() {
      return this._ready;
    }
  },
  readyPromise: {
    get: function() {
      return this._readyPromise;
    }
  }
});
GroundPrimitive.isSupported = ClassificationPrimitive_default.isSupported;
function getComputeMaximumHeightFunction(primitive) {
  return function(granularity, ellipsoid) {
    const r = ellipsoid.maximumRadius;
    const delta = r / Math.cos(granularity * 0.5) - r;
    return primitive._maxHeight + delta;
  };
}
function getComputeMinimumHeightFunction(primitive) {
  return function(granularity, ellipsoid) {
    return primitive._minHeight;
  };
}
var scratchBVCartesianHigh = new Cartesian3_default();
var scratchBVCartesianLow = new Cartesian3_default();
var scratchBVCartesian = new Cartesian3_default();
var scratchBVCartographic = new Cartographic_default();
var scratchBVRectangle = new Rectangle_default();
function getRectangle(frameState, geometry) {
  const ellipsoid = frameState.mapProjection.ellipsoid;
  if (!defined_default(geometry.attributes) || !defined_default(geometry.attributes.position3DHigh)) {
    if (defined_default(geometry.rectangle)) {
      return geometry.rectangle;
    }
    return void 0;
  }
  const highPositions = geometry.attributes.position3DHigh.values;
  const lowPositions = geometry.attributes.position3DLow.values;
  const length = highPositions.length;
  let minLat = Number.POSITIVE_INFINITY;
  let minLon = Number.POSITIVE_INFINITY;
  let maxLat = Number.NEGATIVE_INFINITY;
  let maxLon = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < length; i += 3) {
    const highPosition = Cartesian3_default.unpack(
      highPositions,
      i,
      scratchBVCartesianHigh
    );
    const lowPosition = Cartesian3_default.unpack(
      lowPositions,
      i,
      scratchBVCartesianLow
    );
    const position = Cartesian3_default.add(
      highPosition,
      lowPosition,
      scratchBVCartesian
    );
    const cartographic = ellipsoid.cartesianToCartographic(
      position,
      scratchBVCartographic
    );
    const latitude = cartographic.latitude;
    const longitude = cartographic.longitude;
    minLat = Math.min(minLat, latitude);
    minLon = Math.min(minLon, longitude);
    maxLat = Math.max(maxLat, latitude);
    maxLon = Math.max(maxLon, longitude);
  }
  const rectangle = scratchBVRectangle;
  rectangle.north = maxLat;
  rectangle.south = minLat;
  rectangle.east = maxLon;
  rectangle.west = minLon;
  return rectangle;
}
function setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {
  const result = ApproximateTerrainHeights_default.getMinimumMaximumHeights(
    rectangle,
    ellipsoid
  );
  primitive._minTerrainHeight = result.minimumTerrainHeight;
  primitive._maxTerrainHeight = result.maximumTerrainHeight;
}
function createBoundingVolume(groundPrimitive, frameState, geometry) {
  const ellipsoid = frameState.mapProjection.ellipsoid;
  const rectangle = getRectangle(frameState, geometry);
  const obb = OrientedBoundingBox_default.fromRectangle(
    rectangle,
    groundPrimitive._minHeight,
    groundPrimitive._maxHeight,
    ellipsoid
  );
  groundPrimitive._boundingVolumes.push(obb);
  if (!frameState.scene3DOnly) {
    const projection = frameState.mapProjection;
    const boundingVolume = BoundingSphere_default.fromRectangleWithHeights2D(
      rectangle,
      projection,
      groundPrimitive._maxHeight,
      groundPrimitive._minHeight
    );
    Cartesian3_default.fromElements(
      boundingVolume.center.z,
      boundingVolume.center.x,
      boundingVolume.center.y,
      boundingVolume.center
    );
    groundPrimitive._boundingVolumes2D.push(boundingVolume);
  }
}
function boundingVolumeIndex2(commandIndex, length) {
  return Math.floor(commandIndex % length / 2);
}
function updateAndQueueRenderCommand2(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  const classificationPrimitive = groundPrimitive._primitive;
  if (frameState.mode !== SceneMode_default.SCENE3D && command.shaderProgram === classificationPrimitive._spColor && classificationPrimitive._needs2DShader) {
    command = command.derivedCommands.appearance2D;
  }
  command.owner = groundPrimitive;
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueuePickCommand2(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume) {
  const classificationPrimitive = groundPrimitive._primitive;
  if (frameState.mode !== SceneMode_default.SCENE3D && command.shaderProgram === classificationPrimitive._spPick && classificationPrimitive._needs2DShader) {
    command = command.derivedCommands.pick2D;
  }
  command.owner = groundPrimitive;
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  frameState.commandList.push(command);
}
function updateAndQueueCommands3(groundPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  let boundingVolumes;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolumes = groundPrimitive._boundingVolumes;
  } else {
    boundingVolumes = groundPrimitive._boundingVolumes2D;
  }
  const classificationType = groundPrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN;
  const passes = frameState.passes;
  const classificationPrimitive = groundPrimitive._primitive;
  let i;
  let boundingVolume;
  let command;
  if (passes.render) {
    const colorLength = colorCommands.length;
    for (i = 0; i < colorLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex2(i, colorLength)];
      if (queueTerrainCommands) {
        command = colorCommands[i];
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[i].derivedCommands.tileset;
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
    if (frameState.invertClassification) {
      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;
      const ignoreShowCommandsLength = ignoreShowCommands.length;
      for (i = 0; i < ignoreShowCommandsLength; ++i) {
        boundingVolume = boundingVolumes[i];
        command = ignoreShowCommands[i];
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
  if (passes.pick) {
    const pickLength = pickCommands.length;
    let pickOffsets;
    if (!groundPrimitive._useFragmentCulling) {
      pickOffsets = classificationPrimitive._primitive._pickOffsets;
    }
    for (i = 0; i < pickLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex2(i, pickLength)];
      if (!groundPrimitive._useFragmentCulling) {
        const pickOffset = pickOffsets[boundingVolumeIndex2(i, pickLength)];
        boundingVolume = boundingVolumes[pickOffset.index];
      }
      if (queueTerrainCommands) {
        command = pickCommands[i];
        updateAndQueuePickCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = pickCommands[i].derivedCommands.tileset;
        updateAndQueuePickCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
    }
  }
}
GroundPrimitive.initializeTerrainHeights = function() {
  return ApproximateTerrainHeights_default.initialize();
};
GroundPrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  if (!ApproximateTerrainHeights_default.initialized) {
    if (!this.asynchronous) {
      throw new DeveloperError_default(
        "For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve."
      );
    }
    GroundPrimitive.initializeTerrainHeights();
    return;
  }
  const that = this;
  const primitiveOptions = this._classificationPrimitiveOptions;
  if (!defined_default(this._primitive)) {
    const ellipsoid = frameState.mapProjection.ellipsoid;
    let instance;
    let geometry;
    let instanceType;
    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const length = instances.length;
    const groundInstances = new Array(length);
    let i;
    let rectangle;
    for (i = 0; i < length; ++i) {
      instance = instances[i];
      geometry = instance.geometry;
      const instanceRectangle = getRectangle(frameState, geometry);
      if (!defined_default(rectangle)) {
        rectangle = Rectangle_default.clone(instanceRectangle);
      } else if (defined_default(instanceRectangle)) {
        Rectangle_default.union(rectangle, instanceRectangle, rectangle);
      }
      const id = instance.id;
      if (defined_default(id) && defined_default(instanceRectangle)) {
        const boundingSphere = ApproximateTerrainHeights_default.getBoundingSphere(
          instanceRectangle,
          ellipsoid
        );
        this._boundingSpheresKeys.push(id);
        this._boundingSpheres.push(boundingSphere);
      }
      instanceType = geometry.constructor;
      if (!defined_default(instanceType) || !defined_default(instanceType.createShadowVolume)) {
        throw new DeveloperError_default(
          "Not all of the geometry instances have GroundPrimitive support."
        );
      }
    }
    setMinMaxTerrainHeights(this, rectangle, ellipsoid);
    const exaggeration = frameState.terrainExaggeration;
    const exaggerationRelativeHeight = frameState.terrainExaggerationRelativeHeight;
    this._minHeight = TerrainExaggeration_default.getHeight(
      this._minTerrainHeight,
      exaggeration,
      exaggerationRelativeHeight
    );
    this._maxHeight = TerrainExaggeration_default.getHeight(
      this._maxTerrainHeight,
      exaggeration,
      exaggerationRelativeHeight
    );
    const useFragmentCulling = GroundPrimitive._supportsMaterials(
      frameState.context
    );
    this._useFragmentCulling = useFragmentCulling;
    if (useFragmentCulling) {
      let attributes;
      let usePlanarExtents = true;
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        rectangle = getRectangle(frameState, geometry);
        if (ShadowVolumeAppearance_default.shouldUseSphericalCoordinates(rectangle)) {
          usePlanarExtents = false;
          break;
        }
      }
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        instanceType = geometry.constructor;
        const boundingRectangle = getRectangle(frameState, geometry);
        const textureCoordinateRotationPoints = geometry.textureCoordinateRotationPoints;
        if (usePlanarExtents) {
          attributes = ShadowVolumeAppearance_default.getPlanarTextureCoordinateAttributes(
            boundingRectangle,
            textureCoordinateRotationPoints,
            ellipsoid,
            frameState.mapProjection,
            this._maxHeight
          );
        } else {
          attributes = ShadowVolumeAppearance_default.getSphericalExtentGeometryInstanceAttributes(
            boundingRectangle,
            textureCoordinateRotationPoints,
            ellipsoid,
            frameState.mapProjection
          );
        }
        const instanceAttributes = instance.attributes;
        for (const attributeKey in instanceAttributes) {
          if (instanceAttributes.hasOwnProperty(attributeKey)) {
            attributes[attributeKey] = instanceAttributes[attributeKey];
          }
        }
        groundInstances[i] = new GeometryInstance_default({
          geometry: instanceType.createShadowVolume(
            geometry,
            getComputeMinimumHeightFunction(this),
            getComputeMaximumHeightFunction(this)
          ),
          attributes,
          id: instance.id
        });
      }
    } else {
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        instanceType = geometry.constructor;
        groundInstances[i] = new GeometryInstance_default({
          geometry: instanceType.createShadowVolume(
            geometry,
            getComputeMinimumHeightFunction(this),
            getComputeMaximumHeightFunction(this)
          ),
          attributes: instance.attributes,
          id: instance.id
        });
      }
    }
    primitiveOptions.geometryInstances = groundInstances;
    primitiveOptions.appearance = this.appearance;
    primitiveOptions._createBoundingVolumeFunction = function(frameState2, geometry2) {
      createBoundingVolume(that, frameState2, geometry2);
    };
    primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
      updateAndQueueCommands3(
        that,
        frameState2,
        colorCommands,
        pickCommands,
        modelMatrix,
        cull,
        debugShowBoundingVolume,
        twoPasses
      );
    };
    this._primitive = new ClassificationPrimitive_default(primitiveOptions);
  }
  this._primitive.appearance = this.appearance;
  this._primitive.show = this.show;
  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (defined_default(this._primitive) && this._primitive.ready) {
      this._completeLoad();
    }
  });
};
GroundPrimitive.prototype.getBoundingSphere = function(id) {
  const index = this._boundingSpheresKeys.indexOf(id);
  if (index !== -1) {
    return this._boundingSpheres[index];
  }
  return void 0;
};
GroundPrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
GroundPrimitive.prototype.isDestroyed = function() {
  return false;
};
GroundPrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  return destroyObject_default(this);
};
GroundPrimitive._supportsMaterials = function(context) {
  return context.depthTexture;
};
GroundPrimitive.supportsMaterials = function(scene) {
  Check_default.typeOf.object("scene", scene);
  return GroundPrimitive._supportsMaterials(scene.frameState.context);
};
var GroundPrimitive_default = GroundPrimitive;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/ArcType.js
var ArcType = {
  NONE: 0,
  GEODESIC: 1,
  RHUMB: 2
};
var ArcType_default = Object.freeze(ArcType);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/arrayRemoveDuplicates.js
var removeDuplicatesEpsilon = Math_default.EPSILON10;
function arrayRemoveDuplicates(values, equalsEpsilon, wrapAround, removedIndices) {
  Check_default.defined("equalsEpsilon", equalsEpsilon);
  if (!defined_default(values)) {
    return void 0;
  }
  wrapAround = defaultValue_default(wrapAround, false);
  const storeRemovedIndices = defined_default(removedIndices);
  const length = values.length;
  if (length < 2) {
    return values;
  }
  let i;
  let v02 = values[0];
  let v12;
  let cleanedValues;
  let lastCleanIndex = 0;
  let removedIndexLCI = -1;
  for (i = 1; i < length; ++i) {
    v12 = values[i];
    if (equalsEpsilon(v02, v12, removeDuplicatesEpsilon)) {
      if (!defined_default(cleanedValues)) {
        cleanedValues = values.slice(0, i);
        lastCleanIndex = i - 1;
        removedIndexLCI = 0;
      }
      if (storeRemovedIndices) {
        removedIndices.push(i);
      }
    } else {
      if (defined_default(cleanedValues)) {
        cleanedValues.push(v12);
        lastCleanIndex = i;
        if (storeRemovedIndices) {
          removedIndexLCI = removedIndices.length;
        }
      }
      v02 = v12;
    }
  }
  if (wrapAround && equalsEpsilon(values[0], values[length - 1], removeDuplicatesEpsilon)) {
    if (storeRemovedIndices) {
      if (defined_default(cleanedValues)) {
        removedIndices.splice(removedIndexLCI, 0, lastCleanIndex);
      } else {
        removedIndices.push(length - 1);
      }
    }
    if (defined_default(cleanedValues)) {
      cleanedValues.length -= 1;
    } else {
      cleanedValues = values.slice(0, -1);
    }
  }
  return defined_default(cleanedValues) ? cleanedValues : values;
}
var arrayRemoveDuplicates_default = arrayRemoveDuplicates;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/EllipsoidGeodesic.js
function setConstants(ellipsoidGeodesic) {
  const uSquared = ellipsoidGeodesic._uSquared;
  const a3 = ellipsoidGeodesic._ellipsoid.maximumRadius;
  const b = ellipsoidGeodesic._ellipsoid.minimumRadius;
  const f = (a3 - b) / a3;
  const cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);
  const sineHeading = Math.sin(ellipsoidGeodesic._startHeading);
  const tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);
  const cosineU = 1 / Math.sqrt(1 + tanU * tanU);
  const sineU = cosineU * tanU;
  const sigma = Math.atan2(tanU, cosineHeading);
  const sineAlpha = cosineU * sineHeading;
  const sineSquaredAlpha = sineAlpha * sineAlpha;
  const cosineSquaredAlpha = 1 - sineSquaredAlpha;
  const cosineAlpha = Math.sqrt(cosineSquaredAlpha);
  const u2Over4 = uSquared / 4;
  const u4Over16 = u2Over4 * u2Over4;
  const u6Over64 = u4Over16 * u2Over4;
  const u8Over256 = u4Over16 * u4Over16;
  const a0 = 1 + u2Over4 - 3 * u4Over16 / 4 + 5 * u6Over64 / 4 - 175 * u8Over256 / 64;
  const a1 = 1 - u2Over4 + 15 * u4Over16 / 8 - 35 * u6Over64 / 8;
  const a22 = 1 - 3 * u2Over4 + 35 * u4Over16 / 4;
  const a32 = 1 - 5 * u2Over4;
  const distanceRatio = a0 * sigma - a1 * Math.sin(2 * sigma) * u2Over4 / 2 - a22 * Math.sin(4 * sigma) * u4Over16 / 16 - a32 * Math.sin(6 * sigma) * u6Over64 / 48 - Math.sin(8 * sigma) * 5 * u8Over256 / 512;
  const constants = ellipsoidGeodesic._constants;
  constants.a = a3;
  constants.b = b;
  constants.f = f;
  constants.cosineHeading = cosineHeading;
  constants.sineHeading = sineHeading;
  constants.tanU = tanU;
  constants.cosineU = cosineU;
  constants.sineU = sineU;
  constants.sigma = sigma;
  constants.sineAlpha = sineAlpha;
  constants.sineSquaredAlpha = sineSquaredAlpha;
  constants.cosineSquaredAlpha = cosineSquaredAlpha;
  constants.cosineAlpha = cosineAlpha;
  constants.u2Over4 = u2Over4;
  constants.u4Over16 = u4Over16;
  constants.u6Over64 = u6Over64;
  constants.u8Over256 = u8Over256;
  constants.a0 = a0;
  constants.a1 = a1;
  constants.a2 = a22;
  constants.a3 = a32;
  constants.distanceRatio = distanceRatio;
}
function computeC(f, cosineSquaredAlpha) {
  return f * cosineSquaredAlpha * (4 + f * (4 - 3 * cosineSquaredAlpha)) / 16;
}
function computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {
  const C = computeC(f, cosineSquaredAlpha);
  return (1 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint + C * cosineSigma * (2 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1)));
}
function vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {
  const eff = (major - minor) / major;
  const l = secondLongitude - firstLongitude;
  const u12 = Math.atan((1 - eff) * Math.tan(firstLatitude));
  const u22 = Math.atan((1 - eff) * Math.tan(secondLatitude));
  const cosineU1 = Math.cos(u12);
  const sineU1 = Math.sin(u12);
  const cosineU2 = Math.cos(u22);
  const sineU2 = Math.sin(u22);
  const cc = cosineU1 * cosineU2;
  const cs = cosineU1 * sineU2;
  const ss = sineU1 * sineU2;
  const sc = sineU1 * cosineU2;
  let lambda = l;
  let lambdaDot = Math_default.TWO_PI;
  let cosineLambda = Math.cos(lambda);
  let sineLambda = Math.sin(lambda);
  let sigma;
  let cosineSigma;
  let sineSigma;
  let cosineSquaredAlpha;
  let cosineTwiceSigmaMidpoint;
  do {
    cosineLambda = Math.cos(lambda);
    sineLambda = Math.sin(lambda);
    const temp = cs - sc * cosineLambda;
    sineSigma = Math.sqrt(
      cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp
    );
    cosineSigma = ss + cc * cosineLambda;
    sigma = Math.atan2(sineSigma, cosineSigma);
    let sineAlpha;
    if (sineSigma === 0) {
      sineAlpha = 0;
      cosineSquaredAlpha = 1;
    } else {
      sineAlpha = cc * sineLambda / sineSigma;
      cosineSquaredAlpha = 1 - sineAlpha * sineAlpha;
    }
    lambdaDot = lambda;
    cosineTwiceSigmaMidpoint = cosineSigma - 2 * ss / cosineSquaredAlpha;
    if (!isFinite(cosineTwiceSigmaMidpoint)) {
      cosineTwiceSigmaMidpoint = 0;
    }
    lambda = l + computeDeltaLambda(
      eff,
      sineAlpha,
      cosineSquaredAlpha,
      sigma,
      sineSigma,
      cosineSigma,
      cosineTwiceSigmaMidpoint
    );
  } while (Math.abs(lambda - lambdaDot) > Math_default.EPSILON12);
  const uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);
  const A = 1 + uSquared * (4096 + uSquared * (uSquared * (320 - 175 * uSquared) - 768)) / 16384;
  const B = uSquared * (256 + uSquared * (uSquared * (74 - 47 * uSquared) - 128)) / 1024;
  const cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;
  const deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma * (2 * cosineSquaredTwiceSigmaMidpoint - 1) - B * cosineTwiceSigmaMidpoint * (4 * sineSigma * sineSigma - 3) * (4 * cosineSquaredTwiceSigmaMidpoint - 3) / 6) / 4);
  const distance = minor * A * (sigma - deltaSigma);
  const startHeading = Math.atan2(
    cosineU2 * sineLambda,
    cs - sc * cosineLambda
  );
  const endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);
  ellipsoidGeodesic._distance = distance;
  ellipsoidGeodesic._startHeading = startHeading;
  ellipsoidGeodesic._endHeading = endHeading;
  ellipsoidGeodesic._uSquared = uSquared;
}
var scratchCart1 = new Cartesian3_default();
var scratchCart2 = new Cartesian3_default();
function computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {
  const firstCartesian = Cartesian3_default.normalize(
    ellipsoid.cartographicToCartesian(start, scratchCart2),
    scratchCart1
  );
  const lastCartesian = Cartesian3_default.normalize(
    ellipsoid.cartographicToCartesian(end, scratchCart2),
    scratchCart2
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "value",
    Math.abs(
      Math.abs(Cartesian3_default.angleBetween(firstCartesian, lastCartesian)) - Math.PI
    ),
    0.0125
  );
  vincentyInverseFormula(
    ellipsoidGeodesic,
    ellipsoid.maximumRadius,
    ellipsoid.minimumRadius,
    start.longitude,
    start.latitude,
    end.longitude,
    end.latitude
  );
  ellipsoidGeodesic._start = Cartographic_default.clone(
    start,
    ellipsoidGeodesic._start
  );
  ellipsoidGeodesic._end = Cartographic_default.clone(end, ellipsoidGeodesic._end);
  ellipsoidGeodesic._start.height = 0;
  ellipsoidGeodesic._end.height = 0;
  setConstants(ellipsoidGeodesic);
}
function EllipsoidGeodesic(start, end, ellipsoid) {
  const e = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  this._ellipsoid = e;
  this._start = new Cartographic_default();
  this._end = new Cartographic_default();
  this._constants = {};
  this._startHeading = void 0;
  this._endHeading = void 0;
  this._distance = void 0;
  this._uSquared = void 0;
  if (defined_default(start) && defined_default(end)) {
    computeProperties(this, start, end, e);
  }
}
Object.defineProperties(EllipsoidGeodesic.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  surfaceDistance: {
    get: function() {
      Check_default.defined("distance", this._distance);
      return this._distance;
    }
  },
  start: {
    get: function() {
      return this._start;
    }
  },
  end: {
    get: function() {
      return this._end;
    }
  },
  startHeading: {
    get: function() {
      Check_default.defined("distance", this._distance);
      return this._startHeading;
    }
  },
  endHeading: {
    get: function() {
      Check_default.defined("distance", this._distance);
      return this._endHeading;
    }
  }
});
EllipsoidGeodesic.prototype.setEndPoints = function(start, end) {
  Check_default.defined("start", start);
  Check_default.defined("end", end);
  computeProperties(this, start, end, this._ellipsoid);
};
EllipsoidGeodesic.prototype.interpolateUsingFraction = function(fraction, result) {
  return this.interpolateUsingSurfaceDistance(
    this._distance * fraction,
    result
  );
};
EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function(distance, result) {
  Check_default.defined("distance", this._distance);
  const constants = this._constants;
  const s = constants.distanceRatio + distance / constants.b;
  const cosine2S = Math.cos(2 * s);
  const cosine4S = Math.cos(4 * s);
  const cosine6S = Math.cos(6 * s);
  const sine2S = Math.sin(2 * s);
  const sine4S = Math.sin(4 * s);
  const sine6S = Math.sin(6 * s);
  const sine8S = Math.sin(8 * s);
  const s2 = s * s;
  const s3 = s * s2;
  const u8Over256 = constants.u8Over256;
  const u2Over4 = constants.u2Over4;
  const u6Over64 = constants.u6Over64;
  const u4Over16 = constants.u4Over16;
  let sigma = 2 * s3 * u8Over256 * cosine2S / 3 + s * (1 - u2Over4 + 7 * u4Over16 / 4 - 15 * u6Over64 / 4 + 579 * u8Over256 / 64 - (u4Over16 - 15 * u6Over64 / 4 + 187 * u8Over256 / 16) * cosine2S - (5 * u6Over64 / 4 - 115 * u8Over256 / 16) * cosine4S - 29 * u8Over256 * cosine6S / 16) + (u2Over4 / 2 - u4Over16 + 71 * u6Over64 / 32 - 85 * u8Over256 / 16) * sine2S + (5 * u4Over16 / 16 - 5 * u6Over64 / 4 + 383 * u8Over256 / 96) * sine4S - s2 * ((u6Over64 - 11 * u8Over256 / 2) * sine2S + 5 * u8Over256 * sine4S / 2) + (29 * u6Over64 / 96 - 29 * u8Over256 / 16) * sine6S + 539 * u8Over256 * sine8S / 1536;
  const theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);
  const latitude = Math.atan(constants.a / constants.b * Math.tan(theta));
  sigma = sigma - constants.sigma;
  const cosineTwiceSigmaMidpoint = Math.cos(2 * constants.sigma + sigma);
  const sineSigma = Math.sin(sigma);
  const cosineSigma = Math.cos(sigma);
  const cc = constants.cosineU * cosineSigma;
  const ss = constants.sineU * sineSigma;
  const lambda = Math.atan2(
    sineSigma * constants.sineHeading,
    cc - ss * constants.cosineHeading
  );
  const l = lambda - computeDeltaLambda(
    constants.f,
    constants.sineAlpha,
    constants.cosineSquaredAlpha,
    sigma,
    sineSigma,
    cosineSigma,
    cosineTwiceSigmaMidpoint
  );
  if (defined_default(result)) {
    result.longitude = this._start.longitude + l;
    result.latitude = latitude;
    result.height = 0;
    return result;
  }
  return new Cartographic_default(this._start.longitude + l, latitude, 0);
};
var EllipsoidGeodesic_default = EllipsoidGeodesic;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/EllipsoidRhumbLine.js
function calculateM(ellipticity, major, latitude) {
  if (ellipticity === 0) {
    return major * latitude;
  }
  const e2 = ellipticity * ellipticity;
  const e4 = e2 * e2;
  const e6 = e4 * e2;
  const e8 = e6 * e2;
  const e10 = e8 * e2;
  const e12 = e10 * e2;
  const phi = latitude;
  const sin2Phi = Math.sin(2 * phi);
  const sin4Phi = Math.sin(4 * phi);
  const sin6Phi = Math.sin(6 * phi);
  const sin8Phi = Math.sin(8 * phi);
  const sin10Phi = Math.sin(10 * phi);
  const sin12Phi = Math.sin(12 * phi);
  return major * ((1 - e2 / 4 - 3 * e4 / 64 - 5 * e6 / 256 - 175 * e8 / 16384 - 441 * e10 / 65536 - 4851 * e12 / 1048576) * phi - (3 * e2 / 8 + 3 * e4 / 32 + 45 * e6 / 1024 + 105 * e8 / 4096 + 2205 * e10 / 131072 + 6237 * e12 / 524288) * sin2Phi + (15 * e4 / 256 + 45 * e6 / 1024 + 525 * e8 / 16384 + 1575 * e10 / 65536 + 155925 * e12 / 8388608) * sin4Phi - (35 * e6 / 3072 + 175 * e8 / 12288 + 3675 * e10 / 262144 + 13475 * e12 / 1048576) * sin6Phi + (315 * e8 / 131072 + 2205 * e10 / 524288 + 43659 * e12 / 8388608) * sin8Phi - (693 * e10 / 1310720 + 6237 * e12 / 5242880) * sin10Phi + 1001 * e12 / 8388608 * sin12Phi);
}
function calculateInverseM(M, ellipticity, major) {
  const d = M / major;
  if (ellipticity === 0) {
    return d;
  }
  const d2 = d * d;
  const d3 = d2 * d;
  const d4 = d3 * d;
  const e = ellipticity;
  const e2 = e * e;
  const e4 = e2 * e2;
  const e6 = e4 * e2;
  const e8 = e6 * e2;
  const e10 = e8 * e2;
  const e12 = e10 * e2;
  const sin2D = Math.sin(2 * d);
  const cos2D = Math.cos(2 * d);
  const sin4D = Math.sin(4 * d);
  const cos4D = Math.cos(4 * d);
  const sin6D = Math.sin(6 * d);
  const cos6D = Math.cos(6 * d);
  const sin8D = Math.sin(8 * d);
  const cos8D = Math.cos(8 * d);
  const sin10D = Math.sin(10 * d);
  const cos10D = Math.cos(10 * d);
  const sin12D = Math.sin(12 * d);
  return d + d * e2 / 4 + 7 * d * e4 / 64 + 15 * d * e6 / 256 + 579 * d * e8 / 16384 + 1515 * d * e10 / 65536 + 16837 * d * e12 / 1048576 + (3 * d * e4 / 16 + 45 * d * e6 / 256 - d * (32 * d2 - 561) * e8 / 4096 - d * (232 * d2 - 1677) * e10 / 16384 + d * (399985 - 90560 * d2 + 512 * d4) * e12 / 5242880) * cos2D + (21 * d * e6 / 256 + 483 * d * e8 / 4096 - d * (224 * d2 - 1969) * e10 / 16384 - d * (33152 * d2 - 112599) * e12 / 1048576) * cos4D + (151 * d * e8 / 4096 + 4681 * d * e10 / 65536 + 1479 * d * e12 / 16384 - 453 * d3 * e12 / 32768) * cos6D + (1097 * d * e10 / 65536 + 42783 * d * e12 / 1048576) * cos8D + 8011 * d * e12 / 1048576 * cos10D + (3 * e2 / 8 + 3 * e4 / 16 + 213 * e6 / 2048 - 3 * d2 * e6 / 64 + 255 * e8 / 4096 - 33 * d2 * e8 / 512 + 20861 * e10 / 524288 - 33 * d2 * e10 / 512 + d4 * e10 / 1024 + 28273 * e12 / 1048576 - 471 * d2 * e12 / 8192 + 9 * d4 * e12 / 4096) * sin2D + (21 * e4 / 256 + 21 * e6 / 256 + 533 * e8 / 8192 - 21 * d2 * e8 / 512 + 197 * e10 / 4096 - 315 * d2 * e10 / 4096 + 584039 * e12 / 16777216 - 12517 * d2 * e12 / 131072 + 7 * d4 * e12 / 2048) * sin4D + (151 * e6 / 6144 + 151 * e8 / 4096 + 5019 * e10 / 131072 - 453 * d2 * e10 / 16384 + 26965 * e12 / 786432 - 8607 * d2 * e12 / 131072) * sin6D + (1097 * e8 / 131072 + 1097 * e10 / 65536 + 225797 * e12 / 10485760 - 1097 * d2 * e12 / 65536) * sin8D + (8011 * e10 / 2621440 + 8011 * e12 / 1048576) * sin10D + 293393 * e12 / 251658240 * sin12D;
}
function calculateSigma(ellipticity, latitude) {
  if (ellipticity === 0) {
    return Math.log(Math.tan(0.5 * (Math_default.PI_OVER_TWO + latitude)));
  }
  const eSinL = ellipticity * Math.sin(latitude);
  return Math.log(Math.tan(0.5 * (Math_default.PI_OVER_TWO + latitude))) - ellipticity / 2 * Math.log((1 + eSinL) / (1 - eSinL));
}
function calculateHeading(ellipsoidRhumbLine, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {
  const sigma1 = calculateSigma(ellipsoidRhumbLine._ellipticity, firstLatitude);
  const sigma2 = calculateSigma(
    ellipsoidRhumbLine._ellipticity,
    secondLatitude
  );
  return Math.atan2(
    Math_default.negativePiToPi(secondLongitude - firstLongitude),
    sigma2 - sigma1
  );
}
function calculateArcLength(ellipsoidRhumbLine, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {
  const heading = ellipsoidRhumbLine._heading;
  const deltaLongitude = secondLongitude - firstLongitude;
  let distance = 0;
  if (Math_default.equalsEpsilon(
    Math.abs(heading),
    Math_default.PI_OVER_TWO,
    Math_default.EPSILON8
  )) {
    if (major === minor) {
      distance = major * Math.cos(firstLatitude) * Math_default.negativePiToPi(deltaLongitude);
    } else {
      const sinPhi = Math.sin(firstLatitude);
      distance = major * Math.cos(firstLatitude) * Math_default.negativePiToPi(deltaLongitude) / Math.sqrt(1 - ellipsoidRhumbLine._ellipticitySquared * sinPhi * sinPhi);
    }
  } else {
    const M1 = calculateM(
      ellipsoidRhumbLine._ellipticity,
      major,
      firstLatitude
    );
    const M2 = calculateM(
      ellipsoidRhumbLine._ellipticity,
      major,
      secondLatitude
    );
    distance = (M2 - M1) / Math.cos(heading);
  }
  return Math.abs(distance);
}
var scratchCart12 = new Cartesian3_default();
var scratchCart22 = new Cartesian3_default();
function computeProperties2(ellipsoidRhumbLine, start, end, ellipsoid) {
  const firstCartesian = Cartesian3_default.normalize(
    ellipsoid.cartographicToCartesian(start, scratchCart22),
    scratchCart12
  );
  const lastCartesian = Cartesian3_default.normalize(
    ellipsoid.cartographicToCartesian(end, scratchCart22),
    scratchCart22
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "value",
    Math.abs(
      Math.abs(Cartesian3_default.angleBetween(firstCartesian, lastCartesian)) - Math.PI
    ),
    0.0125
  );
  const major = ellipsoid.maximumRadius;
  const minor = ellipsoid.minimumRadius;
  const majorSquared = major * major;
  const minorSquared = minor * minor;
  ellipsoidRhumbLine._ellipticitySquared = (majorSquared - minorSquared) / majorSquared;
  ellipsoidRhumbLine._ellipticity = Math.sqrt(
    ellipsoidRhumbLine._ellipticitySquared
  );
  ellipsoidRhumbLine._start = Cartographic_default.clone(
    start,
    ellipsoidRhumbLine._start
  );
  ellipsoidRhumbLine._start.height = 0;
  ellipsoidRhumbLine._end = Cartographic_default.clone(end, ellipsoidRhumbLine._end);
  ellipsoidRhumbLine._end.height = 0;
  ellipsoidRhumbLine._heading = calculateHeading(
    ellipsoidRhumbLine,
    start.longitude,
    start.latitude,
    end.longitude,
    end.latitude
  );
  ellipsoidRhumbLine._distance = calculateArcLength(
    ellipsoidRhumbLine,
    ellipsoid.maximumRadius,
    ellipsoid.minimumRadius,
    start.longitude,
    start.latitude,
    end.longitude,
    end.latitude
  );
}
function interpolateUsingSurfaceDistance(start, heading, distance, major, ellipticity, result) {
  if (distance === 0) {
    return Cartographic_default.clone(start, result);
  }
  const ellipticitySquared = ellipticity * ellipticity;
  let longitude;
  let latitude;
  let deltaLongitude;
  if (Math.abs(Math_default.PI_OVER_TWO - Math.abs(heading)) > Math_default.EPSILON8) {
    const M1 = calculateM(ellipticity, major, start.latitude);
    const deltaM = distance * Math.cos(heading);
    const M2 = M1 + deltaM;
    latitude = calculateInverseM(M2, ellipticity, major);
    const sigma1 = calculateSigma(ellipticity, start.latitude);
    const sigma2 = calculateSigma(ellipticity, latitude);
    deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);
    longitude = Math_default.negativePiToPi(start.longitude + deltaLongitude);
  } else {
    latitude = start.latitude;
    let localRad;
    if (ellipticity === 0) {
      localRad = major * Math.cos(start.latitude);
    } else {
      const sinPhi = Math.sin(start.latitude);
      localRad = major * Math.cos(start.latitude) / Math.sqrt(1 - ellipticitySquared * sinPhi * sinPhi);
    }
    deltaLongitude = distance / localRad;
    if (heading > 0) {
      longitude = Math_default.negativePiToPi(start.longitude + deltaLongitude);
    } else {
      longitude = Math_default.negativePiToPi(start.longitude - deltaLongitude);
    }
  }
  if (defined_default(result)) {
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = 0;
    return result;
  }
  return new Cartographic_default(longitude, latitude, 0);
}
function EllipsoidRhumbLine(start, end, ellipsoid) {
  const e = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  this._ellipsoid = e;
  this._start = new Cartographic_default();
  this._end = new Cartographic_default();
  this._heading = void 0;
  this._distance = void 0;
  this._ellipticity = void 0;
  this._ellipticitySquared = void 0;
  if (defined_default(start) && defined_default(end)) {
    computeProperties2(this, start, end, e);
  }
}
Object.defineProperties(EllipsoidRhumbLine.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  surfaceDistance: {
    get: function() {
      Check_default.defined("distance", this._distance);
      return this._distance;
    }
  },
  start: {
    get: function() {
      return this._start;
    }
  },
  end: {
    get: function() {
      return this._end;
    }
  },
  heading: {
    get: function() {
      Check_default.defined("distance", this._distance);
      return this._heading;
    }
  }
});
EllipsoidRhumbLine.fromStartHeadingDistance = function(start, heading, distance, ellipsoid, result) {
  Check_default.defined("start", start);
  Check_default.defined("heading", heading);
  Check_default.defined("distance", distance);
  Check_default.typeOf.number.greaterThan("distance", distance, 0);
  const e = defaultValue_default(ellipsoid, Ellipsoid_default.WGS84);
  const major = e.maximumRadius;
  const minor = e.minimumRadius;
  const majorSquared = major * major;
  const minorSquared = minor * minor;
  const ellipticity = Math.sqrt((majorSquared - minorSquared) / majorSquared);
  heading = Math_default.negativePiToPi(heading);
  const end = interpolateUsingSurfaceDistance(
    start,
    heading,
    distance,
    e.maximumRadius,
    ellipticity
  );
  if (!defined_default(result) || defined_default(ellipsoid) && !ellipsoid.equals(result.ellipsoid)) {
    return new EllipsoidRhumbLine(start, end, e);
  }
  result.setEndPoints(start, end);
  return result;
};
EllipsoidRhumbLine.prototype.setEndPoints = function(start, end) {
  Check_default.defined("start", start);
  Check_default.defined("end", end);
  computeProperties2(this, start, end, this._ellipsoid);
};
EllipsoidRhumbLine.prototype.interpolateUsingFraction = function(fraction, result) {
  return this.interpolateUsingSurfaceDistance(
    fraction * this._distance,
    result
  );
};
EllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance = function(distance, result) {
  Check_default.typeOf.number("distance", distance);
  if (!defined_default(this._distance) || this._distance === 0) {
    throw new DeveloperError_default(
      "EllipsoidRhumbLine must have distinct start and end set."
    );
  }
  return interpolateUsingSurfaceDistance(
    this._start,
    this._heading,
    distance,
    this._ellipsoid.maximumRadius,
    this._ellipticity,
    result
  );
};
EllipsoidRhumbLine.prototype.findIntersectionWithLongitude = function(intersectionLongitude, result) {
  Check_default.typeOf.number("intersectionLongitude", intersectionLongitude);
  if (!defined_default(this._distance) || this._distance === 0) {
    throw new DeveloperError_default(
      "EllipsoidRhumbLine must have distinct start and end set."
    );
  }
  const ellipticity = this._ellipticity;
  const heading = this._heading;
  const absHeading = Math.abs(heading);
  const start = this._start;
  intersectionLongitude = Math_default.negativePiToPi(intersectionLongitude);
  if (Math_default.equalsEpsilon(
    Math.abs(intersectionLongitude),
    Math.PI,
    Math_default.EPSILON14
  )) {
    intersectionLongitude = Math_default.sign(start.longitude) * Math.PI;
  }
  if (!defined_default(result)) {
    result = new Cartographic_default();
  }
  if (Math.abs(Math_default.PI_OVER_TWO - absHeading) <= Math_default.EPSILON8) {
    result.longitude = intersectionLongitude;
    result.latitude = start.latitude;
    result.height = 0;
    return result;
  } else if (Math_default.equalsEpsilon(
    Math.abs(Math_default.PI_OVER_TWO - absHeading),
    Math_default.PI_OVER_TWO,
    Math_default.EPSILON8
  )) {
    if (Math_default.equalsEpsilon(
      intersectionLongitude,
      start.longitude,
      Math_default.EPSILON12
    )) {
      return void 0;
    }
    result.longitude = intersectionLongitude;
    result.latitude = Math_default.PI_OVER_TWO * Math_default.sign(Math_default.PI_OVER_TWO - heading);
    result.height = 0;
    return result;
  }
  const phi1 = start.latitude;
  const eSinPhi1 = ellipticity * Math.sin(phi1);
  const leftComponent = Math.tan(0.5 * (Math_default.PI_OVER_TWO + phi1)) * Math.exp((intersectionLongitude - start.longitude) / Math.tan(heading));
  const denominator = (1 + eSinPhi1) / (1 - eSinPhi1);
  let newPhi = start.latitude;
  let phi;
  do {
    phi = newPhi;
    const eSinPhi = ellipticity * Math.sin(phi);
    const numerator = (1 + eSinPhi) / (1 - eSinPhi);
    newPhi = 2 * Math.atan(
      leftComponent * Math.pow(numerator / denominator, ellipticity / 2)
    ) - Math_default.PI_OVER_TWO;
  } while (!Math_default.equalsEpsilon(newPhi, phi, Math_default.EPSILON12));
  result.longitude = intersectionLongitude;
  result.latitude = newPhi;
  result.height = 0;
  return result;
};
EllipsoidRhumbLine.prototype.findIntersectionWithLatitude = function(intersectionLatitude, result) {
  Check_default.typeOf.number("intersectionLatitude", intersectionLatitude);
  if (!defined_default(this._distance) || this._distance === 0) {
    throw new DeveloperError_default(
      "EllipsoidRhumbLine must have distinct start and end set."
    );
  }
  const ellipticity = this._ellipticity;
  const heading = this._heading;
  const start = this._start;
  if (Math_default.equalsEpsilon(
    Math.abs(heading),
    Math_default.PI_OVER_TWO,
    Math_default.EPSILON8
  )) {
    return;
  }
  const sigma1 = calculateSigma(ellipticity, start.latitude);
  const sigma2 = calculateSigma(ellipticity, intersectionLatitude);
  const deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);
  const longitude = Math_default.negativePiToPi(start.longitude + deltaLongitude);
  if (defined_default(result)) {
    result.longitude = longitude;
    result.latitude = intersectionLatitude;
    result.height = 0;
    return result;
  }
  return new Cartographic_default(longitude, intersectionLatitude, 0);
};
var EllipsoidRhumbLine_default = EllipsoidRhumbLine;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/GroundPolylineGeometry.js
var PROJECTIONS = [GeographicProjection_default, WebMercatorProjection_default];
var PROJECTION_COUNT = PROJECTIONS.length;
var MITER_BREAK_SMALL = Math.cos(Math_default.toRadians(30));
var MITER_BREAK_LARGE = Math.cos(Math_default.toRadians(150));
var WALL_INITIAL_MIN_HEIGHT = 0;
var WALL_INITIAL_MAX_HEIGHT = 1e3;
function GroundPolylineGeometry(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const positions = options.positions;
  if (!defined_default(positions) || positions.length < 2) {
    throw new DeveloperError_default("At least two positions are required.");
  }
  if (defined_default(options.arcType) && options.arcType !== ArcType_default.GEODESIC && options.arcType !== ArcType_default.RHUMB) {
    throw new DeveloperError_default(
      "Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB."
    );
  }
  this.width = defaultValue_default(options.width, 1);
  this._positions = positions;
  this.granularity = defaultValue_default(options.granularity, 9999);
  this.loop = defaultValue_default(options.loop, false);
  this.arcType = defaultValue_default(options.arcType, ArcType_default.GEODESIC);
  this._ellipsoid = Ellipsoid_default.WGS84;
  this._projectionIndex = 0;
  this._workerName = "createGroundPolylineGeometry";
  this._scene3DOnly = false;
}
Object.defineProperties(GroundPolylineGeometry.prototype, {
  packedLength: {
    get: function() {
      return 1 + this._positions.length * 3 + 1 + 1 + 1 + Ellipsoid_default.packedLength + 1 + 1;
    }
  }
});
GroundPolylineGeometry.setProjectionAndEllipsoid = function(groundPolylineGeometry, mapProjection) {
  let projectionIndex = 0;
  for (let i = 0; i < PROJECTION_COUNT; i++) {
    if (mapProjection instanceof PROJECTIONS[i]) {
      projectionIndex = i;
      break;
    }
  }
  groundPolylineGeometry._projectionIndex = projectionIndex;
  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;
};
var cart3Scratch1 = new Cartesian3_default();
var cart3Scratch2 = new Cartesian3_default();
var cart3Scratch3 = new Cartesian3_default();
function computeRightNormal(start, end, maxHeight, ellipsoid, result) {
  const startBottom = getPosition(ellipsoid, start, 0, cart3Scratch1);
  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);
  const endBottom = getPosition(ellipsoid, end, 0, cart3Scratch3);
  const up = direction(startTop, startBottom, cart3Scratch2);
  const forward = direction(endBottom, startBottom, cart3Scratch3);
  Cartesian3_default.cross(forward, up, result);
  return Cartesian3_default.normalize(result, result);
}
var interpolatedCartographicScratch = new Cartographic_default();
var interpolatedBottomScratch = new Cartesian3_default();
var interpolatedTopScratch = new Cartesian3_default();
var interpolatedNormalScratch = new Cartesian3_default();
function interpolateSegment(start, end, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray) {
  if (granularity === 0) {
    return;
  }
  let ellipsoidLine;
  if (arcType === ArcType_default.GEODESIC) {
    ellipsoidLine = new EllipsoidGeodesic_default(start, end, ellipsoid);
  } else if (arcType === ArcType_default.RHUMB) {
    ellipsoidLine = new EllipsoidRhumbLine_default(start, end, ellipsoid);
  }
  const surfaceDistance = ellipsoidLine.surfaceDistance;
  if (surfaceDistance < granularity) {
    return;
  }
  const interpolatedNormal = computeRightNormal(
    start,
    end,
    maxHeight,
    ellipsoid,
    interpolatedNormalScratch
  );
  const segments = Math.ceil(surfaceDistance / granularity);
  const interpointDistance = surfaceDistance / segments;
  let distanceFromStart = interpointDistance;
  const pointsToAdd = segments - 1;
  let packIndex = normalsArray.length;
  for (let i = 0; i < pointsToAdd; i++) {
    const interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(
      distanceFromStart,
      interpolatedCartographicScratch
    );
    const interpolatedBottom = getPosition(
      ellipsoid,
      interpolatedCartographic,
      minHeight,
      interpolatedBottomScratch
    );
    const interpolatedTop = getPosition(
      ellipsoid,
      interpolatedCartographic,
      maxHeight,
      interpolatedTopScratch
    );
    Cartesian3_default.pack(interpolatedNormal, normalsArray, packIndex);
    Cartesian3_default.pack(interpolatedBottom, bottomPositionsArray, packIndex);
    Cartesian3_default.pack(interpolatedTop, topPositionsArray, packIndex);
    cartographicsArray.push(interpolatedCartographic.latitude);
    cartographicsArray.push(interpolatedCartographic.longitude);
    packIndex += 3;
    distanceFromStart += interpointDistance;
  }
}
var heightlessCartographicScratch = new Cartographic_default();
function getPosition(ellipsoid, cartographic, height, result) {
  Cartographic_default.clone(cartographic, heightlessCartographicScratch);
  heightlessCartographicScratch.height = height;
  return Cartographic_default.toCartesian(
    heightlessCartographicScratch,
    ellipsoid,
    result
  );
}
GroundPolylineGeometry.pack = function(value, array, startingIndex) {
  Check_default.typeOf.object("value", value);
  Check_default.defined("array", array);
  let index = defaultValue_default(startingIndex, 0);
  const positions = value._positions;
  const positionsLength = positions.length;
  array[index++] = positionsLength;
  for (let i = 0; i < positionsLength; ++i) {
    const cartesian = positions[i];
    Cartesian3_default.pack(cartesian, array, index);
    index += 3;
  }
  array[index++] = value.granularity;
  array[index++] = value.loop ? 1 : 0;
  array[index++] = value.arcType;
  Ellipsoid_default.pack(value._ellipsoid, array, index);
  index += Ellipsoid_default.packedLength;
  array[index++] = value._projectionIndex;
  array[index++] = value._scene3DOnly ? 1 : 0;
  return array;
};
GroundPolylineGeometry.unpack = function(array, startingIndex, result) {
  Check_default.defined("array", array);
  let index = defaultValue_default(startingIndex, 0);
  const positionsLength = array[index++];
  const positions = new Array(positionsLength);
  for (let i = 0; i < positionsLength; i++) {
    positions[i] = Cartesian3_default.unpack(array, index);
    index += 3;
  }
  const granularity = array[index++];
  const loop = array[index++] === 1;
  const arcType = array[index++];
  const ellipsoid = Ellipsoid_default.unpack(array, index);
  index += Ellipsoid_default.packedLength;
  const projectionIndex = array[index++];
  const scene3DOnly = array[index++] === 1;
  if (!defined_default(result)) {
    result = new GroundPolylineGeometry({
      positions
    });
  }
  result._positions = positions;
  result.granularity = granularity;
  result.loop = loop;
  result.arcType = arcType;
  result._ellipsoid = ellipsoid;
  result._projectionIndex = projectionIndex;
  result._scene3DOnly = scene3DOnly;
  return result;
};
function direction(target, origin, result) {
  Cartesian3_default.subtract(target, origin, result);
  Cartesian3_default.normalize(result, result);
  return result;
}
function tangentDirection(target, origin, up, result) {
  result = direction(target, origin, result);
  result = Cartesian3_default.cross(result, up, result);
  result = Cartesian3_default.normalize(result, result);
  result = Cartesian3_default.cross(up, result, result);
  return result;
}
var toPreviousScratch = new Cartesian3_default();
var toNextScratch = new Cartesian3_default();
var forwardScratch = new Cartesian3_default();
var vertexUpScratch = new Cartesian3_default();
var cosine90 = 0;
var cosine180 = -1;
function computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, result) {
  const up = direction(vertexTop, vertexBottom, vertexUpScratch);
  const toPrevious = tangentDirection(
    previousBottom,
    vertexBottom,
    up,
    toPreviousScratch
  );
  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);
  if (Math_default.equalsEpsilon(
    Cartesian3_default.dot(toPrevious, toNext),
    cosine180,
    Math_default.EPSILON5
  )) {
    result = Cartesian3_default.cross(up, toPrevious, result);
    result = Cartesian3_default.normalize(result, result);
    return result;
  }
  result = Cartesian3_default.add(toNext, toPrevious, result);
  result = Cartesian3_default.normalize(result, result);
  const forward = Cartesian3_default.cross(up, result, forwardScratch);
  if (Cartesian3_default.dot(toNext, forward) < cosine90) {
    result = Cartesian3_default.negate(result, result);
  }
  return result;
}
var XZ_PLANE = Plane_default.fromPointNormal(Cartesian3_default.ZERO, Cartesian3_default.UNIT_Y);
var previousBottomScratch = new Cartesian3_default();
var vertexBottomScratch = new Cartesian3_default();
var vertexTopScratch = new Cartesian3_default();
var nextBottomScratch = new Cartesian3_default();
var vertexNormalScratch = new Cartesian3_default();
var intersectionScratch = new Cartesian3_default();
var cartographicScratch0 = new Cartographic_default();
var cartographicScratch1 = new Cartographic_default();
var cartographicIntersectionScratch = new Cartographic_default();
GroundPolylineGeometry.createGeometry = function(groundPolylineGeometry) {
  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;
  let loop = groundPolylineGeometry.loop;
  const ellipsoid = groundPolylineGeometry._ellipsoid;
  const granularity = groundPolylineGeometry.granularity;
  const arcType = groundPolylineGeometry.arcType;
  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](
    ellipsoid
  );
  const minHeight = WALL_INITIAL_MIN_HEIGHT;
  const maxHeight = WALL_INITIAL_MAX_HEIGHT;
  let index;
  let i;
  const positions = groundPolylineGeometry._positions;
  const positionsLength = positions.length;
  if (positionsLength === 2) {
    loop = false;
  }
  let p0;
  let p1;
  let c0;
  let c1;
  const rhumbLine = new EllipsoidRhumbLine_default(void 0, void 0, ellipsoid);
  let intersection;
  let intersectionCartographic;
  let intersectionLongitude;
  const splitPositions = [positions[0]];
  for (i = 0; i < positionsLength - 1; i++) {
    p0 = positions[i];
    p1 = positions[i + 1];
    intersection = IntersectionTests_default.lineSegmentPlane(
      p0,
      p1,
      XZ_PLANE,
      intersectionScratch
    );
    if (defined_default(intersection) && !Cartesian3_default.equalsEpsilon(intersection, p0, Math_default.EPSILON7) && !Cartesian3_default.equalsEpsilon(intersection, p1, Math_default.EPSILON7)) {
      if (groundPolylineGeometry.arcType === ArcType_default.GEODESIC) {
        splitPositions.push(Cartesian3_default.clone(intersection));
      } else if (groundPolylineGeometry.arcType === ArcType_default.RHUMB) {
        intersectionLongitude = ellipsoid.cartesianToCartographic(
          intersection,
          cartographicScratch0
        ).longitude;
        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);
        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);
        rhumbLine.setEndPoints(c0, c1);
        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(
          intersectionLongitude,
          cartographicIntersectionScratch
        );
        intersection = ellipsoid.cartographicToCartesian(
          intersectionCartographic,
          intersectionScratch
        );
        if (defined_default(intersection) && !Cartesian3_default.equalsEpsilon(intersection, p0, Math_default.EPSILON7) && !Cartesian3_default.equalsEpsilon(intersection, p1, Math_default.EPSILON7)) {
          splitPositions.push(Cartesian3_default.clone(intersection));
        }
      }
    }
    splitPositions.push(p1);
  }
  if (loop) {
    p0 = positions[positionsLength - 1];
    p1 = positions[0];
    intersection = IntersectionTests_default.lineSegmentPlane(
      p0,
      p1,
      XZ_PLANE,
      intersectionScratch
    );
    if (defined_default(intersection) && !Cartesian3_default.equalsEpsilon(intersection, p0, Math_default.EPSILON7) && !Cartesian3_default.equalsEpsilon(intersection, p1, Math_default.EPSILON7)) {
      if (groundPolylineGeometry.arcType === ArcType_default.GEODESIC) {
        splitPositions.push(Cartesian3_default.clone(intersection));
      } else if (groundPolylineGeometry.arcType === ArcType_default.RHUMB) {
        intersectionLongitude = ellipsoid.cartesianToCartographic(
          intersection,
          cartographicScratch0
        ).longitude;
        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);
        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);
        rhumbLine.setEndPoints(c0, c1);
        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(
          intersectionLongitude,
          cartographicIntersectionScratch
        );
        intersection = ellipsoid.cartographicToCartesian(
          intersectionCartographic,
          intersectionScratch
        );
        if (defined_default(intersection) && !Cartesian3_default.equalsEpsilon(intersection, p0, Math_default.EPSILON7) && !Cartesian3_default.equalsEpsilon(intersection, p1, Math_default.EPSILON7)) {
          splitPositions.push(Cartesian3_default.clone(intersection));
        }
      }
    }
  }
  let cartographicsLength = splitPositions.length;
  let cartographics = new Array(cartographicsLength);
  for (i = 0; i < cartographicsLength; i++) {
    const cartographic = Cartographic_default.fromCartesian(
      splitPositions[i],
      ellipsoid
    );
    cartographic.height = 0;
    cartographics[i] = cartographic;
  }
  cartographics = arrayRemoveDuplicates_default(
    cartographics,
    Cartographic_default.equalsEpsilon
  );
  cartographicsLength = cartographics.length;
  if (cartographicsLength < 2) {
    return void 0;
  }
  const cartographicsArray = [];
  const normalsArray = [];
  const bottomPositionsArray = [];
  const topPositionsArray = [];
  let previousBottom = previousBottomScratch;
  let vertexBottom = vertexBottomScratch;
  let vertexTop = vertexTopScratch;
  let nextBottom = nextBottomScratch;
  let vertexNormal = vertexNormalScratch;
  const startCartographic = cartographics[0];
  const nextCartographic = cartographics[1];
  const prestartCartographic = cartographics[cartographicsLength - 1];
  previousBottom = getPosition(
    ellipsoid,
    prestartCartographic,
    minHeight,
    previousBottom
  );
  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);
  vertexBottom = getPosition(
    ellipsoid,
    startCartographic,
    minHeight,
    vertexBottom
  );
  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);
  if (loop) {
    vertexNormal = computeVertexMiterNormal(
      previousBottom,
      vertexBottom,
      vertexTop,
      nextBottom,
      vertexNormal
    );
  } else {
    vertexNormal = computeRightNormal(
      startCartographic,
      nextCartographic,
      maxHeight,
      ellipsoid,
      vertexNormal
    );
  }
  Cartesian3_default.pack(vertexNormal, normalsArray, 0);
  Cartesian3_default.pack(vertexBottom, bottomPositionsArray, 0);
  Cartesian3_default.pack(vertexTop, topPositionsArray, 0);
  cartographicsArray.push(startCartographic.latitude);
  cartographicsArray.push(startCartographic.longitude);
  interpolateSegment(
    startCartographic,
    nextCartographic,
    minHeight,
    maxHeight,
    granularity,
    arcType,
    ellipsoid,
    normalsArray,
    bottomPositionsArray,
    topPositionsArray,
    cartographicsArray
  );
  for (i = 1; i < cartographicsLength - 1; ++i) {
    previousBottom = Cartesian3_default.clone(vertexBottom, previousBottom);
    vertexBottom = Cartesian3_default.clone(nextBottom, vertexBottom);
    const vertexCartographic = cartographics[i];
    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);
    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);
    computeVertexMiterNormal(
      previousBottom,
      vertexBottom,
      vertexTop,
      nextBottom,
      vertexNormal
    );
    index = normalsArray.length;
    Cartesian3_default.pack(vertexNormal, normalsArray, index);
    Cartesian3_default.pack(vertexBottom, bottomPositionsArray, index);
    Cartesian3_default.pack(vertexTop, topPositionsArray, index);
    cartographicsArray.push(vertexCartographic.latitude);
    cartographicsArray.push(vertexCartographic.longitude);
    interpolateSegment(
      cartographics[i],
      cartographics[i + 1],
      minHeight,
      maxHeight,
      granularity,
      arcType,
      ellipsoid,
      normalsArray,
      bottomPositionsArray,
      topPositionsArray,
      cartographicsArray
    );
  }
  const endCartographic = cartographics[cartographicsLength - 1];
  const preEndCartographic = cartographics[cartographicsLength - 2];
  vertexBottom = getPosition(
    ellipsoid,
    endCartographic,
    minHeight,
    vertexBottom
  );
  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);
  if (loop) {
    const postEndCartographic = cartographics[0];
    previousBottom = getPosition(
      ellipsoid,
      preEndCartographic,
      minHeight,
      previousBottom
    );
    nextBottom = getPosition(
      ellipsoid,
      postEndCartographic,
      minHeight,
      nextBottom
    );
    vertexNormal = computeVertexMiterNormal(
      previousBottom,
      vertexBottom,
      vertexTop,
      nextBottom,
      vertexNormal
    );
  } else {
    vertexNormal = computeRightNormal(
      preEndCartographic,
      endCartographic,
      maxHeight,
      ellipsoid,
      vertexNormal
    );
  }
  index = normalsArray.length;
  Cartesian3_default.pack(vertexNormal, normalsArray, index);
  Cartesian3_default.pack(vertexBottom, bottomPositionsArray, index);
  Cartesian3_default.pack(vertexTop, topPositionsArray, index);
  cartographicsArray.push(endCartographic.latitude);
  cartographicsArray.push(endCartographic.longitude);
  if (loop) {
    interpolateSegment(
      endCartographic,
      startCartographic,
      minHeight,
      maxHeight,
      granularity,
      arcType,
      ellipsoid,
      normalsArray,
      bottomPositionsArray,
      topPositionsArray,
      cartographicsArray
    );
    index = normalsArray.length;
    for (i = 0; i < 3; ++i) {
      normalsArray[index + i] = normalsArray[i];
      bottomPositionsArray[index + i] = bottomPositionsArray[i];
      topPositionsArray[index + i] = topPositionsArray[i];
    }
    cartographicsArray.push(startCartographic.latitude);
    cartographicsArray.push(startCartographic.longitude);
  }
  return generateGeometryAttributes(
    loop,
    projection,
    bottomPositionsArray,
    topPositionsArray,
    normalsArray,
    cartographicsArray,
    compute2dAttributes
  );
};
var lineDirectionScratch = new Cartesian3_default();
var matrix3Scratch = new Matrix3_default();
var quaternionScratch = new Quaternion_default();
function breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {
  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);
  const dot = Cartesian3_default.dot(lineDirection, endGeometryNormal);
  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {
    const vertexUp = direction(endTop, endBottom, vertexUpScratch);
    const angle = dot < MITER_BREAK_LARGE ? Math_default.PI_OVER_TWO : -Math_default.PI_OVER_TWO;
    const quaternion = Quaternion_default.fromAxisAngle(
      vertexUp,
      angle,
      quaternionScratch
    );
    const rotationMatrix = Matrix3_default.fromQuaternion(quaternion, matrix3Scratch);
    Matrix3_default.multiplyByVector(
      rotationMatrix,
      endGeometryNormal,
      endGeometryNormal
    );
    return true;
  }
  return false;
}
var endPosCartographicScratch = new Cartographic_default();
var normalStartpointScratch = new Cartesian3_default();
var normalEndpointScratch = new Cartesian3_default();
function projectNormal(projection, cartographic, normal2, projectedPosition, result) {
  const position = Cartographic_default.toCartesian(
    cartographic,
    projection._ellipsoid,
    normalStartpointScratch
  );
  let normalEndpoint = Cartesian3_default.add(position, normal2, normalEndpointScratch);
  let flipNormal = false;
  const ellipsoid = projection._ellipsoid;
  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(
    normalEndpoint,
    endPosCartographicScratch
  );
  if (Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) > Math_default.PI_OVER_TWO) {
    flipNormal = true;
    normalEndpoint = Cartesian3_default.subtract(
      position,
      normal2,
      normalEndpointScratch
    );
    normalEndpointCartographic = ellipsoid.cartesianToCartographic(
      normalEndpoint,
      endPosCartographicScratch
    );
  }
  normalEndpointCartographic.height = 0;
  const normalEndpointProjected = projection.project(
    normalEndpointCartographic,
    result
  );
  result = Cartesian3_default.subtract(
    normalEndpointProjected,
    projectedPosition,
    result
  );
  result.z = 0;
  result = Cartesian3_default.normalize(result, result);
  if (flipNormal) {
    Cartesian3_default.negate(result, result);
  }
  return result;
}
var adjustHeightNormalScratch = new Cartesian3_default();
var adjustHeightOffsetScratch = new Cartesian3_default();
function adjustHeights(bottom, top, minHeight, maxHeight, adjustHeightBottom, adjustHeightTop) {
  const adjustHeightNormal = Cartesian3_default.subtract(
    top,
    bottom,
    adjustHeightNormalScratch
  );
  Cartesian3_default.normalize(adjustHeightNormal, adjustHeightNormal);
  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;
  let adjustHeightOffset = Cartesian3_default.multiplyByScalar(
    adjustHeightNormal,
    distanceForBottom,
    adjustHeightOffsetScratch
  );
  Cartesian3_default.add(bottom, adjustHeightOffset, adjustHeightBottom);
  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;
  adjustHeightOffset = Cartesian3_default.multiplyByScalar(
    adjustHeightNormal,
    distanceForTop,
    adjustHeightOffsetScratch
  );
  Cartesian3_default.add(top, adjustHeightOffset, adjustHeightTop);
}
var nudgeDirectionScratch = new Cartesian3_default();
function nudgeXZ(start, end) {
  const startToXZdistance = Plane_default.getPointDistance(XZ_PLANE, start);
  const endToXZdistance = Plane_default.getPointDistance(XZ_PLANE, end);
  let offset = nudgeDirectionScratch;
  if (Math_default.equalsEpsilon(startToXZdistance, 0, Math_default.EPSILON2)) {
    offset = direction(end, start, offset);
    Cartesian3_default.multiplyByScalar(offset, Math_default.EPSILON2, offset);
    Cartesian3_default.add(start, offset, start);
  } else if (Math_default.equalsEpsilon(endToXZdistance, 0, Math_default.EPSILON2)) {
    offset = direction(start, end, offset);
    Cartesian3_default.multiplyByScalar(offset, Math_default.EPSILON2, offset);
    Cartesian3_default.add(end, offset, end);
  }
}
function nudgeCartographic(start, end) {
  const absStartLon = Math.abs(start.longitude);
  const absEndLon = Math.abs(end.longitude);
  if (Math_default.equalsEpsilon(absStartLon, Math_default.PI, Math_default.EPSILON11)) {
    const endSign = Math_default.sign(end.longitude);
    start.longitude = endSign * (absStartLon - Math_default.EPSILON11);
    return 1;
  } else if (Math_default.equalsEpsilon(absEndLon, Math_default.PI, Math_default.EPSILON11)) {
    const startSign = Math_default.sign(start.longitude);
    end.longitude = startSign * (absEndLon - Math_default.EPSILON11);
    return 2;
  }
  return 0;
}
var startCartographicScratch = new Cartographic_default();
var endCartographicScratch = new Cartographic_default();
var segmentStartTopScratch = new Cartesian3_default();
var segmentEndTopScratch = new Cartesian3_default();
var segmentStartBottomScratch = new Cartesian3_default();
var segmentEndBottomScratch = new Cartesian3_default();
var segmentStartNormalScratch = new Cartesian3_default();
var segmentEndNormalScratch = new Cartesian3_default();
var getHeightCartographics = [
  startCartographicScratch,
  endCartographicScratch
];
var getHeightRectangleScratch = new Rectangle_default();
var adjustHeightStartTopScratch = new Cartesian3_default();
var adjustHeightEndTopScratch = new Cartesian3_default();
var adjustHeightStartBottomScratch = new Cartesian3_default();
var adjustHeightEndBottomScratch = new Cartesian3_default();
var segmentStart2DScratch = new Cartesian3_default();
var segmentEnd2DScratch = new Cartesian3_default();
var segmentStartNormal2DScratch = new Cartesian3_default();
var segmentEndNormal2DScratch = new Cartesian3_default();
var offsetScratch3 = new Cartesian3_default();
var startUpScratch = new Cartesian3_default();
var endUpScratch = new Cartesian3_default();
var rightScratch2 = new Cartesian3_default();
var startPlaneNormalScratch = new Cartesian3_default();
var endPlaneNormalScratch = new Cartesian3_default();
var encodeScratch2 = new EncodedCartesian3_default();
var encodeScratch2D = new EncodedCartesian3_default();
var forwardOffset2DScratch = new Cartesian3_default();
var right2DScratch = new Cartesian3_default();
var normalNudgeScratch = new Cartesian3_default();
var scratchBoundingSpheres = [new BoundingSphere_default(), new BoundingSphere_default()];
var REFERENCE_INDICES = [
  0,
  2,
  1,
  0,
  3,
  2,
  0,
  7,
  3,
  0,
  4,
  7,
  0,
  5,
  4,
  0,
  1,
  5,
  5,
  7,
  4,
  5,
  6,
  7,
  5,
  2,
  6,
  5,
  1,
  2,
  3,
  6,
  2,
  3,
  7,
  6
];
var REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;
function generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes) {
  let i;
  let index;
  const ellipsoid = projection._ellipsoid;
  const segmentCount = bottomPositionsArray.length / 3 - 1;
  const vertexCount = segmentCount * 8;
  const arraySizeVec4 = vertexCount * 4;
  const indexCount = segmentCount * 36;
  const indices = vertexCount > 65535 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);
  const positionsArray = new Float64Array(vertexCount * 3);
  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);
  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);
  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);
  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(
    arraySizeVec4
  );
  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(
    arraySizeVec4
  );
  let startHiLo2D;
  let offsetAndRight2D;
  let startEndNormals2D;
  let texcoordNormalization2D;
  if (compute2dAttributes) {
    startHiLo2D = new Float32Array(arraySizeVec4);
    offsetAndRight2D = new Float32Array(arraySizeVec4);
    startEndNormals2D = new Float32Array(arraySizeVec4);
    texcoordNormalization2D = new Float32Array(vertexCount * 2);
  }
  const cartographicsLength = cartographicsArray.length / 2;
  let length2D = 0;
  const startCartographic = startCartographicScratch;
  startCartographic.height = 0;
  const endCartographic = endCartographicScratch;
  endCartographic.height = 0;
  let segmentStartCartesian = segmentStartTopScratch;
  let segmentEndCartesian = segmentEndTopScratch;
  if (compute2dAttributes) {
    index = 0;
    for (i = 1; i < cartographicsLength; i++) {
      startCartographic.latitude = cartographicsArray[index];
      startCartographic.longitude = cartographicsArray[index + 1];
      endCartographic.latitude = cartographicsArray[index + 2];
      endCartographic.longitude = cartographicsArray[index + 3];
      segmentStartCartesian = projection.project(
        startCartographic,
        segmentStartCartesian
      );
      segmentEndCartesian = projection.project(
        endCartographic,
        segmentEndCartesian
      );
      length2D += Cartesian3_default.distance(
        segmentStartCartesian,
        segmentEndCartesian
      );
      index += 2;
    }
  }
  const positionsLength = topPositionsArray.length / 3;
  segmentEndCartesian = Cartesian3_default.unpack(
    topPositionsArray,
    0,
    segmentEndCartesian
  );
  let length3D = 0;
  index = 3;
  for (i = 1; i < positionsLength; i++) {
    segmentStartCartesian = Cartesian3_default.clone(
      segmentEndCartesian,
      segmentStartCartesian
    );
    segmentEndCartesian = Cartesian3_default.unpack(
      topPositionsArray,
      index,
      segmentEndCartesian
    );
    length3D += Cartesian3_default.distance(segmentStartCartesian, segmentEndCartesian);
    index += 3;
  }
  let j;
  index = 3;
  let cartographicsIndex = 0;
  let vec2sWriteIndex = 0;
  let vec3sWriteIndex = 0;
  let vec4sWriteIndex = 0;
  let miterBroken = false;
  let endBottom = Cartesian3_default.unpack(
    bottomPositionsArray,
    0,
    segmentEndBottomScratch
  );
  let endTop = Cartesian3_default.unpack(topPositionsArray, 0, segmentEndTopScratch);
  let endGeometryNormal = Cartesian3_default.unpack(
    normalsArray,
    0,
    segmentEndNormalScratch
  );
  if (loop) {
    const preEndBottom = Cartesian3_default.unpack(
      bottomPositionsArray,
      bottomPositionsArray.length - 6,
      segmentStartBottomScratch
    );
    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {
      endGeometryNormal = Cartesian3_default.negate(
        endGeometryNormal,
        endGeometryNormal
      );
    }
  }
  let lengthSoFar3D = 0;
  let lengthSoFar2D = 0;
  let sumHeights = 0;
  for (i = 0; i < segmentCount; i++) {
    const startBottom = Cartesian3_default.clone(endBottom, segmentStartBottomScratch);
    const startTop = Cartesian3_default.clone(endTop, segmentStartTopScratch);
    let startGeometryNormal = Cartesian3_default.clone(
      endGeometryNormal,
      segmentStartNormalScratch
    );
    if (miterBroken) {
      startGeometryNormal = Cartesian3_default.negate(
        startGeometryNormal,
        startGeometryNormal
      );
    }
    endBottom = Cartesian3_default.unpack(
      bottomPositionsArray,
      index,
      segmentEndBottomScratch
    );
    endTop = Cartesian3_default.unpack(topPositionsArray, index, segmentEndTopScratch);
    endGeometryNormal = Cartesian3_default.unpack(
      normalsArray,
      index,
      segmentEndNormalScratch
    );
    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);
    startCartographic.latitude = cartographicsArray[cartographicsIndex];
    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];
    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];
    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];
    let start2D;
    let end2D;
    let startGeometryNormal2D;
    let endGeometryNormal2D;
    if (compute2dAttributes) {
      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);
      start2D = projection.project(startCartographic, segmentStart2DScratch);
      end2D = projection.project(endCartographic, segmentEnd2DScratch);
      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);
      direction2D.y = Math.abs(direction2D.y);
      startGeometryNormal2D = segmentStartNormal2DScratch;
      endGeometryNormal2D = segmentEndNormal2DScratch;
      if (nudgeResult === 0 || Cartesian3_default.dot(direction2D, Cartesian3_default.UNIT_Y) > MITER_BREAK_SMALL) {
        startGeometryNormal2D = projectNormal(
          projection,
          startCartographic,
          startGeometryNormal,
          start2D,
          segmentStartNormal2DScratch
        );
        endGeometryNormal2D = projectNormal(
          projection,
          endCartographic,
          endGeometryNormal,
          end2D,
          segmentEndNormal2DScratch
        );
      } else if (nudgeResult === 1) {
        endGeometryNormal2D = projectNormal(
          projection,
          endCartographic,
          endGeometryNormal,
          end2D,
          segmentEndNormal2DScratch
        );
        startGeometryNormal2D.x = 0;
        startGeometryNormal2D.y = Math_default.sign(
          startCartographic.longitude - Math.abs(endCartographic.longitude)
        );
        startGeometryNormal2D.z = 0;
      } else {
        startGeometryNormal2D = projectNormal(
          projection,
          startCartographic,
          startGeometryNormal,
          start2D,
          segmentStartNormal2DScratch
        );
        endGeometryNormal2D.x = 0;
        endGeometryNormal2D.y = Math_default.sign(
          startCartographic.longitude - endCartographic.longitude
        );
        endGeometryNormal2D.z = 0;
      }
    }
    const segmentLength3D = Cartesian3_default.distance(startTop, endTop);
    const encodedStart = EncodedCartesian3_default.fromCartesian(
      startBottom,
      encodeScratch2
    );
    const forwardOffset = Cartesian3_default.subtract(
      endBottom,
      startBottom,
      offsetScratch3
    );
    const forward = Cartesian3_default.normalize(forwardOffset, rightScratch2);
    let startUp = Cartesian3_default.subtract(startTop, startBottom, startUpScratch);
    startUp = Cartesian3_default.normalize(startUp, startUp);
    let rightNormal = Cartesian3_default.cross(forward, startUp, rightScratch2);
    rightNormal = Cartesian3_default.normalize(rightNormal, rightNormal);
    let startPlaneNormal = Cartesian3_default.cross(
      startUp,
      startGeometryNormal,
      startPlaneNormalScratch
    );
    startPlaneNormal = Cartesian3_default.normalize(startPlaneNormal, startPlaneNormal);
    let endUp = Cartesian3_default.subtract(endTop, endBottom, endUpScratch);
    endUp = Cartesian3_default.normalize(endUp, endUp);
    let endPlaneNormal = Cartesian3_default.cross(
      endGeometryNormal,
      endUp,
      endPlaneNormalScratch
    );
    endPlaneNormal = Cartesian3_default.normalize(endPlaneNormal, endPlaneNormal);
    const texcoordNormalization3DX = segmentLength3D / length3D;
    const texcoordNormalization3DY = lengthSoFar3D / length3D;
    let segmentLength2D = 0;
    let encodedStart2D;
    let forwardOffset2D;
    let right2D;
    let texcoordNormalization2DX = 0;
    let texcoordNormalization2DY = 0;
    if (compute2dAttributes) {
      segmentLength2D = Cartesian3_default.distance(start2D, end2D);
      encodedStart2D = EncodedCartesian3_default.fromCartesian(
        start2D,
        encodeScratch2D
      );
      forwardOffset2D = Cartesian3_default.subtract(
        end2D,
        start2D,
        forwardOffset2DScratch
      );
      right2D = Cartesian3_default.normalize(forwardOffset2D, right2DScratch);
      const swap2 = right2D.x;
      right2D.x = right2D.y;
      right2D.y = -swap2;
      texcoordNormalization2DX = segmentLength2D / length2D;
      texcoordNormalization2DY = lengthSoFar2D / length2D;
    }
    for (j = 0; j < 8; j++) {
      const vec4Index = vec4sWriteIndex + j * 4;
      const vec2Index = vec2sWriteIndex + j * 2;
      const wIndex = vec4Index + 3;
      const rightPlaneSide = j < 4 ? 1 : -1;
      const topBottomSide = j === 2 || j === 3 || j === 6 || j === 7 ? 1 : -1;
      Cartesian3_default.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);
      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;
      Cartesian3_default.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);
      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;
      Cartesian3_default.pack(
        startPlaneNormal,
        startNormalAndForwardOffsetZ,
        vec4Index
      );
      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;
      Cartesian3_default.pack(
        endPlaneNormal,
        endNormalAndTextureCoordinateNormalizationX,
        vec4Index
      );
      endNormalAndTextureCoordinateNormalizationX[wIndex] = texcoordNormalization3DX * rightPlaneSide;
      Cartesian3_default.pack(
        rightNormal,
        rightNormalAndTextureCoordinateNormalizationY,
        vec4Index
      );
      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;
      if (texcoordNormalization === 0 && topBottomSide < 0) {
        texcoordNormalization = 9;
      }
      rightNormalAndTextureCoordinateNormalizationY[wIndex] = texcoordNormalization;
      if (compute2dAttributes) {
        startHiLo2D[vec4Index] = encodedStart2D.high.x;
        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;
        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;
        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;
        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;
        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;
        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;
        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;
        offsetAndRight2D[vec4Index] = forwardOffset2D.x;
        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;
        offsetAndRight2D[vec4Index + 2] = right2D.x;
        offsetAndRight2D[vec4Index + 3] = right2D.y;
        texcoordNormalization2D[vec2Index] = texcoordNormalization2DX * rightPlaneSide;
        texcoordNormalization = texcoordNormalization2DY * topBottomSide;
        if (texcoordNormalization === 0 && topBottomSide < 0) {
          texcoordNormalization = 9;
        }
        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;
      }
    }
    const adjustHeightStartBottom = adjustHeightStartBottomScratch;
    const adjustHeightEndBottom = adjustHeightEndBottomScratch;
    const adjustHeightStartTop = adjustHeightStartTopScratch;
    const adjustHeightEndTop = adjustHeightEndTopScratch;
    const getHeightsRectangle = Rectangle_default.fromCartographicArray(
      getHeightCartographics,
      getHeightRectangleScratch
    );
    const minMaxHeights = ApproximateTerrainHeights_default.getMinimumMaximumHeights(
      getHeightsRectangle,
      ellipsoid
    );
    const minHeight = minMaxHeights.minimumTerrainHeight;
    const maxHeight = minMaxHeights.maximumTerrainHeight;
    sumHeights += minHeight;
    sumHeights += maxHeight;
    adjustHeights(
      startBottom,
      startTop,
      minHeight,
      maxHeight,
      adjustHeightStartBottom,
      adjustHeightStartTop
    );
    adjustHeights(
      endBottom,
      endTop,
      minHeight,
      maxHeight,
      adjustHeightEndBottom,
      adjustHeightEndTop
    );
    let normalNudge = Cartesian3_default.multiplyByScalar(
      rightNormal,
      Math_default.EPSILON5,
      normalNudgeScratch
    );
    Cartesian3_default.add(
      adjustHeightStartBottom,
      normalNudge,
      adjustHeightStartBottom
    );
    Cartesian3_default.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);
    Cartesian3_default.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);
    Cartesian3_default.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);
    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);
    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);
    Cartesian3_default.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);
    Cartesian3_default.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);
    Cartesian3_default.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);
    Cartesian3_default.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);
    normalNudge = Cartesian3_default.multiplyByScalar(
      rightNormal,
      -2 * Math_default.EPSILON5,
      normalNudgeScratch
    );
    Cartesian3_default.add(
      adjustHeightStartBottom,
      normalNudge,
      adjustHeightStartBottom
    );
    Cartesian3_default.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);
    Cartesian3_default.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);
    Cartesian3_default.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);
    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);
    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);
    Cartesian3_default.pack(
      adjustHeightStartBottom,
      positionsArray,
      vec3sWriteIndex + 12
    );
    Cartesian3_default.pack(
      adjustHeightEndBottom,
      positionsArray,
      vec3sWriteIndex + 15
    );
    Cartesian3_default.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);
    Cartesian3_default.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);
    cartographicsIndex += 2;
    index += 3;
    vec2sWriteIndex += 16;
    vec3sWriteIndex += 24;
    vec4sWriteIndex += 32;
    lengthSoFar3D += segmentLength3D;
    lengthSoFar2D += segmentLength2D;
  }
  index = 0;
  let indexOffset = 0;
  for (i = 0; i < segmentCount; i++) {
    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {
      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;
    }
    indexOffset += 8;
    index += REFERENCE_INDICES_LENGTH;
  }
  const boundingSpheres = scratchBoundingSpheres;
  BoundingSphere_default.fromVertices(
    bottomPositionsArray,
    Cartesian3_default.ZERO,
    3,
    boundingSpheres[0]
  );
  BoundingSphere_default.fromVertices(
    topPositionsArray,
    Cartesian3_default.ZERO,
    3,
    boundingSpheres[1]
  );
  const boundingSphere = BoundingSphere_default.fromBoundingSpheres(boundingSpheres);
  boundingSphere.radius += sumHeights / (segmentCount * 2);
  const attributes = {
    position: new GeometryAttribute_default({
      componentDatatype: ComponentDatatype_default.DOUBLE,
      componentsPerAttribute: 3,
      normalize: false,
      values: positionsArray
    }),
    startHiAndForwardOffsetX: getVec4GeometryAttribute(
      startHiAndForwardOffsetX
    ),
    startLoAndForwardOffsetY: getVec4GeometryAttribute(
      startLoAndForwardOffsetY
    ),
    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(
      startNormalAndForwardOffsetZ
    ),
    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(
      endNormalAndTextureCoordinateNormalizationX
    ),
    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(
      rightNormalAndTextureCoordinateNormalizationY
    )
  };
  if (compute2dAttributes) {
    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);
    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);
    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);
    attributes.texcoordNormalization2D = new GeometryAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 2,
      normalize: false,
      values: texcoordNormalization2D
    });
  }
  return new Geometry_default({
    attributes,
    indices,
    boundingSphere
  });
}
function getVec4GeometryAttribute(typedArray) {
  return new GeometryAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    values: typedArray
  });
}
GroundPolylineGeometry._projectNormal = projectNormal;
var GroundPolylineGeometry_default = GroundPolylineGeometry;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/PolylineShadowVolumeFS.js
var PolylineShadowVolumeFS_default = '#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n\nvarying vec4 v_startPlaneNormalEcAndHalfWidth;\nvarying vec4 v_endPlaneNormalEcAndBatchId;\nvarying vec4 v_rightPlaneEC; // Technically can compute distance for this here\nvarying vec4 v_endEcAndStartEcX;\nvarying vec4 v_texcoordNormalizationAndStartEcYZ;\n\n#ifdef PER_INSTANCE_COLOR\nvarying vec4 v_color;\n#endif\n\nvoid main(void)\n{\n    float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));\n    vec3 ecStart = vec3(v_endEcAndStartEcX.w, v_texcoordNormalizationAndStartEcYZ.zw);\n\n    // Discard for sky\n    if (logDepthOrDepth == 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    eyeCoordinate /= eyeCoordinate.w;\n\n    float halfMaxWidth = v_startPlaneNormalEcAndHalfWidth.w * czm_metersPerPixel(eyeCoordinate);\n    // Check distance of the eye coordinate against the right-facing plane\n    float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);\n\n    // Check eye coordinate against the mitering planes\n    float distanceFromStart = czm_planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz, -dot(ecStart, v_startPlaneNormalEcAndHalfWidth.xyz), eyeCoordinate.xyz);\n    float distanceFromEnd = czm_planeDistance(v_endPlaneNormalEcAndBatchId.xyz, -dot(v_endEcAndStartEcX.xyz, v_endPlaneNormalEcAndBatchId.xyz), eyeCoordinate.xyz);\n\n    if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    // Check distance of the eye coordinate against start and end planes with normals in the right plane.\n    // For computing unskewed lengthwise texture coordinate.\n    // Can also be used for clipping extremely pointy miters, but in practice unnecessary because of miter breaking.\n\n    // aligned plane: cross the right plane normal with miter plane normal, then cross the result with right again to point it more "forward"\n    vec3 alignedPlaneNormal;\n\n    // start aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_startPlaneNormalEcAndHalfWidth.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromStart = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, ecStart), eyeCoordinate.xyz);\n\n    // end aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_endPlaneNormalEcAndBatchId.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromEnd = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, v_endEcAndStartEcX.xyz), eyeCoordinate.xyz);\n\n#ifdef PER_INSTANCE_COLOR\n    gl_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Clamp - distance to aligned planes may be negative due to mitering,\n    // so fragment texture coordinate might be out-of-bounds.\n    float s = clamp(distanceFromStart / (distanceFromStart + distanceFromEnd), 0.0, 1.0);\n    s = (s * v_texcoordNormalizationAndStartEcYZ.x) + v_texcoordNormalizationAndStartEcYZ.y;\n    float t = (widthwiseDistance + halfMaxWidth) / (2.0 * halfMaxWidth);\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, t);\n    materialInput.str = vec3(s, t, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    gl_FragColor.rgb *= gl_FragColor.a;\n\n    czm_writeDepthClamp();\n}\n';

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/PolylineShadowVolumeMorphFS.js
var PolylineShadowVolumeMorphFS_default = "varying vec3 v_forwardDirectionEC;\nvarying vec3 v_texcoordNormalizationAndHalfWidth;\nvarying float v_batchId;\n\n#ifdef PER_INSTANCE_COLOR\nvarying vec4 v_color;\n#else\nvarying vec2 v_alignedPlaneDistances;\nvarying float v_texcoordT;\n#endif\n\nfloat rayPlaneDistanceUnsafe(vec3 origin, vec3 direction, vec3 planeNormal, float planeDistance) {\n    // We don't expect the ray to ever be parallel to the plane\n    return (-planeDistance - dot(planeNormal, origin)) / dot(planeNormal, direction);\n}\n\nvoid main(void)\n{\n    vec4 eyeCoordinate = gl_FragCoord;\n    eyeCoordinate /= eyeCoordinate.w;\n\n#ifdef PER_INSTANCE_COLOR\n    gl_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Use distances for planes aligned with segment to prevent skew in dashing\n    float distanceFromStart = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, -v_forwardDirectionEC, v_forwardDirectionEC.xyz, v_alignedPlaneDistances.x);\n    float distanceFromEnd = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, v_forwardDirectionEC, -v_forwardDirectionEC.xyz, v_alignedPlaneDistances.y);\n\n    // Clamp - distance to aligned planes may be negative due to mitering\n    distanceFromStart = max(0.0, distanceFromStart);\n    distanceFromEnd = max(0.0, distanceFromEnd);\n\n    float s = distanceFromStart / (distanceFromStart + distanceFromEnd);\n    s = (s * v_texcoordNormalizationAndHalfWidth.x) + v_texcoordNormalizationAndHalfWidth.y;\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, v_texcoordT);\n    materialInput.str = vec3(s, v_texcoordT, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/PolylineShadowVolumeMorphVS.js
var PolylineShadowVolumeMorphVS_default = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;

attribute vec4 startHiAndForwardOffsetX;
attribute vec4 startLoAndForwardOffsetY;
attribute vec4 startNormalAndForwardOffsetZ;
attribute vec4 endNormalAndTextureCoordinateNormalizationX;
attribute vec4 rightNormalAndTextureCoordinateNormalizationY;
attribute vec4 startHiLo2D;
attribute vec4 offsetAndRight2D;
attribute vec4 startEndNormals2D;
attribute vec2 texcoordNormalization2D;

attribute float batchId;

varying vec3 v_forwardDirectionEC;
varying vec3 v_texcoordNormalizationAndHalfWidth;
varying float v_batchId;

// For materials
#ifdef WIDTH_VARYING
varying float v_width;
#endif
#ifdef ANGLE_VARYING
varying float v_polylineAngle;
#endif

#ifdef PER_INSTANCE_COLOR
varying vec4 v_color;
#else
varying vec2 v_alignedPlaneDistances;
varying float v_texcoordT;
#endif

// Morphing planes using SLERP or NLERP doesn't seem to work, so instead draw the material directly on the shadow volume.
// Morph views are from very far away and aren't meant to be used precisely, so this should be sufficient.
void main()
{
    v_batchId = batchId;

    // Start position
    vec4 posRelativeToEye2D = czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw));
    vec4 posRelativeToEye3D = czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz);
    vec4 posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
    vec3 posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
    vec3 posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
    vec3 startEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;

    // Start plane
    vec4 startPlane2D;
    vec4 startPlane3D;
    startPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.xy);
    startPlane3D.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;
    startPlane2D.w = -dot(startPlane2D.xyz, posEc2D);
    startPlane3D.w = -dot(startPlane3D.xyz, posEc3D);

    // Right plane
    vec4 rightPlane2D;
    vec4 rightPlane3D;
    rightPlane2D.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);
    rightPlane3D.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;
    rightPlane2D.w = -dot(rightPlane2D.xyz, posEc2D);
    rightPlane3D.w = -dot(rightPlane3D.xyz, posEc3D);

    // End position
    posRelativeToEye2D = posRelativeToEye2D + vec4(0.0, offsetAndRight2D.xy, 0.0);
    posRelativeToEye3D = posRelativeToEye3D + vec4(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w, 0.0);
    posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
    posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
    posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
    vec3 endEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;
    vec3 forwardEc3D = czm_normal * normalize(vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w));
    vec3 forwardEc2D = czm_normal * normalize(vec3(0.0, offsetAndRight2D.xy));

    // End plane
    vec4 endPlane2D;
    vec4 endPlane3D;
    endPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.zw);
    endPlane3D.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;
    endPlane2D.w = -dot(endPlane2D.xyz, posEc2D);
    endPlane3D.w = -dot(endPlane3D.xyz, posEc3D);

    // Forward direction
    v_forwardDirectionEC = normalize(endEC - startEC);

    vec2 cleanTexcoordNormalization2D;
    cleanTexcoordNormalization2D.x = abs(texcoordNormalization2D.x);
    cleanTexcoordNormalization2D.y = czm_branchFreeTernary(texcoordNormalization2D.y > 1.0, 0.0, abs(texcoordNormalization2D.y));
    vec2 cleanTexcoordNormalization3D;
    cleanTexcoordNormalization3D.x = abs(endNormalAndTextureCoordinateNormalizationX.w);
    cleanTexcoordNormalization3D.y = rightNormalAndTextureCoordinateNormalizationY.w;
    cleanTexcoordNormalization3D.y = czm_branchFreeTernary(cleanTexcoordNormalization3D.y > 1.0, 0.0, abs(cleanTexcoordNormalization3D.y));

    v_texcoordNormalizationAndHalfWidth.xy = mix(cleanTexcoordNormalization2D, cleanTexcoordNormalization3D, czm_morphTime);

#ifdef PER_INSTANCE_COLOR
    v_color = czm_batchTable_color(batchId);
#else // PER_INSTANCE_COLOR
    // For computing texture coordinates

    v_alignedPlaneDistances.x = -dot(v_forwardDirectionEC, startEC);
    v_alignedPlaneDistances.y = -dot(-v_forwardDirectionEC, endEC);
#endif // PER_INSTANCE_COLOR

#ifdef WIDTH_VARYING
    float width = czm_batchTable_width(batchId);
    float halfWidth = width * 0.5;
    v_width = width;
    v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#else
    float halfWidth = 0.5 * czm_batchTable_width(batchId);
    v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#endif

    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.
    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.
    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.
    // Since this is morphing, compute both 3D and 2D positions and then blend.

    // ****** 3D ******
    // Check distance to the end plane and start plane, pick the plane that is closer
    vec4 positionEc3D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position3DHigh, position3DLow); // w = 1.0, see czm_computePosition
    float absStartPlaneDistance = abs(czm_planeDistance(startPlane3D, positionEc3D.xyz));
    float absEndPlaneDistance = abs(czm_planeDistance(endPlane3D, positionEc3D.xyz));
    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane3D.xyz, endPlane3D.xyz);
    vec3 upOrDown = normalize(cross(rightPlane3D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.
    vec3 normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.

    // Nudge the top vertex upwards to prevent flickering
    vec3 geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc3D));
    geodeticSurfaceNormal *= float(0.0 <= rightNormalAndTextureCoordinateNormalizationY.w && rightNormalAndTextureCoordinateNormalizationY.w <= 1.0);
    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
    positionEc3D.xyz += geodeticSurfaceNormal;

    // Determine if this vertex is on the "left" or "right"
    normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);

    // A "perfect" implementation would push along normals according to the angle against forward.
    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.
    positionEc3D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc3D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)

    // ****** 2D ******
    // Check distance to the end plane and start plane, pick the plane that is closer
    vec4 positionEc2D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy); // w = 1.0, see czm_computePosition
    absStartPlaneDistance = abs(czm_planeDistance(startPlane2D, positionEc2D.xyz));
    absEndPlaneDistance = abs(czm_planeDistance(endPlane2D, positionEc2D.xyz));
    planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane2D.xyz, endPlane2D.xyz);
    upOrDown = normalize(cross(rightPlane2D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.
    normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.

    // Nudge the top vertex upwards to prevent flickering
    geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc2D));
    geodeticSurfaceNormal *= float(0.0 <= texcoordNormalization2D.y && texcoordNormalization2D.y <= 1.0);
    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
    positionEc2D.xyz += geodeticSurfaceNormal;

    // Determine if this vertex is on the "left" or "right"
    normalEC *= sign(texcoordNormalization2D.x);
#ifndef PER_INSTANCE_COLOR
    // Use vertex's sidedness to compute its texture coordinate.
    v_texcoordT = clamp(sign(texcoordNormalization2D.x), 0.0, 1.0);
#endif

    // A "perfect" implementation would push along normals according to the angle against forward.
    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.
    positionEc2D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc2D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)

    // Blend for actual position
    gl_Position = czm_projection * mix(positionEc2D, positionEc3D, czm_morphTime);

#ifdef ANGLE_VARYING
    // Approximate relative screen space direction of the line.
    vec2 approxLineDirection = normalize(vec2(v_forwardDirectionEC.x, -v_forwardDirectionEC.y));
    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);
    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);
#endif
}
`;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/PolylineShadowVolumeVS.js
var PolylineShadowVolumeVS_default = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\n\n// In 2D and in 3D, texture coordinate normalization component signs encodes:\n// * X sign - sidedness relative to right plane\n// * Y sign - is negative OR magnitude is greater than 1.0 if vertex is on bottom of volume\n#ifndef COLUMBUS_VIEW_2D\nattribute vec4 startHiAndForwardOffsetX;\nattribute vec4 startLoAndForwardOffsetY;\nattribute vec4 startNormalAndForwardOffsetZ;\nattribute vec4 endNormalAndTextureCoordinateNormalizationX;\nattribute vec4 rightNormalAndTextureCoordinateNormalizationY;\n#else\nattribute vec4 startHiLo2D;\nattribute vec4 offsetAndRight2D;\nattribute vec4 startEndNormals2D;\nattribute vec2 texcoordNormalization2D;\n#endif\n\nattribute float batchId;\n\nvarying vec4 v_startPlaneNormalEcAndHalfWidth;\nvarying vec4 v_endPlaneNormalEcAndBatchId;\nvarying vec4 v_rightPlaneEC;\nvarying vec4 v_endEcAndStartEcX;\nvarying vec4 v_texcoordNormalizationAndStartEcYZ;\n\n// For materials\n#ifdef WIDTH_VARYING\nvarying float v_width;\n#endif\n#ifdef ANGLE_VARYING\nvarying float v_polylineAngle;\n#endif\n\n#ifdef PER_INSTANCE_COLOR\nvarying vec4 v_color;\n#endif\n\nvoid main()\n{\n#ifdef COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw))).xyz;\n\n    vec3 forwardDirectionEC = czm_normal * vec3(0.0, offsetAndRight2D.xy);\n    vec3 ecEnd = forwardDirectionEC + ecStart;\n    forwardDirectionEC = normalize(forwardDirectionEC);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.xy);\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.zw);\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(texcoordNormalization2D.x);\n    v_texcoordNormalizationAndStartEcYZ.y = texcoordNormalization2D.y;\n\n#else // COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz)).xyz;\n    vec3 offset = czm_normal * vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w);\n    vec3 ecEnd = ecStart + offset;\n\n    vec3 forwardDirectionEC = normalize(offset);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w);\n    v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w;\n\n#endif // COLUMBUS_VIEW_2D\n\n    v_endEcAndStartEcX.xyz = ecEnd;\n    v_endEcAndStartEcX.w = ecStart.x;\n    v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz;\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif // PER_INSTANCE_COLOR\n\n    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.\n    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.\n    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.\n    vec4 positionRelativeToEye = czm_computePosition();\n\n    // Check distance to the end plane and start plane, pick the plane that is closer\n    vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye; // w = 1.0, see czm_computePosition\n    float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz));\n    float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz));\n    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz);\n    vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.\n    vec3 normalEC = normalize(cross(planeDirection, upOrDown));           // In practice, the opposite seems to work too.\n\n    // Extrude bottom vertices downward for far view distances, like for GroundPrimitives\n    upOrDown = cross(forwardDirectionEC, normalEC);\n    upOrDown = float(czm_sceneMode == czm_sceneMode3D) * upOrDown;\n    upOrDown = float(v_texcoordNormalizationAndStartEcYZ.y > 1.0 || v_texcoordNormalizationAndStartEcYZ.y < 0.0) * upOrDown;\n    upOrDown = min(GLOBE_MINIMUM_ALTITUDE, czm_geometricToleranceOverMeter * length(positionRelativeToEye.xyz)) * upOrDown;\n    positionEC.xyz += upOrDown;\n\n    v_texcoordNormalizationAndStartEcYZ.y = czm_branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y > 1.0, 0.0, abs(v_texcoordNormalizationAndStartEcYZ.y));\n\n    // Determine distance along normalEC to push for a volume of appropriate width.\n    // Make volumes about double pixel width for a conservative fit - in practice the\n    // extra cost here is minimal compared to the loose volume heights.\n    //\n    // N = normalEC (guaranteed "right-facing")\n    // R = rightEC\n    // p = angle between N and R\n    // w = distance to push along R if R == N\n    // d = distance to push along N\n    //\n    //   N   R\n    //  {  p| }      * cos(p) = dot(N, R) = w / d\n    //  d  |  |w    * d = w / dot(N, R)\n    //    { | }\n    //       o---------- polyline segment ---->\n    //\n    float width = czm_batchTable_width(batchId);\n#ifdef WIDTH_VARYING\n    v_width = width;\n#endif\n\n    v_startPlaneNormalEcAndHalfWidth.xyz = startPlaneEC.xyz;\n    v_startPlaneNormalEcAndHalfWidth.w = width * 0.5;\n\n    v_endPlaneNormalEcAndBatchId.xyz = endPlaneEC.xyz;\n    v_endPlaneNormalEcAndBatchId.w = batchId;\n\n    width = width * max(0.0, czm_metersPerPixel(positionEC)); // width = distance to push along R\n    width = width / dot(normalEC, v_rightPlaneEC.xyz); // width = distance to push along N\n\n    // Determine if this vertex is on the "left" or "right"\n#ifdef COLUMBUS_VIEW_2D\n        normalEC *= sign(texcoordNormalization2D.x);\n#else\n        normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);\n#endif\n\n    positionEC.xyz += width * normalEC;\n    gl_Position = czm_depthClamp(czm_projection * positionEC);\n\n#ifdef ANGLE_VARYING\n    // Approximate relative screen space direction of the line.\n    vec2 approxLineDirection = normalize(vec2(forwardDirectionEC.x, -forwardDirectionEC.y));\n    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);\n    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);\n#endif\n}\n';

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Appearances/PolylineColorAppearanceVS.js
var PolylineColorAppearanceVS_default = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_color = color;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/PolylineCommon.js
var PolylineCommon_default = "void clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane,\n    out vec4 clippedPositionEC)\n{\n    culledByNearPlane = false;\n    clipped = false;\n\n    vec3 p0ToP1 = p1 - p0;\n    float magnitude = length(p0ToP1);\n    vec3 direction = normalize(p0ToP1);\n\n    // Distance that p0 is behind the near plane. Negative means p0 is\n    // in front of the near plane.\n    float endPoint0Distance =  czm_currentFrustum.x + p0.z;\n\n    // Camera looks down -Z.\n    // When moving a point along +Z: LESS VISIBLE\n    //   * Points in front of the camera move closer to the camera.\n    //   * Points behind the camrea move farther away from the camera.\n    // When moving a point along -Z: MORE VISIBLE\n    //   * Points in front of the camera move farther away from the camera.\n    //   * Points behind the camera move closer to the camera.\n\n    // Positive denominator: -Z, becoming more visible\n    // Negative denominator: +Z, becoming less visible\n    // Nearly zero: parallel to near plane\n    float denominator = -direction.z;\n\n    if (endPoint0Distance > 0.0 && abs(denominator) < czm_epsilon7)\n    {\n        // p0 is behind the near plane and the line to p1 is nearly parallel to\n        // the near plane, so cull the segment completely.\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance > 0.0)\n    {\n        // p0 is behind the near plane, and the line to p1 is moving distinctly\n        // toward or away from it.\n\n        // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction)\n        float t = endPoint0Distance / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            // Near plane intersection is not between the two points.\n            // We already confirmed p0 is behind the naer plane, so now\n            // we know the entire segment is behind it.\n            culledByNearPlane = true;\n        }\n        else\n        {\n            // Segment crosses the near plane, update p0 to lie exactly on it.\n            p0 = p0 + t * direction;\n\n            // Numerical noise might put us a bit on the wrong side of the near plane.\n            // Don't let that happen.\n            p0.z = min(p0.z, -czm_currentFrustum.x);\n\n            clipped = true;\n        }\n    }\n\n    clippedPositionEC = vec4(p0, 1.0);\n    positionWC = czm_eyeToWindowCoordinates(clippedPositionEC);\n}\n\nvec4 getPolylineWindowCoordinatesEC(vec4 positionEC, vec4 prevEC, vec4 nextEC, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    // expandDirection +1 is to the _left_ when looking from positionEC toward nextEC.\n\n#ifdef POLYLINE_DASH\n    // Compute the window coordinates of the points.\n    vec4 positionWindow = czm_eyeToWindowCoordinates(positionEC);\n    vec4 previousWindow = czm_eyeToWindowCoordinates(prevEC);\n    vec4 nextWindow = czm_eyeToWindowCoordinates(nextEC);\n\n    // Determine the relative screen space direction of the line.\n    vec2 lineDir;\n    if (usePrevious) {\n        lineDir = normalize(positionWindow.xy - previousWindow.xy);\n    }\n    else {\n        lineDir = normalize(nextWindow.xy - positionWindow.xy);\n    }\n    angle = atan(lineDir.x, lineDir.y) - 1.570796327; // precomputed atan(1,0)\n\n    // Quantize the angle so it doesn't change rapidly between segments.\n    angle = floor(angle / czm_piOverFour + 0.5) * czm_piOverFour;\n#endif\n\n    vec4 clippedPrevWC, clippedPrevEC;\n    bool prevSegmentClipped, prevSegmentCulled;\n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);\n\n    vec4 clippedNextWC, clippedNextEC;\n    bool nextSegmentClipped, nextSegmentCulled;\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);\n\n    bool segmentClipped, segmentCulled;\n    vec4 clippedPositionWC, clippedPositionEC;\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);\n\n    if (segmentCulled)\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);\n    vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);\n\n    // If a segment was culled, we can't use the corresponding direction\n    // computed above. We should never see both of these be true without\n    // `segmentCulled` above also being true.\n    if (prevSegmentCulled)\n    {\n        directionToPrevWC = -directionToNextWC;\n    }\n    else if (nextSegmentCulled)\n    {\n        directionToNextWC = -directionToPrevWC;\n    }\n\n    vec2 thisSegmentForwardWC, otherSegmentForwardWC;\n    if (usePrevious)\n    {\n        thisSegmentForwardWC = -directionToPrevWC;\n        otherSegmentForwardWC = directionToNextWC;\n    }\n    else\n    {\n        thisSegmentForwardWC = directionToNextWC;\n        otherSegmentForwardWC =  -directionToPrevWC;\n    }\n\n    vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);\n\n    vec2 leftWC = thisSegmentLeftWC;\n    float expandWidth = width * 0.5;\n\n    // When lines are split at the anti-meridian, the position may be at the\n    // same location as the next or previous position, and we need to handle\n    // that to avoid producing NaNs.\n    if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1))\n    {\n        vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);\n\n        vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;\n        float leftSumLength = length(leftSumWC);\n        leftWC = leftSumLength < czm_epsilon6 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);\n\n        // The sine of the angle between the two vectors is given by the formula\n        //         |a x b| = |a||b|sin(theta)\n        // which is\n        //     float sinAngle = length(cross(vec3(leftWC, 0.0), vec3(-thisSegmentForwardWC, 0.0)));\n        // Because the z components of both vectors are zero, the x and y coordinate will be zero.\n        // Therefore, the sine of the angle is just the z component of the cross product.\n        vec2 u = -thisSegmentForwardWC;\n        vec2 v = leftWC;\n        float sinAngle = abs(u.x * v.y - u.y * v.x);\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\n    }\n\n    vec2 offset = leftWC * expandDirection * expandWidth * czm_pixelRatio;\n    return vec4(clippedPositionWC.xy + offset, -clippedPositionWC.z, 1.0) * (czm_projection * clippedPositionEC).w;\n}\n\nvec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    vec4 positionEC = czm_modelViewRelativeToEye * position;\n    vec4 prevEC = czm_modelViewRelativeToEye * previous;\n    vec4 nextEC = czm_modelViewRelativeToEye * next;\n    return getPolylineWindowCoordinatesEC(positionEC, prevEC, nextEC, expandDirection, width, usePrevious, angle);\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/PolylineColorAppearance.js
var defaultVertexShaderSource = `${PolylineCommon_default}
${PolylineColorAppearanceVS_default}`;
var defaultFragmentShaderSource = PerInstanceFlatColorAppearanceFS_default;
if (!FeatureDetection_default.isInternetExplorer()) {
  defaultVertexShaderSource = `#define CLIP_POLYLINE 
${defaultVertexShaderSource}`;
}
function PolylineColorAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = false;
  const vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;
  this.material = void 0;
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(
    options.vertexShaderSource,
    defaultVertexShaderSource
  );
  this._fragmentShaderSource = defaultValue_default(
    options.fragmentShaderSource,
    defaultFragmentShaderSource
  );
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
}
Object.defineProperties(PolylineColorAppearance.prototype, {
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  closed: {
    get: function() {
      return this._closed;
    }
  },
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  }
});
PolylineColorAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_ONLY;
PolylineColorAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PolylineColorAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PolylineColorAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PolylineColorAppearance_default = PolylineColorAppearance;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/Appearances/PolylineMaterialAppearanceVS.js
var PolylineMaterialAppearanceVS_default = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec2 st;\nattribute float batchId;\n\nvarying float v_width;\nvarying vec2 v_st;\nvarying float v_polylineAngle;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_width = width;\n    v_st.s = st.s;\n    v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);\n    v_polylineAngle = angle;\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Shaders/PolylineFS.js
var PolylineFS_default = "#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec2 st = v_st;\n    st.t = czm_readNonPerspective(st.t, gl_FragCoord.w);\n\n    materialInput.s = st.s;\n    materialInput.st = st;\n    materialInput.str = vec3(st, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#ifdef VECTOR_TILE\n    gl_FragColor *= u_highlightColor;\n#endif\n\n    czm_writeLogDepth();\n}\n";

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/PolylineMaterialAppearance.js
var defaultVertexShaderSource2 = `${PolylineCommon_default}
${PolylineMaterialAppearanceVS_default}`;
var defaultFragmentShaderSource2 = PolylineFS_default;
if (!FeatureDetection_default.isInternetExplorer()) {
  defaultVertexShaderSource2 = `#define CLIP_POLYLINE 
${defaultVertexShaderSource2}`;
}
function PolylineMaterialAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = false;
  const vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;
  this.material = defined_default(options.material) ? options.material : Material_default.fromType(Material_default.ColorType);
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(
    options.vertexShaderSource,
    defaultVertexShaderSource2
  );
  this._fragmentShaderSource = defaultValue_default(
    options.fragmentShaderSource,
    defaultFragmentShaderSource2
  );
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
}
Object.defineProperties(PolylineMaterialAppearance.prototype, {
  vertexShaderSource: {
    get: function() {
      let vs = this._vertexShaderSource;
      if (this.material.shaderSource.search(
        /varying\s+float\s+v_polylineAngle;/g
      ) !== -1) {
        vs = `#define POLYLINE_DASH
${vs}`;
      }
      return vs;
    }
  },
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  closed: {
    get: function() {
      return this._closed;
    }
  },
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  }
});
PolylineMaterialAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_AND_ST;
PolylineMaterialAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PolylineMaterialAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PolylineMaterialAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PolylineMaterialAppearance_default = PolylineMaterialAppearance;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Scene/GroundPolylinePrimitive.js
function GroundPolylinePrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.geometryInstances = options.geometryInstances;
  this._hasPerInstanceColors = true;
  let appearance = options.appearance;
  if (!defined_default(appearance)) {
    appearance = new PolylineMaterialAppearance_default();
  }
  this.appearance = appearance;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this._debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._primitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: false,
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: false,
    _createShaderProgramFunction: void 0,
    _createCommandsFunction: void 0,
    _updateAndQueueCommandsFunction: void 0
  };
  this._zIndex = void 0;
  this._ready = false;
  const groundPolylinePrimitive = this;
  this._readyPromise = new Promise((resolve, reject) => {
    groundPolylinePrimitive._completeLoad = () => {
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
      const error = this._error;
      if (!defined_default(error)) {
        resolve(this);
      } else {
        reject(error);
      }
    };
  });
  this._primitive = void 0;
  this._sp = void 0;
  this._sp2D = void 0;
  this._spMorph = void 0;
  this._renderState = getRenderState(false);
  this._renderState3DTiles = getRenderState(true);
  this._renderStateMorph = RenderState_default.fromCache({
    cull: {
      enabled: true,
      face: CullFace_default.FRONT
    },
    depthTest: {
      enabled: true
    },
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND,
    depthMask: false
  });
}
Object.defineProperties(GroundPolylinePrimitive.prototype, {
  interleave: {
    get: function() {
      return this._primitiveOptions.interleave;
    }
  },
  releaseGeometryInstances: {
    get: function() {
      return this._primitiveOptions.releaseGeometryInstances;
    }
  },
  allowPicking: {
    get: function() {
      return this._primitiveOptions.allowPicking;
    }
  },
  asynchronous: {
    get: function() {
      return this._primitiveOptions.asynchronous;
    }
  },
  ready: {
    get: function() {
      return this._ready;
    }
  },
  readyPromise: {
    get: function() {
      return this._readyPromise;
    }
  },
  debugShowShadowVolume: {
    get: function() {
      return this._debugShowShadowVolume;
    }
  }
});
GroundPolylinePrimitive.initializeTerrainHeights = function() {
  return ApproximateTerrainHeights_default.initialize();
};
function createShaderProgram3(groundPolylinePrimitive, frameState, appearance) {
  const context = frameState.context;
  const primitive = groundPolylinePrimitive._primitive;
  const attributeLocations = primitive._attributeLocations;
  let vs = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeVS_default
  );
  vs = Primitive_default._appendShowToShader(primitive, vs);
  vs = Primitive_default._appendDistanceDisplayConditionToShader(primitive, vs);
  vs = Primitive_default._modifyShaderPosition(
    groundPolylinePrimitive,
    vs,
    frameState.scene3DOnly
  );
  let vsMorph = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeMorphVS_default
  );
  vsMorph = Primitive_default._appendShowToShader(primitive, vsMorph);
  vsMorph = Primitive_default._appendDistanceDisplayConditionToShader(
    primitive,
    vsMorph
  );
  vsMorph = Primitive_default._modifyShaderPosition(
    groundPolylinePrimitive,
    vsMorph,
    frameState.scene3DOnly
  );
  let fs = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeFS_default
  );
  const vsDefines = [
    `GLOBE_MINIMUM_ALTITUDE ${frameState.mapProjection.ellipsoid.minimumRadius.toFixed(
      1
    )}`
  ];
  let colorDefine = "";
  let materialShaderSource = "";
  if (defined_default(appearance.material)) {
    materialShaderSource = defined_default(appearance.material) ? appearance.material.shaderSource : "";
    if (materialShaderSource.search(/varying\s+float\s+v_polylineAngle;/g) !== -1) {
      vsDefines.push("ANGLE_VARYING");
    }
    if (materialShaderSource.search(/varying\s+float\s+v_width;/g) !== -1) {
      vsDefines.push("WIDTH_VARYING");
    }
  } else {
    colorDefine = "PER_INSTANCE_COLOR";
  }
  vsDefines.push(colorDefine);
  const fsDefines = groundPolylinePrimitive.debugShowShadowVolume ? ["DEBUG_SHOW_VOLUME", colorDefine] : [colorDefine];
  const vsColor3D = new ShaderSource_default({
    defines: vsDefines,
    sources: [vs]
  });
  const fsColor3D = new ShaderSource_default({
    defines: fsDefines,
    sources: [materialShaderSource, fs]
  });
  groundPolylinePrimitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vsColor3D,
    fragmentShaderSource: fsColor3D,
    attributeLocations
  });
  let colorProgram2D = context.shaderCache.getDerivedShaderProgram(
    groundPolylinePrimitive._sp,
    "2dColor"
  );
  if (!defined_default(colorProgram2D)) {
    const vsColor2D = new ShaderSource_default({
      defines: vsDefines.concat(["COLUMBUS_VIEW_2D"]),
      sources: [vs]
    });
    colorProgram2D = context.shaderCache.createDerivedShaderProgram(
      groundPolylinePrimitive._sp,
      "2dColor",
      {
        context,
        shaderProgram: groundPolylinePrimitive._sp2D,
        vertexShaderSource: vsColor2D,
        fragmentShaderSource: fsColor3D,
        attributeLocations
      }
    );
  }
  groundPolylinePrimitive._sp2D = colorProgram2D;
  let colorProgramMorph = context.shaderCache.getDerivedShaderProgram(
    groundPolylinePrimitive._sp,
    "MorphColor"
  );
  if (!defined_default(colorProgramMorph)) {
    const vsColorMorph = new ShaderSource_default({
      defines: vsDefines.concat([
        `MAX_TERRAIN_HEIGHT ${ApproximateTerrainHeights_default._defaultMaxTerrainHeight.toFixed(
          1
        )}`
      ]),
      sources: [vsMorph]
    });
    fs = primitive._batchTable.getVertexShaderCallback()(
      PolylineShadowVolumeMorphFS_default
    );
    const fsColorMorph = new ShaderSource_default({
      defines: fsDefines,
      sources: [materialShaderSource, fs]
    });
    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(
      groundPolylinePrimitive._sp,
      "MorphColor",
      {
        context,
        shaderProgram: groundPolylinePrimitive._spMorph,
        vertexShaderSource: vsColorMorph,
        fragmentShaderSource: fsColorMorph,
        attributeLocations
      }
    );
  }
  groundPolylinePrimitive._spMorph = colorProgramMorph;
}
function getRenderState(mask3DTiles) {
  return RenderState_default.fromCache({
    cull: {
      enabled: true
    },
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND,
    depthMask: false,
    stencilTest: {
      enabled: mask3DTiles,
      frontFunction: StencilFunction_default.EQUAL,
      frontOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.KEEP,
        zPass: StencilOperation_default.KEEP
      },
      backFunction: StencilFunction_default.EQUAL,
      backOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.KEEP,
        zPass: StencilOperation_default.KEEP
      },
      reference: StencilConstants_default.CESIUM_3D_TILE_MASK,
      mask: StencilConstants_default.CESIUM_3D_TILE_MASK
    }
  });
}
function createCommands3(groundPolylinePrimitive, appearance, material, translucent, colorCommands, pickCommands) {
  const primitive = groundPolylinePrimitive._primitive;
  const length = primitive._va.length;
  colorCommands.length = length;
  pickCommands.length = length;
  const isPolylineColorAppearance = appearance instanceof PolylineColorAppearance_default;
  const materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;
  const uniformMap = primitive._batchTable.getUniformMapCallback()(
    materialUniforms
  );
  for (let i = 0; i < length; i++) {
    const vertexArray = primitive._va[i];
    let command = colorCommands[i];
    if (!defined_default(command)) {
      command = colorCommands[i] = new DrawCommand_default({
        owner: groundPolylinePrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = groundPolylinePrimitive._renderState;
    command.shaderProgram = groundPolylinePrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    command.pickId = "czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)";
    const derivedTilesetCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedTilesetCommand.renderState = groundPolylinePrimitive._renderState3DTiles;
    derivedTilesetCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedTilesetCommand;
    const derived2DCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.color2D
    );
    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;
    command.derivedCommands.color2D = derived2DCommand;
    const derived2DTilesetCommand = DrawCommand_default.shallowClone(
      derivedTilesetCommand,
      derivedTilesetCommand.derivedCommands.color2D
    );
    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;
    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand;
    const derivedMorphCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.colorMorph
    );
    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;
    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;
    derivedMorphCommand.pickId = "czm_batchTable_pickColor(v_batchId)";
    command.derivedCommands.colorMorph = derivedMorphCommand;
  }
}
function updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  if (frameState.mode === SceneMode_default.MORPHING) {
    command = command.derivedCommands.colorMorph;
  } else if (frameState.mode !== SceneMode_default.SCENE3D) {
    command = command.derivedCommands.color2D;
  }
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueueCommands4(groundPolylinePrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume) {
  const primitive = groundPolylinePrimitive._primitive;
  Primitive_default._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingSpheres;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingSpheres = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingSpheres = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingSpheres = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingSpheres = primitive._boundingSphereMorph;
  }
  const morphing = frameState.mode === SceneMode_default.MORPHING;
  const classificationType = groundPolylinePrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN && !morphing;
  let command;
  const passes = frameState.passes;
  if (passes.render || passes.pick && primitive.allowPicking) {
    const colorLength = colorCommands.length;
    for (let j = 0; j < colorLength; ++j) {
      const boundingVolume = boundingSpheres[j];
      if (queueTerrainCommands) {
        command = colorCommands[j];
        updateAndQueueCommand(
          groundPolylinePrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[j].derivedCommands.tileset;
        updateAndQueueCommand(
          groundPolylinePrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
}
GroundPolylinePrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  if (!ApproximateTerrainHeights_default.initialized) {
    if (!this.asynchronous) {
      throw new DeveloperError_default(
        "For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve."
      );
    }
    GroundPolylinePrimitive.initializeTerrainHeights();
    return;
  }
  let i;
  const that = this;
  const primitiveOptions = this._primitiveOptions;
  if (!defined_default(this._primitive)) {
    const geometryInstances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const geometryInstancesLength = geometryInstances.length;
    const groundInstances = new Array(geometryInstancesLength);
    let attributes;
    for (i = 0; i < geometryInstancesLength; ++i) {
      attributes = geometryInstances[i].attributes;
      if (!defined_default(attributes) || !defined_default(attributes.color)) {
        this._hasPerInstanceColors = false;
        break;
      }
    }
    for (i = 0; i < geometryInstancesLength; ++i) {
      const geometryInstance = geometryInstances[i];
      attributes = {};
      const instanceAttributes = geometryInstance.attributes;
      for (const attributeKey in instanceAttributes) {
        if (instanceAttributes.hasOwnProperty(attributeKey)) {
          attributes[attributeKey] = instanceAttributes[attributeKey];
        }
      }
      if (!defined_default(attributes.width)) {
        attributes.width = new GeometryInstanceAttribute_default({
          componentDatatype: ComponentDatatype_default.UNSIGNED_BYTE,
          componentsPerAttribute: 1,
          value: [geometryInstance.geometry.width]
        });
      }
      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;
      GroundPolylineGeometry_default.setProjectionAndEllipsoid(
        geometryInstance.geometry,
        frameState.mapProjection
      );
      groundInstances[i] = new GeometryInstance_default({
        geometry: geometryInstance.geometry,
        attributes,
        id: geometryInstance.id,
        pickPrimitive: that
      });
    }
    primitiveOptions.geometryInstances = groundInstances;
    primitiveOptions.appearance = this.appearance;
    primitiveOptions._createShaderProgramFunction = function(primitive, frameState2, appearance) {
      createShaderProgram3(that, frameState2, appearance);
    };
    primitiveOptions._createCommandsFunction = function(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {
      createCommands3(
        that,
        appearance,
        material,
        translucent,
        colorCommands,
        pickCommands
      );
    };
    primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
      updateAndQueueCommands4(
        that,
        frameState2,
        colorCommands,
        pickCommands,
        modelMatrix,
        cull,
        debugShowBoundingVolume
      );
    };
    this._primitive = new Primitive_default(primitiveOptions);
    this._primitive.readyPromise.then(this._completeLoad);
  }
  if (this.appearance instanceof PolylineColorAppearance_default && !this._hasPerInstanceColors) {
    throw new DeveloperError_default(
      "All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive."
    );
  }
  this._primitive.appearance = this.appearance;
  this._primitive.show = this.show;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
};
GroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
GroundPolylinePrimitive.isSupported = function(scene) {
  return scene.frameState.context.depthTexture;
};
GroundPolylinePrimitive.prototype.isDestroyed = function() {
  return false;
};
GroundPolylinePrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._sp2D = void 0;
  this._spMorph = void 0;
  return destroyObject_default(this);
};
var GroundPolylinePrimitive_default = GroundPolylinePrimitive;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/ImageMaterialProperty.js
var defaultRepeat = new Cartesian2_default(1, 1);
var defaultTransparent = false;
var defaultColor = Color_default.WHITE;
function ImageMaterialProperty(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._definitionChanged = new Event_default();
  this._image = void 0;
  this._imageSubscription = void 0;
  this._repeat = void 0;
  this._repeatSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._transparent = void 0;
  this._transparentSubscription = void 0;
  this.image = options.image;
  this.repeat = options.repeat;
  this.color = options.color;
  this.transparent = options.transparent;
}
Object.defineProperties(ImageMaterialProperty.prototype, {
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._image) && Property_default.isConstant(this._repeat);
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  image: createPropertyDescriptor_default("image"),
  repeat: createPropertyDescriptor_default("repeat"),
  color: createPropertyDescriptor_default("color"),
  transparent: createPropertyDescriptor_default("transparent")
});
ImageMaterialProperty.prototype.getType = function(time) {
  return "Image";
};
ImageMaterialProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = {};
  }
  result.image = Property_default.getValueOrUndefined(this._image, time);
  result.repeat = Property_default.getValueOrClonedDefault(
    this._repeat,
    time,
    defaultRepeat,
    result.repeat
  );
  result.color = Property_default.getValueOrClonedDefault(
    this._color,
    time,
    defaultColor,
    result.color
  );
  if (Property_default.getValueOrDefault(this._transparent, time, defaultTransparent)) {
    result.color.alpha = Math.min(0.99, result.color.alpha);
  }
  return result;
};
ImageMaterialProperty.prototype.equals = function(other) {
  return this === other || other instanceof ImageMaterialProperty && Property_default.equals(this._image, other._image) && Property_default.equals(this._repeat, other._repeat) && Property_default.equals(this._color, other._color) && Property_default.equals(this._transparent, other._transparent);
};
var ImageMaterialProperty_default = ImageMaterialProperty;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/createMaterialPropertyDescriptor.js
function createMaterialProperty(value) {
  if (value instanceof Color_default) {
    return new ColorMaterialProperty_default(value);
  }
  if (typeof value === "string" || value instanceof Resource_default || value instanceof HTMLCanvasElement || value instanceof HTMLVideoElement) {
    const result = new ImageMaterialProperty_default();
    result.image = value;
    return result;
  }
  throw new DeveloperError_default(`Unable to infer material type: ${value}`);
}
function createMaterialPropertyDescriptor(name, configurable) {
  return createPropertyDescriptor_default(name, configurable, createMaterialProperty);
}
var createMaterialPropertyDescriptor_default = createMaterialPropertyDescriptor;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/BoxGraphics.js
function BoxGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._dimensions = void 0;
  this._dimensionsSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(BoxGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  dimensions: createPropertyDescriptor_default("dimensions"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
BoxGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new BoxGraphics(this);
  }
  result.show = this.show;
  result.dimensions = this.dimensions;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
BoxGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.dimensions = defaultValue_default(this.dimensions, source.dimensions);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var BoxGraphics_default = BoxGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/ReferenceFrame.js
var ReferenceFrame = {
  FIXED: 0,
  INERTIAL: 1
};
var ReferenceFrame_default = Object.freeze(ReferenceFrame);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PositionProperty.js
function PositionProperty() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(PositionProperty.prototype, {
  isConstant: {
    get: DeveloperError_default.throwInstantiationError
  },
  definitionChanged: {
    get: DeveloperError_default.throwInstantiationError
  },
  referenceFrame: {
    get: DeveloperError_default.throwInstantiationError
  }
});
PositionProperty.prototype.getValue = DeveloperError_default.throwInstantiationError;
PositionProperty.prototype.getValueInReferenceFrame = DeveloperError_default.throwInstantiationError;
PositionProperty.prototype.equals = DeveloperError_default.throwInstantiationError;
var scratchMatrix3 = new Matrix3_default();
PositionProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
  if (!defined_default(value)) {
    return value;
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  if (inputFrame === outputFrame) {
    return Cartesian3_default.clone(value, result);
  }
  let icrfToFixed = Transforms_default.computeIcrfToFixedMatrix(time, scratchMatrix3);
  if (!defined_default(icrfToFixed)) {
    icrfToFixed = Transforms_default.computeTemeToPseudoFixedMatrix(
      time,
      scratchMatrix3
    );
  }
  if (inputFrame === ReferenceFrame_default.INERTIAL) {
    return Matrix3_default.multiplyByVector(icrfToFixed, value, result);
  }
  if (inputFrame === ReferenceFrame_default.FIXED) {
    return Matrix3_default.multiplyByVector(
      Matrix3_default.transpose(icrfToFixed, scratchMatrix3),
      value,
      result
    );
  }
};
var PositionProperty_default = PositionProperty;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/ConstantPositionProperty.js
function ConstantPositionProperty(value, referenceFrame) {
  this._definitionChanged = new Event_default();
  this._value = Cartesian3_default.clone(value);
  this._referenceFrame = defaultValue_default(referenceFrame, ReferenceFrame_default.FIXED);
}
Object.defineProperties(ConstantPositionProperty.prototype, {
  isConstant: {
    get: function() {
      return !defined_default(this._value) || this._referenceFrame === ReferenceFrame_default.FIXED;
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  referenceFrame: {
    get: function() {
      return this._referenceFrame;
    }
  }
});
ConstantPositionProperty.prototype.getValue = function(time, result) {
  return this.getValueInReferenceFrame(time, ReferenceFrame_default.FIXED, result);
};
ConstantPositionProperty.prototype.setValue = function(value, referenceFrame) {
  let definitionChanged = false;
  if (!Cartesian3_default.equals(this._value, value)) {
    definitionChanged = true;
    this._value = Cartesian3_default.clone(value);
  }
  if (defined_default(referenceFrame) && this._referenceFrame !== referenceFrame) {
    definitionChanged = true;
    this._referenceFrame = referenceFrame;
  }
  if (definitionChanged) {
    this._definitionChanged.raiseEvent(this);
  }
};
ConstantPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  if (!defined_default(referenceFrame)) {
    throw new DeveloperError_default("referenceFrame is required.");
  }
  return PositionProperty_default.convertToReferenceFrame(
    time,
    this._value,
    this._referenceFrame,
    referenceFrame,
    result
  );
};
ConstantPositionProperty.prototype.equals = function(other) {
  return this === other || other instanceof ConstantPositionProperty && Cartesian3_default.equals(this._value, other._value) && this._referenceFrame === other._referenceFrame;
};
var ConstantPositionProperty_default = ConstantPositionProperty;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/CorridorGraphics.js
function CorridorGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._cornerType = void 0;
  this._cornerTypeSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(CorridorGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  positions: createPropertyDescriptor_default("positions"),
  width: createPropertyDescriptor_default("width"),
  height: createPropertyDescriptor_default("height"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  cornerType: createPropertyDescriptor_default("cornerType"),
  granularity: createPropertyDescriptor_default("granularity"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  classificationType: createPropertyDescriptor_default("classificationType"),
  zIndex: createPropertyDescriptor_default("zIndex")
});
CorridorGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new CorridorGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.width = this.width;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.cornerType = this.cornerType;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
CorridorGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.width = defaultValue_default(this.width, source.width);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.cornerType = defaultValue_default(this.cornerType, source.cornerType);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var CorridorGraphics_default = CorridorGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/createRawPropertyDescriptor.js
function createRawProperty(value) {
  return value;
}
function createRawPropertyDescriptor(name, configurable) {
  return createPropertyDescriptor_default(name, configurable, createRawProperty);
}
var createRawPropertyDescriptor_default = createRawPropertyDescriptor;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/CylinderGraphics.js
function CylinderGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._length = void 0;
  this._lengthSubscription = void 0;
  this._topRadius = void 0;
  this._topRadiusSubscription = void 0;
  this._bottomRadius = void 0;
  this._bottomRadiusSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._numberOfVerticalLines = void 0;
  this._numberOfVerticalLinesSubscription = void 0;
  this._slices = void 0;
  this._slicesSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(CylinderGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  length: createPropertyDescriptor_default("length"),
  topRadius: createPropertyDescriptor_default("topRadius"),
  bottomRadius: createPropertyDescriptor_default("bottomRadius"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  numberOfVerticalLines: createPropertyDescriptor_default("numberOfVerticalLines"),
  slices: createPropertyDescriptor_default("slices"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
CylinderGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new CylinderGraphics(this);
  }
  result.show = this.show;
  result.length = this.length;
  result.topRadius = this.topRadius;
  result.bottomRadius = this.bottomRadius;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.numberOfVerticalLines = this.numberOfVerticalLines;
  result.slices = this.slices;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
CylinderGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.length = defaultValue_default(this.length, source.length);
  this.topRadius = defaultValue_default(this.topRadius, source.topRadius);
  this.bottomRadius = defaultValue_default(this.bottomRadius, source.bottomRadius);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.numberOfVerticalLines = defaultValue_default(
    this.numberOfVerticalLines,
    source.numberOfVerticalLines
  );
  this.slices = defaultValue_default(this.slices, source.slices);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var CylinderGraphics_default = CylinderGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/EllipseGraphics.js
function EllipseGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._semiMajorAxis = void 0;
  this._semiMajorAxisSubscription = void 0;
  this._semiMinorAxis = void 0;
  this._semiMinorAxisSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._numberOfVerticalLines = void 0;
  this._numberOfVerticalLinesSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(EllipseGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  semiMajorAxis: createPropertyDescriptor_default("semiMajorAxis"),
  semiMinorAxis: createPropertyDescriptor_default("semiMinorAxis"),
  height: createPropertyDescriptor_default("height"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  rotation: createPropertyDescriptor_default("rotation"),
  stRotation: createPropertyDescriptor_default("stRotation"),
  granularity: createPropertyDescriptor_default("granularity"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  numberOfVerticalLines: createPropertyDescriptor_default("numberOfVerticalLines"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  classificationType: createPropertyDescriptor_default("classificationType"),
  zIndex: createPropertyDescriptor_default("zIndex")
});
EllipseGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new EllipseGraphics(this);
  }
  result.show = this.show;
  result.semiMajorAxis = this.semiMajorAxis;
  result.semiMinorAxis = this.semiMinorAxis;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.rotation = this.rotation;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.numberOfVerticalLines = this.numberOfVerticalLines;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
EllipseGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.semiMajorAxis = defaultValue_default(this.semiMajorAxis, source.semiMajorAxis);
  this.semiMinorAxis = defaultValue_default(this.semiMinorAxis, source.semiMinorAxis);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.rotation = defaultValue_default(this.rotation, source.rotation);
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.numberOfVerticalLines = defaultValue_default(
    this.numberOfVerticalLines,
    source.numberOfVerticalLines
  );
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var EllipseGraphics_default = EllipseGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/EllipsoidGraphics.js
function EllipsoidGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._radii = void 0;
  this._radiiSubscription = void 0;
  this._innerRadii = void 0;
  this._innerRadiiSubscription = void 0;
  this._minimumClock = void 0;
  this._minimumClockSubscription = void 0;
  this._maximumClock = void 0;
  this._maximumClockSubscription = void 0;
  this._minimumCone = void 0;
  this._minimumConeSubscription = void 0;
  this._maximumCone = void 0;
  this._maximumConeSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._stackPartitions = void 0;
  this._stackPartitionsSubscription = void 0;
  this._slicePartitions = void 0;
  this._slicePartitionsSubscription = void 0;
  this._subdivisions = void 0;
  this._subdivisionsSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(EllipsoidGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  radii: createPropertyDescriptor_default("radii"),
  innerRadii: createPropertyDescriptor_default("innerRadii"),
  minimumClock: createPropertyDescriptor_default("minimumClock"),
  maximumClock: createPropertyDescriptor_default("maximumClock"),
  minimumCone: createPropertyDescriptor_default("minimumCone"),
  maximumCone: createPropertyDescriptor_default("maximumCone"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  stackPartitions: createPropertyDescriptor_default("stackPartitions"),
  slicePartitions: createPropertyDescriptor_default("slicePartitions"),
  subdivisions: createPropertyDescriptor_default("subdivisions"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
EllipsoidGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new EllipsoidGraphics(this);
  }
  result.show = this.show;
  result.radii = this.radii;
  result.innerRadii = this.innerRadii;
  result.minimumClock = this.minimumClock;
  result.maximumClock = this.maximumClock;
  result.minimumCone = this.minimumCone;
  result.maximumCone = this.maximumCone;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.stackPartitions = this.stackPartitions;
  result.slicePartitions = this.slicePartitions;
  result.subdivisions = this.subdivisions;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
EllipsoidGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.radii = defaultValue_default(this.radii, source.radii);
  this.innerRadii = defaultValue_default(this.innerRadii, source.innerRadii);
  this.minimumClock = defaultValue_default(this.minimumClock, source.minimumClock);
  this.maximumClock = defaultValue_default(this.maximumClock, source.maximumClock);
  this.minimumCone = defaultValue_default(this.minimumCone, source.minimumCone);
  this.maximumCone = defaultValue_default(this.maximumCone, source.maximumCone);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.stackPartitions = defaultValue_default(
    this.stackPartitions,
    source.stackPartitions
  );
  this.slicePartitions = defaultValue_default(
    this.slicePartitions,
    source.slicePartitions
  );
  this.subdivisions = defaultValue_default(this.subdivisions, source.subdivisions);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var EllipsoidGraphics_default = EllipsoidGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/LabelGraphics.js
function LabelGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._text = void 0;
  this._textSubscription = void 0;
  this._font = void 0;
  this._fontSubscription = void 0;
  this._style = void 0;
  this._styleSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._showBackground = void 0;
  this._showBackgroundSubscription = void 0;
  this._backgroundColor = void 0;
  this._backgroundColorSubscription = void 0;
  this._backgroundPadding = void 0;
  this._backgroundPaddingSubscription = void 0;
  this._pixelOffset = void 0;
  this._pixelOffsetSubscription = void 0;
  this._eyeOffset = void 0;
  this._eyeOffsetSubscription = void 0;
  this._horizontalOrigin = void 0;
  this._horizontalOriginSubscription = void 0;
  this._verticalOrigin = void 0;
  this._verticalOriginSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fillColor = void 0;
  this._fillColorSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._pixelOffsetScaleByDistance = void 0;
  this._pixelOffsetScaleByDistanceSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(LabelGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  text: createPropertyDescriptor_default("text"),
  font: createPropertyDescriptor_default("font"),
  style: createPropertyDescriptor_default("style"),
  scale: createPropertyDescriptor_default("scale"),
  showBackground: createPropertyDescriptor_default("showBackground"),
  backgroundColor: createPropertyDescriptor_default("backgroundColor"),
  backgroundPadding: createPropertyDescriptor_default("backgroundPadding"),
  pixelOffset: createPropertyDescriptor_default("pixelOffset"),
  eyeOffset: createPropertyDescriptor_default("eyeOffset"),
  horizontalOrigin: createPropertyDescriptor_default("horizontalOrigin"),
  verticalOrigin: createPropertyDescriptor_default("verticalOrigin"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  fillColor: createPropertyDescriptor_default("fillColor"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  pixelOffsetScaleByDistance: createPropertyDescriptor_default(
    "pixelOffsetScaleByDistance"
  ),
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
LabelGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new LabelGraphics(this);
  }
  result.show = this.show;
  result.text = this.text;
  result.font = this.font;
  result.style = this.style;
  result.scale = this.scale;
  result.showBackground = this.showBackground;
  result.backgroundColor = this.backgroundColor;
  result.backgroundPadding = this.backgroundPadding;
  result.pixelOffset = this.pixelOffset;
  result.eyeOffset = this.eyeOffset;
  result.horizontalOrigin = this.horizontalOrigin;
  result.verticalOrigin = this.verticalOrigin;
  result.heightReference = this.heightReference;
  result.fillColor = this.fillColor;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.translucencyByDistance = this.translucencyByDistance;
  result.pixelOffsetScaleByDistance = this.pixelOffsetScaleByDistance;
  result.scaleByDistance = this.scaleByDistance;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.disableDepthTestDistance = this.disableDepthTestDistance;
  return result;
};
LabelGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.text = defaultValue_default(this.text, source.text);
  this.font = defaultValue_default(this.font, source.font);
  this.style = defaultValue_default(this.style, source.style);
  this.scale = defaultValue_default(this.scale, source.scale);
  this.showBackground = defaultValue_default(
    this.showBackground,
    source.showBackground
  );
  this.backgroundColor = defaultValue_default(
    this.backgroundColor,
    source.backgroundColor
  );
  this.backgroundPadding = defaultValue_default(
    this.backgroundPadding,
    source.backgroundPadding
  );
  this.pixelOffset = defaultValue_default(this.pixelOffset, source.pixelOffset);
  this.eyeOffset = defaultValue_default(this.eyeOffset, source.eyeOffset);
  this.horizontalOrigin = defaultValue_default(
    this.horizontalOrigin,
    source.horizontalOrigin
  );
  this.verticalOrigin = defaultValue_default(
    this.verticalOrigin,
    source.verticalOrigin
  );
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fillColor = defaultValue_default(this.fillColor, source.fillColor);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.translucencyByDistance = defaultValue_default(
    this.translucencyByDistance,
    source.translucencyByDistance
  );
  this.pixelOffsetScaleByDistance = defaultValue_default(
    this.pixelOffsetScaleByDistance,
    source.pixelOffsetScaleByDistance
  );
  this.scaleByDistance = defaultValue_default(
    this.scaleByDistance,
    source.scaleByDistance
  );
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this.disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var LabelGraphics_default = LabelGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/TranslationRotationScale.js
var defaultScale = new Cartesian3_default(1, 1, 1);
var defaultTranslation = Cartesian3_default.ZERO;
var defaultRotation = Quaternion_default.IDENTITY;
function TranslationRotationScale(translation, rotation, scale) {
  this.translation = Cartesian3_default.clone(
    defaultValue_default(translation, defaultTranslation)
  );
  this.rotation = Quaternion_default.clone(defaultValue_default(rotation, defaultRotation));
  this.scale = Cartesian3_default.clone(defaultValue_default(scale, defaultScale));
}
TranslationRotationScale.prototype.equals = function(right) {
  return this === right || defined_default(right) && Cartesian3_default.equals(this.translation, right.translation) && Quaternion_default.equals(this.rotation, right.rotation) && Cartesian3_default.equals(this.scale, right.scale);
};
var TranslationRotationScale_default = TranslationRotationScale;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/NodeTransformationProperty.js
var defaultNodeTransformation = new TranslationRotationScale_default();
function NodeTransformationProperty(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._definitionChanged = new Event_default();
  this._translation = void 0;
  this._translationSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this.translation = options.translation;
  this.rotation = options.rotation;
  this.scale = options.scale;
}
Object.defineProperties(NodeTransformationProperty.prototype, {
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._translation) && Property_default.isConstant(this._rotation) && Property_default.isConstant(this._scale);
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  translation: createPropertyDescriptor_default("translation"),
  rotation: createPropertyDescriptor_default("rotation"),
  scale: createPropertyDescriptor_default("scale")
});
NodeTransformationProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = new TranslationRotationScale_default();
  }
  result.translation = Property_default.getValueOrClonedDefault(
    this._translation,
    time,
    defaultNodeTransformation.translation,
    result.translation
  );
  result.rotation = Property_default.getValueOrClonedDefault(
    this._rotation,
    time,
    defaultNodeTransformation.rotation,
    result.rotation
  );
  result.scale = Property_default.getValueOrClonedDefault(
    this._scale,
    time,
    defaultNodeTransformation.scale,
    result.scale
  );
  return result;
};
NodeTransformationProperty.prototype.equals = function(other) {
  return this === other || other instanceof NodeTransformationProperty && Property_default.equals(this._translation, other._translation) && Property_default.equals(this._rotation, other._rotation) && Property_default.equals(this._scale, other._scale);
};
var NodeTransformationProperty_default = NodeTransformationProperty;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PropertyBag.js
function PropertyBag(value, createPropertyCallback) {
  this._propertyNames = [];
  this._definitionChanged = new Event_default();
  if (defined_default(value)) {
    this.merge(value, createPropertyCallback);
  }
}
Object.defineProperties(PropertyBag.prototype, {
  propertyNames: {
    get: function() {
      return this._propertyNames;
    }
  },
  isConstant: {
    get: function() {
      const propertyNames = this._propertyNames;
      for (let i = 0, len = propertyNames.length; i < len; i++) {
        if (!Property_default.isConstant(this[propertyNames[i]])) {
          return false;
        }
      }
      return true;
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
PropertyBag.prototype.hasProperty = function(propertyName) {
  return this._propertyNames.indexOf(propertyName) !== -1;
};
function createConstantProperty2(value) {
  return new ConstantProperty_default(value);
}
PropertyBag.prototype.addProperty = function(propertyName, value, createPropertyCallback) {
  const propertyNames = this._propertyNames;
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (propertyNames.indexOf(propertyName) !== -1) {
    throw new DeveloperError_default(
      `${propertyName} is already a registered property.`
    );
  }
  propertyNames.push(propertyName);
  Object.defineProperty(
    this,
    propertyName,
    createPropertyDescriptor_default(
      propertyName,
      true,
      defaultValue_default(createPropertyCallback, createConstantProperty2)
    )
  );
  if (defined_default(value)) {
    this[propertyName] = value;
  }
  this._definitionChanged.raiseEvent(this);
};
PropertyBag.prototype.removeProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  const index = propertyNames.indexOf(propertyName);
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (index === -1) {
    throw new DeveloperError_default(`${propertyName} is not a registered property.`);
  }
  this._propertyNames.splice(index, 1);
  delete this[propertyName];
  this._definitionChanged.raiseEvent(this);
};
PropertyBag.prototype.getValue = function(time, result) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  if (!defined_default(result)) {
    result = {};
  }
  const propertyNames = this._propertyNames;
  for (let i = 0, len = propertyNames.length; i < len; i++) {
    const propertyName = propertyNames[i];
    result[propertyName] = Property_default.getValueOrUndefined(
      this[propertyName],
      time,
      result[propertyName]
    );
  }
  return result;
};
PropertyBag.prototype.merge = function(source, createPropertyCallback) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  const propertyNames = this._propertyNames;
  const sourcePropertyNames = defined_default(source._propertyNames) ? source._propertyNames : Object.keys(source);
  for (let i = 0, len = sourcePropertyNames.length; i < len; i++) {
    const name = sourcePropertyNames[i];
    const targetProperty = this[name];
    const sourceProperty = source[name];
    if (targetProperty === void 0 && propertyNames.indexOf(name) === -1) {
      this.addProperty(name, void 0, createPropertyCallback);
    }
    if (sourceProperty !== void 0) {
      if (targetProperty !== void 0) {
        if (defined_default(targetProperty) && defined_default(targetProperty.merge)) {
          targetProperty.merge(sourceProperty);
        }
      } else if (defined_default(sourceProperty) && defined_default(sourceProperty.merge) && defined_default(sourceProperty.clone)) {
        this[name] = sourceProperty.clone();
      } else {
        this[name] = sourceProperty;
      }
    }
  }
};
function propertiesEqual(a3, b) {
  const aPropertyNames = a3._propertyNames;
  const bPropertyNames = b._propertyNames;
  const len = aPropertyNames.length;
  if (len !== bPropertyNames.length) {
    return false;
  }
  for (let aIndex = 0; aIndex < len; ++aIndex) {
    const name = aPropertyNames[aIndex];
    const bIndex = bPropertyNames.indexOf(name);
    if (bIndex === -1) {
      return false;
    }
    if (!Property_default.equals(a3[name], b[name])) {
      return false;
    }
  }
  return true;
}
PropertyBag.prototype.equals = function(other) {
  return this === other || other instanceof PropertyBag && propertiesEqual(this, other);
};
var PropertyBag_default = PropertyBag;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/ModelGraphics.js
function createNodeTransformationProperty(value) {
  return new NodeTransformationProperty_default(value);
}
function createNodeTransformationPropertyBag(value) {
  return new PropertyBag_default(value, createNodeTransformationProperty);
}
function createArticulationStagePropertyBag(value) {
  return new PropertyBag_default(value);
}
function ModelGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._uri = void 0;
  this._uriSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._minimumPixelSize = void 0;
  this._minimumPixelSizeSubscription = void 0;
  this._maximumScale = void 0;
  this._maximumScaleSubscription = void 0;
  this._incrementallyLoadTextures = void 0;
  this._incrementallyLoadTexturesSubscription = void 0;
  this._runAnimations = void 0;
  this._runAnimationsSubscription = void 0;
  this._clampAnimations = void 0;
  this._clampAnimationsSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._silhouetteColor = void 0;
  this._silhouetteColorSubscription = void 0;
  this._silhouetteSize = void 0;
  this._silhouetteSizeSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._colorBlendMode = void 0;
  this._colorBlendModeSubscription = void 0;
  this._colorBlendAmount = void 0;
  this._colorBlendAmountSubscription = void 0;
  this._imageBasedLightingFactor = void 0;
  this._imageBasedLightingFactorSubscription = void 0;
  this._lightColor = void 0;
  this._lightColorSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._nodeTransformations = void 0;
  this._nodeTransformationsSubscription = void 0;
  this._articulations = void 0;
  this._articulationsSubscription = void 0;
  this._clippingPlanes = void 0;
  this._clippingPlanesSubscription = void 0;
  this._customShader = void 0;
  this._customShaderSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(ModelGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  uri: createPropertyDescriptor_default("uri"),
  scale: createPropertyDescriptor_default("scale"),
  minimumPixelSize: createPropertyDescriptor_default("minimumPixelSize"),
  maximumScale: createPropertyDescriptor_default("maximumScale"),
  incrementallyLoadTextures: createPropertyDescriptor_default(
    "incrementallyLoadTextures"
  ),
  runAnimations: createPropertyDescriptor_default("runAnimations"),
  clampAnimations: createPropertyDescriptor_default("clampAnimations"),
  shadows: createPropertyDescriptor_default("shadows"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  silhouetteColor: createPropertyDescriptor_default("silhouetteColor"),
  silhouetteSize: createPropertyDescriptor_default("silhouetteSize"),
  color: createPropertyDescriptor_default("color"),
  colorBlendMode: createPropertyDescriptor_default("colorBlendMode"),
  colorBlendAmount: createPropertyDescriptor_default("colorBlendAmount"),
  imageBasedLightingFactor: createPropertyDescriptor_default(
    "imageBasedLightingFactor"
  ),
  lightColor: createPropertyDescriptor_default("lightColor"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  nodeTransformations: createPropertyDescriptor_default(
    "nodeTransformations",
    void 0,
    createNodeTransformationPropertyBag
  ),
  articulations: createPropertyDescriptor_default(
    "articulations",
    void 0,
    createArticulationStagePropertyBag
  ),
  clippingPlanes: createPropertyDescriptor_default("clippingPlanes"),
  customShader: createPropertyDescriptor_default("customShader")
});
ModelGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new ModelGraphics(this);
  }
  result.show = this.show;
  result.uri = this.uri;
  result.scale = this.scale;
  result.minimumPixelSize = this.minimumPixelSize;
  result.maximumScale = this.maximumScale;
  result.incrementallyLoadTextures = this.incrementallyLoadTextures;
  result.runAnimations = this.runAnimations;
  result.clampAnimations = this.clampAnimations;
  result.heightReference = this._heightReference;
  result.silhouetteColor = this.silhouetteColor;
  result.silhouetteSize = this.silhouetteSize;
  result.color = this.color;
  result.colorBlendMode = this.colorBlendMode;
  result.colorBlendAmount = this.colorBlendAmount;
  result.imageBasedLightingFactor = this.imageBasedLightingFactor;
  result.lightColor = this.lightColor;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.nodeTransformations = this.nodeTransformations;
  result.articulations = this.articulations;
  result.clippingPlanes = this.clippingPlanes;
  result.customShader = this.customShader;
  return result;
};
ModelGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.uri = defaultValue_default(this.uri, source.uri);
  this.scale = defaultValue_default(this.scale, source.scale);
  this.minimumPixelSize = defaultValue_default(
    this.minimumPixelSize,
    source.minimumPixelSize
  );
  this.maximumScale = defaultValue_default(this.maximumScale, source.maximumScale);
  this.incrementallyLoadTextures = defaultValue_default(
    this.incrementallyLoadTextures,
    source.incrementallyLoadTextures
  );
  this.runAnimations = defaultValue_default(this.runAnimations, source.runAnimations);
  this.clampAnimations = defaultValue_default(
    this.clampAnimations,
    source.clampAnimations
  );
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.silhouetteColor = defaultValue_default(
    this.silhouetteColor,
    source.silhouetteColor
  );
  this.silhouetteSize = defaultValue_default(
    this.silhouetteSize,
    source.silhouetteSize
  );
  this.color = defaultValue_default(this.color, source.color);
  this.colorBlendMode = defaultValue_default(
    this.colorBlendMode,
    source.colorBlendMode
  );
  this.colorBlendAmount = defaultValue_default(
    this.colorBlendAmount,
    source.colorBlendAmount
  );
  this.imageBasedLightingFactor = defaultValue_default(
    this.imageBasedLightingFactor,
    source.imageBasedLightingFactor
  );
  this.lightColor = defaultValue_default(this.lightColor, source.lightColor);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.clippingPlanes = defaultValue_default(
    this.clippingPlanes,
    source.clippingPlanes
  );
  this.customShader = defaultValue_default(this.customShader, source.customShader);
  const sourceNodeTransformations = source.nodeTransformations;
  if (defined_default(sourceNodeTransformations)) {
    const targetNodeTransformations = this.nodeTransformations;
    if (defined_default(targetNodeTransformations)) {
      targetNodeTransformations.merge(sourceNodeTransformations);
    } else {
      this.nodeTransformations = new PropertyBag_default(
        sourceNodeTransformations,
        createNodeTransformationProperty
      );
    }
  }
  const sourceArticulations = source.articulations;
  if (defined_default(sourceArticulations)) {
    const targetArticulations = this.articulations;
    if (defined_default(targetArticulations)) {
      targetArticulations.merge(sourceArticulations);
    } else {
      this.articulations = new PropertyBag_default(sourceArticulations);
    }
  }
};
var ModelGraphics_default = ModelGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/Cesium3DTilesetGraphics.js
function Cesium3DTilesetGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._uri = void 0;
  this._uriSubscription = void 0;
  this._maximumScreenSpaceError = void 0;
  this._maximumScreenSpaceErrorSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(Cesium3DTilesetGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  uri: createPropertyDescriptor_default("uri"),
  maximumScreenSpaceError: createPropertyDescriptor_default("maximumScreenSpaceError")
});
Cesium3DTilesetGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new Cesium3DTilesetGraphics(this);
  }
  result.show = this.show;
  result.uri = this.uri;
  result.maximumScreenSpaceError = this.maximumScreenSpaceError;
  return result;
};
Cesium3DTilesetGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.uri = defaultValue_default(this.uri, source.uri);
  this.maximumScreenSpaceError = defaultValue_default(
    this.maximumScreenSpaceError,
    source.maximumScreenSpaceError
  );
};
var Cesium3DTilesetGraphics_default = Cesium3DTilesetGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PathGraphics.js
function PathGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._leadTime = void 0;
  this._leadTimeSubscription = void 0;
  this._trailTime = void 0;
  this._trailTimeSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._resolution = void 0;
  this._resolutionSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PathGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  leadTime: createPropertyDescriptor_default("leadTime"),
  trailTime: createPropertyDescriptor_default("trailTime"),
  width: createPropertyDescriptor_default("width"),
  resolution: createPropertyDescriptor_default("resolution"),
  material: createMaterialPropertyDescriptor_default("material"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PathGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PathGraphics(this);
  }
  result.show = this.show;
  result.leadTime = this.leadTime;
  result.trailTime = this.trailTime;
  result.width = this.width;
  result.resolution = this.resolution;
  result.material = this.material;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PathGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.leadTime = defaultValue_default(this.leadTime, source.leadTime);
  this.trailTime = defaultValue_default(this.trailTime, source.trailTime);
  this.width = defaultValue_default(this.width, source.width);
  this.resolution = defaultValue_default(this.resolution, source.resolution);
  this.material = defaultValue_default(this.material, source.material);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PathGraphics_default = PathGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PlaneGraphics.js
function PlaneGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._plane = void 0;
  this._planeSubscription = void 0;
  this._dimensions = void 0;
  this._dimensionsSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PlaneGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  plane: createPropertyDescriptor_default("plane"),
  dimensions: createPropertyDescriptor_default("dimensions"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PlaneGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PlaneGraphics(this);
  }
  result.show = this.show;
  result.plane = this.plane;
  result.dimensions = this.dimensions;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PlaneGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.plane = defaultValue_default(this.plane, source.plane);
  this.dimensions = defaultValue_default(this.dimensions, source.dimensions);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PlaneGraphics_default = PlaneGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PointGraphics.js
function PointGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._pixelSize = void 0;
  this._pixelSizeSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PointGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  pixelSize: createPropertyDescriptor_default("pixelSize"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  color: createPropertyDescriptor_default("color"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
PointGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PointGraphics(this);
  }
  result.show = this.show;
  result.pixelSize = this.pixelSize;
  result.heightReference = this.heightReference;
  result.color = this.color;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.scaleByDistance = this.scaleByDistance;
  result.translucencyByDistance = this._translucencyByDistance;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.disableDepthTestDistance = this.disableDepthTestDistance;
  return result;
};
PointGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.pixelSize = defaultValue_default(this.pixelSize, source.pixelSize);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.color = defaultValue_default(this.color, source.color);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.scaleByDistance = defaultValue_default(
    this.scaleByDistance,
    source.scaleByDistance
  );
  this.translucencyByDistance = defaultValue_default(
    this._translucencyByDistance,
    source.translucencyByDistance
  );
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this.disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var PointGraphics_default = PointGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/PolygonHierarchy.js
function PolygonHierarchy(positions, holes) {
  this.positions = defined_default(positions) ? positions : [];
  this.holes = defined_default(holes) ? holes : [];
}
var PolygonHierarchy_default = PolygonHierarchy;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PolygonGraphics.js
function createPolygonHierarchyProperty(value) {
  if (Array.isArray(value)) {
    value = new PolygonHierarchy_default(value);
  }
  return new ConstantProperty_default(value);
}
function PolygonGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._hierarchy = void 0;
  this._hierarchySubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._perPositionHeight = void 0;
  this._perPositionHeightSubscription = void 0;
  this._closeTop = void 0;
  this._closeTopSubscription = void 0;
  this._closeBottom = void 0;
  this._closeBottomSubscription = void 0;
  this._arcType = void 0;
  this._arcTypeSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this._textureCoordinates = void 0;
  this._textureCoordinatesSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolygonGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  hierarchy: createPropertyDescriptor_default(
    "hierarchy",
    void 0,
    createPolygonHierarchyProperty
  ),
  height: createPropertyDescriptor_default("height"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  stRotation: createPropertyDescriptor_default("stRotation"),
  granularity: createPropertyDescriptor_default("granularity"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  perPositionHeight: createPropertyDescriptor_default("perPositionHeight"),
  closeTop: createPropertyDescriptor_default("closeTop"),
  closeBottom: createPropertyDescriptor_default("closeBottom"),
  arcType: createPropertyDescriptor_default("arcType"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  classificationType: createPropertyDescriptor_default("classificationType"),
  zIndex: createPropertyDescriptor_default("zIndex"),
  textureCoordinates: createPropertyDescriptor_default("textureCoordinates")
});
PolygonGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolygonGraphics(this);
  }
  result.show = this.show;
  result.hierarchy = this.hierarchy;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.perPositionHeight = this.perPositionHeight;
  result.closeTop = this.closeTop;
  result.closeBottom = this.closeBottom;
  result.arcType = this.arcType;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  result.textureCoordinates = this.textureCoordinates;
  return result;
};
PolygonGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.hierarchy = defaultValue_default(this.hierarchy, source.hierarchy);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.perPositionHeight = defaultValue_default(
    this.perPositionHeight,
    source.perPositionHeight
  );
  this.closeTop = defaultValue_default(this.closeTop, source.closeTop);
  this.closeBottom = defaultValue_default(this.closeBottom, source.closeBottom);
  this.arcType = defaultValue_default(this.arcType, source.arcType);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
  this.textureCoordinates = defaultValue_default(
    this.textureCoordinates,
    source.textureCoordinates
  );
};
var PolygonGraphics_default = PolygonGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PolylineGraphics.js
function PolylineGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._depthFailMaterial = void 0;
  this._depthFailMaterialSubscription = void 0;
  this._arcType = void 0;
  this._arcTypeSubscription = void 0;
  this._clampToGround = void 0;
  this._clampToGroundSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolylineGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  positions: createPropertyDescriptor_default("positions"),
  width: createPropertyDescriptor_default("width"),
  granularity: createPropertyDescriptor_default("granularity"),
  material: createMaterialPropertyDescriptor_default("material"),
  depthFailMaterial: createMaterialPropertyDescriptor_default("depthFailMaterial"),
  arcType: createPropertyDescriptor_default("arcType"),
  clampToGround: createPropertyDescriptor_default("clampToGround"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  classificationType: createPropertyDescriptor_default("classificationType"),
  zIndex: createPropertyDescriptor_default("zIndex")
});
PolylineGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolylineGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.width = this.width;
  result.granularity = this.granularity;
  result.material = this.material;
  result.depthFailMaterial = this.depthFailMaterial;
  result.arcType = this.arcType;
  result.clampToGround = this.clampToGround;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
PolylineGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.width = defaultValue_default(this.width, source.width);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.material = defaultValue_default(this.material, source.material);
  this.depthFailMaterial = defaultValue_default(
    this.depthFailMaterial,
    source.depthFailMaterial
  );
  this.arcType = defaultValue_default(this.arcType, source.arcType);
  this.clampToGround = defaultValue_default(this.clampToGround, source.clampToGround);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var PolylineGraphics_default = PolylineGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/PolylineVolumeGraphics.js
function PolylineVolumeGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._shape = void 0;
  this._shapeSubscription = void 0;
  this._cornerType = void 0;
  this._cornerTypeSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubsription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolylineVolumeGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  positions: createPropertyDescriptor_default("positions"),
  shape: createPropertyDescriptor_default("shape"),
  cornerType: createPropertyDescriptor_default("cornerType"),
  granularity: createPropertyDescriptor_default("granularity"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PolylineVolumeGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolylineVolumeGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.shape = this.shape;
  result.cornerType = this.cornerType;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PolylineVolumeGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.shape = defaultValue_default(this.shape, source.shape);
  this.cornerType = defaultValue_default(this.cornerType, source.cornerType);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PolylineVolumeGraphics_default = PolylineVolumeGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/RectangleGraphics.js
function RectangleGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._coordinates = void 0;
  this._coordinatesSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distancedisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(RectangleGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  coordinates: createPropertyDescriptor_default("coordinates"),
  height: createPropertyDescriptor_default("height"),
  heightReference: createPropertyDescriptor_default("heightReference"),
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  rotation: createPropertyDescriptor_default("rotation"),
  stRotation: createPropertyDescriptor_default("stRotation"),
  granularity: createPropertyDescriptor_default("granularity"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  classificationType: createPropertyDescriptor_default("classificationType"),
  zIndex: createPropertyDescriptor_default("zIndex")
});
RectangleGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new RectangleGraphics(this);
  }
  result.show = this.show;
  result.coordinates = this.coordinates;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.rotation = this.rotation;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
RectangleGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.coordinates = defaultValue_default(this.coordinates, source.coordinates);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.rotation = defaultValue_default(this.rotation, source.rotation);
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var RectangleGraphics_default = RectangleGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/WallGraphics.js
function WallGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._minimumHeights = void 0;
  this._minimumHeightsSubscription = void 0;
  this._maximumHeights = void 0;
  this._maximumHeightsSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(WallGraphics.prototype, {
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  show: createPropertyDescriptor_default("show"),
  positions: createPropertyDescriptor_default("positions"),
  minimumHeights: createPropertyDescriptor_default("minimumHeights"),
  maximumHeights: createPropertyDescriptor_default("maximumHeights"),
  granularity: createPropertyDescriptor_default("granularity"),
  fill: createPropertyDescriptor_default("fill"),
  material: createMaterialPropertyDescriptor_default("material"),
  outline: createPropertyDescriptor_default("outline"),
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  shadows: createPropertyDescriptor_default("shadows"),
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
WallGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new WallGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.minimumHeights = this.minimumHeights;
  result.maximumHeights = this.maximumHeights;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
WallGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.minimumHeights = defaultValue_default(
    this.minimumHeights,
    source.minimumHeights
  );
  this.maximumHeights = defaultValue_default(
    this.maximumHeights,
    source.maximumHeights
  );
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var WallGraphics_default = WallGraphics;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/Entity.js
var cartoScratch = new Cartographic_default();
function createConstantPositionProperty(value) {
  return new ConstantPositionProperty_default(value);
}
function createPositionPropertyDescriptor(name) {
  return createPropertyDescriptor_default(
    name,
    void 0,
    createConstantPositionProperty
  );
}
function createPropertyTypeDescriptor(name, Type) {
  return createPropertyDescriptor_default(name, void 0, function(value) {
    if (value instanceof Type) {
      return value;
    }
    return new Type(value);
  });
}
function Entity(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  let id = options.id;
  if (!defined_default(id)) {
    id = createGuid_default();
  }
  this._availability = void 0;
  this._id = id;
  this._definitionChanged = new Event_default();
  this._name = options.name;
  this._show = defaultValue_default(options.show, true);
  this._parent = void 0;
  this._propertyNames = [
    "billboard",
    "box",
    "corridor",
    "cylinder",
    "description",
    "ellipse",
    "ellipsoid",
    "label",
    "model",
    "tileset",
    "orientation",
    "path",
    "plane",
    "point",
    "polygon",
    "polyline",
    "polylineVolume",
    "position",
    "properties",
    "rectangle",
    "viewFrom",
    "wall"
  ];
  this._billboard = void 0;
  this._billboardSubscription = void 0;
  this._box = void 0;
  this._boxSubscription = void 0;
  this._corridor = void 0;
  this._corridorSubscription = void 0;
  this._cylinder = void 0;
  this._cylinderSubscription = void 0;
  this._description = void 0;
  this._descriptionSubscription = void 0;
  this._ellipse = void 0;
  this._ellipseSubscription = void 0;
  this._ellipsoid = void 0;
  this._ellipsoidSubscription = void 0;
  this._label = void 0;
  this._labelSubscription = void 0;
  this._model = void 0;
  this._modelSubscription = void 0;
  this._tileset = void 0;
  this._tilesetSubscription = void 0;
  this._orientation = void 0;
  this._orientationSubscription = void 0;
  this._path = void 0;
  this._pathSubscription = void 0;
  this._plane = void 0;
  this._planeSubscription = void 0;
  this._point = void 0;
  this._pointSubscription = void 0;
  this._polygon = void 0;
  this._polygonSubscription = void 0;
  this._polyline = void 0;
  this._polylineSubscription = void 0;
  this._polylineVolume = void 0;
  this._polylineVolumeSubscription = void 0;
  this._position = void 0;
  this._positionSubscription = void 0;
  this._properties = void 0;
  this._propertiesSubscription = void 0;
  this._rectangle = void 0;
  this._rectangleSubscription = void 0;
  this._viewFrom = void 0;
  this._viewFromSubscription = void 0;
  this._wall = void 0;
  this._wallSubscription = void 0;
  this._children = [];
  this.entityCollection = void 0;
  this.parent = options.parent;
  this.merge(options);
}
function updateShow(entity, children, isShowing) {
  const length = children.length;
  for (let i = 0; i < length; i++) {
    const child = children[i];
    const childShow = child._show;
    const oldValue2 = !isShowing && childShow;
    const newValue = isShowing && childShow;
    if (oldValue2 !== newValue) {
      updateShow(child, child._children, isShowing);
    }
  }
  entity._definitionChanged.raiseEvent(
    entity,
    "isShowing",
    isShowing,
    !isShowing
  );
}
Object.defineProperties(Entity.prototype, {
  availability: createRawPropertyDescriptor_default("availability"),
  id: {
    get: function() {
      return this._id;
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  name: createRawPropertyDescriptor_default("name"),
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (value === this._show) {
        return;
      }
      const wasShowing = this.isShowing;
      this._show = value;
      const isShowing = this.isShowing;
      if (wasShowing !== isShowing) {
        updateShow(this, this._children, isShowing);
      }
      this._definitionChanged.raiseEvent(this, "show", value, !value);
    }
  },
  isShowing: {
    get: function() {
      return this._show && (!defined_default(this.entityCollection) || this.entityCollection.show) && (!defined_default(this._parent) || this._parent.isShowing);
    }
  },
  parent: {
    get: function() {
      return this._parent;
    },
    set: function(value) {
      const oldValue2 = this._parent;
      if (oldValue2 === value) {
        return;
      }
      const wasShowing = this.isShowing;
      if (defined_default(oldValue2)) {
        const index = oldValue2._children.indexOf(this);
        oldValue2._children.splice(index, 1);
      }
      this._parent = value;
      if (defined_default(value)) {
        value._children.push(this);
      }
      const isShowing = this.isShowing;
      if (wasShowing !== isShowing) {
        updateShow(this, this._children, isShowing);
      }
      this._definitionChanged.raiseEvent(this, "parent", value, oldValue2);
    }
  },
  propertyNames: {
    get: function() {
      return this._propertyNames;
    }
  },
  billboard: createPropertyTypeDescriptor("billboard", BillboardGraphics_default),
  box: createPropertyTypeDescriptor("box", BoxGraphics_default),
  corridor: createPropertyTypeDescriptor("corridor", CorridorGraphics_default),
  cylinder: createPropertyTypeDescriptor("cylinder", CylinderGraphics_default),
  description: createPropertyDescriptor_default("description"),
  ellipse: createPropertyTypeDescriptor("ellipse", EllipseGraphics_default),
  ellipsoid: createPropertyTypeDescriptor("ellipsoid", EllipsoidGraphics_default),
  label: createPropertyTypeDescriptor("label", LabelGraphics_default),
  model: createPropertyTypeDescriptor("model", ModelGraphics_default),
  tileset: createPropertyTypeDescriptor("tileset", Cesium3DTilesetGraphics_default),
  orientation: createPropertyDescriptor_default("orientation"),
  path: createPropertyTypeDescriptor("path", PathGraphics_default),
  plane: createPropertyTypeDescriptor("plane", PlaneGraphics_default),
  point: createPropertyTypeDescriptor("point", PointGraphics_default),
  polygon: createPropertyTypeDescriptor("polygon", PolygonGraphics_default),
  polyline: createPropertyTypeDescriptor("polyline", PolylineGraphics_default),
  polylineVolume: createPropertyTypeDescriptor(
    "polylineVolume",
    PolylineVolumeGraphics_default
  ),
  properties: createPropertyTypeDescriptor("properties", PropertyBag_default),
  position: createPositionPropertyDescriptor("position"),
  rectangle: createPropertyTypeDescriptor("rectangle", RectangleGraphics_default),
  viewFrom: createPropertyDescriptor_default("viewFrom"),
  wall: createPropertyTypeDescriptor("wall", WallGraphics_default)
});
Entity.prototype.isAvailable = function(time) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  const availability = this._availability;
  return !defined_default(availability) || availability.contains(time);
};
Entity.prototype.addProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (propertyNames.indexOf(propertyName) !== -1) {
    throw new DeveloperError_default(
      `${propertyName} is already a registered property.`
    );
  }
  if (propertyName in this) {
    throw new DeveloperError_default(`${propertyName} is a reserved property name.`);
  }
  propertyNames.push(propertyName);
  Object.defineProperty(
    this,
    propertyName,
    createRawPropertyDescriptor_default(propertyName, true)
  );
};
Entity.prototype.removeProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  const index = propertyNames.indexOf(propertyName);
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (index === -1) {
    throw new DeveloperError_default(`${propertyName} is not a registered property.`);
  }
  this._propertyNames.splice(index, 1);
  delete this[propertyName];
};
Entity.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.name = defaultValue_default(this.name, source.name);
  this.availability = defaultValue_default(this.availability, source.availability);
  const propertyNames = this._propertyNames;
  const sourcePropertyNames = defined_default(source._propertyNames) ? source._propertyNames : Object.keys(source);
  const propertyNamesLength = sourcePropertyNames.length;
  for (let i = 0; i < propertyNamesLength; i++) {
    const name = sourcePropertyNames[i];
    if (name === "parent" || name === "name" || name === "availability") {
      continue;
    }
    const targetProperty = this[name];
    const sourceProperty = source[name];
    if (!defined_default(targetProperty) && propertyNames.indexOf(name) === -1) {
      this.addProperty(name);
    }
    if (defined_default(sourceProperty)) {
      if (defined_default(targetProperty)) {
        if (defined_default(targetProperty.merge)) {
          targetProperty.merge(sourceProperty);
        }
      } else if (defined_default(sourceProperty.merge) && defined_default(sourceProperty.clone)) {
        this[name] = sourceProperty.clone();
      } else {
        this[name] = sourceProperty;
      }
    }
  }
};
var matrix3Scratch2 = new Matrix3_default();
var positionScratch = new Cartesian3_default();
var orientationScratch = new Quaternion_default();
Entity.prototype.computeModelMatrix = function(time, result) {
  Check_default.typeOf.object("time", time);
  const position = Property_default.getValueOrUndefined(
    this._position,
    time,
    positionScratch
  );
  if (!defined_default(position)) {
    return void 0;
  }
  const orientation = Property_default.getValueOrUndefined(
    this._orientation,
    time,
    orientationScratch
  );
  if (!defined_default(orientation)) {
    result = Transforms_default.eastNorthUpToFixedFrame(position, void 0, result);
  } else {
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch2),
      position,
      result
    );
  }
  return result;
};
Entity.prototype.computeModelMatrixForHeightReference = function(time, heightReferenceProperty, heightOffset, ellipsoid, result) {
  Check_default.typeOf.object("time", time);
  const heightReference = Property_default.getValueOrDefault(
    heightReferenceProperty,
    time,
    HeightReference_default.NONE
  );
  let position = Property_default.getValueOrUndefined(
    this._position,
    time,
    positionScratch
  );
  if (heightReference === HeightReference_default.NONE || !defined_default(position) || Cartesian3_default.equalsEpsilon(position, Cartesian3_default.ZERO, Math_default.EPSILON8)) {
    return this.computeModelMatrix(time, result);
  }
  const carto = ellipsoid.cartesianToCartographic(position, cartoScratch);
  if (heightReference === HeightReference_default.CLAMP_TO_GROUND) {
    carto.height = heightOffset;
  } else {
    carto.height += heightOffset;
  }
  position = ellipsoid.cartographicToCartesian(carto, position);
  const orientation = Property_default.getValueOrUndefined(
    this._orientation,
    time,
    orientationScratch
  );
  if (!defined_default(orientation)) {
    result = Transforms_default.eastNorthUpToFixedFrame(position, void 0, result);
  } else {
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch2),
      position,
      result
    );
  }
  return result;
};
Entity.supportsMaterialsforEntitiesOnTerrain = function(scene) {
  return GroundPrimitive_default.supportsMaterials(scene);
};
Entity.supportsPolylinesOnTerrain = function(scene) {
  return GroundPolylinePrimitive_default.isSupported(scene);
};
var Entity_default = Entity;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/DataSources/CallbackProperty.js
function CallbackProperty(callback, isConstant) {
  this._callback = void 0;
  this._isConstant = void 0;
  this._definitionChanged = new Event_default();
  this.setCallback(callback, isConstant);
}
Object.defineProperties(CallbackProperty.prototype, {
  isConstant: {
    get: function() {
      return this._isConstant;
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
CallbackProperty.prototype.getValue = function(time, result) {
  return this._callback(time, result);
};
CallbackProperty.prototype.setCallback = function(callback, isConstant) {
  if (!defined_default(callback)) {
    throw new DeveloperError_default("callback is required.");
  }
  if (!defined_default(isConstant)) {
    throw new DeveloperError_default("isConstant is required.");
  }
  const changed = this._callback !== callback || this._isConstant !== isConstant;
  this._callback = callback;
  this._isConstant = isConstant;
  if (changed) {
    this._definitionChanged.raiseEvent(this);
  }
};
CallbackProperty.prototype.equals = function(other) {
  return this === other || other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant;
};
var CallbackProperty_default = CallbackProperty;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/getTimestamp.js
var getTimestamp;
if (typeof performance !== "undefined" && typeof performance.now === "function" && isFinite(performance.now())) {
  getTimestamp = function() {
    return performance.now();
  };
} else {
  getTimestamp = function() {
    return Date.now();
  };
}
var getTimestamp_default = getTimestamp;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/KeyboardEventModifier.js
var KeyboardEventModifier = {
  SHIFT: 0,
  CTRL: 1,
  ALT: 2
};
var KeyboardEventModifier_default = Object.freeze(KeyboardEventModifier);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/ScreenSpaceEventType.js
var ScreenSpaceEventType = {
  LEFT_DOWN: 0,
  LEFT_UP: 1,
  LEFT_CLICK: 2,
  LEFT_DOUBLE_CLICK: 3,
  RIGHT_DOWN: 5,
  RIGHT_UP: 6,
  RIGHT_CLICK: 7,
  MIDDLE_DOWN: 10,
  MIDDLE_UP: 11,
  MIDDLE_CLICK: 12,
  MOUSE_MOVE: 15,
  WHEEL: 16,
  PINCH_START: 17,
  PINCH_END: 18,
  PINCH_MOVE: 19
};
var ScreenSpaceEventType_default = Object.freeze(ScreenSpaceEventType);

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Core/ScreenSpaceEventHandler.js
function getPosition2(screenSpaceEventHandler, event, result) {
  const element = screenSpaceEventHandler._element;
  if (element === document) {
    result.x = event.clientX;
    result.y = event.clientY;
    return result;
  }
  const rect = element.getBoundingClientRect();
  result.x = event.clientX - rect.left;
  result.y = event.clientY - rect.top;
  return result;
}
function getInputEventKey(type2, modifier) {
  let key = type2;
  if (defined_default(modifier)) {
    key += `+${modifier}`;
  }
  return key;
}
function getModifier(event) {
  if (event.shiftKey) {
    return KeyboardEventModifier_default.SHIFT;
  } else if (event.ctrlKey) {
    return KeyboardEventModifier_default.CTRL;
  } else if (event.altKey) {
    return KeyboardEventModifier_default.ALT;
  }
  return void 0;
}
var MouseButton = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
function registerListener(screenSpaceEventHandler, domType, element, callback) {
  function listener(e) {
    callback(screenSpaceEventHandler, e);
  }
  if (FeatureDetection_default.isInternetExplorer()) {
    element.addEventListener(domType, listener, false);
  } else {
    element.addEventListener(domType, listener, {
      capture: false,
      passive: false
    });
  }
  screenSpaceEventHandler._removalFunctions.push(function() {
    element.removeEventListener(domType, listener, false);
  });
}
function registerListeners(screenSpaceEventHandler) {
  const element = screenSpaceEventHandler._element;
  const alternateElement = !defined_default(element.disableRootEvents) ? document : element;
  if (FeatureDetection_default.supportsPointerEvents()) {
    registerListener(
      screenSpaceEventHandler,
      "pointerdown",
      element,
      handlePointerDown
    );
    registerListener(
      screenSpaceEventHandler,
      "pointerup",
      element,
      handlePointerUp
    );
    registerListener(
      screenSpaceEventHandler,
      "pointermove",
      element,
      handlePointerMove
    );
    registerListener(
      screenSpaceEventHandler,
      "pointercancel",
      element,
      handlePointerUp
    );
  } else {
    registerListener(
      screenSpaceEventHandler,
      "mousedown",
      element,
      handleMouseDown
    );
    registerListener(
      screenSpaceEventHandler,
      "mouseup",
      alternateElement,
      handleMouseUp
    );
    registerListener(
      screenSpaceEventHandler,
      "mousemove",
      alternateElement,
      handleMouseMove
    );
    registerListener(
      screenSpaceEventHandler,
      "touchstart",
      element,
      handleTouchStart
    );
    registerListener(
      screenSpaceEventHandler,
      "touchend",
      alternateElement,
      handleTouchEnd
    );
    registerListener(
      screenSpaceEventHandler,
      "touchmove",
      alternateElement,
      handleTouchMove
    );
    registerListener(
      screenSpaceEventHandler,
      "touchcancel",
      alternateElement,
      handleTouchEnd
    );
  }
  registerListener(
    screenSpaceEventHandler,
    "dblclick",
    element,
    handleDblClick
  );
  let wheelEvent;
  if ("onwheel" in element) {
    wheelEvent = "wheel";
  } else if (document.onmousewheel !== void 0) {
    wheelEvent = "mousewheel";
  } else {
    wheelEvent = "DOMMouseScroll";
  }
  registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);
}
function unregisterListeners(screenSpaceEventHandler) {
  const removalFunctions = screenSpaceEventHandler._removalFunctions;
  for (let i = 0; i < removalFunctions.length; ++i) {
    removalFunctions[i]();
  }
}
var mouseDownEvent = {
  position: new Cartesian2_default()
};
function gotTouchEvent(screenSpaceEventHandler) {
  screenSpaceEventHandler._lastSeenTouchEvent = getTimestamp_default();
}
function canProcessMouseEvent(screenSpaceEventHandler) {
  return getTimestamp_default() - screenSpaceEventHandler._lastSeenTouchEvent > ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;
}
function checkPixelTolerance(startPosition, endPosition, pixelTolerance) {
  const xDiff = startPosition.x - endPosition.x;
  const yDiff = startPosition.y - endPosition.y;
  const totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
  return totalPixels < pixelTolerance;
}
function handleMouseDown(screenSpaceEventHandler, event) {
  if (!canProcessMouseEvent(screenSpaceEventHandler)) {
    return;
  }
  const button = event.button;
  screenSpaceEventHandler._buttonDown[button] = true;
  let screenSpaceEventType;
  if (button === MouseButton.LEFT) {
    screenSpaceEventType = ScreenSpaceEventType_default.LEFT_DOWN;
  } else if (button === MouseButton.MIDDLE) {
    screenSpaceEventType = ScreenSpaceEventType_default.MIDDLE_DOWN;
  } else if (button === MouseButton.RIGHT) {
    screenSpaceEventType = ScreenSpaceEventType_default.RIGHT_DOWN;
  } else {
    return;
  }
  const position = getPosition2(
    screenSpaceEventHandler,
    event,
    screenSpaceEventHandler._primaryPosition
  );
  Cartesian2_default.clone(position, screenSpaceEventHandler._primaryStartPosition);
  Cartesian2_default.clone(position, screenSpaceEventHandler._primaryPreviousPosition);
  const modifier = getModifier(event);
  const action = screenSpaceEventHandler.getInputAction(
    screenSpaceEventType,
    modifier
  );
  if (defined_default(action)) {
    Cartesian2_default.clone(position, mouseDownEvent.position);
    action(mouseDownEvent);
    event.preventDefault();
  }
}
var mouseUpEvent = {
  position: new Cartesian2_default()
};
var mouseClickEvent = {
  position: new Cartesian2_default()
};
function cancelMouseEvent(screenSpaceEventHandler, screenSpaceEventType, clickScreenSpaceEventType, event) {
  const modifier = getModifier(event);
  const action = screenSpaceEventHandler.getInputAction(
    screenSpaceEventType,
    modifier
  );
  const clickAction = screenSpaceEventHandler.getInputAction(
    clickScreenSpaceEventType,
    modifier
  );
  if (defined_default(action) || defined_default(clickAction)) {
    const position = getPosition2(
      screenSpaceEventHandler,
      event,
      screenSpaceEventHandler._primaryPosition
    );
    if (defined_default(action)) {
      Cartesian2_default.clone(position, mouseUpEvent.position);
      action(mouseUpEvent);
    }
    if (defined_default(clickAction)) {
      const startPosition = screenSpaceEventHandler._primaryStartPosition;
      if (checkPixelTolerance(
        startPosition,
        position,
        screenSpaceEventHandler._clickPixelTolerance
      )) {
        Cartesian2_default.clone(position, mouseClickEvent.position);
        clickAction(mouseClickEvent);
      }
    }
  }
}
function handleMouseUp(screenSpaceEventHandler, event) {
  if (!canProcessMouseEvent(screenSpaceEventHandler)) {
    return;
  }
  const button = event.button;
  if (button !== MouseButton.LEFT && button !== MouseButton.MIDDLE && button !== MouseButton.RIGHT) {
    return;
  }
  if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {
    cancelMouseEvent(
      screenSpaceEventHandler,
      ScreenSpaceEventType_default.LEFT_UP,
      ScreenSpaceEventType_default.LEFT_CLICK,
      event
    );
    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;
  }
  if (screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE]) {
    cancelMouseEvent(
      screenSpaceEventHandler,
      ScreenSpaceEventType_default.MIDDLE_UP,
      ScreenSpaceEventType_default.MIDDLE_CLICK,
      event
    );
    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] = false;
  }
  if (screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {
    cancelMouseEvent(
      screenSpaceEventHandler,
      ScreenSpaceEventType_default.RIGHT_UP,
      ScreenSpaceEventType_default.RIGHT_CLICK,
      event
    );
    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT] = false;
  }
}
var mouseMoveEvent = {
  startPosition: new Cartesian2_default(),
  endPosition: new Cartesian2_default()
};
function handleMouseMove(screenSpaceEventHandler, event) {
  if (!canProcessMouseEvent(screenSpaceEventHandler)) {
    return;
  }
  const modifier = getModifier(event);
  const position = getPosition2(
    screenSpaceEventHandler,
    event,
    screenSpaceEventHandler._primaryPosition
  );
  const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
  const action = screenSpaceEventHandler.getInputAction(
    ScreenSpaceEventType_default.MOUSE_MOVE,
    modifier
  );
  if (defined_default(action)) {
    Cartesian2_default.clone(previousPosition, mouseMoveEvent.startPosition);
    Cartesian2_default.clone(position, mouseMoveEvent.endPosition);
    action(mouseMoveEvent);
  }
  Cartesian2_default.clone(position, previousPosition);
  if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT] || screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] || screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {
    event.preventDefault();
  }
}
var mouseDblClickEvent = {
  position: new Cartesian2_default()
};
function handleDblClick(screenSpaceEventHandler, event) {
  const button = event.button;
  let screenSpaceEventType;
  if (button === MouseButton.LEFT) {
    screenSpaceEventType = ScreenSpaceEventType_default.LEFT_DOUBLE_CLICK;
  } else {
    return;
  }
  const modifier = getModifier(event);
  const action = screenSpaceEventHandler.getInputAction(
    screenSpaceEventType,
    modifier
  );
  if (defined_default(action)) {
    getPosition2(screenSpaceEventHandler, event, mouseDblClickEvent.position);
    action(mouseDblClickEvent);
  }
}
function handleWheel(screenSpaceEventHandler, event) {
  let delta;
  if (defined_default(event.deltaY)) {
    const deltaMode = event.deltaMode;
    if (deltaMode === event.DOM_DELTA_PIXEL) {
      delta = -event.deltaY;
    } else if (deltaMode === event.DOM_DELTA_LINE) {
      delta = -event.deltaY * 40;
    } else {
      delta = -event.deltaY * 120;
    }
  } else if (event.detail > 0) {
    delta = event.detail * -120;
  } else {
    delta = event.wheelDelta;
  }
  if (!defined_default(delta)) {
    return;
  }
  const modifier = getModifier(event);
  const action = screenSpaceEventHandler.getInputAction(
    ScreenSpaceEventType_default.WHEEL,
    modifier
  );
  if (defined_default(action)) {
    action(delta);
    event.preventDefault();
  }
}
function handleTouchStart(screenSpaceEventHandler, event) {
  gotTouchEvent(screenSpaceEventHandler);
  const changedTouches = event.changedTouches;
  let i;
  const length = changedTouches.length;
  let touch;
  let identifier;
  const positions = screenSpaceEventHandler._positions;
  for (i = 0; i < length; ++i) {
    touch = changedTouches[i];
    identifier = touch.identifier;
    positions.set(
      identifier,
      getPosition2(screenSpaceEventHandler, touch, new Cartesian2_default())
    );
  }
  fireTouchEvents(screenSpaceEventHandler, event);
  const previousPositions = screenSpaceEventHandler._previousPositions;
  for (i = 0; i < length; ++i) {
    touch = changedTouches[i];
    identifier = touch.identifier;
    previousPositions.set(
      identifier,
      Cartesian2_default.clone(positions.get(identifier))
    );
  }
}
function handleTouchEnd(screenSpaceEventHandler, event) {
  gotTouchEvent(screenSpaceEventHandler);
  const changedTouches = event.changedTouches;
  let i;
  const length = changedTouches.length;
  let touch;
  let identifier;
  const positions = screenSpaceEventHandler._positions;
  for (i = 0; i < length; ++i) {
    touch = changedTouches[i];
    identifier = touch.identifier;
    positions.remove(identifier);
  }
  fireTouchEvents(screenSpaceEventHandler, event);
  const previousPositions = screenSpaceEventHandler._previousPositions;
  for (i = 0; i < length; ++i) {
    touch = changedTouches[i];
    identifier = touch.identifier;
    previousPositions.remove(identifier);
  }
}
var touchStartEvent = {
  position: new Cartesian2_default()
};
var touch2StartEvent = {
  position1: new Cartesian2_default(),
  position2: new Cartesian2_default()
};
var touchEndEvent = {
  position: new Cartesian2_default()
};
var touchClickEvent = {
  position: new Cartesian2_default()
};
var touchHoldEvent = {
  position: new Cartesian2_default()
};
function fireTouchEvents(screenSpaceEventHandler, event) {
  const modifier = getModifier(event);
  const positions = screenSpaceEventHandler._positions;
  const numberOfTouches = positions.length;
  let action;
  let clickAction;
  const pinching = screenSpaceEventHandler._isPinching;
  if (numberOfTouches !== 1 && screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {
    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;
    if (defined_default(screenSpaceEventHandler._touchHoldTimer)) {
      clearTimeout(screenSpaceEventHandler._touchHoldTimer);
      screenSpaceEventHandler._touchHoldTimer = void 0;
    }
    action = screenSpaceEventHandler.getInputAction(
      ScreenSpaceEventType_default.LEFT_UP,
      modifier
    );
    if (defined_default(action)) {
      Cartesian2_default.clone(
        screenSpaceEventHandler._primaryPosition,
        touchEndEvent.position
      );
      action(touchEndEvent);
    }
    if (numberOfTouches === 0 && !screenSpaceEventHandler._isTouchHolding) {
      clickAction = screenSpaceEventHandler.getInputAction(
        ScreenSpaceEventType_default.LEFT_CLICK,
        modifier
      );
      if (defined_default(clickAction)) {
        const startPosition = screenSpaceEventHandler._primaryStartPosition;
        const endPosition = screenSpaceEventHandler._previousPositions.values[0];
        if (checkPixelTolerance(
          startPosition,
          endPosition,
          screenSpaceEventHandler._clickPixelTolerance
        )) {
          Cartesian2_default.clone(
            screenSpaceEventHandler._primaryPosition,
            touchClickEvent.position
          );
          clickAction(touchClickEvent);
        }
      }
    }
    screenSpaceEventHandler._isTouchHolding = false;
  }
  if (numberOfTouches === 0 && pinching) {
    screenSpaceEventHandler._isPinching = false;
    action = screenSpaceEventHandler.getInputAction(
      ScreenSpaceEventType_default.PINCH_END,
      modifier
    );
    if (defined_default(action)) {
      action();
    }
  }
  if (numberOfTouches === 1 && !pinching) {
    const position = positions.values[0];
    Cartesian2_default.clone(position, screenSpaceEventHandler._primaryPosition);
    Cartesian2_default.clone(position, screenSpaceEventHandler._primaryStartPosition);
    Cartesian2_default.clone(
      position,
      screenSpaceEventHandler._primaryPreviousPosition
    );
    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = true;
    action = screenSpaceEventHandler.getInputAction(
      ScreenSpaceEventType_default.LEFT_DOWN,
      modifier
    );
    if (defined_default(action)) {
      Cartesian2_default.clone(position, touchStartEvent.position);
      action(touchStartEvent);
    }
    screenSpaceEventHandler._touchHoldTimer = setTimeout(function() {
      if (!screenSpaceEventHandler.isDestroyed()) {
        screenSpaceEventHandler._touchHoldTimer = void 0;
        screenSpaceEventHandler._isTouchHolding = true;
        clickAction = screenSpaceEventHandler.getInputAction(
          ScreenSpaceEventType_default.RIGHT_CLICK,
          modifier
        );
        if (defined_default(clickAction)) {
          const startPosition = screenSpaceEventHandler._primaryStartPosition;
          const endPosition = screenSpaceEventHandler._previousPositions.values[0];
          if (checkPixelTolerance(
            startPosition,
            endPosition,
            screenSpaceEventHandler._holdPixelTolerance
          )) {
            Cartesian2_default.clone(
              screenSpaceEventHandler._primaryPosition,
              touchHoldEvent.position
            );
            clickAction(touchHoldEvent);
          }
        }
      }
    }, ScreenSpaceEventHandler.touchHoldDelayMilliseconds);
    event.preventDefault();
  }
  if (numberOfTouches === 2 && !pinching) {
    screenSpaceEventHandler._isPinching = true;
    action = screenSpaceEventHandler.getInputAction(
      ScreenSpaceEventType_default.PINCH_START,
      modifier
    );
    if (defined_default(action)) {
      Cartesian2_default.clone(positions.values[0], touch2StartEvent.position1);
      Cartesian2_default.clone(positions.values[1], touch2StartEvent.position2);
      action(touch2StartEvent);
      event.preventDefault();
    }
  }
}
function handleTouchMove(screenSpaceEventHandler, event) {
  gotTouchEvent(screenSpaceEventHandler);
  const changedTouches = event.changedTouches;
  let i;
  const length = changedTouches.length;
  let touch;
  let identifier;
  const positions = screenSpaceEventHandler._positions;
  for (i = 0; i < length; ++i) {
    touch = changedTouches[i];
    identifier = touch.identifier;
    const position = positions.get(identifier);
    if (defined_default(position)) {
      getPosition2(screenSpaceEventHandler, touch, position);
    }
  }
  fireTouchMoveEvents(screenSpaceEventHandler, event);
  const previousPositions = screenSpaceEventHandler._previousPositions;
  for (i = 0; i < length; ++i) {
    touch = changedTouches[i];
    identifier = touch.identifier;
    Cartesian2_default.clone(
      positions.get(identifier),
      previousPositions.get(identifier)
    );
  }
}
var touchMoveEvent = {
  startPosition: new Cartesian2_default(),
  endPosition: new Cartesian2_default()
};
var touchPinchMovementEvent = {
  distance: {
    startPosition: new Cartesian2_default(),
    endPosition: new Cartesian2_default()
  },
  angleAndHeight: {
    startPosition: new Cartesian2_default(),
    endPosition: new Cartesian2_default()
  }
};
function fireTouchMoveEvents(screenSpaceEventHandler, event) {
  const modifier = getModifier(event);
  const positions = screenSpaceEventHandler._positions;
  const previousPositions = screenSpaceEventHandler._previousPositions;
  const numberOfTouches = positions.length;
  let action;
  if (numberOfTouches === 1 && screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {
    const position = positions.values[0];
    Cartesian2_default.clone(position, screenSpaceEventHandler._primaryPosition);
    const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
    action = screenSpaceEventHandler.getInputAction(
      ScreenSpaceEventType_default.MOUSE_MOVE,
      modifier
    );
    if (defined_default(action)) {
      Cartesian2_default.clone(previousPosition, touchMoveEvent.startPosition);
      Cartesian2_default.clone(position, touchMoveEvent.endPosition);
      action(touchMoveEvent);
    }
    Cartesian2_default.clone(position, previousPosition);
    event.preventDefault();
  } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {
    action = screenSpaceEventHandler.getInputAction(
      ScreenSpaceEventType_default.PINCH_MOVE,
      modifier
    );
    if (defined_default(action)) {
      const position1 = positions.values[0];
      const position2 = positions.values[1];
      const previousPosition1 = previousPositions.values[0];
      const previousPosition2 = previousPositions.values[1];
      const dX = position2.x - position1.x;
      const dY = position2.y - position1.y;
      const dist = Math.sqrt(dX * dX + dY * dY) * 0.25;
      const prevDX = previousPosition2.x - previousPosition1.x;
      const prevDY = previousPosition2.y - previousPosition1.y;
      const prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;
      const cY = (position2.y + position1.y) * 0.125;
      const prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;
      const angle = Math.atan2(dY, dX);
      const prevAngle = Math.atan2(prevDY, prevDX);
      Cartesian2_default.fromElements(
        0,
        prevDist,
        touchPinchMovementEvent.distance.startPosition
      );
      Cartesian2_default.fromElements(
        0,
        dist,
        touchPinchMovementEvent.distance.endPosition
      );
      Cartesian2_default.fromElements(
        prevAngle,
        prevCY,
        touchPinchMovementEvent.angleAndHeight.startPosition
      );
      Cartesian2_default.fromElements(
        angle,
        cY,
        touchPinchMovementEvent.angleAndHeight.endPosition
      );
      action(touchPinchMovementEvent);
    }
  }
}
function handlePointerDown(screenSpaceEventHandler, event) {
  event.target.setPointerCapture(event.pointerId);
  if (event.pointerType === "touch") {
    const positions = screenSpaceEventHandler._positions;
    const identifier = event.pointerId;
    positions.set(
      identifier,
      getPosition2(screenSpaceEventHandler, event, new Cartesian2_default())
    );
    fireTouchEvents(screenSpaceEventHandler, event);
    const previousPositions = screenSpaceEventHandler._previousPositions;
    previousPositions.set(
      identifier,
      Cartesian2_default.clone(positions.get(identifier))
    );
  } else {
    handleMouseDown(screenSpaceEventHandler, event);
  }
}
function handlePointerUp(screenSpaceEventHandler, event) {
  if (event.pointerType === "touch") {
    const positions = screenSpaceEventHandler._positions;
    const identifier = event.pointerId;
    positions.remove(identifier);
    fireTouchEvents(screenSpaceEventHandler, event);
    const previousPositions = screenSpaceEventHandler._previousPositions;
    previousPositions.remove(identifier);
  } else {
    handleMouseUp(screenSpaceEventHandler, event);
  }
}
function handlePointerMove(screenSpaceEventHandler, event) {
  if (event.pointerType === "touch") {
    const positions = screenSpaceEventHandler._positions;
    const identifier = event.pointerId;
    const position = positions.get(identifier);
    if (!defined_default(position)) {
      return;
    }
    getPosition2(screenSpaceEventHandler, event, position);
    fireTouchMoveEvents(screenSpaceEventHandler, event);
    const previousPositions = screenSpaceEventHandler._previousPositions;
    Cartesian2_default.clone(
      positions.get(identifier),
      previousPositions.get(identifier)
    );
  } else {
    handleMouseMove(screenSpaceEventHandler, event);
  }
}
function ScreenSpaceEventHandler(element) {
  this._inputEvents = {};
  this._buttonDown = {
    LEFT: false,
    MIDDLE: false,
    RIGHT: false
  };
  this._isPinching = false;
  this._isTouchHolding = false;
  this._lastSeenTouchEvent = -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;
  this._primaryStartPosition = new Cartesian2_default();
  this._primaryPosition = new Cartesian2_default();
  this._primaryPreviousPosition = new Cartesian2_default();
  this._positions = new AssociativeArray_default();
  this._previousPositions = new AssociativeArray_default();
  this._removalFunctions = [];
  this._touchHoldTimer = void 0;
  this._clickPixelTolerance = 5;
  this._holdPixelTolerance = 25;
  this._element = defaultValue_default(element, document);
  registerListeners(this);
}
ScreenSpaceEventHandler.prototype.setInputAction = function(action, type2, modifier) {
  if (!defined_default(action)) {
    throw new DeveloperError_default("action is required.");
  }
  if (!defined_default(type2)) {
    throw new DeveloperError_default("type is required.");
  }
  const key = getInputEventKey(type2, modifier);
  this._inputEvents[key] = action;
};
ScreenSpaceEventHandler.prototype.getInputAction = function(type2, modifier) {
  if (!defined_default(type2)) {
    throw new DeveloperError_default("type is required.");
  }
  const key = getInputEventKey(type2, modifier);
  return this._inputEvents[key];
};
ScreenSpaceEventHandler.prototype.removeInputAction = function(type2, modifier) {
  if (!defined_default(type2)) {
    throw new DeveloperError_default("type is required.");
  }
  const key = getInputEventKey(type2, modifier);
  delete this._inputEvents[key];
};
ScreenSpaceEventHandler.prototype.isDestroyed = function() {
  return false;
};
ScreenSpaceEventHandler.prototype.destroy = function() {
  unregisterListeners(this);
  return destroyObject_default(this);
};
ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;
ScreenSpaceEventHandler.touchHoldDelayMilliseconds = 1500;
var ScreenSpaceEventHandler_default = ScreenSpaceEventHandler;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/ThirdParty/knockout-3.5.1.js
var oldValue;
if (typeof ko !== "undefined") {
  oldValue = ko;
}
(function() {
  (function() {
    (function(n) {
      var A = this || (0, eval)("this"), w = A.document, R = A.navigator, v3 = A.jQuery, H = A.JSON;
      v3 || "undefined" === typeof jQuery || (v3 = jQuery);
      (function(n2) {
        n2(A.ko = {});
      })(function(S, T) {
        function K(a4, c) {
          return null === a4 || typeof a4 in W ? a4 === c : false;
        }
        function X(b, c) {
          var d;
          return function() {
            d || (d = a3.a.setTimeout(function() {
              d = n;
              b();
            }, c));
          };
        }
        function Y(b, c) {
          var d;
          return function() {
            clearTimeout(d);
            d = a3.a.setTimeout(b, c);
          };
        }
        function Z(a4, c) {
          c && "change" !== c ? "beforeChange" === c ? this.pc(a4) : this.gb(a4, c) : this.qc(a4);
        }
        function aa(a4, c) {
          null !== c && c.s && c.s();
        }
        function ba(a4, c) {
          var d = this.qd, e = d[r];
          e.ra || (this.Qb && this.mb[c] ? (d.uc(c, a4, this.mb[c]), this.mb[c] = null, --this.Qb) : e.I[c] || d.uc(c, a4, e.J ? { da: a4 } : d.$c(a4)), a4.Ja && a4.gd());
        }
        var a3 = "undefined" !== typeof S ? S : {};
        a3.b = function(b, c) {
          for (var d = b.split("."), e = a3, f = 0; f < d.length - 1; f++)
            e = e[d[f]];
          e[d[d.length - 1]] = c;
        };
        a3.L = function(a4, c, d) {
          a4[c] = d;
        };
        a3.version = "3.5.1";
        a3.b(
          "version",
          a3.version
        );
        a3.options = { deferUpdates: false, useOnlyNativeEvents: false, foreachHidesDestroyed: false };
        a3.a = function() {
          function b(a4, b2) {
            for (var c2 in a4)
              f.call(a4, c2) && b2(c2, a4[c2]);
          }
          function c(a4, b2) {
            if (b2)
              for (var c2 in b2)
                f.call(b2, c2) && (a4[c2] = b2[c2]);
            return a4;
          }
          function d(a4, b2) {
            a4.__proto__ = b2;
            return a4;
          }
          function e(b2, c2, d2, e2) {
            var l2 = b2[c2].match(q) || [];
            a3.a.D(d2.match(q), function(b3) {
              a3.a.Na(l2, b3, e2);
            });
            b2[c2] = l2.join(" ");
          }
          var f = Object.prototype.hasOwnProperty, g = { __proto__: [] } instanceof Array, h = "function" === typeof Symbol, m = {}, k = {};
          m[R && /Firefox\/2/i.test(R.userAgent) ? "KeyboardEvent" : "UIEvents"] = ["keyup", "keydown", "keypress"];
          m.MouseEvents = "click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");
          b(m, function(a4, b2) {
            if (b2.length)
              for (var c2 = 0, d2 = b2.length; c2 < d2; c2++)
                k[b2[c2]] = a4;
          });
          var l = { propertychange: true }, p = w && function() {
            for (var a4 = 3, b2 = w.createElement("div"), c2 = b2.getElementsByTagName("i"); b2.innerHTML = "<!--[if gt IE " + ++a4 + "]><i></i><![endif]-->", c2[0]; )
              ;
            return 4 < a4 ? a4 : n;
          }(), q = /\S+/g, t;
          return {
            Jc: ["authenticity_token", /^__RequestVerificationToken(_.*)?$/],
            D: function(a4, b2, c2) {
              for (var d2 = 0, e2 = a4.length; d2 < e2; d2++)
                b2.call(c2, a4[d2], d2, a4);
            },
            A: "function" == typeof Array.prototype.indexOf ? function(a4, b2) {
              return Array.prototype.indexOf.call(a4, b2);
            } : function(a4, b2) {
              for (var c2 = 0, d2 = a4.length; c2 < d2; c2++)
                if (a4[c2] === b2)
                  return c2;
              return -1;
            },
            Lb: function(a4, b2, c2) {
              for (var d2 = 0, e2 = a4.length; d2 < e2; d2++)
                if (b2.call(c2, a4[d2], d2, a4))
                  return a4[d2];
              return n;
            },
            Pa: function(b2, c2) {
              var d2 = a3.a.A(b2, c2);
              0 < d2 ? b2.splice(d2, 1) : 0 === d2 && b2.shift();
            },
            wc: function(b2) {
              var c2 = [];
              b2 && a3.a.D(b2, function(b3) {
                0 > a3.a.A(c2, b3) && c2.push(b3);
              });
              return c2;
            },
            Mb: function(a4, b2, c2) {
              var d2 = [];
              if (a4)
                for (var e2 = 0, l2 = a4.length; e2 < l2; e2++)
                  d2.push(b2.call(c2, a4[e2], e2));
              return d2;
            },
            jb: function(a4, b2, c2) {
              var d2 = [];
              if (a4)
                for (var e2 = 0, l2 = a4.length; e2 < l2; e2++)
                  b2.call(c2, a4[e2], e2) && d2.push(a4[e2]);
              return d2;
            },
            Nb: function(a4, b2) {
              if (b2 instanceof Array)
                a4.push.apply(a4, b2);
              else
                for (var c2 = 0, d2 = b2.length; c2 < d2; c2++)
                  a4.push(b2[c2]);
              return a4;
            },
            Na: function(b2, c2, d2) {
              var e2 = a3.a.A(a3.a.bc(b2), c2);
              0 > e2 ? d2 && b2.push(c2) : d2 || b2.splice(e2, 1);
            },
            Ba: g,
            extend: c,
            setPrototypeOf: d,
            Ab: g ? d : c,
            P: b,
            Ga: function(a4, b2, c2) {
              if (!a4)
                return a4;
              var d2 = {}, e2;
              for (e2 in a4)
                f.call(a4, e2) && (d2[e2] = b2.call(c2, a4[e2], e2, a4));
              return d2;
            },
            Tb: function(b2) {
              for (; b2.firstChild; )
                a3.removeNode(b2.firstChild);
            },
            Yb: function(b2) {
              b2 = a3.a.la(b2);
              for (var c2 = (b2[0] && b2[0].ownerDocument || w).createElement("div"), d2 = 0, e2 = b2.length; d2 < e2; d2++)
                c2.appendChild(a3.oa(b2[d2]));
              return c2;
            },
            Ca: function(b2, c2) {
              for (var d2 = 0, e2 = b2.length, l2 = []; d2 < e2; d2++) {
                var k2 = b2[d2].cloneNode(true);
                l2.push(c2 ? a3.oa(k2) : k2);
              }
              return l2;
            },
            va: function(b2, c2) {
              a3.a.Tb(b2);
              if (c2)
                for (var d2 = 0, e2 = c2.length; d2 < e2; d2++)
                  b2.appendChild(c2[d2]);
            },
            Xc: function(b2, c2) {
              var d2 = b2.nodeType ? [b2] : b2;
              if (0 < d2.length) {
                for (var e2 = d2[0], l2 = e2.parentNode, k2 = 0, f2 = c2.length; k2 < f2; k2++)
                  l2.insertBefore(c2[k2], e2);
                k2 = 0;
                for (f2 = d2.length; k2 < f2; k2++)
                  a3.removeNode(d2[k2]);
              }
            },
            Ua: function(a4, b2) {
              if (a4.length) {
                for (b2 = 8 === b2.nodeType && b2.parentNode || b2; a4.length && a4[0].parentNode !== b2; )
                  a4.splice(0, 1);
                for (; 1 < a4.length && a4[a4.length - 1].parentNode !== b2; )
                  a4.length--;
                if (1 < a4.length) {
                  var c2 = a4[0], d2 = a4[a4.length - 1];
                  for (a4.length = 0; c2 !== d2; )
                    a4.push(c2), c2 = c2.nextSibling;
                  a4.push(d2);
                }
              }
              return a4;
            },
            Zc: function(a4, b2) {
              7 > p ? a4.setAttribute("selected", b2) : a4.selected = b2;
            },
            Db: function(a4) {
              return null === a4 || a4 === n ? "" : a4.trim ? a4.trim() : a4.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
            },
            Ud: function(a4, b2) {
              a4 = a4 || "";
              return b2.length > a4.length ? false : a4.substring(0, b2.length) === b2;
            },
            vd: function(a4, b2) {
              if (a4 === b2)
                return true;
              if (11 === a4.nodeType)
                return false;
              if (b2.contains)
                return b2.contains(1 !== a4.nodeType ? a4.parentNode : a4);
              if (b2.compareDocumentPosition)
                return 16 == (b2.compareDocumentPosition(a4) & 16);
              for (; a4 && a4 != b2; )
                a4 = a4.parentNode;
              return !!a4;
            },
            Sb: function(b2) {
              return a3.a.vd(b2, b2.ownerDocument.documentElement);
            },
            kd: function(b2) {
              return !!a3.a.Lb(b2, a3.a.Sb);
            },
            R: function(a4) {
              return a4 && a4.tagName && a4.tagName.toLowerCase();
            },
            Ac: function(b2) {
              return a3.onError ? function() {
                try {
                  return b2.apply(this, arguments);
                } catch (c2) {
                  throw a3.onError && a3.onError(c2), c2;
                }
              } : b2;
            },
            setTimeout: function(b2, c2) {
              return setTimeout(a3.a.Ac(b2), c2);
            },
            Gc: function(b2) {
              setTimeout(function() {
                a3.onError && a3.onError(b2);
                throw b2;
              }, 0);
            },
            B: function(b2, c2, d2) {
              var e2 = a3.a.Ac(d2);
              d2 = l[c2];
              if (a3.options.useOnlyNativeEvents || d2 || !v3)
                if (d2 || "function" != typeof b2.addEventListener)
                  if ("undefined" != typeof b2.attachEvent) {
                    var k2 = function(a4) {
                      e2.call(b2, a4);
                    }, f2 = "on" + c2;
                    b2.attachEvent(
                      f2,
                      k2
                    );
                    a3.a.K.za(b2, function() {
                      b2.detachEvent(f2, k2);
                    });
                  } else
                    throw Error("Browser doesn't support addEventListener or attachEvent");
                else
                  b2.addEventListener(c2, e2, false);
              else
                t || (t = "function" == typeof v3(b2).on ? "on" : "bind"), v3(b2)[t](c2, e2);
            },
            Fb: function(b2, c2) {
              if (!b2 || !b2.nodeType)
                throw Error("element must be a DOM node when calling triggerEvent");
              var d2;
              "input" === a3.a.R(b2) && b2.type && "click" == c2.toLowerCase() ? (d2 = b2.type, d2 = "checkbox" == d2 || "radio" == d2) : d2 = false;
              if (a3.options.useOnlyNativeEvents || !v3 || d2)
                if ("function" == typeof w.createEvent)
                  if ("function" == typeof b2.dispatchEvent)
                    d2 = w.createEvent(k[c2] || "HTMLEvents"), d2.initEvent(c2, true, true, A, 0, 0, 0, 0, 0, false, false, false, false, 0, b2), b2.dispatchEvent(d2);
                  else
                    throw Error("The supplied element doesn't support dispatchEvent");
                else if (d2 && b2.click)
                  b2.click();
                else if ("undefined" != typeof b2.fireEvent)
                  b2.fireEvent("on" + c2);
                else
                  throw Error("Browser doesn't support triggering events");
              else
                v3(b2).trigger(c2);
            },
            f: function(b2) {
              return a3.O(b2) ? b2() : b2;
            },
            bc: function(b2) {
              return a3.O(b2) ? b2.v() : b2;
            },
            Eb: function(b2, c2, d2) {
              var l2;
              c2 && ("object" === typeof b2.classList ? (l2 = b2.classList[d2 ? "add" : "remove"], a3.a.D(c2.match(q), function(a4) {
                l2.call(b2.classList, a4);
              })) : "string" === typeof b2.className.baseVal ? e(b2.className, "baseVal", c2, d2) : e(b2, "className", c2, d2));
            },
            Bb: function(b2, c2) {
              var d2 = a3.a.f(c2);
              if (null === d2 || d2 === n)
                d2 = "";
              var e2 = a3.h.firstChild(b2);
              !e2 || 3 != e2.nodeType || a3.h.nextSibling(e2) ? a3.h.va(b2, [b2.ownerDocument.createTextNode(d2)]) : e2.data = d2;
              a3.a.Ad(b2);
            },
            Yc: function(a4, b2) {
              a4.name = b2;
              if (7 >= p)
                try {
                  var c2 = a4.name.replace(/[&<>'"]/g, function(a5) {
                    return "&#" + a5.charCodeAt(0) + ";";
                  });
                  a4.mergeAttributes(w.createElement("<input name='" + c2 + "'/>"), false);
                } catch (d2) {
                }
            },
            Ad: function(a4) {
              9 <= p && (a4 = 1 == a4.nodeType ? a4 : a4.parentNode, a4.style && (a4.style.zoom = a4.style.zoom));
            },
            wd: function(a4) {
              if (p) {
                var b2 = a4.style.width;
                a4.style.width = 0;
                a4.style.width = b2;
              }
            },
            Pd: function(b2, c2) {
              b2 = a3.a.f(b2);
              c2 = a3.a.f(c2);
              for (var d2 = [], e2 = b2; e2 <= c2; e2++)
                d2.push(e2);
              return d2;
            },
            la: function(a4) {
              for (var b2 = [], c2 = 0, d2 = a4.length; c2 < d2; c2++)
                b2.push(a4[c2]);
              return b2;
            },
            Da: function(a4) {
              return h ? Symbol(a4) : a4;
            },
            Zd: 6 === p,
            $d: 7 === p,
            W: p,
            Lc: function(b2, c2) {
              for (var d2 = a3.a.la(b2.getElementsByTagName("input")).concat(a3.a.la(b2.getElementsByTagName("textarea"))), e2 = "string" == typeof c2 ? function(a4) {
                return a4.name === c2;
              } : function(a4) {
                return c2.test(a4.name);
              }, l2 = [], k2 = d2.length - 1; 0 <= k2; k2--)
                e2(d2[k2]) && l2.push(d2[k2]);
              return l2;
            },
            Nd: function(b2) {
              return "string" == typeof b2 && (b2 = a3.a.Db(b2)) ? H && H.parse ? H.parse(b2) : new Function("return " + b2)() : null;
            },
            hc: function(b2, c2, d2) {
              if (!H || !H.stringify)
                throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
              return H.stringify(a3.a.f(b2), c2, d2);
            },
            Od: function(c2, d2, e2) {
              e2 = e2 || {};
              var l2 = e2.params || {}, k2 = e2.includeFields || this.Jc, f2 = c2;
              if ("object" == typeof c2 && "form" === a3.a.R(c2))
                for (var f2 = c2.action, h2 = k2.length - 1; 0 <= h2; h2--)
                  for (var g2 = a3.a.Lc(c2, k2[h2]), m2 = g2.length - 1; 0 <= m2; m2--)
                    l2[g2[m2].name] = g2[m2].value;
              d2 = a3.a.f(d2);
              var p2 = w.createElement("form");
              p2.style.display = "none";
              p2.action = f2;
              p2.method = "post";
              for (var q3 in d2)
                c2 = w.createElement("input"), c2.type = "hidden", c2.name = q3, c2.value = a3.a.hc(a3.a.f(d2[q3])), p2.appendChild(c2);
              b(l2, function(a4, b2) {
                var c4 = w.createElement("input");
                c4.type = "hidden";
                c4.name = a4;
                c4.value = b2;
                p2.appendChild(c4);
              });
              w.body.appendChild(p2);
              e2.submitter ? e2.submitter(p2) : p2.submit();
              setTimeout(function() {
                p2.parentNode.removeChild(p2);
              }, 0);
            }
          };
        }();
        a3.b("utils", a3.a);
        a3.b("utils.arrayForEach", a3.a.D);
        a3.b("utils.arrayFirst", a3.a.Lb);
        a3.b("utils.arrayFilter", a3.a.jb);
        a3.b("utils.arrayGetDistinctValues", a3.a.wc);
        a3.b("utils.arrayIndexOf", a3.a.A);
        a3.b("utils.arrayMap", a3.a.Mb);
        a3.b("utils.arrayPushAll", a3.a.Nb);
        a3.b("utils.arrayRemoveItem", a3.a.Pa);
        a3.b("utils.cloneNodes", a3.a.Ca);
        a3.b(
          "utils.createSymbolOrString",
          a3.a.Da
        );
        a3.b("utils.extend", a3.a.extend);
        a3.b("utils.fieldsIncludedWithJsonPost", a3.a.Jc);
        a3.b("utils.getFormFields", a3.a.Lc);
        a3.b("utils.objectMap", a3.a.Ga);
        a3.b("utils.peekObservable", a3.a.bc);
        a3.b("utils.postJson", a3.a.Od);
        a3.b("utils.parseJson", a3.a.Nd);
        a3.b("utils.registerEventHandler", a3.a.B);
        a3.b("utils.stringifyJson", a3.a.hc);
        a3.b("utils.range", a3.a.Pd);
        a3.b("utils.toggleDomNodeCssClass", a3.a.Eb);
        a3.b("utils.triggerEvent", a3.a.Fb);
        a3.b("utils.unwrapObservable", a3.a.f);
        a3.b("utils.objectForEach", a3.a.P);
        a3.b(
          "utils.addOrRemoveItem",
          a3.a.Na
        );
        a3.b("utils.setTextContent", a3.a.Bb);
        a3.b("unwrap", a3.a.f);
        Function.prototype.bind || (Function.prototype.bind = function(a4) {
          var c = this;
          if (1 === arguments.length)
            return function() {
              return c.apply(a4, arguments);
            };
          var d = Array.prototype.slice.call(arguments, 1);
          return function() {
            var e = d.slice(0);
            e.push.apply(e, arguments);
            return c.apply(a4, e);
          };
        });
        a3.a.g = new function() {
          var b = 0, c = "__ko__" + new Date().getTime(), d = {}, e, f;
          a3.a.W ? (e = function(a4, e2) {
            var f2 = a4[c];
            if (!f2 || "null" === f2 || !d[f2]) {
              if (!e2)
                return n;
              f2 = a4[c] = "ko" + b++;
              d[f2] = {};
            }
            return d[f2];
          }, f = function(a4) {
            var b2 = a4[c];
            return b2 ? (delete d[b2], a4[c] = null, true) : false;
          }) : (e = function(a4, b2) {
            var d2 = a4[c];
            !d2 && b2 && (d2 = a4[c] = {});
            return d2;
          }, f = function(a4) {
            return a4[c] ? (delete a4[c], true) : false;
          });
          return { get: function(a4, b2) {
            var c2 = e(a4, false);
            return c2 && c2[b2];
          }, set: function(a4, b2, c2) {
            (a4 = e(a4, c2 !== n)) && (a4[b2] = c2);
          }, Ub: function(a4, b2, c2) {
            a4 = e(a4, true);
            return a4[b2] || (a4[b2] = c2);
          }, clear: f, Z: function() {
            return b++ + c;
          } };
        }();
        a3.b("utils.domData", a3.a.g);
        a3.b("utils.domData.clear", a3.a.g.clear);
        a3.a.K = new function() {
          function b(b2, c2) {
            var d2 = a3.a.g.get(b2, e);
            d2 === n && c2 && (d2 = [], a3.a.g.set(b2, e, d2));
            return d2;
          }
          function c(c2) {
            var e2 = b(c2, false);
            if (e2)
              for (var e2 = e2.slice(0), k = 0; k < e2.length; k++)
                e2[k](c2);
            a3.a.g.clear(c2);
            a3.a.K.cleanExternalData(c2);
            g[c2.nodeType] && d(c2.childNodes, true);
          }
          function d(b2, d2) {
            for (var e2 = [], l, f2 = 0; f2 < b2.length; f2++)
              if (!d2 || 8 === b2[f2].nodeType) {
                if (c(e2[e2.length] = l = b2[f2]), b2[f2] !== l)
                  for (; f2-- && -1 == a3.a.A(e2, b2[f2]); )
                    ;
              }
          }
          var e = a3.a.g.Z(), f = { 1: true, 8: true, 9: true }, g = { 1: true, 9: true };
          return { za: function(a4, c2) {
            if ("function" != typeof c2)
              throw Error("Callback must be a function");
            b(a4, true).push(c2);
          }, yb: function(c2, d2) {
            var f2 = b(c2, false);
            f2 && (a3.a.Pa(f2, d2), 0 == f2.length && a3.a.g.set(c2, e, n));
          }, oa: function(b2) {
            a3.u.G(function() {
              f[b2.nodeType] && (c(b2), g[b2.nodeType] && d(b2.getElementsByTagName("*")));
            });
            return b2;
          }, removeNode: function(b2) {
            a3.oa(b2);
            b2.parentNode && b2.parentNode.removeChild(b2);
          }, cleanExternalData: function(a4) {
            v3 && "function" == typeof v3.cleanData && v3.cleanData([a4]);
          } };
        }();
        a3.oa = a3.a.K.oa;
        a3.removeNode = a3.a.K.removeNode;
        a3.b("cleanNode", a3.oa);
        a3.b("removeNode", a3.removeNode);
        a3.b("utils.domNodeDisposal", a3.a.K);
        a3.b(
          "utils.domNodeDisposal.addDisposeCallback",
          a3.a.K.za
        );
        a3.b("utils.domNodeDisposal.removeDisposeCallback", a3.a.K.yb);
        (function() {
          var b = [0, "", ""], c = [1, "<table>", "</table>"], d = [3, "<table><tbody><tr>", "</tr></tbody></table>"], e = [1, "<select multiple='multiple'>", "</select>"], f = { thead: c, tbody: c, tfoot: c, tr: [2, "<table><tbody>", "</tbody></table>"], td: d, th: d, option: e, optgroup: e }, g = 8 >= a3.a.W;
          a3.a.ua = function(c2, d2) {
            var e2;
            if (v3)
              if (v3.parseHTML)
                e2 = v3.parseHTML(c2, d2) || [];
              else {
                if ((e2 = v3.clean([c2], d2)) && e2[0]) {
                  for (var l = e2[0]; l.parentNode && 11 !== l.parentNode.nodeType; )
                    l = l.parentNode;
                  l.parentNode && l.parentNode.removeChild(l);
                }
              }
            else {
              (e2 = d2) || (e2 = w);
              var l = e2.parentWindow || e2.defaultView || A, p = a3.a.Db(c2).toLowerCase(), q = e2.createElement("div"), t;
              t = (p = p.match(/^(?:\x3c!--.*?--\x3e\s*?)*?<([a-z]+)[\s>]/)) && f[p[1]] || b;
              p = t[0];
              t = "ignored<div>" + t[1] + c2 + t[2] + "</div>";
              "function" == typeof l.innerShiv ? q.appendChild(l.innerShiv(t)) : (g && e2.body.appendChild(q), q.innerHTML = t, g && q.parentNode.removeChild(q));
              for (; p--; )
                q = q.lastChild;
              e2 = a3.a.la(q.lastChild.childNodes);
            }
            return e2;
          };
          a3.a.Md = function(b2, c2) {
            var d2 = a3.a.ua(
              b2,
              c2
            );
            return d2.length && d2[0].parentElement || a3.a.Yb(d2);
          };
          a3.a.fc = function(b2, c2) {
            a3.a.Tb(b2);
            c2 = a3.a.f(c2);
            if (null !== c2 && c2 !== n)
              if ("string" != typeof c2 && (c2 = c2.toString()), v3)
                v3(b2).html(c2);
              else
                for (var d2 = a3.a.ua(c2, b2.ownerDocument), e2 = 0; e2 < d2.length; e2++)
                  b2.appendChild(d2[e2]);
          };
        })();
        a3.b("utils.parseHtmlFragment", a3.a.ua);
        a3.b("utils.setHtml", a3.a.fc);
        a3.aa = function() {
          function b(c2, e) {
            if (c2) {
              if (8 == c2.nodeType) {
                var f = a3.aa.Uc(c2.nodeValue);
                null != f && e.push({ ud: c2, Kd: f });
              } else if (1 == c2.nodeType)
                for (var f = 0, g = c2.childNodes, h = g.length; f < h; f++)
                  b(
                    g[f],
                    e
                  );
            }
          }
          var c = {};
          return { Xb: function(a4) {
            if ("function" != typeof a4)
              throw Error("You can only pass a function to ko.memoization.memoize()");
            var b2 = (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1) + (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1);
            c[b2] = a4;
            return "<!--[ko_memo:" + b2 + "]-->";
          }, bd: function(a4, b2) {
            var f = c[a4];
            if (f === n)
              throw Error("Couldn't find any memo with ID " + a4 + ". Perhaps it's already been unmemoized.");
            try {
              return f.apply(null, b2 || []), true;
            } finally {
              delete c[a4];
            }
          }, cd: function(c2, e) {
            var f = [];
            b(c2, f);
            for (var g = 0, h = f.length; g < h; g++) {
              var m = f[g].ud, k = [m];
              e && a3.a.Nb(k, e);
              a3.aa.bd(f[g].Kd, k);
              m.nodeValue = "";
              m.parentNode && m.parentNode.removeChild(m);
            }
          }, Uc: function(a4) {
            return (a4 = a4.match(/^\[ko_memo\:(.*?)\]$/)) ? a4[1] : null;
          } };
        }();
        a3.b("memoization", a3.aa);
        a3.b("memoization.memoize", a3.aa.Xb);
        a3.b("memoization.unmemoize", a3.aa.bd);
        a3.b("memoization.parseMemoText", a3.aa.Uc);
        a3.b("memoization.unmemoizeDomNodeAndDescendants", a3.aa.cd);
        a3.na = function() {
          function b() {
            if (f) {
              for (var b2 = f, c2 = 0, d2; h < f; )
                if (d2 = e[h++]) {
                  if (h > b2) {
                    if (5e3 <= ++c2) {
                      h = f;
                      a3.a.Gc(Error("'Too much recursion' after processing " + c2 + " task groups."));
                      break;
                    }
                    b2 = f;
                  }
                  try {
                    d2();
                  } catch (p) {
                    a3.a.Gc(p);
                  }
                }
            }
          }
          function c() {
            b();
            h = f = e.length = 0;
          }
          var d, e = [], f = 0, g = 1, h = 0;
          A.MutationObserver ? d = function(a4) {
            var b2 = w.createElement("div");
            new MutationObserver(a4).observe(b2, { attributes: true });
            return function() {
              b2.classList.toggle("foo");
            };
          }(c) : d = w && "onreadystatechange" in w.createElement("script") ? function(a4) {
            var b2 = w.createElement("script");
            b2.onreadystatechange = function() {
              b2.onreadystatechange = null;
              w.documentElement.removeChild(b2);
              b2 = null;
              a4();
            };
            w.documentElement.appendChild(b2);
          } : function(a4) {
            setTimeout(a4, 0);
          };
          return { scheduler: d, zb: function(b2) {
            f || a3.na.scheduler(c);
            e[f++] = b2;
            return g++;
          }, cancel: function(a4) {
            a4 = a4 - (g - f);
            a4 >= h && a4 < f && (e[a4] = null);
          }, resetForTesting: function() {
            var a4 = f - h;
            h = f = e.length = 0;
            return a4;
          }, Sd: b };
        }();
        a3.b("tasks", a3.na);
        a3.b("tasks.schedule", a3.na.zb);
        a3.b("tasks.runEarly", a3.na.Sd);
        a3.Ta = { throttle: function(b, c) {
          b.throttleEvaluation = c;
          var d = null;
          return a3.$({ read: b, write: function(e) {
            clearTimeout(d);
            d = a3.a.setTimeout(
              function() {
                b(e);
              },
              c
            );
          } });
        }, rateLimit: function(a4, c) {
          var d, e, f;
          "number" == typeof c ? d = c : (d = c.timeout, e = c.method);
          a4.Hb = false;
          f = "function" == typeof e ? e : "notifyWhenChangesStop" == e ? Y : X;
          a4.ub(function(a5) {
            return f(a5, d, c);
          });
        }, deferred: function(b, c) {
          if (true !== c)
            throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");
          b.Hb || (b.Hb = true, b.ub(function(c2) {
            var e, f = false;
            return function() {
              if (!f) {
                a3.na.cancel(e);
                e = a3.na.zb(c2);
                try {
                  f = true, b.notifySubscribers(n, "dirty");
                } finally {
                  f = false;
                }
              }
            };
          }));
        }, notify: function(a4, c) {
          a4.equalityComparer = "always" == c ? null : K;
        } };
        var W = { undefined: 1, "boolean": 1, number: 1, string: 1 };
        a3.b("extenders", a3.Ta);
        a3.ic = function(b, c, d) {
          this.da = b;
          this.lc = c;
          this.mc = d;
          this.Ib = false;
          this.fb = this.Jb = null;
          a3.L(this, "dispose", this.s);
          a3.L(this, "disposeWhenNodeIsRemoved", this.l);
        };
        a3.ic.prototype.s = function() {
          this.Ib || (this.fb && a3.a.K.yb(this.Jb, this.fb), this.Ib = true, this.mc(), this.da = this.lc = this.mc = this.Jb = this.fb = null);
        };
        a3.ic.prototype.l = function(b) {
          this.Jb = b;
          a3.a.K.za(b, this.fb = this.s.bind(this));
        };
        a3.T = function() {
          a3.a.Ab(this, D);
          D.qb(this);
        };
        var D = {
          qb: function(a4) {
            a4.U = { change: [] };
            a4.sc = 1;
          },
          subscribe: function(b, c, d) {
            var e = this;
            d = d || "change";
            var f = new a3.ic(e, c ? b.bind(c) : b, function() {
              a3.a.Pa(e.U[d], f);
              e.hb && e.hb(d);
            });
            e.Qa && e.Qa(d);
            e.U[d] || (e.U[d] = []);
            e.U[d].push(f);
            return f;
          },
          notifySubscribers: function(b, c) {
            c = c || "change";
            "change" === c && this.Gb();
            if (this.Wa(c)) {
              var d = "change" === c && this.ed || this.U[c].slice(0);
              try {
                a3.u.xc();
                for (var e = 0, f; f = d[e]; ++e)
                  f.Ib || f.lc(b);
              } finally {
                a3.u.end();
              }
            }
          },
          ob: function() {
            return this.sc;
          },
          Dd: function(a4) {
            return this.ob() !== a4;
          },
          Gb: function() {
            ++this.sc;
          },
          ub: function(b) {
            var c = this, d = a3.O(c), e, f, g, h, m;
            c.gb || (c.gb = c.notifySubscribers, c.notifySubscribers = Z);
            var k = b(function() {
              c.Ja = false;
              d && h === c && (h = c.nc ? c.nc() : c());
              var a4 = f || m && c.sb(g, h);
              m = f = e = false;
              a4 && c.gb(g = h);
            });
            c.qc = function(a4, b2) {
              b2 && c.Ja || (m = !b2);
              c.ed = c.U.change.slice(0);
              c.Ja = e = true;
              h = a4;
              k();
            };
            c.pc = function(a4) {
              e || (g = a4, c.gb(a4, "beforeChange"));
            };
            c.rc = function() {
              m = true;
            };
            c.gd = function() {
              c.sb(g, c.v(true)) && (f = true);
            };
          },
          Wa: function(a4) {
            return this.U[a4] && this.U[a4].length;
          },
          Bd: function(b) {
            if (b)
              return this.U[b] && this.U[b].length || 0;
            var c = 0;
            a3.a.P(this.U, function(a4, b2) {
              "dirty" !== a4 && (c += b2.length);
            });
            return c;
          },
          sb: function(a4, c) {
            return !this.equalityComparer || !this.equalityComparer(a4, c);
          },
          toString: function() {
            return "[object Object]";
          },
          extend: function(b) {
            var c = this;
            b && a3.a.P(b, function(b2, e) {
              var f = a3.Ta[b2];
              "function" == typeof f && (c = f(c, e) || c);
            });
            return c;
          }
        };
        a3.L(D, "init", D.qb);
        a3.L(D, "subscribe", D.subscribe);
        a3.L(D, "extend", D.extend);
        a3.L(D, "getSubscriptionsCount", D.Bd);
        a3.a.Ba && a3.a.setPrototypeOf(
          D,
          Function.prototype
        );
        a3.T.fn = D;
        a3.Qc = function(a4) {
          return null != a4 && "function" == typeof a4.subscribe && "function" == typeof a4.notifySubscribers;
        };
        a3.b("subscribable", a3.T);
        a3.b("isSubscribable", a3.Qc);
        a3.S = a3.u = function() {
          function b(a4) {
            d.push(e);
            e = a4;
          }
          function c() {
            e = d.pop();
          }
          var d = [], e, f = 0;
          return {
            xc: b,
            end: c,
            cc: function(b2) {
              if (e) {
                if (!a3.Qc(b2))
                  throw Error("Only subscribable things can act as dependencies");
                e.od.call(e.pd, b2, b2.fd || (b2.fd = ++f));
              }
            },
            G: function(a4, d2, e2) {
              try {
                return b(), a4.apply(d2, e2 || []);
              } finally {
                c();
              }
            },
            qa: function() {
              if (e)
                return e.o.qa();
            },
            Va: function() {
              if (e)
                return e.o.Va();
            },
            Ya: function() {
              if (e)
                return e.Ya;
            },
            o: function() {
              if (e)
                return e.o;
            }
          };
        }();
        a3.b("computedContext", a3.S);
        a3.b("computedContext.getDependenciesCount", a3.S.qa);
        a3.b("computedContext.getDependencies", a3.S.Va);
        a3.b("computedContext.isInitial", a3.S.Ya);
        a3.b("computedContext.registerDependency", a3.S.cc);
        a3.b("ignoreDependencies", a3.Yd = a3.u.G);
        var I = a3.a.Da("_latestValue");
        a3.ta = function(b) {
          function c() {
            if (0 < arguments.length)
              return c.sb(c[I], arguments[0]) && (c.ya(), c[I] = arguments[0], c.xa()), this;
            a3.u.cc(c);
            return c[I];
          }
          c[I] = b;
          a3.a.Ba || a3.a.extend(c, a3.T.fn);
          a3.T.fn.qb(c);
          a3.a.Ab(c, F);
          a3.options.deferUpdates && a3.Ta.deferred(c, true);
          return c;
        };
        var F = { equalityComparer: K, v: function() {
          return this[I];
        }, xa: function() {
          this.notifySubscribers(this[I], "spectate");
          this.notifySubscribers(this[I]);
        }, ya: function() {
          this.notifySubscribers(this[I], "beforeChange");
        } };
        a3.a.Ba && a3.a.setPrototypeOf(F, a3.T.fn);
        var G = a3.ta.Ma = "__ko_proto__";
        F[G] = a3.ta;
        a3.O = function(b) {
          if ((b = "function" == typeof b && b[G]) && b !== F[G] && b !== a3.o.fn[G])
            throw Error("Invalid object that looks like an observable; possibly from another Knockout instance");
          return !!b;
        };
        a3.Za = function(b) {
          return "function" == typeof b && (b[G] === F[G] || b[G] === a3.o.fn[G] && b.Nc);
        };
        a3.b("observable", a3.ta);
        a3.b("isObservable", a3.O);
        a3.b("isWriteableObservable", a3.Za);
        a3.b("isWritableObservable", a3.Za);
        a3.b("observable.fn", F);
        a3.L(F, "peek", F.v);
        a3.L(F, "valueHasMutated", F.xa);
        a3.L(F, "valueWillMutate", F.ya);
        a3.Ha = function(b) {
          b = b || [];
          if ("object" != typeof b || !("length" in b))
            throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
          b = a3.ta(b);
          a3.a.Ab(
            b,
            a3.Ha.fn
          );
          return b.extend({ trackArrayChanges: true });
        };
        a3.Ha.fn = { remove: function(b) {
          for (var c = this.v(), d = [], e = "function" != typeof b || a3.O(b) ? function(a4) {
            return a4 === b;
          } : b, f = 0; f < c.length; f++) {
            var g = c[f];
            if (e(g)) {
              0 === d.length && this.ya();
              if (c[f] !== g)
                throw Error("Array modified during remove; cannot remove item");
              d.push(g);
              c.splice(f, 1);
              f--;
            }
          }
          d.length && this.xa();
          return d;
        }, removeAll: function(b) {
          if (b === n) {
            var c = this.v(), d = c.slice(0);
            this.ya();
            c.splice(0, c.length);
            this.xa();
            return d;
          }
          return b ? this.remove(function(c2) {
            return 0 <= a3.a.A(b, c2);
          }) : [];
        }, destroy: function(b) {
          var c = this.v(), d = "function" != typeof b || a3.O(b) ? function(a4) {
            return a4 === b;
          } : b;
          this.ya();
          for (var e = c.length - 1; 0 <= e; e--) {
            var f = c[e];
            d(f) && (f._destroy = true);
          }
          this.xa();
        }, destroyAll: function(b) {
          return b === n ? this.destroy(function() {
            return true;
          }) : b ? this.destroy(function(c) {
            return 0 <= a3.a.A(b, c);
          }) : [];
        }, indexOf: function(b) {
          var c = this();
          return a3.a.A(c, b);
        }, replace: function(a4, c) {
          var d = this.indexOf(a4);
          0 <= d && (this.ya(), this.v()[d] = c, this.xa());
        }, sorted: function(a4) {
          var c = this().slice(0);
          return a4 ? c.sort(a4) : c.sort();
        }, reversed: function() {
          return this().slice(0).reverse();
        } };
        a3.a.Ba && a3.a.setPrototypeOf(a3.Ha.fn, a3.ta.fn);
        a3.a.D("pop push reverse shift sort splice unshift".split(" "), function(b) {
          a3.Ha.fn[b] = function() {
            var a4 = this.v();
            this.ya();
            this.zc(a4, b, arguments);
            var d = a4[b].apply(a4, arguments);
            this.xa();
            return d === a4 ? this : d;
          };
        });
        a3.a.D(["slice"], function(b) {
          a3.Ha.fn[b] = function() {
            var a4 = this();
            return a4[b].apply(a4, arguments);
          };
        });
        a3.Pc = function(b) {
          return a3.O(b) && "function" == typeof b.remove && "function" == typeof b.push;
        };
        a3.b("observableArray", a3.Ha);
        a3.b("isObservableArray", a3.Pc);
        a3.Ta.trackArrayChanges = function(b, c) {
          function d() {
            function c2() {
              if (m) {
                var d2 = [].concat(b.v() || []), e2;
                if (b.Wa("arrayChange")) {
                  if (!f || 1 < m)
                    f = a3.a.Pb(k, d2, b.Ob);
                  e2 = f;
                }
                k = d2;
                f = null;
                m = 0;
                e2 && e2.length && b.notifySubscribers(e2, "arrayChange");
              }
            }
            e ? c2() : (e = true, h = b.subscribe(function() {
              ++m;
            }, null, "spectate"), k = [].concat(b.v() || []), f = null, g = b.subscribe(c2));
          }
          b.Ob = {};
          c && "object" == typeof c && a3.a.extend(b.Ob, c);
          b.Ob.sparse = true;
          if (!b.zc) {
            var e = false, f = null, g, h, m = 0, k, l = b.Qa, p = b.hb;
            b.Qa = function(a4) {
              l && l.call(b, a4);
              "arrayChange" === a4 && d();
            };
            b.hb = function(a4) {
              p && p.call(b, a4);
              "arrayChange" !== a4 || b.Wa("arrayChange") || (g && g.s(), h && h.s(), h = g = null, e = false, k = n);
            };
            b.zc = function(b2, c2, d2) {
              function l2(a4, b3, c4) {
                return k2[k2.length] = { status: a4, value: b3, index: c4 };
              }
              if (e && !m) {
                var k2 = [], p2 = b2.length, g2 = d2.length, h2 = 0;
                switch (c2) {
                  case "push":
                    h2 = p2;
                  case "unshift":
                    for (c2 = 0; c2 < g2; c2++)
                      l2("added", d2[c2], h2 + c2);
                    break;
                  case "pop":
                    h2 = p2 - 1;
                  case "shift":
                    p2 && l2("deleted", b2[h2], h2);
                    break;
                  case "splice":
                    c2 = Math.min(Math.max(0, 0 > d2[0] ? p2 + d2[0] : d2[0]), p2);
                    for (var p2 = 1 === g2 ? p2 : Math.min(c2 + (d2[1] || 0), p2), g2 = c2 + g2 - 2, h2 = Math.max(p2, g2), U = [], L = [], n2 = 2; c2 < h2; ++c2, ++n2)
                      c2 < p2 && L.push(l2("deleted", b2[c2], c2)), c2 < g2 && U.push(l2("added", d2[n2], c2));
                    a3.a.Kc(L, U);
                    break;
                  default:
                    return;
                }
                f = k2;
              }
            };
          }
        };
        var r = a3.a.Da("_state");
        a3.o = a3.$ = function(b, c, d) {
          function e() {
            if (0 < arguments.length) {
              if ("function" === typeof f)
                f.apply(g.nb, arguments);
              else
                throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
              return this;
            }
            g.ra || a3.u.cc(e);
            (g.ka || g.J && e.Xa()) && e.ha();
            return g.X;
          }
          "object" === typeof b ? d = b : (d = d || {}, b && (d.read = b));
          if ("function" != typeof d.read)
            throw Error("Pass a function that returns the value of the ko.computed");
          var f = d.write, g = { X: n, sa: true, ka: true, rb: false, jc: false, ra: false, wb: false, J: false, Wc: d.read, nb: c || d.owner, l: d.disposeWhenNodeIsRemoved || d.l || null, Sa: d.disposeWhen || d.Sa, Rb: null, I: {}, V: 0, Ic: null };
          e[r] = g;
          e.Nc = "function" === typeof f;
          a3.a.Ba || a3.a.extend(e, a3.T.fn);
          a3.T.fn.qb(e);
          a3.a.Ab(e, C);
          d.pure ? (g.wb = true, g.J = true, a3.a.extend(e, da)) : d.deferEvaluation && a3.a.extend(e, ea);
          a3.options.deferUpdates && a3.Ta.deferred(e, true);
          g.l && (g.jc = true, g.l.nodeType || (g.l = null));
          g.J || d.deferEvaluation || e.ha();
          g.l && e.ja() && a3.a.K.za(g.l, g.Rb = function() {
            e.s();
          });
          return e;
        };
        var C = {
          equalityComparer: K,
          qa: function() {
            return this[r].V;
          },
          Va: function() {
            var b = [];
            a3.a.P(this[r].I, function(a4, d) {
              b[d.Ka] = d.da;
            });
            return b;
          },
          Vb: function(b) {
            if (!this[r].V)
              return false;
            var c = this.Va();
            return -1 !== a3.a.A(c, b) ? true : !!a3.a.Lb(c, function(a4) {
              return a4.Vb && a4.Vb(b);
            });
          },
          uc: function(a4, c, d) {
            if (this[r].wb && c === this)
              throw Error("A 'pure' computed must not be called recursively");
            this[r].I[a4] = d;
            d.Ka = this[r].V++;
            d.La = c.ob();
          },
          Xa: function() {
            var a4, c, d = this[r].I;
            for (a4 in d)
              if (Object.prototype.hasOwnProperty.call(d, a4) && (c = d[a4], this.Ia && c.da.Ja || c.da.Dd(c.La)))
                return true;
          },
          Jd: function() {
            this.Ia && !this[r].rb && this.Ia(false);
          },
          ja: function() {
            var a4 = this[r];
            return a4.ka || 0 < a4.V;
          },
          Rd: function() {
            this.Ja ? this[r].ka && (this[r].sa = true) : this.Hc();
          },
          $c: function(a4) {
            if (a4.Hb) {
              var c = a4.subscribe(this.Jd, this, "dirty"), d = a4.subscribe(
                this.Rd,
                this
              );
              return { da: a4, s: function() {
                c.s();
                d.s();
              } };
            }
            return a4.subscribe(this.Hc, this);
          },
          Hc: function() {
            var b = this, c = b.throttleEvaluation;
            c && 0 <= c ? (clearTimeout(this[r].Ic), this[r].Ic = a3.a.setTimeout(function() {
              b.ha(true);
            }, c)) : b.Ia ? b.Ia(true) : b.ha(true);
          },
          ha: function(b) {
            var c = this[r], d = c.Sa, e = false;
            if (!c.rb && !c.ra) {
              if (c.l && !a3.a.Sb(c.l) || d && d()) {
                if (!c.jc) {
                  this.s();
                  return;
                }
              } else
                c.jc = false;
              c.rb = true;
              try {
                e = this.zd(b);
              } finally {
                c.rb = false;
              }
              return e;
            }
          },
          zd: function(b) {
            var c = this[r], d = false, e = c.wb ? n : !c.V, d = { qd: this, mb: c.I, Qb: c.V };
            a3.u.xc({
              pd: d,
              od: ba,
              o: this,
              Ya: e
            });
            c.I = {};
            c.V = 0;
            var f = this.yd(c, d);
            c.V ? d = this.sb(c.X, f) : (this.s(), d = true);
            d && (c.J ? this.Gb() : this.notifySubscribers(c.X, "beforeChange"), c.X = f, this.notifySubscribers(c.X, "spectate"), !c.J && b && this.notifySubscribers(c.X), this.rc && this.rc());
            e && this.notifySubscribers(c.X, "awake");
            return d;
          },
          yd: function(b, c) {
            try {
              var d = b.Wc;
              return b.nb ? d.call(b.nb) : d();
            } finally {
              a3.u.end(), c.Qb && !b.J && a3.a.P(c.mb, aa), b.sa = b.ka = false;
            }
          },
          v: function(a4) {
            var c = this[r];
            (c.ka && (a4 || !c.V) || c.J && this.Xa()) && this.ha();
            return c.X;
          },
          ub: function(b) {
            a3.T.fn.ub.call(this, b);
            this.nc = function() {
              this[r].J || (this[r].sa ? this.ha() : this[r].ka = false);
              return this[r].X;
            };
            this.Ia = function(a4) {
              this.pc(this[r].X);
              this[r].ka = true;
              a4 && (this[r].sa = true);
              this.qc(this, !a4);
            };
          },
          s: function() {
            var b = this[r];
            !b.J && b.I && a3.a.P(b.I, function(a4, b2) {
              b2.s && b2.s();
            });
            b.l && b.Rb && a3.a.K.yb(b.l, b.Rb);
            b.I = n;
            b.V = 0;
            b.ra = true;
            b.sa = false;
            b.ka = false;
            b.J = false;
            b.l = n;
            b.Sa = n;
            b.Wc = n;
            this.Nc || (b.nb = n);
          }
        }, da = { Qa: function(b) {
          var c = this, d = c[r];
          if (!d.ra && d.J && "change" == b) {
            d.J = false;
            if (d.sa || c.Xa())
              d.I = null, d.V = 0, c.ha() && c.Gb();
            else {
              var e = [];
              a3.a.P(d.I, function(a4, b2) {
                e[b2.Ka] = a4;
              });
              a3.a.D(e, function(a4, b2) {
                var e2 = d.I[a4], m = c.$c(e2.da);
                m.Ka = b2;
                m.La = e2.La;
                d.I[a4] = m;
              });
              c.Xa() && c.ha() && c.Gb();
            }
            d.ra || c.notifySubscribers(d.X, "awake");
          }
        }, hb: function(b) {
          var c = this[r];
          c.ra || "change" != b || this.Wa("change") || (a3.a.P(c.I, function(a4, b2) {
            b2.s && (c.I[a4] = { da: b2.da, Ka: b2.Ka, La: b2.La }, b2.s());
          }), c.J = true, this.notifySubscribers(n, "asleep"));
        }, ob: function() {
          var b = this[r];
          b.J && (b.sa || this.Xa()) && this.ha();
          return a3.T.fn.ob.call(this);
        } }, ea = { Qa: function(a4) {
          "change" != a4 && "beforeChange" != a4 || this.v();
        } };
        a3.a.Ba && a3.a.setPrototypeOf(C, a3.T.fn);
        var N = a3.ta.Ma;
        C[N] = a3.o;
        a3.Oc = function(a4) {
          return "function" == typeof a4 && a4[N] === C[N];
        };
        a3.Fd = function(b) {
          return a3.Oc(b) && b[r] && b[r].wb;
        };
        a3.b("computed", a3.o);
        a3.b("dependentObservable", a3.o);
        a3.b("isComputed", a3.Oc);
        a3.b("isPureComputed", a3.Fd);
        a3.b("computed.fn", C);
        a3.L(C, "peek", C.v);
        a3.L(C, "dispose", C.s);
        a3.L(C, "isActive", C.ja);
        a3.L(C, "getDependenciesCount", C.qa);
        a3.L(C, "getDependencies", C.Va);
        a3.xb = function(b, c) {
          if ("function" === typeof b)
            return a3.o(
              b,
              c,
              { pure: true }
            );
          b = a3.a.extend({}, b);
          b.pure = true;
          return a3.o(b, c);
        };
        a3.b("pureComputed", a3.xb);
        (function() {
          function b(a4, f, g) {
            g = g || new d();
            a4 = f(a4);
            if ("object" != typeof a4 || null === a4 || a4 === n || a4 instanceof RegExp || a4 instanceof Date || a4 instanceof String || a4 instanceof Number || a4 instanceof Boolean)
              return a4;
            var h = a4 instanceof Array ? [] : {};
            g.save(a4, h);
            c(a4, function(c2) {
              var d2 = f(a4[c2]);
              switch (typeof d2) {
                case "boolean":
                case "number":
                case "string":
                case "function":
                  h[c2] = d2;
                  break;
                case "object":
                case "undefined":
                  var l = g.get(d2);
                  h[c2] = l !== n ? l : b(d2, f, g);
              }
            });
            return h;
          }
          function c(a4, b2) {
            if (a4 instanceof Array) {
              for (var c2 = 0; c2 < a4.length; c2++)
                b2(c2);
              "function" == typeof a4.toJSON && b2("toJSON");
            } else
              for (c2 in a4)
                b2(c2);
          }
          function d() {
            this.keys = [];
            this.values = [];
          }
          a3.ad = function(c2) {
            if (0 == arguments.length)
              throw Error("When calling ko.toJS, pass the object you want to convert.");
            return b(c2, function(b2) {
              for (var c4 = 0; a3.O(b2) && 10 > c4; c4++)
                b2 = b2();
              return b2;
            });
          };
          a3.toJSON = function(b2, c2, d2) {
            b2 = a3.ad(b2);
            return a3.a.hc(b2, c2, d2);
          };
          d.prototype = { constructor: d, save: function(b2, c2) {
            var d2 = a3.a.A(
              this.keys,
              b2
            );
            0 <= d2 ? this.values[d2] = c2 : (this.keys.push(b2), this.values.push(c2));
          }, get: function(b2) {
            b2 = a3.a.A(this.keys, b2);
            return 0 <= b2 ? this.values[b2] : n;
          } };
        })();
        a3.b("toJS", a3.ad);
        a3.b("toJSON", a3.toJSON);
        a3.Wd = function(b, c, d) {
          function e(c2) {
            var e2 = a3.xb(b, d).extend({ ma: "always" }), h = e2.subscribe(function(a4) {
              a4 && (h.s(), c2(a4));
            });
            e2.notifySubscribers(e2.v());
            return h;
          }
          return "function" !== typeof Promise || c ? e(c.bind(d)) : new Promise(e);
        };
        a3.b("when", a3.Wd);
        (function() {
          a3.w = { M: function(b) {
            switch (a3.a.R(b)) {
              case "option":
                return true === b.__ko__hasDomDataOptionValue__ ? a3.a.g.get(b, a3.c.options.$b) : 7 >= a3.a.W ? b.getAttributeNode("value") && b.getAttributeNode("value").specified ? b.value : b.text : b.value;
              case "select":
                return 0 <= b.selectedIndex ? a3.w.M(b.options[b.selectedIndex]) : n;
              default:
                return b.value;
            }
          }, cb: function(b, c, d) {
            switch (a3.a.R(b)) {
              case "option":
                "string" === typeof c ? (a3.a.g.set(b, a3.c.options.$b, n), "__ko__hasDomDataOptionValue__" in b && delete b.__ko__hasDomDataOptionValue__, b.value = c) : (a3.a.g.set(b, a3.c.options.$b, c), b.__ko__hasDomDataOptionValue__ = true, b.value = "number" === typeof c ? c : "");
                break;
              case "select":
                if ("" === c || null === c)
                  c = n;
                for (var e = -1, f = 0, g = b.options.length, h; f < g; ++f)
                  if (h = a3.w.M(b.options[f]), h == c || "" === h && c === n) {
                    e = f;
                    break;
                  }
                if (d || 0 <= e || c === n && 1 < b.size)
                  b.selectedIndex = e, 6 === a3.a.W && a3.a.setTimeout(function() {
                    b.selectedIndex = e;
                  }, 0);
                break;
              default:
                if (null === c || c === n)
                  c = "";
                b.value = c;
            }
          } };
        })();
        a3.b("selectExtensions", a3.w);
        a3.b("selectExtensions.readValue", a3.w.M);
        a3.b("selectExtensions.writeValue", a3.w.cb);
        a3.m = function() {
          function b(b2) {
            b2 = a3.a.Db(b2);
            123 === b2.charCodeAt(0) && (b2 = b2.slice(
              1,
              -1
            ));
            b2 += "\n,";
            var c2 = [], d2 = b2.match(e), p, q = [], h2 = 0;
            if (1 < d2.length) {
              for (var x = 0, B; B = d2[x]; ++x) {
                var u3 = B.charCodeAt(0);
                if (44 === u3) {
                  if (0 >= h2) {
                    c2.push(p && q.length ? { key: p, value: q.join("") } : { unknown: p || q.join("") });
                    p = h2 = 0;
                    q = [];
                    continue;
                  }
                } else if (58 === u3) {
                  if (!h2 && !p && 1 === q.length) {
                    p = q.pop();
                    continue;
                  }
                } else if (47 === u3 && 1 < B.length && (47 === B.charCodeAt(1) || 42 === B.charCodeAt(1)))
                  continue;
                else
                  47 === u3 && x && 1 < B.length ? (u3 = d2[x - 1].match(f)) && !g[u3[0]] && (b2 = b2.substr(b2.indexOf(B) + 1), d2 = b2.match(e), x = -1, B = "/") : 40 === u3 || 123 === u3 || 91 === u3 ? ++h2 : 41 === u3 || 125 === u3 || 93 === u3 ? --h2 : p || q.length || 34 !== u3 && 39 !== u3 || (B = B.slice(1, -1));
                q.push(B);
              }
              if (0 < h2)
                throw Error("Unbalanced parentheses, braces, or brackets");
            }
            return c2;
          }
          var c = ["true", "false", "null", "undefined"], d = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i, e = RegExp("\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|`(?:\\\\.|[^`])*`|/\\*(?:[^*]|\\*+[^*/])*\\*+/|//.*\n|/(?:\\\\.|[^/])+/w*|[^\\s:,/][^,\"'`{}()/:[\\]]*[^\\s,\"'`{}()/:[\\]]|[^\\s]", "g"), f = /[\])"'A-Za-z0-9_$]+$/, g = { "in": 1, "return": 1, "typeof": 1 }, h = {};
          return { Ra: [], wa: h, ac: b, vb: function(e2, f2) {
            function l(b2, e3) {
              var f3;
              if (!x) {
                var k = a3.getBindingHandler(b2);
                if (k && k.preprocess && !(e3 = k.preprocess(e3, b2, l)))
                  return;
                if (k = h[b2])
                  f3 = e3, 0 <= a3.a.A(c, f3) ? f3 = false : (k = f3.match(d), f3 = null === k ? false : k[1] ? "Object(" + k[1] + ")" + k[2] : f3), k = f3;
                k && q.push("'" + ("string" == typeof h[b2] ? h[b2] : b2) + "':function(_z){" + f3 + "=_z}");
              }
              g2 && (e3 = "function(){return " + e3 + " }");
              p.push("'" + b2 + "':" + e3);
            }
            f2 = f2 || {};
            var p = [], q = [], g2 = f2.valueAccessors, x = f2.bindingParams, B = "string" === typeof e2 ? b(e2) : e2;
            a3.a.D(B, function(a4) {
              l(
                a4.key || a4.unknown,
                a4.value
              );
            });
            q.length && l("_ko_property_writers", "{" + q.join(",") + " }");
            return p.join(",");
          }, Id: function(a4, b2) {
            for (var c2 = 0; c2 < a4.length; c2++)
              if (a4[c2].key == b2)
                return true;
            return false;
          }, eb: function(b2, c2, d2, e2, f2) {
            if (b2 && a3.O(b2))
              !a3.Za(b2) || f2 && b2.v() === e2 || b2(e2);
            else if ((b2 = c2.get("_ko_property_writers")) && b2[d2])
              b2[d2](e2);
          } };
        }();
        a3.b("expressionRewriting", a3.m);
        a3.b("expressionRewriting.bindingRewriteValidators", a3.m.Ra);
        a3.b("expressionRewriting.parseObjectLiteral", a3.m.ac);
        a3.b("expressionRewriting.preProcessBindings", a3.m.vb);
        a3.b(
          "expressionRewriting._twoWayBindings",
          a3.m.wa
        );
        a3.b("jsonExpressionRewriting", a3.m);
        a3.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson", a3.m.vb);
        (function() {
          function b(a4) {
            return 8 == a4.nodeType && g.test(f ? a4.text : a4.nodeValue);
          }
          function c(a4) {
            return 8 == a4.nodeType && h.test(f ? a4.text : a4.nodeValue);
          }
          function d(d2, e2) {
            for (var f2 = d2, h2 = 1, g2 = []; f2 = f2.nextSibling; ) {
              if (c(f2) && (a3.a.g.set(f2, k, true), h2--, 0 === h2))
                return g2;
              g2.push(f2);
              b(f2) && h2++;
            }
            if (!e2)
              throw Error("Cannot find closing comment tag to match: " + d2.nodeValue);
            return null;
          }
          function e(a4, b2) {
            var c2 = d(a4, b2);
            return c2 ? 0 < c2.length ? c2[c2.length - 1].nextSibling : a4.nextSibling : null;
          }
          var f = w && "<!--test-->" === w.createComment("test").text, g = f ? /^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/, h = f ? /^\x3c!--\s*\/ko\s*--\x3e$/ : /^\s*\/ko\s*$/, m = { ul: true, ol: true }, k = "__ko_matchedEndComment__";
          a3.h = { ea: {}, childNodes: function(a4) {
            return b(a4) ? d(a4) : a4.childNodes;
          }, Ea: function(c2) {
            if (b(c2)) {
              c2 = a3.h.childNodes(c2);
              for (var d2 = 0, e2 = c2.length; d2 < e2; d2++)
                a3.removeNode(c2[d2]);
            } else
              a3.a.Tb(c2);
          }, va: function(c2, d2) {
            if (b(c2)) {
              a3.h.Ea(c2);
              for (var e2 = c2.nextSibling, f2 = 0, k2 = d2.length; f2 < k2; f2++)
                e2.parentNode.insertBefore(d2[f2], e2);
            } else
              a3.a.va(c2, d2);
          }, Vc: function(a4, c2) {
            var d2;
            b(a4) ? (d2 = a4.nextSibling, a4 = a4.parentNode) : d2 = a4.firstChild;
            d2 ? c2 !== d2 && a4.insertBefore(c2, d2) : a4.appendChild(c2);
          }, Wb: function(c2, d2, e2) {
            e2 ? (e2 = e2.nextSibling, b(c2) && (c2 = c2.parentNode), e2 ? d2 !== e2 && c2.insertBefore(d2, e2) : c2.appendChild(d2)) : a3.h.Vc(c2, d2);
          }, firstChild: function(a4) {
            if (b(a4))
              return !a4.nextSibling || c(a4.nextSibling) ? null : a4.nextSibling;
            if (a4.firstChild && c(a4.firstChild))
              throw Error("Found invalid end comment, as the first child of " + a4);
            return a4.firstChild;
          }, nextSibling: function(d2) {
            b(d2) && (d2 = e(d2));
            if (d2.nextSibling && c(d2.nextSibling)) {
              var f2 = d2.nextSibling;
              if (c(f2) && !a3.a.g.get(f2, k))
                throw Error("Found end comment without a matching opening comment, as child of " + d2);
              return null;
            }
            return d2.nextSibling;
          }, Cd: b, Vd: function(a4) {
            return (a4 = (f ? a4.text : a4.nodeValue).match(g)) ? a4[1] : null;
          }, Sc: function(d2) {
            if (m[a3.a.R(d2)]) {
              var f2 = d2.firstChild;
              if (f2) {
                do
                  if (1 === f2.nodeType) {
                    var k2;
                    k2 = f2.firstChild;
                    var h2 = null;
                    if (k2) {
                      do
                        if (h2)
                          h2.push(k2);
                        else if (b(k2)) {
                          var g2 = e(k2, true);
                          g2 ? k2 = g2 : h2 = [k2];
                        } else
                          c(k2) && (h2 = [k2]);
                      while (k2 = k2.nextSibling);
                    }
                    if (k2 = h2)
                      for (h2 = f2.nextSibling, g2 = 0; g2 < k2.length; g2++)
                        h2 ? d2.insertBefore(k2[g2], h2) : d2.appendChild(k2[g2]);
                  }
                while (f2 = f2.nextSibling);
              }
            }
          } };
        })();
        a3.b("virtualElements", a3.h);
        a3.b("virtualElements.allowedBindings", a3.h.ea);
        a3.b("virtualElements.emptyNode", a3.h.Ea);
        a3.b("virtualElements.insertAfter", a3.h.Wb);
        a3.b("virtualElements.prepend", a3.h.Vc);
        a3.b("virtualElements.setDomNodeChildren", a3.h.va);
        (function() {
          a3.ga = function() {
            this.nd = {};
          };
          a3.a.extend(a3.ga.prototype, {
            nodeHasBindings: function(b) {
              switch (b.nodeType) {
                case 1:
                  return null != b.getAttribute("data-bind") || a3.j.getComponentNameForNode(b);
                case 8:
                  return a3.h.Cd(b);
                default:
                  return false;
              }
            },
            getBindings: function(b, c) {
              var d = this.getBindingsString(b, c), d = d ? this.parseBindingsString(d, c, b) : null;
              return a3.j.tc(d, b, c, false);
            },
            getBindingAccessors: function(b, c) {
              var d = this.getBindingsString(b, c), d = d ? this.parseBindingsString(d, c, b, { valueAccessors: true }) : null;
              return a3.j.tc(d, b, c, true);
            },
            getBindingsString: function(b) {
              switch (b.nodeType) {
                case 1:
                  return b.getAttribute("data-bind");
                case 8:
                  return a3.h.Vd(b);
                default:
                  return null;
              }
            },
            parseBindingsString: function(b, c, d, e) {
              try {
                var f = this.nd, g = b + (e && e.valueAccessors || ""), h;
                if (!(h = f[g])) {
                  var m, k = "with($context){with($data||{}){return{" + a3.m.vb(b, e) + "}}}";
                  m = new Function("$context", "$element", k);
                  h = f[g] = m;
                }
                return h(c, d);
              } catch (l) {
                throw l.message = "Unable to parse bindings.\nBindings value: " + b + "\nMessage: " + l.message, l;
              }
            }
          });
          a3.ga.instance = new a3.ga();
        })();
        a3.b("bindingProvider", a3.ga);
        (function() {
          function b(b2) {
            var c2 = (b2 = a3.a.g.get(b2, z)) && b2.N;
            c2 && (b2.N = null, c2.Tc());
          }
          function c(c2, d2, e2) {
            this.node = c2;
            this.yc = d2;
            this.kb = [];
            this.H = false;
            d2.N || a3.a.K.za(c2, b);
            e2 && e2.N && (e2.N.kb.push(c2), this.Kb = e2);
          }
          function d(a4) {
            return function() {
              return a4;
            };
          }
          function e(a4) {
            return a4();
          }
          function f(b2) {
            return a3.a.Ga(a3.u.G(b2), function(a4, c2) {
              return function() {
                return b2()[c2];
              };
            });
          }
          function g(b2, c2, e2) {
            return "function" === typeof b2 ? f(b2.bind(null, c2, e2)) : a3.a.Ga(b2, d);
          }
          function h(a4, b2) {
            return f(this.getBindings.bind(this, a4, b2));
          }
          function m(b2, c2) {
            var d2 = a3.h.firstChild(c2);
            if (d2) {
              var e2, f2 = a3.ga.instance, l2 = f2.preprocessNode;
              if (l2) {
                for (; e2 = d2; )
                  d2 = a3.h.nextSibling(e2), l2.call(f2, e2);
                d2 = a3.h.firstChild(c2);
              }
              for (; e2 = d2; )
                d2 = a3.h.nextSibling(e2), k(b2, e2);
            }
            a3.i.ma(c2, a3.i.H);
          }
          function k(b2, c2) {
            var d2 = b2, e2 = 1 === c2.nodeType;
            e2 && a3.h.Sc(c2);
            if (e2 || a3.ga.instance.nodeHasBindings(c2))
              d2 = p(c2, null, b2).bindingContextForDescendants;
            d2 && !u3[a3.a.R(c2)] && m(d2, c2);
          }
          function l(b2) {
            var c2 = [], d2 = {}, e2 = [];
            a3.a.P(b2, function ca(f2) {
              if (!d2[f2]) {
                var k2 = a3.getBindingHandler(f2);
                k2 && (k2.after && (e2.push(f2), a3.a.D(k2.after, function(c4) {
                  if (b2[c4]) {
                    if (-1 !== a3.a.A(e2, c4))
                      throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + e2.join(", "));
                    ca(c4);
                  }
                }), e2.length--), c2.push({ key: f2, Mc: k2 }));
                d2[f2] = true;
              }
            });
            return c2;
          }
          function p(b2, c2, d2) {
            var f2 = a3.a.g.Ub(b2, z, {}), k2 = f2.hd;
            if (!c2) {
              if (k2)
                throw Error("You cannot apply bindings multiple times to the same element.");
              f2.hd = true;
            }
            k2 || (f2.context = d2);
            f2.Zb || (f2.Zb = {});
            var g2;
            if (c2 && "function" !== typeof c2)
              g2 = c2;
            else {
              var p2 = a3.ga.instance, q3 = p2.getBindingAccessors || h, m2 = a3.$(function() {
                if (g2 = c2 ? c2(d2, b2) : q3.call(p2, b2, d2)) {
                  if (d2[t])
                    d2[t]();
                  if (d2[B])
                    d2[B]();
                }
                return g2;
              }, null, { l: b2 });
              g2 && m2.ja() || (m2 = null);
            }
            var x2 = d2, u4;
            if (g2) {
              var J2 = function() {
                return a3.a.Ga(m2 ? m2() : g2, e);
              }, r2 = m2 ? function(a4) {
                return function() {
                  return e(m2()[a4]);
                };
              } : function(a4) {
                return g2[a4];
              };
              J2.get = function(a4) {
                return g2[a4] && e(r2(a4));
              };
              J2.has = function(a4) {
                return a4 in g2;
              };
              a3.i.H in g2 && a3.i.subscribe(b2, a3.i.H, function() {
                var c4 = (0, g2[a3.i.H])();
                if (c4) {
                  var d3 = a3.h.childNodes(b2);
                  d3.length && c4(d3, a3.Ec(d3[0]));
                }
              });
              a3.i.pa in g2 && (x2 = a3.i.Cb(b2, d2), a3.i.subscribe(b2, a3.i.pa, function() {
                var c4 = (0, g2[a3.i.pa])();
                c4 && a3.h.firstChild(b2) && c4(b2);
              }));
              f2 = l(g2);
              a3.a.D(f2, function(c4) {
                var d3 = c4.Mc.init, e2 = c4.Mc.update, f3 = c4.key;
                if (8 === b2.nodeType && !a3.h.ea[f3])
                  throw Error("The binding '" + f3 + "' cannot be used with virtual elements");
                try {
                  "function" == typeof d3 && a3.u.G(function() {
                    var a4 = d3(b2, r2(f3), J2, x2.$data, x2);
                    if (a4 && a4.controlsDescendantBindings) {
                      if (u4 !== n)
                        throw Error("Multiple bindings (" + u4 + " and " + f3 + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                      u4 = f3;
                    }
                  }), "function" == typeof e2 && a3.$(function() {
                    e2(b2, r2(f3), J2, x2.$data, x2);
                  }, null, { l: b2 });
                } catch (k3) {
                  throw k3.message = 'Unable to process binding "' + f3 + ": " + g2[f3] + '"\nMessage: ' + k3.message, k3;
                }
              });
            }
            f2 = u4 === n;
            return { shouldBindDescendants: f2, bindingContextForDescendants: f2 && x2 };
          }
          function q(b2, c2) {
            return b2 && b2 instanceof a3.fa ? b2 : new a3.fa(b2, n, n, c2);
          }
          var t = a3.a.Da("_subscribable"), x = a3.a.Da("_ancestorBindingInfo"), B = a3.a.Da("_dataDependency");
          a3.c = {};
          var u3 = { script: true, textarea: true, template: true };
          a3.getBindingHandler = function(b2) {
            return a3.c[b2];
          };
          var J = {};
          a3.fa = function(b2, c2, d2, e2, f2) {
            function k2() {
              var b3 = p2 ? h2() : h2, f3 = a3.a.f(b3);
              c2 ? (a3.a.extend(l2, c2), x in c2 && (l2[x] = c2[x])) : (l2.$parents = [], l2.$root = f3, l2.ko = a3);
              l2[t] = q3;
              g2 ? f3 = l2.$data : (l2.$rawData = b3, l2.$data = f3);
              d2 && (l2[d2] = f3);
              e2 && e2(l2, c2, f3);
              if (c2 && c2[t] && !a3.S.o().Vb(c2[t]))
                c2[t]();
              m2 && (l2[B] = m2);
              return l2.$data;
            }
            var l2 = this, g2 = b2 === J, h2 = g2 ? n : b2, p2 = "function" == typeof h2 && !a3.O(h2), q3, m2 = f2 && f2.dataDependency;
            f2 && f2.exportDependencies ? k2() : (q3 = a3.xb(k2), q3.v(), q3.ja() ? q3.equalityComparer = null : l2[t] = n);
          };
          a3.fa.prototype.createChildContext = function(b2, c2, d2, e2) {
            !e2 && c2 && "object" == typeof c2 && (e2 = c2, c2 = e2.as, d2 = e2.extend);
            if (c2 && e2 && e2.noChildContext) {
              var f2 = "function" == typeof b2 && !a3.O(b2);
              return new a3.fa(J, this, null, function(a4) {
                d2 && d2(a4);
                a4[c2] = f2 ? b2() : b2;
              }, e2);
            }
            return new a3.fa(
              b2,
              this,
              c2,
              function(a4, b3) {
                a4.$parentContext = b3;
                a4.$parent = b3.$data;
                a4.$parents = (b3.$parents || []).slice(0);
                a4.$parents.unshift(a4.$parent);
                d2 && d2(a4);
              },
              e2
            );
          };
          a3.fa.prototype.extend = function(b2, c2) {
            return new a3.fa(J, this, null, function(c4) {
              a3.a.extend(c4, "function" == typeof b2 ? b2(c4) : b2);
            }, c2);
          };
          var z = a3.a.g.Z();
          c.prototype.Tc = function() {
            this.Kb && this.Kb.N && this.Kb.N.sd(this.node);
          };
          c.prototype.sd = function(b2) {
            a3.a.Pa(this.kb, b2);
            !this.kb.length && this.H && this.Cc();
          };
          c.prototype.Cc = function() {
            this.H = true;
            this.yc.N && !this.kb.length && (this.yc.N = null, a3.a.K.yb(this.node, b), a3.i.ma(this.node, a3.i.pa), this.Tc());
          };
          a3.i = { H: "childrenComplete", pa: "descendantsComplete", subscribe: function(b2, c2, d2, e2, f2) {
            var k2 = a3.a.g.Ub(b2, z, {});
            k2.Fa || (k2.Fa = new a3.T());
            f2 && f2.notifyImmediately && k2.Zb[c2] && a3.u.G(d2, e2, [b2]);
            return k2.Fa.subscribe(d2, e2, c2);
          }, ma: function(b2, c2) {
            var d2 = a3.a.g.get(b2, z);
            if (d2 && (d2.Zb[c2] = true, d2.Fa && d2.Fa.notifySubscribers(b2, c2), c2 == a3.i.H)) {
              if (d2.N)
                d2.N.Cc();
              else if (d2.N === n && d2.Fa && d2.Fa.Wa(a3.i.pa))
                throw Error("descendantsComplete event not supported for bindings on this node");
            }
          }, Cb: function(b2, d2) {
            var e2 = a3.a.g.Ub(b2, z, {});
            e2.N || (e2.N = new c(b2, e2, d2[x]));
            return d2[x] == e2 ? d2 : d2.extend(function(a4) {
              a4[x] = e2;
            });
          } };
          a3.Td = function(b2) {
            return (b2 = a3.a.g.get(b2, z)) && b2.context;
          };
          a3.ib = function(b2, c2, d2) {
            1 === b2.nodeType && a3.h.Sc(b2);
            return p(b2, c2, q(d2));
          };
          a3.ld = function(b2, c2, d2) {
            d2 = q(d2);
            return a3.ib(b2, g(c2, d2, b2), d2);
          };
          a3.Oa = function(a4, b2) {
            1 !== b2.nodeType && 8 !== b2.nodeType || m(q(a4), b2);
          };
          a3.vc = function(a4, b2, c2) {
            !v3 && A.jQuery && (v3 = A.jQuery);
            if (2 > arguments.length) {
              if (b2 = w.body, !b2)
                throw Error("ko.applyBindings: could not find document.body; has the document been loaded?");
            } else if (!b2 || 1 !== b2.nodeType && 8 !== b2.nodeType)
              throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
            k(q(a4, c2), b2);
          };
          a3.Dc = function(b2) {
            return !b2 || 1 !== b2.nodeType && 8 !== b2.nodeType ? n : a3.Td(b2);
          };
          a3.Ec = function(b2) {
            return (b2 = a3.Dc(b2)) ? b2.$data : n;
          };
          a3.b("bindingHandlers", a3.c);
          a3.b("bindingEvent", a3.i);
          a3.b("bindingEvent.subscribe", a3.i.subscribe);
          a3.b("bindingEvent.startPossiblyAsyncContentBinding", a3.i.Cb);
          a3.b("applyBindings", a3.vc);
          a3.b("applyBindingsToDescendants", a3.Oa);
          a3.b("applyBindingAccessorsToNode", a3.ib);
          a3.b("applyBindingsToNode", a3.ld);
          a3.b("contextFor", a3.Dc);
          a3.b("dataFor", a3.Ec);
        })();
        (function(b) {
          function c(c2, e2) {
            var k = Object.prototype.hasOwnProperty.call(f, c2) ? f[c2] : b, l;
            k ? k.subscribe(e2) : (k = f[c2] = new a3.T(), k.subscribe(e2), d(c2, function(b2, d2) {
              var e3 = !(!d2 || !d2.synchronous);
              g[c2] = { definition: b2, Gd: e3 };
              delete f[c2];
              l || e3 ? k.notifySubscribers(b2) : a3.na.zb(function() {
                k.notifySubscribers(b2);
              });
            }), l = true);
          }
          function d(a4, b2) {
            e("getConfig", [a4], function(c2) {
              c2 ? e("loadComponent", [a4, c2], function(a5) {
                b2(
                  a5,
                  c2
                );
              }) : b2(null, null);
            });
          }
          function e(c2, d2, f2, l) {
            l || (l = a3.j.loaders.slice(0));
            var g2 = l.shift();
            if (g2) {
              var q = g2[c2];
              if (q) {
                var t = false;
                if (q.apply(g2, d2.concat(function(a4) {
                  t ? f2(null) : null !== a4 ? f2(a4) : e(c2, d2, f2, l);
                })) !== b && (t = true, !g2.suppressLoaderExceptions))
                  throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
              } else
                e(c2, d2, f2, l);
            } else
              f2(null);
          }
          var f = {}, g = {};
          a3.j = { get: function(d2, e2) {
            var f2 = Object.prototype.hasOwnProperty.call(g, d2) ? g[d2] : b;
            f2 ? f2.Gd ? a3.u.G(function() {
              e2(f2.definition);
            }) : a3.na.zb(function() {
              e2(f2.definition);
            }) : c(d2, e2);
          }, Bc: function(a4) {
            delete g[a4];
          }, oc: e };
          a3.j.loaders = [];
          a3.b("components", a3.j);
          a3.b("components.get", a3.j.get);
          a3.b("components.clearCachedDefinition", a3.j.Bc);
        })();
        (function() {
          function b(b2, c2, d2, e2) {
            function g2() {
              0 === --B && e2(h2);
            }
            var h2 = {}, B = 2, u3 = d2.template;
            d2 = d2.viewModel;
            u3 ? f(c2, u3, function(c4) {
              a3.j.oc("loadTemplate", [b2, c4], function(a4) {
                h2.template = a4;
                g2();
              });
            }) : g2();
            d2 ? f(c2, d2, function(c4) {
              a3.j.oc("loadViewModel", [b2, c4], function(a4) {
                h2[m] = a4;
                g2();
              });
            }) : g2();
          }
          function c(a4, b2, d2) {
            if ("function" === typeof b2)
              d2(function(a5) {
                return new b2(a5);
              });
            else if ("function" === typeof b2[m])
              d2(b2[m]);
            else if ("instance" in b2) {
              var e2 = b2.instance;
              d2(function() {
                return e2;
              });
            } else
              "viewModel" in b2 ? c(a4, b2.viewModel, d2) : a4("Unknown viewModel value: " + b2);
          }
          function d(b2) {
            switch (a3.a.R(b2)) {
              case "script":
                return a3.a.ua(b2.text);
              case "textarea":
                return a3.a.ua(b2.value);
              case "template":
                if (e(b2.content))
                  return a3.a.Ca(b2.content.childNodes);
            }
            return a3.a.Ca(b2.childNodes);
          }
          function e(a4) {
            return A.DocumentFragment ? a4 instanceof DocumentFragment : a4 && 11 === a4.nodeType;
          }
          function f(a4, b2, c2) {
            "string" === typeof b2.require ? T || A.require ? (T || A.require)([b2.require], function(a5) {
              a5 && "object" === typeof a5 && a5.Xd && a5["default"] && (a5 = a5["default"]);
              c2(a5);
            }) : a4("Uses require, but no AMD loader is present") : c2(b2);
          }
          function g(a4) {
            return function(b2) {
              throw Error("Component '" + a4 + "': " + b2);
            };
          }
          var h = {};
          a3.j.register = function(b2, c2) {
            if (!c2)
              throw Error("Invalid configuration for " + b2);
            if (a3.j.tb(b2))
              throw Error("Component " + b2 + " is already registered");
            h[b2] = c2;
          };
          a3.j.tb = function(a4) {
            return Object.prototype.hasOwnProperty.call(h, a4);
          };
          a3.j.unregister = function(b2) {
            delete h[b2];
            a3.j.Bc(b2);
          };
          a3.j.Fc = { getConfig: function(b2, c2) {
            c2(a3.j.tb(b2) ? h[b2] : null);
          }, loadComponent: function(a4, c2, d2) {
            var e2 = g(a4);
            f(e2, c2, function(c4) {
              b(a4, e2, c4, d2);
            });
          }, loadTemplate: function(b2, c2, f2) {
            b2 = g(b2);
            if ("string" === typeof c2)
              f2(a3.a.ua(c2));
            else if (c2 instanceof Array)
              f2(c2);
            else if (e(c2))
              f2(a3.a.la(c2.childNodes));
            else if (c2.element)
              if (c2 = c2.element, A.HTMLElement ? c2 instanceof HTMLElement : c2 && c2.tagName && 1 === c2.nodeType)
                f2(d(c2));
              else if ("string" === typeof c2) {
                var h2 = w.getElementById(c2);
                h2 ? f2(d(h2)) : b2("Cannot find element with ID " + c2);
              } else
                b2("Unknown element type: " + c2);
            else
              b2("Unknown template value: " + c2);
          }, loadViewModel: function(a4, b2, d2) {
            c(g(a4), b2, d2);
          } };
          var m = "createViewModel";
          a3.b("components.register", a3.j.register);
          a3.b("components.isRegistered", a3.j.tb);
          a3.b("components.unregister", a3.j.unregister);
          a3.b("components.defaultLoader", a3.j.Fc);
          a3.j.loaders.push(a3.j.Fc);
          a3.j.dd = h;
        })();
        (function() {
          function b(b2, e) {
            var f = b2.getAttribute("params");
            if (f) {
              var f = c.parseBindingsString(f, e, b2, { valueAccessors: true, bindingParams: true }), f = a3.a.Ga(f, function(c2) {
                return a3.o(c2, null, { l: b2 });
              }), g = a3.a.Ga(
                f,
                function(c2) {
                  var e2 = c2.v();
                  return c2.ja() ? a3.o({ read: function() {
                    return a3.a.f(c2());
                  }, write: a3.Za(e2) && function(a4) {
                    c2()(a4);
                  }, l: b2 }) : e2;
                }
              );
              Object.prototype.hasOwnProperty.call(g, "$raw") || (g.$raw = f);
              return g;
            }
            return { $raw: {} };
          }
          a3.j.getComponentNameForNode = function(b2) {
            var c2 = a3.a.R(b2);
            if (a3.j.tb(c2) && (-1 != c2.indexOf("-") || "[object HTMLUnknownElement]" == "" + b2 || 8 >= a3.a.W && b2.tagName === c2))
              return c2;
          };
          a3.j.tc = function(c2, e, f, g) {
            if (1 === e.nodeType) {
              var h = a3.j.getComponentNameForNode(e);
              if (h) {
                c2 = c2 || {};
                if (c2.component)
                  throw Error('Cannot use the "component" binding on a custom element matching a component');
                var m = { name: h, params: b(e, f) };
                c2.component = g ? function() {
                  return m;
                } : m;
              }
            }
            return c2;
          };
          var c = new a3.ga();
          9 > a3.a.W && (a3.j.register = function(a4) {
            return function(b2) {
              return a4.apply(this, arguments);
            };
          }(a3.j.register), w.createDocumentFragment = function(b2) {
            return function() {
              var c2 = b2(), f = a3.j.dd, g;
              for (g in f)
                ;
              return c2;
            };
          }(w.createDocumentFragment));
        })();
        (function() {
          function b(b2, c2, d2) {
            c2 = c2.template;
            if (!c2)
              throw Error("Component '" + b2 + "' has no template");
            b2 = a3.a.Ca(c2);
            a3.h.va(d2, b2);
          }
          function c(a4, b2, c2) {
            var d2 = a4.createViewModel;
            return d2 ? d2.call(
              a4,
              b2,
              c2
            ) : b2;
          }
          var d = 0;
          a3.c.component = { init: function(e, f, g, h, m) {
            function k() {
              var a4 = l && l.dispose;
              "function" === typeof a4 && a4.call(l);
              q && q.s();
              p = l = q = null;
            }
            var l, p, q, t = a3.a.la(a3.h.childNodes(e));
            a3.h.Ea(e);
            a3.a.K.za(e, k);
            a3.o(function() {
              var g2 = a3.a.f(f()), h2, u3;
              "string" === typeof g2 ? h2 = g2 : (h2 = a3.a.f(g2.name), u3 = a3.a.f(g2.params));
              if (!h2)
                throw Error("No component name specified");
              var n2 = a3.i.Cb(e, m), z = p = ++d;
              a3.j.get(h2, function(d2) {
                if (p === z) {
                  k();
                  if (!d2)
                    throw Error("Unknown component '" + h2 + "'");
                  b(h2, d2, e);
                  var f2 = c(d2, u3, { element: e, templateNodes: t });
                  d2 = n2.createChildContext(f2, { extend: function(a4) {
                    a4.$component = f2;
                    a4.$componentTemplateNodes = t;
                  } });
                  f2 && f2.koDescendantsComplete && (q = a3.i.subscribe(e, a3.i.pa, f2.koDescendantsComplete, f2));
                  l = f2;
                  a3.Oa(d2, e);
                }
              });
            }, null, { l: e });
            return { controlsDescendantBindings: true };
          } };
          a3.h.ea.component = true;
        })();
        var V = { "class": "className", "for": "htmlFor" };
        a3.c.attr = { update: function(b, c) {
          var d = a3.a.f(c()) || {};
          a3.a.P(d, function(c2, d2) {
            d2 = a3.a.f(d2);
            var g = c2.indexOf(":"), g = "lookupNamespaceURI" in b && 0 < g && b.lookupNamespaceURI(c2.substr(0, g)), h = false === d2 || null === d2 || d2 === n;
            h ? g ? b.removeAttributeNS(g, c2) : b.removeAttribute(c2) : d2 = d2.toString();
            8 >= a3.a.W && c2 in V ? (c2 = V[c2], h ? b.removeAttribute(c2) : b[c2] = d2) : h || (g ? b.setAttributeNS(g, c2, d2) : b.setAttribute(c2, d2));
            "name" === c2 && a3.a.Yc(b, h ? "" : d2);
          });
        } };
        (function() {
          a3.c.checked = { after: ["value", "attr"], init: function(b, c, d) {
            function e() {
              var e2 = b.checked, f2 = g();
              if (!a3.S.Ya() && (e2 || !m && !a3.S.qa())) {
                var k2 = a3.u.G(c);
                if (l) {
                  var q3 = p ? k2.v() : k2, z = t;
                  t = f2;
                  z !== f2 ? e2 && (a3.a.Na(q3, f2, true), a3.a.Na(q3, z, false)) : a3.a.Na(q3, f2, e2);
                  p && a3.Za(k2) && k2(q3);
                } else
                  h && (f2 === n ? f2 = e2 : e2 || (f2 = n)), a3.m.eb(
                    k2,
                    d,
                    "checked",
                    f2,
                    true
                  );
              }
            }
            function f() {
              var d2 = a3.a.f(c()), e2 = g();
              l ? (b.checked = 0 <= a3.a.A(d2, e2), t = e2) : b.checked = h && e2 === n ? !!d2 : g() === d2;
            }
            var g = a3.xb(function() {
              if (d.has("checkedValue"))
                return a3.a.f(d.get("checkedValue"));
              if (q)
                return d.has("value") ? a3.a.f(d.get("value")) : b.value;
            }), h = "checkbox" == b.type, m = "radio" == b.type;
            if (h || m) {
              var k = c(), l = h && a3.a.f(k) instanceof Array, p = !(l && k.push && k.splice), q = m || l, t = l ? g() : n;
              m && !b.name && a3.c.uniqueName.init(b, function() {
                return true;
              });
              a3.o(e, null, { l: b });
              a3.a.B(b, "click", e);
              a3.o(f, null, { l: b });
              k = n;
            }
          } };
          a3.m.wa.checked = true;
          a3.c.checkedValue = { update: function(b, c) {
            b.value = a3.a.f(c());
          } };
        })();
        a3.c["class"] = { update: function(b, c) {
          var d = a3.a.Db(a3.a.f(c()));
          a3.a.Eb(b, b.__ko__cssValue, false);
          b.__ko__cssValue = d;
          a3.a.Eb(b, d, true);
        } };
        a3.c.css = { update: function(b, c) {
          var d = a3.a.f(c());
          null !== d && "object" == typeof d ? a3.a.P(d, function(c2, d2) {
            d2 = a3.a.f(d2);
            a3.a.Eb(b, c2, d2);
          }) : a3.c["class"].update(b, c);
        } };
        a3.c.enable = { update: function(b, c) {
          var d = a3.a.f(c());
          d && b.disabled ? b.removeAttribute("disabled") : d || b.disabled || (b.disabled = true);
        } };
        a3.c.disable = { update: function(b, c) {
          a3.c.enable.update(b, function() {
            return !a3.a.f(c());
          });
        } };
        a3.c.event = { init: function(b, c, d, e, f) {
          var g = c() || {};
          a3.a.P(g, function(g2) {
            "string" == typeof g2 && a3.a.B(b, g2, function(b2) {
              var k, l = c()[g2];
              if (l) {
                try {
                  var p = a3.a.la(arguments);
                  e = f.$data;
                  p.unshift(e);
                  k = l.apply(e, p);
                } finally {
                  true !== k && (b2.preventDefault ? b2.preventDefault() : b2.returnValue = false);
                }
                false === d.get(g2 + "Bubble") && (b2.cancelBubble = true, b2.stopPropagation && b2.stopPropagation());
              }
            });
          });
        } };
        a3.c.foreach = { Rc: function(b) {
          return function() {
            var c = b(), d = a3.a.bc(c);
            if (!d || "number" == typeof d.length)
              return { foreach: c, templateEngine: a3.ba.Ma };
            a3.a.f(c);
            return { foreach: d.data, as: d.as, noChildContext: d.noChildContext, includeDestroyed: d.includeDestroyed, afterAdd: d.afterAdd, beforeRemove: d.beforeRemove, afterRender: d.afterRender, beforeMove: d.beforeMove, afterMove: d.afterMove, templateEngine: a3.ba.Ma };
          };
        }, init: function(b, c) {
          return a3.c.template.init(b, a3.c.foreach.Rc(c));
        }, update: function(b, c, d, e, f) {
          return a3.c.template.update(b, a3.c.foreach.Rc(c), d, e, f);
        } };
        a3.m.Ra.foreach = false;
        a3.h.ea.foreach = true;
        a3.c.hasfocus = { init: function(b, c, d) {
          function e(e2) {
            b.__ko_hasfocusUpdating = true;
            var f2 = b.ownerDocument;
            if ("activeElement" in f2) {
              var g2;
              try {
                g2 = f2.activeElement;
              } catch (l) {
                g2 = f2.body;
              }
              e2 = g2 === b;
            }
            f2 = c();
            a3.m.eb(f2, d, "hasfocus", e2, true);
            b.__ko_hasfocusLastValue = e2;
            b.__ko_hasfocusUpdating = false;
          }
          var f = e.bind(null, true), g = e.bind(null, false);
          a3.a.B(b, "focus", f);
          a3.a.B(b, "focusin", f);
          a3.a.B(b, "blur", g);
          a3.a.B(b, "focusout", g);
          b.__ko_hasfocusLastValue = false;
        }, update: function(b, c) {
          var d = !!a3.a.f(c());
          b.__ko_hasfocusUpdating || b.__ko_hasfocusLastValue === d || (d ? b.focus() : b.blur(), !d && b.__ko_hasfocusLastValue && b.ownerDocument.body.focus(), a3.u.G(a3.a.Fb, null, [b, d ? "focusin" : "focusout"]));
        } };
        a3.m.wa.hasfocus = true;
        a3.c.hasFocus = a3.c.hasfocus;
        a3.m.wa.hasFocus = "hasfocus";
        a3.c.html = { init: function() {
          return { controlsDescendantBindings: true };
        }, update: function(b, c) {
          a3.a.fc(b, c());
        } };
        (function() {
          function b(b2, d, e) {
            a3.c[b2] = { init: function(b3, c, h, m, k) {
              var l, p, q = {}, t, x, n2;
              if (d) {
                m = h.get("as");
                var u3 = h.get("noChildContext");
                n2 = !(m && u3);
                q = { as: m, noChildContext: u3, exportDependencies: n2 };
              }
              x = (t = "render" == h.get("completeOn")) || h.has(a3.i.pa);
              a3.o(function() {
                var h2 = a3.a.f(c()), m2 = !e !== !h2, u4 = !p, r2;
                if (n2 || m2 !== l) {
                  x && (k = a3.i.Cb(b3, k));
                  if (m2) {
                    if (!d || n2)
                      q.dataDependency = a3.S.o();
                    r2 = d ? k.createChildContext("function" == typeof h2 ? h2 : c, q) : a3.S.qa() ? k.extend(null, q) : k;
                  }
                  u4 && a3.S.qa() && (p = a3.a.Ca(a3.h.childNodes(b3), true));
                  m2 ? (u4 || a3.h.va(b3, a3.a.Ca(p)), a3.Oa(r2, b3)) : (a3.h.Ea(b3), t || a3.i.ma(b3, a3.i.H));
                  l = m2;
                }
              }, null, { l: b3 });
              return { controlsDescendantBindings: true };
            } };
            a3.m.Ra[b2] = false;
            a3.h.ea[b2] = true;
          }
          b("if");
          b("ifnot", false, true);
          b("with", true);
        })();
        a3.c.let = { init: function(b, c, d, e, f) {
          c = f.extend(c);
          a3.Oa(c, b);
          return { controlsDescendantBindings: true };
        } };
        a3.h.ea.let = true;
        var Q = {};
        a3.c.options = { init: function(b) {
          if ("select" !== a3.a.R(b))
            throw Error("options binding applies only to SELECT elements");
          for (; 0 < b.length; )
            b.remove(0);
          return { controlsDescendantBindings: true };
        }, update: function(b, c, d) {
          function e() {
            return a3.a.jb(b.options, function(a4) {
              return a4.selected;
            });
          }
          function f(a4, b2, c2) {
            var d2 = typeof b2;
            return "function" == d2 ? b2(a4) : "string" == d2 ? a4[b2] : c2;
          }
          function g(c2, d2) {
            if (x && l)
              a3.i.ma(b, a3.i.H);
            else if (t.length) {
              var e2 = 0 <= a3.a.A(t, a3.w.M(d2[0]));
              a3.a.Zc(d2[0], e2);
              x && !e2 && a3.u.G(a3.a.Fb, null, [b, "change"]);
            }
          }
          var h = b.multiple, m = 0 != b.length && h ? b.scrollTop : null, k = a3.a.f(c()), l = d.get("valueAllowUnset") && d.has("value"), p = d.get("optionsIncludeDestroyed");
          c = {};
          var q, t = [];
          l || (h ? t = a3.a.Mb(e(), a3.w.M) : 0 <= b.selectedIndex && t.push(a3.w.M(b.options[b.selectedIndex])));
          k && ("undefined" == typeof k.length && (k = [k]), q = a3.a.jb(k, function(b2) {
            return p || b2 === n || null === b2 || !a3.a.f(b2._destroy);
          }), d.has("optionsCaption") && (k = a3.a.f(d.get("optionsCaption")), null !== k && k !== n && q.unshift(Q)));
          var x = false;
          c.beforeRemove = function(a4) {
            b.removeChild(a4);
          };
          k = g;
          d.has("optionsAfterRender") && "function" == typeof d.get("optionsAfterRender") && (k = function(b2, c2) {
            g(0, c2);
            a3.u.G(d.get("optionsAfterRender"), null, [c2[0], b2 !== Q ? b2 : n]);
          });
          a3.a.ec(b, q, function(c2, e2, g2) {
            g2.length && (t = !l && g2[0].selected ? [a3.w.M(g2[0])] : [], x = true);
            e2 = b.ownerDocument.createElement("option");
            c2 === Q ? (a3.a.Bb(e2, d.get("optionsCaption")), a3.w.cb(e2, n)) : (g2 = f(c2, d.get("optionsValue"), c2), a3.w.cb(e2, a3.a.f(g2)), c2 = f(c2, d.get("optionsText"), g2), a3.a.Bb(e2, c2));
            return [e2];
          }, c, k);
          if (!l) {
            var B;
            h ? B = t.length && e().length < t.length : B = t.length && 0 <= b.selectedIndex ? a3.w.M(b.options[b.selectedIndex]) !== t[0] : t.length || 0 <= b.selectedIndex;
            B && a3.u.G(a3.a.Fb, null, [b, "change"]);
          }
          (l || a3.S.Ya()) && a3.i.ma(b, a3.i.H);
          a3.a.wd(b);
          m && 20 < Math.abs(m - b.scrollTop) && (b.scrollTop = m);
        } };
        a3.c.options.$b = a3.a.g.Z();
        a3.c.selectedOptions = { init: function(b, c, d) {
          function e() {
            var e2 = c(), f2 = [];
            a3.a.D(b.getElementsByTagName("option"), function(b2) {
              b2.selected && f2.push(a3.w.M(b2));
            });
            a3.m.eb(
              e2,
              d,
              "selectedOptions",
              f2
            );
          }
          function f() {
            var d2 = a3.a.f(c()), e2 = b.scrollTop;
            d2 && "number" == typeof d2.length && a3.a.D(b.getElementsByTagName("option"), function(b2) {
              var c2 = 0 <= a3.a.A(d2, a3.w.M(b2));
              b2.selected != c2 && a3.a.Zc(b2, c2);
            });
            b.scrollTop = e2;
          }
          if ("select" != a3.a.R(b))
            throw Error("selectedOptions binding applies only to SELECT elements");
          var g;
          a3.i.subscribe(b, a3.i.H, function() {
            g ? e() : (a3.a.B(b, "change", e), g = a3.o(f, null, { l: b }));
          }, null, { notifyImmediately: true });
        }, update: function() {
        } };
        a3.m.wa.selectedOptions = true;
        a3.c.style = { update: function(b, c) {
          var d = a3.a.f(c() || {});
          a3.a.P(d, function(c2, d2) {
            d2 = a3.a.f(d2);
            if (null === d2 || d2 === n || false === d2)
              d2 = "";
            if (v3)
              v3(b).css(c2, d2);
            else if (/^--/.test(c2))
              b.style.setProperty(c2, d2);
            else {
              c2 = c2.replace(/-(\w)/g, function(a4, b2) {
                return b2.toUpperCase();
              });
              var g = b.style[c2];
              b.style[c2] = d2;
              d2 === g || b.style[c2] != g || isNaN(d2) || (b.style[c2] = d2 + "px");
            }
          });
        } };
        a3.c.submit = { init: function(b, c, d, e, f) {
          if ("function" != typeof c())
            throw Error("The value for a submit binding must be a function");
          a3.a.B(b, "submit", function(a4) {
            var d2, e2 = c();
            try {
              d2 = e2.call(f.$data, b);
            } finally {
              true !== d2 && (a4.preventDefault ? a4.preventDefault() : a4.returnValue = false);
            }
          });
        } };
        a3.c.text = { init: function() {
          return { controlsDescendantBindings: true };
        }, update: function(b, c) {
          a3.a.Bb(b, c());
        } };
        a3.h.ea.text = true;
        (function() {
          if (A && A.navigator) {
            var b = function(a4) {
              if (a4)
                return parseFloat(a4[1]);
            }, c = A.navigator.userAgent, d, e, f, g, h;
            (d = A.opera && A.opera.version && parseInt(A.opera.version())) || (h = b(c.match(/Edge\/([^ ]+)$/))) || b(c.match(/Chrome\/([^ ]+)/)) || (e = b(c.match(/Version\/([^ ]+) Safari/))) || (f = b(c.match(/Firefox\/([^ ]+)/))) || (g = a3.a.W || b(c.match(/MSIE ([^ ]+)/))) || (g = b(c.match(/rv:([^ )]+)/)));
          }
          if (8 <= g && 10 > g)
            var m = a3.a.g.Z(), k = a3.a.g.Z(), l = function(b2) {
              var c2 = this.activeElement;
              (c2 = c2 && a3.a.g.get(c2, k)) && c2(b2);
            }, p = function(b2, c2) {
              var d2 = b2.ownerDocument;
              a3.a.g.get(d2, m) || (a3.a.g.set(d2, m, true), a3.a.B(d2, "selectionchange", l));
              a3.a.g.set(b2, k, c2);
            };
          a3.c.textInput = { init: function(b2, c2, k2) {
            function l2(c4, d2) {
              a3.a.B(b2, c4, d2);
            }
            function m2() {
              var d2 = a3.a.f(c2());
              if (null === d2 || d2 === n)
                d2 = "";
              L !== n && d2 === L ? a3.a.setTimeout(m2, 4) : b2.value !== d2 && (y = true, b2.value = d2, y = false, v4 = b2.value);
            }
            function r2() {
              w2 || (L = b2.value, w2 = a3.a.setTimeout(
                z,
                4
              ));
            }
            function z() {
              clearTimeout(w2);
              L = w2 = n;
              var d2 = b2.value;
              v4 !== d2 && (v4 = d2, a3.m.eb(c2(), k2, "textInput", d2));
            }
            var v4 = b2.value, w2, L, A2 = 9 == a3.a.W ? r2 : z, y = false;
            g && l2("keypress", z);
            11 > g && l2("propertychange", function(a4) {
              y || "value" !== a4.propertyName || A2(a4);
            });
            8 == g && (l2("keyup", z), l2("keydown", z));
            p && (p(b2, A2), l2("dragend", r2));
            (!g || 9 <= g) && l2("input", A2);
            5 > e && "textarea" === a3.a.R(b2) ? (l2("keydown", r2), l2("paste", r2), l2("cut", r2)) : 11 > d ? l2("keydown", r2) : 4 > f ? (l2("DOMAutoComplete", z), l2("dragdrop", z), l2("drop", z)) : h && "number" === b2.type && l2("keydown", r2);
            l2(
              "change",
              z
            );
            l2("blur", z);
            a3.o(m2, null, { l: b2 });
          } };
          a3.m.wa.textInput = true;
          a3.c.textinput = { preprocess: function(a4, b2, c2) {
            c2("textInput", a4);
          } };
        })();
        a3.c.uniqueName = { init: function(b, c) {
          if (c()) {
            var d = "ko_unique_" + ++a3.c.uniqueName.rd;
            a3.a.Yc(b, d);
          }
        } };
        a3.c.uniqueName.rd = 0;
        a3.c.using = { init: function(b, c, d, e, f) {
          var g;
          d.has("as") && (g = { as: d.get("as"), noChildContext: d.get("noChildContext") });
          c = f.createChildContext(c, g);
          a3.Oa(c, b);
          return { controlsDescendantBindings: true };
        } };
        a3.h.ea.using = true;
        a3.c.value = { init: function(b, c, d) {
          var e = a3.a.R(b), f = "input" == e;
          if (!f || "checkbox" != b.type && "radio" != b.type) {
            var g = [], h = d.get("valueUpdate"), m = false, k = null;
            h && ("string" == typeof h ? g = [h] : g = a3.a.wc(h), a3.a.Pa(g, "change"));
            var l = function() {
              k = null;
              m = false;
              var e2 = c(), f2 = a3.w.M(b);
              a3.m.eb(e2, d, "value", f2);
            };
            !a3.a.W || !f || "text" != b.type || "off" == b.autocomplete || b.form && "off" == b.form.autocomplete || -1 != a3.a.A(g, "propertychange") || (a3.a.B(b, "propertychange", function() {
              m = true;
            }), a3.a.B(b, "focus", function() {
              m = false;
            }), a3.a.B(b, "blur", function() {
              m && l();
            }));
            a3.a.D(g, function(c2) {
              var d2 = l;
              a3.a.Ud(c2, "after") && (d2 = function() {
                k = a3.w.M(b);
                a3.a.setTimeout(l, 0);
              }, c2 = c2.substring(5));
              a3.a.B(b, c2, d2);
            });
            var p;
            p = f && "file" == b.type ? function() {
              var d2 = a3.a.f(c());
              null === d2 || d2 === n || "" === d2 ? b.value = "" : a3.u.G(l);
            } : function() {
              var f2 = a3.a.f(c()), g2 = a3.w.M(b);
              if (null !== k && f2 === k)
                a3.a.setTimeout(p, 0);
              else if (f2 !== g2 || g2 === n)
                "select" === e ? (g2 = d.get("valueAllowUnset"), a3.w.cb(b, f2, g2), g2 || f2 === a3.w.M(b) || a3.u.G(l)) : a3.w.cb(b, f2);
            };
            if ("select" === e) {
              var q;
              a3.i.subscribe(
                b,
                a3.i.H,
                function() {
                  q ? d.get("valueAllowUnset") ? p() : l() : (a3.a.B(b, "change", l), q = a3.o(p, null, { l: b }));
                },
                null,
                { notifyImmediately: true }
              );
            } else
              a3.a.B(b, "change", l), a3.o(p, null, { l: b });
          } else
            a3.ib(b, { checkedValue: c });
        }, update: function() {
        } };
        a3.m.wa.value = true;
        a3.c.visible = { update: function(b, c) {
          var d = a3.a.f(c()), e = "none" != b.style.display;
          d && !e ? b.style.display = "" : !d && e && (b.style.display = "none");
        } };
        a3.c.hidden = { update: function(b, c) {
          a3.c.visible.update(b, function() {
            return !a3.a.f(c());
          });
        } };
        (function(b) {
          a3.c[b] = { init: function(c, d, e, f, g) {
            return a3.c.event.init.call(this, c, function() {
              var a4 = {};
              a4[b] = d();
              return a4;
            }, e, f, g);
          } };
        })("click");
        a3.ca = function() {
        };
        a3.ca.prototype.renderTemplateSource = function() {
          throw Error("Override renderTemplateSource");
        };
        a3.ca.prototype.createJavaScriptEvaluatorBlock = function() {
          throw Error("Override createJavaScriptEvaluatorBlock");
        };
        a3.ca.prototype.makeTemplateSource = function(b, c) {
          if ("string" == typeof b) {
            c = c || w;
            var d = c.getElementById(b);
            if (!d)
              throw Error("Cannot find template with ID " + b);
            return new a3.C.F(d);
          }
          if (1 == b.nodeType || 8 == b.nodeType)
            return new a3.C.ia(b);
          throw Error("Unknown template type: " + b);
        };
        a3.ca.prototype.renderTemplate = function(a4, c, d, e) {
          a4 = this.makeTemplateSource(a4, e);
          return this.renderTemplateSource(a4, c, d, e);
        };
        a3.ca.prototype.isTemplateRewritten = function(a4, c) {
          return false === this.allowTemplateRewriting ? true : this.makeTemplateSource(a4, c).data("isRewritten");
        };
        a3.ca.prototype.rewriteTemplate = function(a4, c, d) {
          a4 = this.makeTemplateSource(a4, d);
          c = c(a4.text());
          a4.text(c);
          a4.data("isRewritten", true);
        };
        a3.b("templateEngine", a3.ca);
        a3.kc = function() {
          function b(b2, c2, d2, h) {
            b2 = a3.m.ac(b2);
            for (var m = a3.m.Ra, k = 0; k < b2.length; k++) {
              var l = b2[k].key;
              if (Object.prototype.hasOwnProperty.call(
                m,
                l
              )) {
                var p = m[l];
                if ("function" === typeof p) {
                  if (l = p(b2[k].value))
                    throw Error(l);
                } else if (!p)
                  throw Error("This template engine does not support the '" + l + "' binding within its templates");
              }
            }
            d2 = "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + a3.m.vb(b2, { valueAccessors: true }) + " } })()},'" + d2.toLowerCase() + "')";
            return h.createJavaScriptEvaluatorBlock(d2) + c2;
          }
          var c = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi, d = /\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;
          return { xd: function(b2, c2, d2) {
            c2.isTemplateRewritten(b2, d2) || c2.rewriteTemplate(b2, function(b3) {
              return a3.kc.Ld(b3, c2);
            }, d2);
          }, Ld: function(a4, f) {
            return a4.replace(c, function(a5, c2, d2, e, l) {
              return b(l, c2, d2, f);
            }).replace(d, function(a5, c2) {
              return b(c2, "<!-- ko -->", "#comment", f);
            });
          }, md: function(b2, c2) {
            return a3.aa.Xb(function(d2, h) {
              var m = d2.nextSibling;
              m && m.nodeName.toLowerCase() === c2 && a3.ib(m, b2, h);
            });
          } };
        }();
        a3.b("__tr_ambtns", a3.kc.md);
        (function() {
          a3.C = {};
          a3.C.F = function(b2) {
            if (this.F = b2) {
              var c2 = a3.a.R(b2);
              this.ab = "script" === c2 ? 1 : "textarea" === c2 ? 2 : "template" == c2 && b2.content && 11 === b2.content.nodeType ? 3 : 4;
            }
          };
          a3.C.F.prototype.text = function() {
            var b2 = 1 === this.ab ? "text" : 2 === this.ab ? "value" : "innerHTML";
            if (0 == arguments.length)
              return this.F[b2];
            var c2 = arguments[0];
            "innerHTML" === b2 ? a3.a.fc(this.F, c2) : this.F[b2] = c2;
          };
          var b = a3.a.g.Z() + "_";
          a3.C.F.prototype.data = function(c2) {
            if (1 === arguments.length)
              return a3.a.g.get(this.F, b + c2);
            a3.a.g.set(this.F, b + c2, arguments[1]);
          };
          var c = a3.a.g.Z();
          a3.C.F.prototype.nodes = function() {
            var b2 = this.F;
            if (0 == arguments.length) {
              var e = a3.a.g.get(b2, c) || {}, f = e.lb || (3 === this.ab ? b2.content : 4 === this.ab ? b2 : n);
              if (!f || e.jd) {
                var g = this.text();
                g && g !== e.bb && (f = a3.a.Md(g, b2.ownerDocument), a3.a.g.set(b2, c, { lb: f, bb: g, jd: true }));
              }
              return f;
            }
            e = arguments[0];
            this.ab !== n && this.text("");
            a3.a.g.set(b2, c, { lb: e });
          };
          a3.C.ia = function(a4) {
            this.F = a4;
          };
          a3.C.ia.prototype = new a3.C.F();
          a3.C.ia.prototype.constructor = a3.C.ia;
          a3.C.ia.prototype.text = function() {
            if (0 == arguments.length) {
              var b2 = a3.a.g.get(this.F, c) || {};
              b2.bb === n && b2.lb && (b2.bb = b2.lb.innerHTML);
              return b2.bb;
            }
            a3.a.g.set(
              this.F,
              c,
              { bb: arguments[0] }
            );
          };
          a3.b("templateSources", a3.C);
          a3.b("templateSources.domElement", a3.C.F);
          a3.b("templateSources.anonymousTemplate", a3.C.ia);
        })();
        (function() {
          function b(b2, c2, d2) {
            var e2;
            for (c2 = a3.h.nextSibling(c2); b2 && (e2 = b2) !== c2; )
              b2 = a3.h.nextSibling(e2), d2(e2, b2);
          }
          function c(c2, d2) {
            if (c2.length) {
              var e2 = c2[0], f2 = c2[c2.length - 1], g2 = e2.parentNode, h2 = a3.ga.instance, m2 = h2.preprocessNode;
              if (m2) {
                b(e2, f2, function(a4, b2) {
                  var c4 = a4.previousSibling, d3 = m2.call(h2, a4);
                  d3 && (a4 === e2 && (e2 = d3[0] || b2), a4 === f2 && (f2 = d3[d3.length - 1] || c4));
                });
                c2.length = 0;
                if (!e2)
                  return;
                e2 === f2 ? c2.push(e2) : (c2.push(e2, f2), a3.a.Ua(c2, g2));
              }
              b(e2, f2, function(b2) {
                1 !== b2.nodeType && 8 !== b2.nodeType || a3.vc(d2, b2);
              });
              b(e2, f2, function(b2) {
                1 !== b2.nodeType && 8 !== b2.nodeType || a3.aa.cd(b2, [d2]);
              });
              a3.a.Ua(c2, g2);
            }
          }
          function d(a4) {
            return a4.nodeType ? a4 : 0 < a4.length ? a4[0] : null;
          }
          function e(b2, e2, f2, h2, m2) {
            m2 = m2 || {};
            var n2 = (b2 && d(b2) || f2 || {}).ownerDocument, B = m2.templateEngine || g;
            a3.kc.xd(f2, B, n2);
            f2 = B.renderTemplate(f2, h2, m2, n2);
            if ("number" != typeof f2.length || 0 < f2.length && "number" != typeof f2[0].nodeType)
              throw Error("Template engine must return an array of DOM nodes");
            n2 = false;
            switch (e2) {
              case "replaceChildren":
                a3.h.va(
                  b2,
                  f2
                );
                n2 = true;
                break;
              case "replaceNode":
                a3.a.Xc(b2, f2);
                n2 = true;
                break;
              case "ignoreTargetNode":
                break;
              default:
                throw Error("Unknown renderMode: " + e2);
            }
            n2 && (c(f2, h2), m2.afterRender && a3.u.G(m2.afterRender, null, [f2, h2[m2.as || "$data"]]), "replaceChildren" == e2 && a3.i.ma(b2, a3.i.H));
            return f2;
          }
          function f(b2, c2, d2) {
            return a3.O(b2) ? b2() : "function" === typeof b2 ? b2(c2, d2) : b2;
          }
          var g;
          a3.gc = function(b2) {
            if (b2 != n && !(b2 instanceof a3.ca))
              throw Error("templateEngine must inherit from ko.templateEngine");
            g = b2;
          };
          a3.dc = function(b2, c2, h2, m2, t) {
            h2 = h2 || {};
            if ((h2.templateEngine || g) == n)
              throw Error("Set a template engine before calling renderTemplate");
            t = t || "replaceChildren";
            if (m2) {
              var x = d(m2);
              return a3.$(function() {
                var g2 = c2 && c2 instanceof a3.fa ? c2 : new a3.fa(c2, null, null, null, { exportDependencies: true }), n2 = f(b2, g2.$data, g2), g2 = e(m2, t, n2, g2, h2);
                "replaceNode" == t && (m2 = g2, x = d(m2));
              }, null, { Sa: function() {
                return !x || !a3.a.Sb(x);
              }, l: x && "replaceNode" == t ? x.parentNode : x });
            }
            return a3.aa.Xb(function(d2) {
              a3.dc(b2, c2, h2, d2, "replaceNode");
            });
          };
          a3.Qd = function(b2, d2, g2, h2, m2) {
            function x(b3, c2) {
              a3.u.G(a3.a.ec, null, [h2, b3, u3, g2, r2, c2]);
              a3.i.ma(h2, a3.i.H);
            }
            function r2(a4, b3) {
              c(b3, v4);
              g2.afterRender && g2.afterRender(b3, a4);
              v4 = null;
            }
            function u3(a4, c2) {
              v4 = m2.createChildContext(a4, { as: z, noChildContext: g2.noChildContext, extend: function(a5) {
                a5.$index = c2;
                z && (a5[z + "Index"] = c2);
              } });
              var d3 = f(b2, a4, v4);
              return e(h2, "ignoreTargetNode", d3, v4, g2);
            }
            var v4, z = g2.as, w2 = false === g2.includeDestroyed || a3.options.foreachHidesDestroyed && !g2.includeDestroyed;
            if (w2 || g2.beforeRemove || !a3.Pc(d2))
              return a3.$(function() {
                var b3 = a3.a.f(d2) || [];
                "undefined" == typeof b3.length && (b3 = [b3]);
                w2 && (b3 = a3.a.jb(b3, function(b4) {
                  return b4 === n || null === b4 || !a3.a.f(b4._destroy);
                }));
                x(b3);
              }, null, { l: h2 });
            x(d2.v());
            var A2 = d2.subscribe(function(a4) {
              x(d2(), a4);
            }, null, "arrayChange");
            A2.l(h2);
            return A2;
          };
          var h = a3.a.g.Z(), m = a3.a.g.Z();
          a3.c.template = { init: function(b2, c2) {
            var d2 = a3.a.f(c2());
            if ("string" == typeof d2 || "name" in d2)
              a3.h.Ea(b2);
            else if ("nodes" in d2) {
              d2 = d2.nodes || [];
              if (a3.O(d2))
                throw Error('The "nodes" option must be a plain, non-observable array.');
              var e2 = d2[0] && d2[0].parentNode;
              e2 && a3.a.g.get(e2, m) || (e2 = a3.a.Yb(d2), a3.a.g.set(e2, m, true));
              new a3.C.ia(b2).nodes(e2);
            } else if (d2 = a3.h.childNodes(b2), 0 < d2.length)
              e2 = a3.a.Yb(d2), new a3.C.ia(b2).nodes(e2);
            else
              throw Error("Anonymous template defined, but no template content was provided");
            return { controlsDescendantBindings: true };
          }, update: function(b2, c2, d2, e2, f2) {
            var g2 = c2();
            c2 = a3.a.f(g2);
            d2 = true;
            e2 = null;
            "string" == typeof c2 ? c2 = {} : (g2 = "name" in c2 ? c2.name : b2, "if" in c2 && (d2 = a3.a.f(c2["if"])), d2 && "ifnot" in c2 && (d2 = !a3.a.f(c2.ifnot)), d2 && !g2 && (d2 = false));
            "foreach" in c2 ? e2 = a3.Qd(g2, d2 && c2.foreach || [], c2, b2, f2) : d2 ? (d2 = f2, "data" in c2 && (d2 = f2.createChildContext(c2.data, { as: c2.as, noChildContext: c2.noChildContext, exportDependencies: true })), e2 = a3.dc(g2, d2, c2, b2)) : a3.h.Ea(b2);
            f2 = e2;
            (c2 = a3.a.g.get(b2, h)) && "function" == typeof c2.s && c2.s();
            a3.a.g.set(b2, h, !f2 || f2.ja && !f2.ja() ? n : f2);
          } };
          a3.m.Ra.template = function(b2) {
            b2 = a3.m.ac(b2);
            return 1 == b2.length && b2[0].unknown || a3.m.Id(b2, "name") ? null : "This template engine does not support anonymous templates nested within its templates";
          };
          a3.h.ea.template = true;
        })();
        a3.b("setTemplateEngine", a3.gc);
        a3.b("renderTemplate", a3.dc);
        a3.a.Kc = function(a4, c, d) {
          if (a4.length && c.length) {
            var e, f, g, h, m;
            for (e = f = 0; (!d || e < d) && (h = a4[f]); ++f) {
              for (g = 0; m = c[g]; ++g)
                if (h.value === m.value) {
                  h.moved = m.index;
                  m.moved = h.index;
                  c.splice(g, 1);
                  e = g = 0;
                  break;
                }
              e += g;
            }
          }
        };
        a3.a.Pb = function() {
          function b(b2, d, e, f, g) {
            var h = Math.min, m = Math.max, k = [], l, p = b2.length, q, n2 = d.length, r2 = n2 - p || 1, v4 = p + n2 + 1, u3, w2, z;
            for (l = 0; l <= p; l++)
              for (w2 = u3, k.push(u3 = []), z = h(n2, l + r2), q = m(0, l - 1); q <= z; q++)
                u3[q] = q ? l ? b2[l - 1] === d[q - 1] ? w2[q - 1] : h(w2[q] || v4, u3[q - 1] || v4) + 1 : q + 1 : l + 1;
            h = [];
            m = [];
            r2 = [];
            l = p;
            for (q = n2; l || q; )
              n2 = k[l][q] - 1, q && n2 === k[l][q - 1] ? m.push(h[h.length] = { status: e, value: d[--q], index: q }) : l && n2 === k[l - 1][q] ? r2.push(h[h.length] = { status: f, value: b2[--l], index: l }) : (--q, --l, g.sparse || h.push({ status: "retained", value: d[q] }));
            a3.a.Kc(r2, m, !g.dontLimitMoves && 10 * p);
            return h.reverse();
          }
          return function(a4, d, e) {
            e = "boolean" === typeof e ? { dontLimitMoves: e } : e || {};
            a4 = a4 || [];
            d = d || [];
            return a4.length < d.length ? b(a4, d, "added", "deleted", e) : b(d, a4, "deleted", "added", e);
          };
        }();
        a3.b("utils.compareArrays", a3.a.Pb);
        (function() {
          function b(b2, c2, d2, h, m) {
            var k = [], l = a3.$(function() {
              var l2 = c2(d2, m, a3.a.Ua(k, b2)) || [];
              0 < k.length && (a3.a.Xc(k, l2), h && a3.u.G(h, null, [d2, l2, m]));
              k.length = 0;
              a3.a.Nb(k, l2);
            }, null, { l: b2, Sa: function() {
              return !a3.a.kd(k);
            } });
            return { Y: k, $: l.ja() ? l : n };
          }
          var c = a3.a.g.Z(), d = a3.a.g.Z();
          a3.a.ec = function(e, f, g, h, m, k) {
            function l(b2) {
              y = { Aa: b2, pb: a3.ta(w2++) };
              v4.push(y);
              r2 || F2.push(y);
            }
            function p(b2) {
              y = t[b2];
              w2 !== y.pb.v() && D2.push(y);
              y.pb(w2++);
              a3.a.Ua(y.Y, e);
              v4.push(y);
            }
            function q(b2, c2) {
              if (b2)
                for (var d2 = 0, e2 = c2.length; d2 < e2; d2++)
                  a3.a.D(c2[d2].Y, function(a4) {
                    b2(a4, d2, c2[d2].Aa);
                  });
            }
            f = f || [];
            "undefined" == typeof f.length && (f = [f]);
            h = h || {};
            var t = a3.a.g.get(e, c), r2 = !t, v4 = [], u3 = 0, w2 = 0, z = [], A2 = [], C2 = [], D2 = [], F2 = [], y, I2 = 0;
            if (r2)
              a3.a.D(f, l);
            else {
              if (!k || t && t._countWaitingForRemove) {
                var E = a3.a.Mb(t, function(a4) {
                  return a4.Aa;
                });
                k = a3.a.Pb(E, f, { dontLimitMoves: h.dontLimitMoves, sparse: true });
              }
              for (var E = 0, G2, H2, K2; G2 = k[E]; E++)
                switch (H2 = G2.moved, K2 = G2.index, G2.status) {
                  case "deleted":
                    for (; u3 < K2; )
                      p(u3++);
                    H2 === n && (y = t[u3], y.$ && (y.$.s(), y.$ = n), a3.a.Ua(y.Y, e).length && (h.beforeRemove && (v4.push(y), I2++, y.Aa === d ? y = null : C2.push(y)), y && z.push.apply(z, y.Y)));
                    u3++;
                    break;
                  case "added":
                    for (; w2 < K2; )
                      p(u3++);
                    H2 !== n ? (A2.push(v4.length), p(H2)) : l(G2.value);
                }
              for (; w2 < f.length; )
                p(u3++);
              v4._countWaitingForRemove = I2;
            }
            a3.a.g.set(e, c, v4);
            q(h.beforeMove, D2);
            a3.a.D(
              z,
              h.beforeRemove ? a3.oa : a3.removeNode
            );
            var M, O, P;
            try {
              P = e.ownerDocument.activeElement;
            } catch (N2) {
            }
            if (A2.length)
              for (; (E = A2.shift()) != n; ) {
                y = v4[E];
                for (M = n; E; )
                  if ((O = v4[--E].Y) && O.length) {
                    M = O[O.length - 1];
                    break;
                  }
                for (f = 0; u3 = y.Y[f]; M = u3, f++)
                  a3.h.Wb(e, u3, M);
              }
            for (E = 0; y = v4[E]; E++) {
              y.Y || a3.a.extend(y, b(e, g, y.Aa, m, y.pb));
              for (f = 0; u3 = y.Y[f]; M = u3, f++)
                a3.h.Wb(e, u3, M);
              !y.Ed && m && (m(y.Aa, y.Y, y.pb), y.Ed = true, M = y.Y[y.Y.length - 1]);
            }
            P && e.ownerDocument.activeElement != P && P.focus();
            q(h.beforeRemove, C2);
            for (E = 0; E < C2.length; ++E)
              C2[E].Aa = d;
            q(h.afterMove, D2);
            q(h.afterAdd, F2);
          };
        })();
        a3.b("utils.setDomNodeChildrenFromArrayMapping", a3.a.ec);
        a3.ba = function() {
          this.allowTemplateRewriting = false;
        };
        a3.ba.prototype = new a3.ca();
        a3.ba.prototype.constructor = a3.ba;
        a3.ba.prototype.renderTemplateSource = function(b, c, d, e) {
          if (c = (9 > a3.a.W ? 0 : b.nodes) ? b.nodes() : null)
            return a3.a.la(c.cloneNode(true).childNodes);
          b = b.text();
          return a3.a.ua(b, e);
        };
        a3.ba.Ma = new a3.ba();
        a3.gc(a3.ba.Ma);
        a3.b("nativeTemplateEngine", a3.ba);
        (function() {
          a3.$a = function() {
            var a4 = this.Hd = function() {
              if (!v3 || !v3.tmpl)
                return 0;
              try {
                if (0 <= v3.tmpl.tag.tmpl.open.toString().indexOf("__"))
                  return 2;
              } catch (a5) {
              }
              return 1;
            }();
            this.renderTemplateSource = function(b2, e, f, g) {
              g = g || w;
              f = f || {};
              if (2 > a4)
                throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
              var h = b2.data("precompiled");
              h || (h = b2.text() || "", h = v3.template(null, "{{ko_with $item.koBindingContext}}" + h + "{{/ko_with}}"), b2.data("precompiled", h));
              b2 = [e.$data];
              e = v3.extend({ koBindingContext: e }, f.templateOptions);
              e = v3.tmpl(h, b2, e);
              e.appendTo(g.createElement("div"));
              v3.fragments = {};
              return e;
            };
            this.createJavaScriptEvaluatorBlock = function(a5) {
              return "{{ko_code ((function() { return " + a5 + " })()) }}";
            };
            this.addTemplate = function(a5, b2) {
              w.write("<script type='text/html' id='" + a5 + "'>" + b2 + "<\/script>");
            };
            0 < a4 && (v3.tmpl.tag.ko_code = { open: "__.push($1 || '');" }, v3.tmpl.tag.ko_with = { open: "with($1) {", close: "} " });
          };
          a3.$a.prototype = new a3.ca();
          a3.$a.prototype.constructor = a3.$a;
          var b = new a3.$a();
          0 < b.Hd && a3.gc(b);
          a3.b("jqueryTmplTemplateEngine", a3.$a);
        })();
      });
    })();
  })();
})();
var knockout = ko;
if (typeof window !== "undefined") {
  ko = window.ko;
  if (typeof oldValue !== "undefined") {
    window.ko = oldValue;
  } else {
    delete window.ko;
  }
} else {
  ko = global.ko;
  if (typeof oldValue !== "undefined") {
    global.ko = oldValue;
  } else {
    delete global.ko;
  }
}
var knockout_3_5_1_default = knockout;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/ThirdParty/knockout-es5.js
var OBSERVABLES_PROPERTY = "__knockoutObservables";
var SUBSCRIBABLE_PROPERTY = "__knockoutSubscribable";
function track(obj, propertyNames) {
  if (!obj) {
    throw new Error("When calling ko.track, you must pass an object as the first parameter.");
  }
  var ko2 = this, allObservablesForObject = getAllObservablesForObject(obj, true);
  propertyNames = propertyNames || Object.getOwnPropertyNames(obj);
  propertyNames.forEach(function(propertyName) {
    if (propertyName === OBSERVABLES_PROPERTY || propertyName === SUBSCRIBABLE_PROPERTY) {
      return;
    }
    if (propertyName in allObservablesForObject) {
      return;
    }
    var origValue = obj[propertyName], isArray2 = origValue instanceof Array, observable = ko2.isObservable(origValue) ? origValue : isArray2 ? ko2.observableArray(origValue) : ko2.observable(origValue);
    Object.defineProperty(obj, propertyName, {
      configurable: true,
      enumerable: true,
      get: observable,
      set: ko2.isWriteableObservable(observable) ? observable : void 0
    });
    allObservablesForObject[propertyName] = observable;
    if (isArray2) {
      notifyWhenPresentOrFutureArrayValuesMutate(ko2, observable);
    }
  });
  return obj;
}
function getAllObservablesForObject(obj, createIfNotDefined) {
  var result = obj[OBSERVABLES_PROPERTY];
  if (!result && createIfNotDefined) {
    result = {};
    Object.defineProperty(obj, OBSERVABLES_PROPERTY, {
      value: result
    });
  }
  return result;
}
function defineComputedProperty(obj, propertyName, evaluatorOrOptions) {
  var ko2 = this, computedOptions = { owner: obj, deferEvaluation: true };
  if (typeof evaluatorOrOptions === "function") {
    computedOptions.read = evaluatorOrOptions;
  } else {
    if ("value" in evaluatorOrOptions) {
      throw new Error('For ko.defineProperty, you must not specify a "value" for the property. You must provide a "get" function.');
    }
    if (typeof evaluatorOrOptions.get !== "function") {
      throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called "get".');
    }
    computedOptions.read = evaluatorOrOptions.get;
    computedOptions.write = evaluatorOrOptions.set;
  }
  obj[propertyName] = ko2.computed(computedOptions);
  track.call(ko2, obj, [propertyName]);
  return obj;
}
function notifyWhenPresentOrFutureArrayValuesMutate(ko2, observable) {
  var watchingArraySubscription = null;
  ko2.computed(function() {
    if (watchingArraySubscription) {
      watchingArraySubscription.dispose();
      watchingArraySubscription = null;
    }
    var newArrayInstance = observable();
    if (newArrayInstance instanceof Array) {
      watchingArraySubscription = startWatchingArrayInstance(ko2, observable, newArrayInstance);
    }
  });
}
function startWatchingArrayInstance(ko2, observable, arrayInstance) {
  var subscribable = getSubscribableForArray(ko2, arrayInstance);
  return subscribable.subscribe(observable);
}
function getSubscribableForArray(ko2, arrayInstance) {
  var subscribable = arrayInstance[SUBSCRIBABLE_PROPERTY];
  if (!subscribable) {
    subscribable = new ko2.subscribable();
    Object.defineProperty(arrayInstance, SUBSCRIBABLE_PROPERTY, {
      value: subscribable
    });
    var notificationPauseSignal = {};
    wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal);
    addKnockoutArrayMutators(ko2, arrayInstance, subscribable, notificationPauseSignal);
  }
  return subscribable;
}
function wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal) {
  ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"].forEach(function(fnName) {
    var origMutator = arrayInstance[fnName];
    arrayInstance[fnName] = function() {
      var result = origMutator.apply(this, arguments);
      if (notificationPauseSignal.pause !== true) {
        subscribable.notifySubscribers(this);
      }
      return result;
    };
  });
}
function addKnockoutArrayMutators(ko2, arrayInstance, subscribable, notificationPauseSignal) {
  ["remove", "removeAll", "destroy", "destroyAll", "replace"].forEach(function(fnName) {
    Object.defineProperty(arrayInstance, fnName, {
      enumerable: false,
      value: function() {
        var result;
        notificationPauseSignal.pause = true;
        try {
          result = ko2.observableArray.fn[fnName].apply(ko2.observableArray(arrayInstance), arguments);
        } finally {
          notificationPauseSignal.pause = false;
        }
        subscribable.notifySubscribers(arrayInstance);
        return result;
      }
    });
  });
}
function getObservable(obj, propertyName) {
  if (!obj) {
    return null;
  }
  var allObservablesForObject = getAllObservablesForObject(obj, false);
  return allObservablesForObject && allObservablesForObject[propertyName] || null;
}
function valueHasMutated(obj, propertyName) {
  var observable = getObservable(obj, propertyName);
  if (observable) {
    observable.valueHasMutated();
  }
}
function attachToKo(ko2) {
  ko2.track = track;
  ko2.getObservable = getObservable;
  ko2.valueHasMutated = valueHasMutated;
  ko2.defineProperty = defineComputedProperty;
}
var knockout_es5_default = {
  attachToKo
};

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/Widgets/SvgPathBindingHandler.js
var svgNS = "http://www.w3.org/2000/svg";
var svgClassName = "cesium-svgPath-svg";
var SvgPathBindingHandler = {
  register: function(knockout2) {
    knockout2.bindingHandlers.cesiumSvgPath = {
      init: function(element, valueAccessor) {
        const svg = document.createElementNS(svgNS, "svg:svg");
        svg.setAttribute("class", svgClassName);
        const pathElement = document.createElementNS(svgNS, "path");
        svg.appendChild(pathElement);
        knockout2.virtualElements.setDomNodeChildren(element, [svg]);
        knockout2.computed({
          read: function() {
            const value = knockout2.unwrap(valueAccessor());
            pathElement.setAttribute("d", knockout2.unwrap(value.path));
            const pathWidth = knockout2.unwrap(value.width);
            const pathHeight = knockout2.unwrap(value.height);
            svg.setAttribute("width", pathWidth);
            svg.setAttribute("height", pathHeight);
            svg.setAttribute("viewBox", `0 0 ${pathWidth} ${pathHeight}`);
            if (value.css) {
              svg.setAttribute(
                "class",
                `${svgClassName} ${knockout2.unwrap(value.css)}`
              );
            }
          },
          disposeWhenNodeIsRemoved: element
        });
        return {
          controlsDescendantBindings: true
        };
      }
    };
    knockout2.virtualElements.allowedBindings.cesiumSvgPath = true;
  }
};
var SvgPathBindingHandler_default = SvgPathBindingHandler;

// node_modules/.pnpm/registry.npmmirror.com+cesium@1.99.0/node_modules/cesium/Source/ThirdParty/knockout.js
knockout_es5_default.attachToKo(knockout_3_5_1_default);
SvgPathBindingHandler_default.register(knockout_3_5_1_default);

// packages/draw/polygon.ts
var taskMap = /* @__PURE__ */ new WeakMap();
function clearTask(viewer) {
  const task2 = taskMap.get(viewer);
  if (task2 != null) {
    task2.handler.destroy();
    taskMap.delete(viewer);
  }
}
function drawPolygon(viewer) {
  return __async(this, null, function* () {
    clearTask(viewer);
    const positions = [];
    const tmpPositions = [];
    const entity = new Entity_default({
      position: new CallbackProperty_default(() => tmpPositions.slice(-1)[0], false),
      polygon: new PolygonGraphics_default({
        hierarchy: new CallbackProperty_default(() => new PolygonHierarchy_default(tmpPositions), false),
        outline: true,
        outlineColor: Color_default.RED,
        outlineWidth: 2,
        material: Color_default.YELLOW.withAlpha(0.6),
        heightReference: HeightReference_default.CLAMP_TO_GROUND
      }),
      label: new LabelGraphics_default({
        text: new CallbackProperty_default(() => `\u5DF2\u9009\u62E9${positions.length}\u4E2A\u70B9${positions.length > 0 ? "\n\u53F3\u952E\u64A4\u56DE" : ""}${positions.length >= 3 ? "\n\u53CC\u51FB\u5DE6\u952E\u7ED3\u675F" : ""}`, false),
        font: "16px",
        showBackground: true,
        backgroundColor: Color_default.BLACK,
        pixelOffset: new Cartesian2_default(0, -20),
        disableDepthTestDistance: Infinity,
        verticalOrigin: VerticalOrigin_default.BOTTOM,
        heightReference: HeightReference_default.CLAMP_TO_GROUND
      })
    });
    return yield new Promise((resolve, reject) => {
      viewer.entities.add(entity);
      const handler = new ScreenSpaceEventHandler_default(viewer.scene.canvas);
      taskMap.set(viewer, { handler, entity });
      handler.setInputAction((e) => {
        const pos = viewer.scene.pickPosition(e.position);
        if (!defined_default(pos) || pos.equals(positions.slice(-1)[0]))
          return;
        positions.push(pos);
        tmpPositions.push(pos);
      }, ScreenSpaceEventType_default.LEFT_CLICK);
      handler.setInputAction((e) => {
        const pos = viewer.scene.pickPosition(e.endPosition);
        if (!defined_default(pos))
          return;
        tmpPositions.splice(-1, 1, pos);
      }, ScreenSpaceEventType_default.MOUSE_MOVE);
      handler.setInputAction((e) => {
        positions.pop();
        tmpPositions.splice(-2, 1);
      }, ScreenSpaceEventType_default.RIGHT_CLICK);
      handler.setInputAction(() => {
        if (positions.length >= 3 && entity.polygon != null) {
          entity.polygon.hierarchy = new ConstantProperty_default(new PolygonHierarchy_default(positions));
          clearTask(viewer);
          resolve(positions);
        }
      }, ScreenSpaceEventType_default.LEFT_DOUBLE_CLICK);
    });
  });
}

// packages/measure/volume.ts
var volume_exports = {};
__export(volume_exports, {
  computeVolume: () => computeVolume
});
function computeVolume(positions, options) {
  return {
    maxHeight: 0,
    minHeight: 0,
    baseHeight: options.baseHeight,
    cutVolume: 0,
    fillVolume: 0
  };
}

// packages/utils/math.ts
var math_exports = {};
__export(math_exports, {
  computeDistance: () => computeDistance,
  computeTriangleArea: () => computeTriangleArea,
  getCartesian3Center: () => getCartesian3Center
});
function computeTriangleArea(...positions) {
  const [p1, p2, p3] = positions;
  const a3 = computeDistance([p1, p2]);
  const b = computeDistance([p2, p3]);
  const c = computeDistance([p3, p1]);
  const p = (a3 + b + c) / 2;
  return Math.sqrt(p * (p - a3) * (p - b) * (p - c));
}
function getCartesian3Center(...positions) {
  const { x, y, z } = positions.reduce((r, c) => ({ x: r.x + c.x, y: r.y + c.y, z: r.z + c.z }), { x: 0, y: 0, z: 0 });
  return { x: x / positions.length, y: y / positions.length, z: z / positions.length };
}
function computeDistance(positions) {
  let distance = 0;
  for (let i = 1; i < positions.length; i++) {
    const p1 = positions[i - 1];
    const p2 = positions[i];
    distance += Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
  }
  return distance;
}

// packages/utils/geometry-split.ts
var geometry_split_exports = {};
__export(geometry_split_exports, {
  _splitTriangle: () => _splitTriangle,
  simpleSplitTriangle: () => simpleSplitTriangle,
  splitTriangle: () => splitTriangle2
});

// node_modules/.pnpm/registry.npmmirror.com+dexie@3.2.2/node_modules/dexie/dist/modern/dexie.mjs
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
var keys = Object.keys;
var isArray = Array.isArray;
if (typeof Promise !== "undefined" && !_global.Promise) {
  _global.Promise = Promise;
}
function extend(obj, extension) {
  if (typeof extension !== "object")
    return obj;
  keys(extension).forEach(function(key) {
    obj[key] = extension[key];
  });
  return obj;
}
var getProto = Object.getPrototypeOf;
var _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
  return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
  if (typeof extension === "function")
    extension = extension(getProto(proto));
  (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach((key) => {
    setProp(proto, key, extension[key]);
  });
}
var defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options) {
  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
}
function derive(Child) {
  return {
    from: function(Parent) {
      Child.prototype = Object.create(Parent.prototype);
      setProp(Child.prototype, "constructor", Child);
      return {
        extend: props.bind(null, Child.prototype)
      };
    }
  };
}
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
  const pd = getOwnPropertyDescriptor(obj, prop);
  let proto;
  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
var _slice = [].slice;
function slice(args, start, end) {
  return _slice.call(args, start, end);
}
function override(origFunc, overridedFactory) {
  return overridedFactory(origFunc);
}
function assert(b) {
  if (!b)
    throw new Error("Assertion Failed");
}
function asap$1(fn) {
  if (_global.setImmediate)
    setImmediate(fn);
  else
    setTimeout(fn, 0);
}
function arrayToObject(array, extractor) {
  return array.reduce((result, item, i) => {
    var nameAndValue = extractor(item, i);
    if (nameAndValue)
      result[nameAndValue[0]] = nameAndValue[1];
    return result;
  }, {});
}
function tryCatch(fn, onerror, args) {
  try {
    fn.apply(null, args);
  } catch (ex) {
    onerror && onerror(ex);
  }
}
function getByKeyPath(obj, keyPath) {
  if (hasOwn(obj, keyPath))
    return obj[keyPath];
  if (!keyPath)
    return obj;
  if (typeof keyPath !== "string") {
    var rv = [];
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      var val = getByKeyPath(obj, keyPath[i]);
      rv.push(val);
    }
    return rv;
  }
  var period = keyPath.indexOf(".");
  if (period !== -1) {
    var innerObj = obj[keyPath.substr(0, period)];
    return innerObj === void 0 ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
  }
  return void 0;
}
function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === void 0)
    return;
  if ("isFrozen" in Object && Object.isFrozen(obj))
    return;
  if (typeof keyPath !== "string" && "length" in keyPath) {
    assert(typeof value !== "string" && "length" in value);
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      setByKeyPath(obj, keyPath[i], value[i]);
    }
  } else {
    var period = keyPath.indexOf(".");
    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "")
        if (value === void 0) {
          if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
            obj.splice(currentKeyPath, 1);
          else
            delete obj[currentKeyPath];
        } else
          obj[currentKeyPath] = value;
      else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath))
          innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === void 0) {
        if (isArray(obj) && !isNaN(parseInt(keyPath)))
          obj.splice(keyPath, 1);
        else
          delete obj[keyPath];
      } else
        obj[keyPath] = value;
    }
  }
}
function delByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string")
    setByKeyPath(obj, keyPath, void 0);
  else if ("length" in keyPath)
    [].map.call(keyPath, function(kp) {
      setByKeyPath(obj, kp, void 0);
    });
}
function shallowClone(obj) {
  var rv = {};
  for (var m in obj) {
    if (hasOwn(obj, m))
      rv[m] = obj[m];
  }
  return rv;
}
var concat = [].concat;
function flatten(a3) {
  return concat.apply([], a3);
}
var intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map((num) => ["Int", "Uint", "Float"].map((t) => t + num + "Array")))).filter((t) => _global[t]);
var intrinsicTypes = intrinsicTypeNames.map((t) => _global[t]);
arrayToObject(intrinsicTypeNames, (x) => [x, true]);
var circularRefs = null;
function deepClone(any) {
  circularRefs = typeof WeakMap !== "undefined" && /* @__PURE__ */ new WeakMap();
  const rv = innerDeepClone(any);
  circularRefs = null;
  return rv;
}
function innerDeepClone(any) {
  if (!any || typeof any !== "object")
    return any;
  let rv = circularRefs && circularRefs.get(any);
  if (rv)
    return rv;
  if (isArray(any)) {
    rv = [];
    circularRefs && circularRefs.set(any, rv);
    for (var i = 0, l = any.length; i < l; ++i) {
      rv.push(innerDeepClone(any[i]));
    }
  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
    rv = any;
  } else {
    const proto = getProto(any);
    rv = proto === Object.prototype ? {} : Object.create(proto);
    circularRefs && circularRefs.set(any, rv);
    for (var prop in any) {
      if (hasOwn(any, prop)) {
        rv[prop] = innerDeepClone(any[prop]);
      }
    }
  }
  return rv;
}
var { toString } = {};
function toStringTag(o) {
  return toString.call(o).slice(8, -1);
}
var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
  var i;
  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function() {
  return null;
};
var NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
  var i, a3, x, it;
  if (arguments.length === 1) {
    if (isArray(arrayLike))
      return arrayLike.slice();
    if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
      return [arrayLike];
    if (it = getIteratorOf(arrayLike)) {
      a3 = [];
      while (x = it.next(), !x.done)
        a3.push(x.value);
      return a3;
    }
    if (arrayLike == null)
      return [arrayLike];
    i = arrayLike.length;
    if (typeof i === "number") {
      a3 = new Array(i);
      while (i--)
        a3[i] = arrayLike[i];
      return a3;
    }
    return [arrayLike];
  }
  i = arguments.length;
  a3 = new Array(i);
  while (i--)
    a3[i] = arguments[i];
  return a3;
}
var isAsyncFunction = typeof Symbol !== "undefined" ? (fn) => fn[Symbol.toStringTag] === "AsyncFunction" : () => false;
var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter) {
  debug = value;
  libraryFilter = filter;
}
var libraryFilter = () => true;
var NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
  if (NEEDS_THROW_FOR_STACK)
    try {
      getErrorWithStack.arguments;
      throw new Error();
    } catch (e) {
      return e;
    }
  return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
  var stack = exception.stack;
  if (!stack)
    return "";
  numIgnoredFrames = numIgnoredFrames || 0;
  if (stack.indexOf(exception.name) === 0)
    numIgnoredFrames += (exception.name + exception.message).split("\n").length;
  return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map((frame) => "\n" + frame).join("");
}
var dexieErrorNames = [
  "Modify",
  "Bulk",
  "OpenFailed",
  "VersionChange",
  "Schema",
  "Upgrade",
  "InvalidTable",
  "MissingAPI",
  "NoSuchDatabase",
  "InvalidArgument",
  "SubTransaction",
  "Unsupported",
  "Internal",
  "DatabaseClosed",
  "PrematureCommit",
  "ForeignAwait"
];
var idbDomErrorNames = [
  "Unknown",
  "Constraint",
  "Data",
  "TransactionInactive",
  "ReadOnly",
  "Version",
  "NotFound",
  "InvalidState",
  "InvalidAccess",
  "Abort",
  "Timeout",
  "QuotaExceeded",
  "Syntax",
  "DataClone"
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
  VersionChanged: "Database version changed by other database connection",
  DatabaseClosed: "Database has been closed",
  Abort: "Transaction aborted",
  TransactionInactive: "Transaction has already completed or failed",
  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
  this._e = getErrorWithStack();
  this.name = name;
  this.message = msg;
}
derive(DexieError).from(Error).extend({
  stack: {
    get: function() {
      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
    }
  },
  toString: function() {
    return this.name + ": " + this.message;
  }
});
function getMultiErrorMessage(msg, failures) {
  return msg + ". Errors: " + Object.keys(failures).map((key) => failures[key].toString()).filter((v3, i, s) => s.indexOf(v3) === i).join("\n");
}
function ModifyError(msg, failures, successCount, failedKeys) {
  this._e = getErrorWithStack();
  this.failures = failures;
  this.failedKeys = failedKeys;
  this.successCount = successCount;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
  this._e = getErrorWithStack();
  this.name = "BulkError";
  this.failures = Object.keys(failures).map((pos) => failures[pos]);
  this.failuresByPos = failures;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
var BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
  var fullName = name + "Error";
  function DexieError2(msgOrInner, inner) {
    this._e = getErrorWithStack();
    this.name = fullName;
    if (!msgOrInner) {
      this.message = defaultTexts[name] || fullName;
      this.inner = null;
    } else if (typeof msgOrInner === "string") {
      this.message = `${msgOrInner}${!inner ? "" : "\n " + inner}`;
      this.inner = inner || null;
    } else if (typeof msgOrInner === "object") {
      this.message = `${msgOrInner.name} ${msgOrInner.message}`;
      this.inner = msgOrInner;
    }
  }
  derive(DexieError2).from(BaseException);
  obj[name] = DexieError2;
  return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
  obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
function mapError(domError, message) {
  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
    return domError;
  var rv = new exceptionMap[domError.name](message || domError.message, domError);
  if ("stack" in domError) {
    setProp(rv, "stack", { get: function() {
      return this.inner.stack;
    } });
  }
  return rv;
}
var fullNameExceptions = errorList.reduce((obj, name) => {
  if (["Syntax", "Type", "Range"].indexOf(name) === -1)
    obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;
function nop() {
}
function mirror(val) {
  return val;
}
function pureFunctionChain(f1, f2) {
  if (f1 == null || f1 === mirror)
    return f2;
  return function(val) {
    return f2(f1(val));
  };
}
function callBoth(on1, on2) {
  return function() {
    on1.apply(this, arguments);
    on2.apply(this, arguments);
  };
}
function hookCreatingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res !== void 0)
      arguments[0] = res;
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res2 !== void 0 ? res2 : res;
  };
}
function hookDeletingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    f1.apply(this, arguments);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = this.onerror = null;
    f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
  };
}
function hookUpdatingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function(modifications) {
    var res = f1.apply(this, arguments);
    extend(modifications, res);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
  };
}
function reverseStoppableEventChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    if (f2.apply(this, arguments) === false)
      return false;
    return f1.apply(this, arguments);
  };
}
function promisableChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res && typeof res.then === "function") {
      var thiz = this, i = arguments.length, args = new Array(i);
      while (i--)
        args[i] = arguments[i];
      return res.then(function() {
        return f2.apply(thiz, args);
      });
    }
    return f2.apply(this, arguments);
  };
}
var INTERNAL = {};
var LONG_STACKS_CLIP_LIMIT = 100;
var MAX_LONG_STACKS = 20;
var ZONE_ECHO_LIMIT = 100;
var [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === "undefined" ? [] : (() => {
  let globalP = Promise.resolve();
  if (typeof crypto === "undefined" || !crypto.subtle)
    return [globalP, getProto(globalP), globalP];
  const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [
    nativeP,
    getProto(nativeP),
    globalP
  ];
})();
var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
var patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? () => {
  resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {
  var hiddenDiv = document.createElement("div");
  new MutationObserver(() => {
    physicalTick();
    hiddenDiv = null;
  }).observe(hiddenDiv, { attributes: true });
  hiddenDiv.setAttribute("i", "1");
} : () => {
  setTimeout(physicalTick, 0);
};
var asap = function(callback, args) {
  microtickQueue.push([callback, args]);
  if (needsNewPhysicalTick) {
    schedulePhysicalTick();
    needsNewPhysicalTick = false;
  }
};
var isOutsideMicroTick = true;
var needsNewPhysicalTick = true;
var unhandledErrors = [];
var rejectingErrors = [];
var currentFulfiller = null;
var rejectionMapper = mirror;
var globalPSD = {
  id: "global",
  global: true,
  ref: 0,
  unhandleds: [],
  onunhandled: globalError,
  pgp: false,
  env: {},
  finalize: function() {
    this.unhandleds.forEach((uh) => {
      try {
        globalError(uh[0], uh[1]);
      } catch (e) {
      }
    });
  }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn) {
  if (typeof this !== "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [];
  this.onuncatched = nop;
  this._lib = false;
  var psd = this._PSD = PSD;
  if (debug) {
    this._stackHolder = getErrorWithStack();
    this._prev = null;
    this._numPrev = 0;
  }
  if (typeof fn !== "function") {
    if (fn !== INTERNAL)
      throw new TypeError("Not a function");
    this._state = arguments[1];
    this._value = arguments[2];
    if (this._state === false)
      handleRejection(this, this._value);
    return;
  }
  this._state = null;
  this._value = null;
  ++psd.ref;
  executePromiseTask(this, fn);
}
var thenProp = {
  get: function() {
    var psd = PSD, microTaskId = totalEchoes;
    function then(onFulfilled, onRejected) {
      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
      const cleanup = possibleAwait && !decrementExpectedAwaits();
      var rv = new DexiePromise((resolve, reject) => {
        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
      });
      debug && linkToPreviousPromise(rv, this);
      return rv;
    }
    then.prototype = INTERNAL;
    return then;
  },
  set: function(value) {
    setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
      get: function() {
        return value;
      },
      set: thenProp.set
    });
  }
};
props(DexiePromise.prototype, {
  then: thenProp,
  _then: function(onFulfilled, onRejected) {
    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
  },
  catch: function(onRejected) {
    if (arguments.length === 1)
      return this.then(null, onRejected);
    var type2 = arguments[0], handler = arguments[1];
    return typeof type2 === "function" ? this.then(null, (err) => err instanceof type2 ? handler(err) : PromiseReject(err)) : this.then(null, (err) => err && err.name === type2 ? handler(err) : PromiseReject(err));
  },
  finally: function(onFinally) {
    return this.then((value) => {
      onFinally();
      return value;
    }, (err) => {
      onFinally();
      return PromiseReject(err);
    });
  },
  stack: {
    get: function() {
      if (this._stack)
        return this._stack;
      try {
        stack_being_generated = true;
        var stacks = getStack(this, [], MAX_LONG_STACKS);
        var stack = stacks.join("\nFrom previous: ");
        if (this._state !== null)
          this._stack = stack;
        return stack;
      } finally {
        stack_being_generated = false;
      }
    }
  },
  timeout: function(ms, msg) {
    return ms < Infinity ? new DexiePromise((resolve, reject) => {
      var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);
      this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
    }) : this;
  }
});
if (typeof Symbol !== "undefined" && Symbol.toStringTag)
  setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve, reject, zone) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.resolve = resolve;
  this.reject = reject;
  this.psd = zone;
}
props(DexiePromise, {
  all: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(function(resolve, reject) {
      if (values.length === 0)
        resolve([]);
      var remaining = values.length;
      values.forEach((a3, i) => DexiePromise.resolve(a3).then((x) => {
        values[i] = x;
        if (!--remaining)
          resolve(values);
      }, reject));
    });
  },
  resolve: (value) => {
    if (value instanceof DexiePromise)
      return value;
    if (value && typeof value.then === "function")
      return new DexiePromise((resolve, reject) => {
        value.then(resolve, reject);
      });
    var rv = new DexiePromise(INTERNAL, true, value);
    linkToPreviousPromise(rv, currentFulfiller);
    return rv;
  },
  reject: PromiseReject,
  race: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve, reject) => {
      values.map((value) => DexiePromise.resolve(value).then(resolve, reject));
    });
  },
  PSD: {
    get: () => PSD,
    set: (value) => PSD = value
  },
  totalEchoes: { get: () => totalEchoes },
  newPSD: newScope,
  usePSD,
  scheduler: {
    get: () => asap,
    set: (value) => {
      asap = value;
    }
  },
  rejectionMapper: {
    get: () => rejectionMapper,
    set: (value) => {
      rejectionMapper = value;
    }
  },
  follow: (fn, zoneProps) => {
    return new DexiePromise((resolve, reject) => {
      return newScope((resolve2, reject2) => {
        var psd = PSD;
        psd.unhandleds = [];
        psd.onunhandled = reject2;
        psd.finalize = callBoth(function() {
          run_at_end_of_this_or_next_physical_tick(() => {
            this.unhandleds.length === 0 ? resolve2() : reject2(this.unhandleds[0]);
          });
        }, psd.finalize);
        fn();
      }, zoneProps, resolve, reject);
    });
  }
});
if (NativePromise) {
  if (NativePromise.allSettled)
    setProp(DexiePromise, "allSettled", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve) => {
        if (possiblePromises.length === 0)
          resolve([]);
        let remaining = possiblePromises.length;
        const results = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => results[i] = { status: "fulfilled", value }, (reason) => results[i] = { status: "rejected", reason }).then(() => --remaining || resolve(results)));
      });
    });
  if (NativePromise.any && typeof AggregateError !== "undefined")
    setProp(DexiePromise, "any", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve, reject) => {
        if (possiblePromises.length === 0)
          reject(new AggregateError([]));
        let remaining = possiblePromises.length;
        const failures = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => resolve(value), (failure) => {
          failures[i] = failure;
          if (!--remaining)
            reject(new AggregateError(failures));
        }));
      });
    });
}
function executePromiseTask(promise, fn) {
  try {
    fn((value) => {
      if (promise._state !== null)
        return;
      if (value === promise)
        throw new TypeError("A promise cannot be resolved with itself.");
      var shouldExecuteTick = promise._lib && beginMicroTickScope();
      if (value && typeof value.then === "function") {
        executePromiseTask(promise, (resolve, reject) => {
          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
        });
      } else {
        promise._state = true;
        promise._value = value;
        propagateAllListeners(promise);
      }
      if (shouldExecuteTick)
        endMicroTickScope();
    }, handleRejection.bind(null, promise));
  } catch (ex) {
    handleRejection(promise, ex);
  }
}
function handleRejection(promise, reason) {
  rejectingErrors.push(reason);
  if (promise._state !== null)
    return;
  var shouldExecuteTick = promise._lib && beginMicroTickScope();
  reason = rejectionMapper(reason);
  promise._state = false;
  promise._value = reason;
  debug && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(() => {
    var origProp = getPropertyDescriptor(reason, "stack");
    reason._promise = promise;
    setProp(reason, "stack", {
      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack
    });
  });
  addPossiblyUnhandledError(promise);
  propagateAllListeners(promise);
  if (shouldExecuteTick)
    endMicroTickScope();
}
function propagateAllListeners(promise) {
  var listeners = promise._listeners;
  promise._listeners = [];
  for (var i = 0, len = listeners.length; i < len; ++i) {
    propagateToListener(promise, listeners[i]);
  }
  var psd = promise._PSD;
  --psd.ref || psd.finalize();
  if (numScheduledCalls === 0) {
    ++numScheduledCalls;
    asap(() => {
      if (--numScheduledCalls === 0)
        finalizePhysicalTick();
    }, []);
  }
}
function propagateToListener(promise, listener) {
  if (promise._state === null) {
    promise._listeners.push(listener);
    return;
  }
  var cb = promise._state ? listener.onFulfilled : listener.onRejected;
  if (cb === null) {
    return (promise._state ? listener.resolve : listener.reject)(promise._value);
  }
  ++listener.psd.ref;
  ++numScheduledCalls;
  asap(callListener, [cb, promise, listener]);
}
function callListener(cb, promise, listener) {
  try {
    currentFulfiller = promise;
    var ret, value = promise._value;
    if (promise._state) {
      ret = cb(value);
    } else {
      if (rejectingErrors.length)
        rejectingErrors = [];
      ret = cb(value);
      if (rejectingErrors.indexOf(value) === -1)
        markErrorAsHandled(promise);
    }
    listener.resolve(ret);
  } catch (e) {
    listener.reject(e);
  } finally {
    currentFulfiller = null;
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
    --listener.psd.ref || listener.psd.finalize();
  }
}
function getStack(promise, stacks, limit) {
  if (stacks.length === limit)
    return stacks;
  var stack = "";
  if (promise._state === false) {
    var failure = promise._value, errorName, message;
    if (failure != null) {
      errorName = failure.name || "Error";
      message = failure.message || failure;
      stack = prettyStack(failure, 0);
    } else {
      errorName = failure;
      message = "";
    }
    stacks.push(errorName + (message ? ": " + message : "") + stack);
  }
  if (debug) {
    stack = prettyStack(promise._stackHolder, 2);
    if (stack && stacks.indexOf(stack) === -1)
      stacks.push(stack);
    if (promise._prev)
      getStack(promise._prev, stacks, limit);
  }
  return stacks;
}
function linkToPreviousPromise(promise, prev) {
  var numPrev = prev ? prev._numPrev + 1 : 0;
  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
    promise._prev = prev;
    promise._numPrev = numPrev;
  }
}
function physicalTick() {
  beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
  var wasRootExec = isOutsideMicroTick;
  isOutsideMicroTick = false;
  needsNewPhysicalTick = false;
  return wasRootExec;
}
function endMicroTickScope() {
  var callbacks, i, l;
  do {
    while (microtickQueue.length > 0) {
      callbacks = microtickQueue;
      microtickQueue = [];
      l = callbacks.length;
      for (i = 0; i < l; ++i) {
        var item = callbacks[i];
        item[0].apply(null, item[1]);
      }
    }
  } while (microtickQueue.length > 0);
  isOutsideMicroTick = true;
  needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
  var unhandledErrs = unhandledErrors;
  unhandledErrors = [];
  unhandledErrs.forEach((p) => {
    p._PSD.onunhandled.call(null, p._value, p);
  });
  var finalizers = tickFinalizers.slice(0);
  var i = finalizers.length;
  while (i)
    finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn) {
  function finalizer() {
    fn();
    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
  }
  tickFinalizers.push(finalizer);
  ++numScheduledCalls;
  asap(() => {
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
  }, []);
}
function addPossiblyUnhandledError(promise) {
  if (!unhandledErrors.some((p) => p._value === promise._value))
    unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
  var i = unhandledErrors.length;
  while (i)
    if (unhandledErrors[--i]._value === promise._value) {
      unhandledErrors.splice(i, 1);
      return;
    }
}
function PromiseReject(reason) {
  return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn, errorCatcher) {
  var psd = PSD;
  return function() {
    var wasRootExec = beginMicroTickScope(), outerScope = PSD;
    try {
      switchToZone(psd, true);
      return fn.apply(this, arguments);
    } catch (e) {
      errorCatcher && errorCatcher(e);
    } finally {
      switchToZone(outerScope, false);
      if (wasRootExec)
        endMicroTickScope();
    }
  };
}
var task = { awaits: 0, echoes: 0, id: 0 };
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn, props2, a1, a22) {
  var parent = PSD, psd = Object.create(parent);
  psd.parent = parent;
  psd.ref = 0;
  psd.global = false;
  psd.id = ++zone_id_counter;
  var globalEnv = globalPSD.env;
  psd.env = patchGlobalPromise ? {
    Promise: DexiePromise,
    PromiseProp: { value: DexiePromise, configurable: true, writable: true },
    all: DexiePromise.all,
    race: DexiePromise.race,
    allSettled: DexiePromise.allSettled,
    any: DexiePromise.any,
    resolve: DexiePromise.resolve,
    reject: DexiePromise.reject,
    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
  } : {};
  if (props2)
    extend(psd, props2);
  ++parent.ref;
  psd.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var rv = usePSD(psd, fn, a1, a22);
  if (psd.ref === 0)
    psd.finalize();
  return rv;
}
function incrementExpectedAwaits() {
  if (!task.id)
    task.id = ++taskCounter;
  ++task.awaits;
  task.echoes += ZONE_ECHO_LIMIT;
  return task.id;
}
function decrementExpectedAwaits() {
  if (!task.awaits)
    return false;
  if (--task.awaits === 0)
    task.id = 0;
  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
  return true;
}
if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
  incrementExpectedAwaits = decrementExpectedAwaits = nop;
}
function onPossibleParallellAsync(possiblePromise) {
  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
    incrementExpectedAwaits();
    return possiblePromise.then((x) => {
      decrementExpectedAwaits();
      return x;
    }, (e) => {
      decrementExpectedAwaits();
      return rejection(e);
    });
  }
  return possiblePromise;
}
function zoneEnterEcho(targetZone) {
  ++totalEchoes;
  if (!task.echoes || --task.echoes === 0) {
    task.echoes = task.id = 0;
  }
  zoneStack.push(PSD);
  switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
  var zone = zoneStack[zoneStack.length - 1];
  zoneStack.pop();
  switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
  var currentZone = PSD;
  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
  }
  if (targetZone === PSD)
    return;
  PSD = targetZone;
  if (currentZone === globalPSD)
    globalPSD.env = snapShot();
  if (patchGlobalPromise) {
    var GlobalPromise = globalPSD.env.Promise;
    var targetEnv = targetZone.env;
    nativePromiseProto.then = targetEnv.nthen;
    GlobalPromise.prototype.then = targetEnv.gthen;
    if (currentZone.global || targetZone.global) {
      Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
      GlobalPromise.all = targetEnv.all;
      GlobalPromise.race = targetEnv.race;
      GlobalPromise.resolve = targetEnv.resolve;
      GlobalPromise.reject = targetEnv.reject;
      if (targetEnv.allSettled)
        GlobalPromise.allSettled = targetEnv.allSettled;
      if (targetEnv.any)
        GlobalPromise.any = targetEnv.any;
    }
  }
}
function snapShot() {
  var GlobalPromise = _global.Promise;
  return patchGlobalPromise ? {
    Promise: GlobalPromise,
    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
    all: GlobalPromise.all,
    race: GlobalPromise.race,
    allSettled: GlobalPromise.allSettled,
    any: GlobalPromise.any,
    resolve: GlobalPromise.resolve,
    reject: GlobalPromise.reject,
    nthen: nativePromiseProto.then,
    gthen: GlobalPromise.prototype.then
  } : {};
}
function usePSD(psd, fn, a1, a22, a3) {
  var outerScope = PSD;
  try {
    switchToZone(psd, true);
    return fn(a1, a22, a3);
  } finally {
    switchToZone(outerScope, false);
  }
}
function enqueueNativeMicroTask(job) {
  nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
  return typeof fn !== "function" ? fn : function() {
    var outerZone = PSD;
    if (possibleAwait)
      incrementExpectedAwaits();
    switchToZone(zone, true);
    try {
      return fn.apply(this, arguments);
    } finally {
      switchToZone(outerZone, false);
      if (cleanup)
        enqueueNativeMicroTask(decrementExpectedAwaits);
    }
  };
}
function getPatchedPromiseThen(origThen, zone) {
  return function(onResolved, onRejected) {
    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
  };
}
var UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
  var rv;
  try {
    rv = promise.onuncatched(err);
  } catch (e) {
  }
  if (rv !== false)
    try {
      var event, eventData = { promise, reason: err };
      if (_global.document && document.createEvent) {
        event = document.createEvent("Event");
        event.initEvent(UNHANDLEDREJECTION, true, true);
        extend(event, eventData);
      } else if (_global.CustomEvent) {
        event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
        extend(event, eventData);
      }
      if (event && _global.dispatchEvent) {
        dispatchEvent(event);
        if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
          try {
            _global.onunhandledrejection(event);
          } catch (_) {
          }
      }
      if (debug && event && !event.defaultPrevented) {
        console.warn(`Unhandled rejection: ${err.stack || err}`);
      }
    } catch (e) {
    }
}
var rejection = DexiePromise.reject;
function tempTransaction(db, mode, storeNames, fn) {
  if (!db.idbdb || !db._state.openComplete && (!PSD.letThrough && !db._vip)) {
    if (db._state.openComplete) {
      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
    }
    if (!db._state.isBeingOpened) {
      if (!db._options.autoOpen)
        return rejection(new exceptions.DatabaseClosed());
      db.open().catch(nop);
    }
    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));
  } else {
    var trans = db._createTransaction(mode, storeNames, db._dbSchema);
    try {
      trans.create();
      db._state.PR1398_maxLoop = 3;
    } catch (ex) {
      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
        console.warn("Dexie: Need to reopen db");
        db._close();
        return db.open().then(() => tempTransaction(db, mode, storeNames, fn));
      }
      return rejection(ex);
    }
    return trans._promise(mode, (resolve, reject) => {
      return newScope(() => {
        PSD.trans = trans;
        return fn(resolve, reject, trans);
      });
    }).then((result) => {
      return trans._completion.then(() => result);
    });
  }
}
var DEXIE_VERSION = "3.2.2";
var maxString = String.fromCharCode(65535);
var minKey = -Infinity;
var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
var STRING_EXPECTED = "String expected.";
var connections = [];
var isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
var hasIEDeleteObjectStoreBug = isIEOrEdge;
var hangsOnDeleteLargeKeyRange = isIEOrEdge;
var dexieStackFrameFilter = (frame) => !/(dexie\.js|dexie\.min\.js)/.test(frame);
var DBNAMES_DB = "__dbnames";
var READONLY = "readonly";
var READWRITE = "readwrite";
function combine2(filter1, filter2) {
  return filter1 ? filter2 ? function() {
    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
  } : filter1 : filter2;
}
var AnyRange = {
  type: 3,
  lower: -Infinity,
  lowerOpen: false,
  upper: [[]],
  upperOpen: false
};
function workaroundForUndefinedPrimKey(keyPath) {
  return typeof keyPath === "string" && !/\./.test(keyPath) ? (obj) => {
    if (obj[keyPath] === void 0 && keyPath in obj) {
      obj = deepClone(obj);
      delete obj[keyPath];
    }
    return obj;
  } : (obj) => obj;
}
var Table = class {
  _trans(mode, fn, writeLocked) {
    const trans = this._tx || PSD.trans;
    const tableName = this.name;
    function checkTableInTransaction(resolve, reject, trans2) {
      if (!trans2.schema[tableName])
        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
      return fn(trans2.idbtrans, trans2);
    }
    const wasRootExec = beginMicroTickScope();
    try {
      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
    } finally {
      if (wasRootExec)
        endMicroTickScope();
    }
  }
  get(keyOrCrit, cb) {
    if (keyOrCrit && keyOrCrit.constructor === Object)
      return this.where(keyOrCrit).first(cb);
    return this._trans("readonly", (trans) => {
      return this.core.get({ trans, key: keyOrCrit }).then((res) => this.hook.reading.fire(res));
    }).then(cb);
  }
  where(indexOrCrit) {
    if (typeof indexOrCrit === "string")
      return new this.db.WhereClause(this, indexOrCrit);
    if (isArray(indexOrCrit))
      return new this.db.WhereClause(this, `[${indexOrCrit.join("+")}]`);
    const keyPaths = keys(indexOrCrit);
    if (keyPaths.length === 1)
      return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix) => ix.compound && keyPaths.every((keyPath) => ix.keyPath.indexOf(keyPath) >= 0) && ix.keyPath.every((keyPath) => keyPaths.indexOf(keyPath) >= 0))[0];
    if (compoundIndex && this.db._maxKey !== maxString)
      return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map((kp) => indexOrCrit[kp]));
    if (!compoundIndex && debug)
      console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a compound index [${keyPaths.join("+")}]`);
    const { idxByName } = this.schema;
    const idb = this.db._deps.indexedDB;
    function equals(a3, b) {
      try {
        return idb.cmp(a3, b) === 0;
      } catch (e) {
        return false;
      }
    }
    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
      const index = idxByName[keyPath];
      const value = indexOrCrit[keyPath];
      return [
        prevIndex || index,
        prevIndex || !index ? combine2(prevFilterFn, index && index.multi ? (x) => {
          const prop = getByKeyPath(x, keyPath);
          return isArray(prop) && prop.some((item) => equals(value, item));
        } : (x) => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn
      ];
    }, [null, null]);
    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
  }
  filter(filterFunction) {
    return this.toCollection().and(filterFunction);
  }
  count(thenShortcut) {
    return this.toCollection().count(thenShortcut);
  }
  offset(offset) {
    return this.toCollection().offset(offset);
  }
  limit(numRows) {
    return this.toCollection().limit(numRows);
  }
  each(callback) {
    return this.toCollection().each(callback);
  }
  toArray(thenShortcut) {
    return this.toCollection().toArray(thenShortcut);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(index) {
    return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join("+")}]` : index));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(constructor) {
    this.schema.mappedClass = constructor;
    const readHook = (obj) => {
      if (!obj)
        return obj;
      const res = Object.create(constructor.prototype);
      for (var m in obj)
        if (hasOwn(obj, m))
          try {
            res[m] = obj[m];
          } catch (_) {
          }
      return res;
    };
    if (this.schema.readHook) {
      this.hook.reading.unsubscribe(this.schema.readHook);
    }
    this.schema.readHook = readHook;
    this.hook("reading", readHook);
    return constructor;
  }
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return this.mapToClass(Class);
  }
  add(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
    }).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  update(keyOrObject, modifications) {
    if (typeof keyOrObject === "object" && !isArray(keyOrObject)) {
      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
      if (key === void 0)
        return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
      try {
        if (typeof modifications !== "function") {
          keys(modifications).forEach((keyPath) => {
            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
          });
        } else {
          modifications(keyOrObject, { value: keyOrObject, primKey: key });
        }
      } catch (_a) {
      }
      return this.where(":id").equals(key).modify(modifications);
    } else {
      return this.where(":id").equals(keyOrObject).modify(modifications);
    }
  }
  put(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  delete(key) {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "delete", keys: [key] })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "deleteRange", range: AnyRange })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  bulkGet(keys2) {
    return this._trans("readonly", (trans) => {
      return this.core.getMany({
        keys: keys2,
        trans
      }).then((result) => result.map((res) => this.hook.reading.fire(res)));
    });
  }
  bulkAdd(objects, keysOrOptions, options) {
    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys2 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys2)
        throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (keys2 && keys2.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "add", keys: keys2, values: objectsToAdd, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkPut(objects, keysOrOptions, options) {
    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys2 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys2)
        throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (keys2 && keys2.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "put", keys: keys2, values: objectsToPut, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkDelete(keys2) {
    const numKeys = keys2.length;
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "delete", keys: keys2 });
    }).then(({ numFailures, lastResult, failures }) => {
      if (numFailures === 0)
        return lastResult;
      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
    });
  }
};
function Events(ctx) {
  var evs = {};
  var rv = function(eventName, subscriber) {
    if (subscriber) {
      var i2 = arguments.length, args = new Array(i2 - 1);
      while (--i2)
        args[i2 - 1] = arguments[i2];
      evs[eventName].subscribe.apply(null, args);
      return ctx;
    } else if (typeof eventName === "string") {
      return evs[eventName];
    }
  };
  rv.addEventType = add;
  for (var i = 1, l = arguments.length; i < l; ++i) {
    add(arguments[i]);
  }
  return rv;
  function add(eventName, chainFunction, defaultFunction) {
    if (typeof eventName === "object")
      return addConfiguredEvents(eventName);
    if (!chainFunction)
      chainFunction = reverseStoppableEventChain;
    if (!defaultFunction)
      defaultFunction = nop;
    var context = {
      subscribers: [],
      fire: defaultFunction,
      subscribe: function(cb) {
        if (context.subscribers.indexOf(cb) === -1) {
          context.subscribers.push(cb);
          context.fire = chainFunction(context.fire, cb);
        }
      },
      unsubscribe: function(cb) {
        context.subscribers = context.subscribers.filter(function(fn) {
          return fn !== cb;
        });
        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
      }
    };
    evs[eventName] = rv[eventName] = context;
    return context;
  }
  function addConfiguredEvents(cfg) {
    keys(cfg).forEach(function(eventName) {
      var args = cfg[eventName];
      if (isArray(args)) {
        add(eventName, cfg[eventName][0], cfg[eventName][1]);
      } else if (args === "asap") {
        var context = add(eventName, mirror, function fire() {
          var i2 = arguments.length, args2 = new Array(i2);
          while (i2--)
            args2[i2] = arguments[i2];
          context.subscribers.forEach(function(fn) {
            asap$1(function fireEvent() {
              fn.apply(null, args2);
            });
          });
        });
      } else
        throw new exceptions.InvalidArgument("Invalid event config");
    });
  }
}
function makeClassConstructor(prototype, constructor) {
  derive(constructor).from({ prototype });
  return constructor;
}
function createTableConstructor(db) {
  return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
    this.db = db;
    this._tx = trans;
    this.name = name;
    this.schema = tableSchema;
    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
      "creating": [hookCreatingChain, nop],
      "reading": [pureFunctionChain, mirror],
      "updating": [hookUpdatingChain, nop],
      "deleting": [hookDeletingChain, nop]
    });
  });
}
function isPlainKeyRange(ctx, ignoreLimitFilter) {
  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn) {
  ctx.filter = combine2(ctx.filter, fn);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
  var curr = ctx.replayFilter;
  ctx.replayFilter = curr ? () => combine2(curr(), factory()) : factory;
  ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn) {
  ctx.isMatch = combine2(ctx.isMatch, fn);
}
function getIndexOrStore(ctx, coreSchema) {
  if (ctx.isPrimKey)
    return coreSchema.primaryKey;
  const index = coreSchema.getIndexByKeyPath(ctx.index);
  if (!index)
    throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
  return index;
}
function openCursor(ctx, coreTable, trans) {
  const index = getIndexOrStore(ctx, coreTable.schema);
  return coreTable.openCursor({
    trans,
    values: !ctx.keysOnly,
    reverse: ctx.dir === "prev",
    unique: !!ctx.unique,
    query: {
      index,
      range: ctx.range
    }
  });
}
function iter(ctx, fn, coreTrans, coreTable) {
  const filter = ctx.replayFilter ? combine2(ctx.filter, ctx.replayFilter()) : ctx.filter;
  if (!ctx.or) {
    return iterate(openCursor(ctx, coreTable, coreTrans), combine2(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
  } else {
    const set = {};
    const union = (item, cursor, advance) => {
      if (!filter || filter(cursor, advance, (result) => cursor.stop(result), (err) => cursor.fail(err))) {
        var primaryKey = cursor.primaryKey;
        var key = "" + primaryKey;
        if (key === "[object ArrayBuffer]")
          key = "" + new Uint8Array(primaryKey);
        if (!hasOwn(set, key)) {
          set[key] = true;
          fn(item, cursor, advance);
        }
      }
    };
    return Promise.all([
      ctx.or._iterate(union, coreTrans),
      iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
    ]);
  }
}
function iterate(cursorPromise, filter, fn, valueMapper) {
  var mappedFn = valueMapper ? (x, c, a3) => fn(valueMapper(x), c, a3) : fn;
  var wrappedFn = wrap(mappedFn);
  return cursorPromise.then((cursor) => {
    if (cursor) {
      return cursor.start(() => {
        var c = () => cursor.continue();
        if (!filter || filter(cursor, (advancer) => c = advancer, (val) => {
          cursor.stop(val);
          c = nop;
        }, (e) => {
          cursor.fail(e);
          c = nop;
        }))
          wrappedFn(cursor.value, cursor, (advancer) => c = advancer);
        c();
      });
    }
  });
}
function cmp(a3, b) {
  try {
    const ta = type(a3);
    const tb = type(b);
    if (ta !== tb) {
      if (ta === "Array")
        return 1;
      if (tb === "Array")
        return -1;
      if (ta === "binary")
        return 1;
      if (tb === "binary")
        return -1;
      if (ta === "string")
        return 1;
      if (tb === "string")
        return -1;
      if (ta === "Date")
        return 1;
      if (tb !== "Date")
        return NaN;
      return -1;
    }
    switch (ta) {
      case "number":
      case "Date":
      case "string":
        return a3 > b ? 1 : a3 < b ? -1 : 0;
      case "binary": {
        return compareUint8Arrays(getUint8Array(a3), getUint8Array(b));
      }
      case "Array":
        return compareArrays(a3, b);
    }
  } catch (_a) {
  }
  return NaN;
}
function compareArrays(a3, b) {
  const al = a3.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    const res = cmp(a3[i], b[i]);
    if (res !== 0)
      return res;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a3, b) {
  const al = a3.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    if (a3[i] !== b[i])
      return a3[i] < b[i] ? -1 : 1;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function type(x) {
  const t = typeof x;
  if (t !== "object")
    return t;
  if (ArrayBuffer.isView(x))
    return "binary";
  const tsTag = toStringTag(x);
  return tsTag === "ArrayBuffer" ? "binary" : tsTag;
}
function getUint8Array(a3) {
  if (a3 instanceof Uint8Array)
    return a3;
  if (ArrayBuffer.isView(a3))
    return new Uint8Array(a3.buffer, a3.byteOffset, a3.byteLength);
  return new Uint8Array(a3);
}
var Collection = class {
  _read(fn, cb) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
  }
  _write(fn) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
  }
  _addAlgorithm(fn) {
    var ctx = this._ctx;
    ctx.algorithm = combine2(ctx.algorithm, fn);
  }
  _iterate(fn, coreTrans) {
    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
  }
  clone(props2) {
    var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
    if (props2)
      extend(ctx, props2);
    rv._ctx = ctx;
    return rv;
  }
  raw() {
    this._ctx.valueMapper = null;
    return this;
  }
  each(fn) {
    var ctx = this._ctx;
    return this._read((trans) => iter(ctx, fn, trans, ctx.table.core));
  }
  count(cb) {
    return this._read((trans) => {
      const ctx = this._ctx;
      const coreTable = ctx.table.core;
      if (isPlainKeyRange(ctx, true)) {
        return coreTable.count({
          trans,
          query: {
            index: getIndexOrStore(ctx, coreTable.schema),
            range: ctx.range
          }
        }).then((count2) => Math.min(count2, ctx.limit));
      } else {
        var count = 0;
        return iter(ctx, () => {
          ++count;
          return false;
        }, trans, coreTable).then(() => count);
      }
    }).then(cb);
  }
  sortBy(keyPath, cb) {
    const parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
    function getval(obj, i) {
      if (i)
        return getval(obj[parts[i]], i - 1);
      return obj[lastPart];
    }
    var order = this._ctx.dir === "next" ? 1 : -1;
    function sorter(a3, b) {
      var aVal = getval(a3, lastIndex), bVal = getval(b, lastIndex);
      return aVal < bVal ? -order : aVal > bVal ? order : 0;
    }
    return this.toArray(function(a3) {
      return a3.sort(sorter);
    }).then(cb);
  }
  toArray(cb) {
    return this._read((trans) => {
      var ctx = this._ctx;
      if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
        const { valueMapper } = ctx;
        const index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          limit: ctx.limit,
          values: true,
          query: {
            index,
            range: ctx.range
          }
        }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
      } else {
        const a3 = [];
        return iter(ctx, (item) => a3.push(item), trans, ctx.table.core).then(() => a3);
      }
    }, cb);
  }
  offset(offset) {
    var ctx = this._ctx;
    if (offset <= 0)
      return this;
    ctx.offset += offset;
    if (isPlainKeyRange(ctx)) {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return (cursor, advance) => {
          if (offsetLeft === 0)
            return true;
          if (offsetLeft === 1) {
            --offsetLeft;
            return false;
          }
          advance(() => {
            cursor.advance(offsetLeft);
            offsetLeft = 0;
          });
          return false;
        };
      });
    } else {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return () => --offsetLeft < 0;
      });
    }
    return this;
  }
  limit(numRows) {
    this._ctx.limit = Math.min(this._ctx.limit, numRows);
    addReplayFilter(this._ctx, () => {
      var rowsLeft = numRows;
      return function(cursor, advance, resolve) {
        if (--rowsLeft <= 0)
          advance(resolve);
        return rowsLeft >= 0;
      };
    }, true);
    return this;
  }
  until(filterFunction, bIncludeStopEntry) {
    addFilter(this._ctx, function(cursor, advance, resolve) {
      if (filterFunction(cursor.value)) {
        advance(resolve);
        return bIncludeStopEntry;
      } else {
        return true;
      }
    });
    return this;
  }
  first(cb) {
    return this.limit(1).toArray(function(a3) {
      return a3[0];
    }).then(cb);
  }
  last(cb) {
    return this.reverse().first(cb);
  }
  filter(filterFunction) {
    addFilter(this._ctx, function(cursor) {
      return filterFunction(cursor.value);
    });
    addMatchFilter(this._ctx, filterFunction);
    return this;
  }
  and(filter) {
    return this.filter(filter);
  }
  or(indexName) {
    return new this.db.WhereClause(this._ctx.table, indexName, this);
  }
  reverse() {
    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
    if (this._ondirectionchange)
      this._ondirectionchange(this._ctx.dir);
    return this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.key, cursor);
    });
  }
  eachUniqueKey(cb) {
    this._ctx.unique = "unique";
    return this.eachKey(cb);
  }
  eachPrimaryKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.primaryKey, cursor);
    });
  }
  keys(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    var a3 = [];
    return this.each(function(item, cursor) {
      a3.push(cursor.key);
    }).then(function() {
      return a3;
    }).then(cb);
  }
  primaryKeys(cb) {
    var ctx = this._ctx;
    if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
      return this._read((trans) => {
        var index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          values: false,
          limit: ctx.limit,
          query: {
            index,
            range: ctx.range
          }
        });
      }).then(({ result }) => result).then(cb);
    }
    ctx.keysOnly = !ctx.isMatch;
    var a3 = [];
    return this.each(function(item, cursor) {
      a3.push(cursor.primaryKey);
    }).then(function() {
      return a3;
    }).then(cb);
  }
  uniqueKeys(cb) {
    this._ctx.unique = "unique";
    return this.keys(cb);
  }
  firstKey(cb) {
    return this.limit(1).keys(function(a3) {
      return a3[0];
    }).then(cb);
  }
  lastKey(cb) {
    return this.reverse().firstKey(cb);
  }
  distinct() {
    var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
    if (!idx || !idx.multi)
      return this;
    var set = {};
    addFilter(this._ctx, function(cursor) {
      var strKey = cursor.primaryKey.toString();
      var found = hasOwn(set, strKey);
      set[strKey] = true;
      return !found;
    });
    return this;
  }
  modify(changes) {
    var ctx = this._ctx;
    return this._write((trans) => {
      var modifyer;
      if (typeof changes === "function") {
        modifyer = changes;
      } else {
        var keyPaths = keys(changes);
        var numKeys = keyPaths.length;
        modifyer = function(item) {
          var anythingModified = false;
          for (var i = 0; i < numKeys; ++i) {
            var keyPath = keyPaths[i], val = changes[keyPath];
            if (getByKeyPath(item, keyPath) !== val) {
              setByKeyPath(item, keyPath, val);
              anythingModified = true;
            }
          }
          return anythingModified;
        };
      }
      const coreTable = ctx.table.core;
      const { outbound, extractKey } = coreTable.schema.primaryKey;
      const limit = this.db._options.modifyChunkSize || 200;
      const totalFailures = [];
      let successCount = 0;
      const failedKeys = [];
      const applyMutateResult = (expectedCount, res) => {
        const { failures, numFailures } = res;
        successCount += expectedCount - numFailures;
        for (let pos of keys(failures)) {
          totalFailures.push(failures[pos]);
        }
      };
      return this.clone().primaryKeys().then((keys2) => {
        const nextChunk = (offset) => {
          const count = Math.min(limit, keys2.length - offset);
          return coreTable.getMany({
            trans,
            keys: keys2.slice(offset, offset + count),
            cache: "immutable"
          }).then((values) => {
            const addValues = [];
            const putValues = [];
            const putKeys = outbound ? [] : null;
            const deleteKeys = [];
            for (let i = 0; i < count; ++i) {
              const origValue = values[i];
              const ctx2 = {
                value: deepClone(origValue),
                primKey: keys2[offset + i]
              };
              if (modifyer.call(ctx2, ctx2.value, ctx2) !== false) {
                if (ctx2.value == null) {
                  deleteKeys.push(keys2[offset + i]);
                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx2.value)) !== 0) {
                  deleteKeys.push(keys2[offset + i]);
                  addValues.push(ctx2.value);
                } else {
                  putValues.push(ctx2.value);
                  if (outbound)
                    putKeys.push(keys2[offset + i]);
                }
              }
            }
            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
              index: ctx.index,
              range: ctx.range
            };
            return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then((res) => {
              for (let pos in res.failures) {
                deleteKeys.splice(parseInt(pos), 1);
              }
              applyMutateResult(addValues.length, res);
            })).then(() => (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
              trans,
              type: "put",
              keys: putKeys,
              values: putValues,
              criteria,
              changeSpec: typeof changes !== "function" && changes
            }).then((res) => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
              trans,
              type: "delete",
              keys: deleteKeys,
              criteria
            }).then((res) => applyMutateResult(deleteKeys.length, res))).then(() => {
              return keys2.length > offset + count && nextChunk(offset + limit);
            });
          });
        };
        return nextChunk(0).then(() => {
          if (totalFailures.length > 0)
            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
          return keys2.length;
        });
      });
    });
  }
  delete() {
    var ctx = this._ctx, range = ctx.range;
    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
      return this._write((trans) => {
        const { primaryKey } = ctx.table.core.schema;
        const coreRange = range;
        return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then((count) => {
          return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(({ failures, lastResult, results, numFailures }) => {
            if (numFailures)
              throw new ModifyError("Could not delete some values", Object.keys(failures).map((pos) => failures[pos]), count - numFailures);
            return count - numFailures;
          });
        });
      });
    }
    return this.modify(deleteCallback);
  }
};
var deleteCallback = (value, ctx) => ctx.value = null;
function createCollectionConstructor(db) {
  return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
    this.db = db;
    let keyRange = AnyRange, error = null;
    if (keyRangeGenerator)
      try {
        keyRange = keyRangeGenerator();
      } catch (ex) {
        error = ex;
      }
    const whereCtx = whereClause._ctx;
    const table = whereCtx.table;
    const readingHook = table.hook.reading.fire;
    this._ctx = {
      table,
      index: whereCtx.index,
      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
      range: keyRange,
      keysOnly: false,
      dir: "next",
      unique: "",
      algorithm: null,
      filter: null,
      replayFilter: null,
      justLimit: true,
      isMatch: null,
      offset: 0,
      limit: Infinity,
      error,
      or: whereCtx.or,
      valueMapper: readingHook !== mirror ? readingHook : null
    };
  });
}
function simpleCompare(a3, b) {
  return a3 < b ? -1 : a3 === b ? 0 : 1;
}
function simpleCompareReverse(a3, b) {
  return a3 > b ? -1 : a3 === b ? 0 : 1;
}
function fail(collectionOrWhereClause, err, T) {
  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
  collection._ctx.error = T ? new T(err) : new TypeError(err);
  return collection;
}
function emptyCollection(whereClause) {
  return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}
function upperFactory(dir) {
  return dir === "next" ? (s) => s.toUpperCase() : (s) => s.toLowerCase();
}
function lowerFactory(dir) {
  return dir === "next" ? (s) => s.toLowerCase() : (s) => s.toUpperCase();
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {
  var length = Math.min(key.length, lowerNeedle.length);
  var llp = -1;
  for (var i = 0; i < length; ++i) {
    var lwrKeyChar = lowerKey[i];
    if (lwrKeyChar !== lowerNeedle[i]) {
      if (cmp2(key[i], upperNeedle[i]) < 0)
        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
      if (cmp2(key[i], lowerNeedle[i]) < 0)
        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
      if (llp >= 0)
        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
      return null;
    }
    if (cmp2(key[i], lwrKeyChar) < 0)
      llp = i;
  }
  if (length < lowerNeedle.length && dir === "next")
    return key + upperNeedle.substr(key.length);
  if (length < key.length && dir === "prev")
    return key.substr(0, upperNeedle.length);
  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}
function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
  var upper, lower, compare, upperNeedles, lowerNeedles, direction2, nextKeySuffix, needlesLen = needles.length;
  if (!needles.every((s) => typeof s === "string")) {
    return fail(whereClause, STRING_EXPECTED);
  }
  function initDirection(dir) {
    upper = upperFactory(dir);
    lower = lowerFactory(dir);
    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
    var needleBounds = needles.map(function(needle) {
      return { lower: lower(needle), upper: upper(needle) };
    }).sort(function(a3, b) {
      return compare(a3.lower, b.lower);
    });
    upperNeedles = needleBounds.map(function(nb) {
      return nb.upper;
    });
    lowerNeedles = needleBounds.map(function(nb) {
      return nb.lower;
    });
    direction2 = dir;
    nextKeySuffix = dir === "next" ? "" : suffix;
  }
  initDirection("next");
  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
  c._ondirectionchange = function(direction3) {
    initDirection(direction3);
  };
  var firstPossibleNeedle = 0;
  c._addAlgorithm(function(cursor, advance, resolve) {
    var key = cursor.key;
    if (typeof key !== "string")
      return false;
    var lowerKey = lower(key);
    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
      return true;
    } else {
      var lowestPossibleCasing = null;
      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction2);
        if (casing === null && lowestPossibleCasing === null)
          firstPossibleNeedle = i + 1;
        else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
          lowestPossibleCasing = casing;
        }
      }
      if (lowestPossibleCasing !== null) {
        advance(function() {
          cursor.continue(lowestPossibleCasing + nextKeySuffix);
        });
      } else {
        advance(resolve);
      }
      return false;
    }
  });
  return c;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
  return {
    type: 2,
    lower,
    upper,
    lowerOpen,
    upperOpen
  };
}
function rangeEqual(value) {
  return {
    type: 1,
    lower: value,
    upper: value
  };
}
var WhereClause = class {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(lower, upper, includeLower, includeUpper) {
    includeLower = includeLower !== false;
    includeUpper = includeUpper === true;
    try {
      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
        return emptyCollection(this);
      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
  }
  equals(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => rangeEqual(value));
  }
  above(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, true));
  }
  aboveOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, false));
  }
  below(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value, false, true));
  }
  belowOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value));
  }
  startsWith(str) {
    if (typeof str !== "string")
      return fail(this, STRING_EXPECTED);
    return this.between(str, str + maxString, true, true);
  }
  startsWithIgnoreCase(str) {
    if (str === "")
      return this.startsWith(str);
    return addIgnoreCaseAlgorithm(this, (x, a3) => x.indexOf(a3[0]) === 0, [str], maxString);
  }
  equalsIgnoreCase(str) {
    return addIgnoreCaseAlgorithm(this, (x, a3) => x === a3[0], [str], "");
  }
  anyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a3) => a3.indexOf(x) !== -1, set, "");
  }
  startsWithAnyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a3) => a3.some((n) => x.indexOf(n) === 0), set, maxString);
  }
  anyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    let compare = this._cmp;
    try {
      set.sort(compare);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    if (set.length === 0)
      return emptyCollection(this);
    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));
    c._ondirectionchange = (direction2) => {
      compare = direction2 === "next" ? this._ascending : this._descending;
      set.sort(compare);
    };
    let i = 0;
    c._addAlgorithm((cursor, advance, resolve) => {
      const key = cursor.key;
      while (compare(key, set[i]) > 0) {
        ++i;
        if (i === set.length) {
          advance(resolve);
          return false;
        }
      }
      if (compare(key, set[i]) === 0) {
        return true;
      } else {
        advance(() => {
          cursor.continue(set[i]);
        });
        return false;
      }
    });
    return c;
  }
  notEqual(value) {
    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return new this.Collection(this);
    try {
      set.sort(this._ascending);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);
    ranges.push([set[set.length - 1], this.db._maxKey]);
    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(ranges, options) {
    const cmp2 = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
    if (ranges.length === 0)
      return emptyCollection(this);
    if (!ranges.every((range) => range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0)) {
      return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
    }
    const includeLowers = !options || options.includeLowers !== false;
    const includeUppers = options && options.includeUppers === true;
    function addRange2(ranges2, newRange) {
      let i = 0, l = ranges2.length;
      for (; i < l; ++i) {
        const range = ranges2[i];
        if (cmp2(newRange[0], range[1]) < 0 && cmp2(newRange[1], range[0]) > 0) {
          range[0] = min(range[0], newRange[0]);
          range[1] = max(range[1], newRange[1]);
          break;
        }
      }
      if (i === l)
        ranges2.push(newRange);
      return ranges2;
    }
    let sortDirection = ascending;
    function rangeSorter(a3, b) {
      return sortDirection(a3[0], b[0]);
    }
    let set;
    try {
      set = ranges.reduce(addRange2, []);
      set.sort(rangeSorter);
    } catch (ex) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    let rangePos = 0;
    const keyIsBeyondCurrentEntry = includeUppers ? (key) => ascending(key, set[rangePos][1]) > 0 : (key) => ascending(key, set[rangePos][1]) >= 0;
    const keyIsBeforeCurrentEntry = includeLowers ? (key) => descending(key, set[rangePos][0]) > 0 : (key) => descending(key, set[rangePos][0]) >= 0;
    function keyWithinCurrentRange(key) {
      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
    }
    let checkKey = keyIsBeyondCurrentEntry;
    const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));
    c._ondirectionchange = (direction2) => {
      if (direction2 === "next") {
        checkKey = keyIsBeyondCurrentEntry;
        sortDirection = ascending;
      } else {
        checkKey = keyIsBeforeCurrentEntry;
        sortDirection = descending;
      }
      set.sort(rangeSorter);
    };
    c._addAlgorithm((cursor, advance, resolve) => {
      var key = cursor.key;
      while (checkKey(key)) {
        ++rangePos;
        if (rangePos === set.length) {
          advance(resolve);
          return false;
        }
      }
      if (keyWithinCurrentRange(key)) {
        return true;
      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
        return false;
      } else {
        advance(() => {
          if (sortDirection === ascending)
            cursor.continue(set[rangePos][0]);
          else
            cursor.continue(set[rangePos][1]);
        });
        return false;
      }
    });
    return c;
  }
  startsWithAnyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (!set.every((s) => typeof s === "string")) {
      return fail(this, "startsWithAnyOf() only works with strings");
    }
    if (set.length === 0)
      return emptyCollection(this);
    return this.inAnyRange(set.map((str) => [str, str + maxString]));
  }
};
function createWhereClauseConstructor(db) {
  return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
    this.db = db;
    this._ctx = {
      table,
      index: index === ":id" ? null : index,
      or: orCollection
    };
    const indexedDB2 = db._deps.indexedDB;
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);
    this._descending = (a3, b) => indexedDB2.cmp(b, a3);
    this._max = (a3, b) => indexedDB2.cmp(a3, b) > 0 ? a3 : b;
    this._min = (a3, b) => indexedDB2.cmp(a3, b) < 0 ? a3 : b;
    this._IDBKeyRange = db._deps.IDBKeyRange;
  });
}
function eventRejectHandler(reject) {
  return wrap(function(event) {
    preventDefault(event);
    reject(event.target.error);
    return false;
  });
}
function preventDefault(event) {
  if (event.stopPropagation)
    event.stopPropagation();
  if (event.preventDefault)
    event.preventDefault();
}
var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
var Transaction = class {
  _lock() {
    assert(!PSD.global);
    ++this._reculock;
    if (this._reculock === 1 && !PSD.global)
      PSD.lockOwnerFor = this;
    return this;
  }
  _unlock() {
    assert(!PSD.global);
    if (--this._reculock === 0) {
      if (!PSD.global)
        PSD.lockOwnerFor = null;
      while (this._blockedFuncs.length > 0 && !this._locked()) {
        var fnAndPSD = this._blockedFuncs.shift();
        try {
          usePSD(fnAndPSD[1], fnAndPSD[0]);
        } catch (e) {
        }
      }
    }
    return this;
  }
  _locked() {
    return this._reculock && PSD.lockOwnerFor !== this;
  }
  create(idbtrans) {
    if (!this.mode)
      return this;
    const idbdb = this.db.idbdb;
    const dbOpenError = this.db._state.dbOpenError;
    assert(!this.idbtrans);
    if (!idbtrans && !idbdb) {
      switch (dbOpenError && dbOpenError.name) {
        case "DatabaseClosedError":
          throw new exceptions.DatabaseClosed(dbOpenError);
        case "MissingAPIError":
          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
        default:
          throw new exceptions.OpenFailed(dbOpenError);
      }
    }
    if (!this.active)
      throw new exceptions.TransactionInactive();
    assert(this._completion._state === null);
    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
    idbtrans.onerror = wrap((ev) => {
      preventDefault(ev);
      this._reject(idbtrans.error);
    });
    idbtrans.onabort = wrap((ev) => {
      preventDefault(ev);
      this.active && this._reject(new exceptions.Abort(idbtrans.error));
      this.active = false;
      this.on("abort").fire(ev);
    });
    idbtrans.oncomplete = wrap(() => {
      this.active = false;
      this._resolve();
      if ("mutatedParts" in idbtrans) {
        globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
      }
    });
    return this;
  }
  _promise(mode, fn, bWriteLock) {
    if (mode === "readwrite" && this.mode !== "readwrite")
      return rejection(new exceptions.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return rejection(new exceptions.TransactionInactive());
    if (this._locked()) {
      return new DexiePromise((resolve, reject) => {
        this._blockedFuncs.push([() => {
          this._promise(mode, fn, bWriteLock).then(resolve, reject);
        }, PSD]);
      });
    } else if (bWriteLock) {
      return newScope(() => {
        var p2 = new DexiePromise((resolve, reject) => {
          this._lock();
          const rv = fn(resolve, reject, this);
          if (rv && rv.then)
            rv.then(resolve, reject);
        });
        p2.finally(() => this._unlock());
        p2._lib = true;
        return p2;
      });
    } else {
      var p = new DexiePromise((resolve, reject) => {
        var rv = fn(resolve, reject, this);
        if (rv && rv.then)
          rv.then(resolve, reject);
      });
      p._lib = true;
      return p;
    }
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(promiseLike) {
    var root = this._root();
    const promise = DexiePromise.resolve(promiseLike);
    if (root._waitingFor) {
      root._waitingFor = root._waitingFor.then(() => promise);
    } else {
      root._waitingFor = promise;
      root._waitingQueue = [];
      var store = root.idbtrans.objectStore(root.storeNames[0]);
      (function spin() {
        ++root._spinCount;
        while (root._waitingQueue.length)
          root._waitingQueue.shift()();
        if (root._waitingFor)
          store.get(-Infinity).onsuccess = spin;
      })();
    }
    var currentWaitPromise = root._waitingFor;
    return new DexiePromise((resolve, reject) => {
      promise.then((res) => root._waitingQueue.push(wrap(resolve.bind(null, res))), (err) => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {
        if (root._waitingFor === currentWaitPromise) {
          root._waitingFor = null;
        }
      });
    });
  }
  abort() {
    if (this.active) {
      this.active = false;
      if (this.idbtrans)
        this.idbtrans.abort();
      this._reject(new exceptions.Abort());
    }
  }
  table(tableName) {
    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});
    if (hasOwn(memoizedTables, tableName))
      return memoizedTables[tableName];
    const tableSchema = this.schema[tableName];
    if (!tableSchema) {
      throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
    }
    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
    transactionBoundTable.core = this.db.core.table(tableName);
    memoizedTables[tableName] = transactionBoundTable;
    return transactionBoundTable;
  }
};
function createTransactionConstructor(db) {
  return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
    this.db = db;
    this.mode = mode;
    this.storeNames = storeNames;
    this.schema = dbschema;
    this.chromeTransactionDurability = chromeTransactionDurability;
    this.idbtrans = null;
    this.on = Events(this, "complete", "error", "abort");
    this.parent = parent || null;
    this.active = true;
    this._reculock = 0;
    this._blockedFuncs = [];
    this._resolve = null;
    this._reject = null;
    this._waitingFor = null;
    this._waitingQueue = null;
    this._spinCount = 0;
    this._completion = new DexiePromise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._completion.then(() => {
      this.active = false;
      this.on.complete.fire();
    }, (e) => {
      var wasActive = this.active;
      this.active = false;
      this.on.error.fire(e);
      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();
      return rejection(e);
    });
  });
}
function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
  return {
    name,
    keyPath,
    unique,
    multi,
    auto,
    compound,
    src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
  };
}
function nameFromKeyPath(keyPath) {
  return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
function createTableSchema(name, primKey, indexes) {
  return {
    name,
    primKey,
    indexes,
    mappedClass: null,
    idxByName: arrayToObject(indexes, (index) => [index.name, index])
  };
}
function safariMultiStoreFix(storeNames) {
  return storeNames.length === 1 ? storeNames[0] : storeNames;
}
var getMaxKey = (IdbKeyRange) => {
  try {
    IdbKeyRange.only([[]]);
    getMaxKey = () => [[]];
    return [[]];
  } catch (e) {
    getMaxKey = () => maxString;
    return maxString;
  }
};
function getKeyExtractor(keyPath) {
  if (keyPath == null) {
    return () => void 0;
  } else if (typeof keyPath === "string") {
    return getSinglePathKeyExtractor(keyPath);
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function getSinglePathKeyExtractor(keyPath) {
  const split = keyPath.split(".");
  if (split.length === 1) {
    return (obj) => obj[keyPath];
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function arrayify(arrayLike) {
  return [].slice.call(arrayLike);
}
var _id_counter = 0;
function getKeyPathAlias(keyPath) {
  return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : `[${keyPath.join("+")}]`;
}
function createDBCore(db, IdbKeyRange, tmpTrans) {
  function extractSchema(db2, trans) {
    const tables2 = arrayify(db2.objectStoreNames);
    return {
      schema: {
        name: db2.name,
        tables: tables2.map((table) => trans.objectStore(table)).map((store) => {
          const { keyPath, autoIncrement } = store;
          const compound = isArray(keyPath);
          const outbound = keyPath == null;
          const indexByKeyPath = {};
          const result = {
            name: store.name,
            primaryKey: {
              name: null,
              isPrimaryKey: true,
              outbound,
              compound,
              keyPath,
              autoIncrement,
              unique: true,
              extractKey: getKeyExtractor(keyPath)
            },
            indexes: arrayify(store.indexNames).map((indexName) => store.index(indexName)).map((index) => {
              const { name, unique, multiEntry, keyPath: keyPath2 } = index;
              const compound2 = isArray(keyPath2);
              const result2 = {
                name,
                compound: compound2,
                keyPath: keyPath2,
                unique,
                multiEntry,
                extractKey: getKeyExtractor(keyPath2)
              };
              indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
              return result2;
            }),
            getIndexByKeyPath: (keyPath2) => indexByKeyPath[getKeyPathAlias(keyPath2)]
          };
          indexByKeyPath[":id"] = result.primaryKey;
          if (keyPath != null) {
            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
          }
          return result;
        })
      },
      hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
    };
  }
  function makeIDBKeyRange(range) {
    if (range.type === 3)
      return null;
    if (range.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower, upper, lowerOpen, upperOpen } = range;
    const idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
    return idbRange;
  }
  function createDbCoreTable(tableSchema) {
    const tableName = tableSchema.name;
    function mutate({ trans, type: type2, keys: keys2, values, range }) {
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const store = trans.objectStore(tableName);
        const outbound = store.keyPath == null;
        const isAddOrPut = type2 === "put" || type2 === "add";
        if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
          throw new Error("Invalid operation type: " + type2);
        const { length } = keys2 || values || { length: 1 };
        if (keys2 && values && keys2.length !== values.length) {
          throw new Error("Given keys array must have same length as given values array.");
        }
        if (length === 0)
          return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let req;
        const reqs = [];
        const failures = [];
        let numFailures = 0;
        const errorHandler = (event) => {
          ++numFailures;
          preventDefault(event);
        };
        if (type2 === "deleteRange") {
          if (range.type === 4)
            return resolve({ numFailures, failures, results: [], lastResult: void 0 });
          if (range.type === 3)
            reqs.push(req = store.clear());
          else
            reqs.push(req = store.delete(makeIDBKeyRange(range)));
        } else {
          const [args1, args2] = isAddOrPut ? outbound ? [values, keys2] : [values, null] : [keys2, null];
          if (isAddOrPut) {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          } else {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          }
        }
        const done = (event) => {
          const lastResult = event.target.result;
          reqs.forEach((req2, i) => req2.error != null && (failures[i] = req2.error));
          resolve({
            numFailures,
            failures,
            results: type2 === "delete" ? keys2 : reqs.map((req2) => req2.result),
            lastResult
          });
        };
        req.onerror = (event) => {
          errorHandler(event);
          done(event);
        };
        req.onsuccess = done;
      });
    }
    function openCursor2({ trans, values, query: query2, reverse, unique }) {
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const { index, range } = query2;
        const store = trans.objectStore(tableName);
        const source = index.isPrimaryKey ? store : store.index(index.name);
        const direction2 = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
        const req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction2) : source.openKeyCursor(makeIDBKeyRange(range), direction2);
        req.onerror = eventRejectHandler(reject);
        req.onsuccess = wrap((ev) => {
          const cursor = req.result;
          if (!cursor) {
            resolve(null);
            return;
          }
          cursor.___id = ++_id_counter;
          cursor.done = false;
          const _cursorContinue = cursor.continue.bind(cursor);
          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
          if (_cursorContinuePrimaryKey)
            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
          const _cursorAdvance = cursor.advance.bind(cursor);
          const doThrowCursorIsNotStarted = () => {
            throw new Error("Cursor not started");
          };
          const doThrowCursorIsStopped = () => {
            throw new Error("Cursor not stopped");
          };
          cursor.trans = trans;
          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
          cursor.fail = wrap(reject);
          cursor.next = function() {
            let gotOne = 1;
            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
          };
          cursor.start = (callback) => {
            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
              resolveIteration = wrap(resolveIteration);
              req.onerror = eventRejectHandler(rejectIteration);
              cursor.fail = rejectIteration;
              cursor.stop = (value) => {
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                resolveIteration(value);
              };
            });
            const guardedCallback = () => {
              if (req.result) {
                try {
                  callback();
                } catch (err) {
                  cursor.fail(err);
                }
              } else {
                cursor.done = true;
                cursor.start = () => {
                  throw new Error("Cursor behind last entry");
                };
                cursor.stop();
              }
            };
            req.onsuccess = wrap((ev2) => {
              req.onsuccess = guardedCallback;
              guardedCallback();
            });
            cursor.continue = _cursorContinue;
            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
            cursor.advance = _cursorAdvance;
            guardedCallback();
            return iterationPromise;
          };
          resolve(cursor);
        }, reject);
      });
    }
    function query(hasGetAll2) {
      return (request) => {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const { trans, values, limit, query: query2 } = request;
          const nonInfinitLimit = limit === Infinity ? void 0 : limit;
          const { index, range } = query2;
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          if (limit === 0)
            return resolve({ result: [] });
          if (hasGetAll2) {
            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
            req.onsuccess = (event) => resolve({ result: event.target.result });
            req.onerror = eventRejectHandler(reject);
          } else {
            let count = 0;
            const req = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
            const result = [];
            req.onsuccess = (event) => {
              const cursor = req.result;
              if (!cursor)
                return resolve({ result });
              result.push(values ? cursor.value : cursor.primaryKey);
              if (++count === limit)
                return resolve({ result });
              cursor.continue();
            };
            req.onerror = eventRejectHandler(reject);
          }
        });
      };
    }
    return {
      name: tableName,
      schema: tableSchema,
      mutate,
      getMany({ trans, keys: keys2 }) {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const length = keys2.length;
          const result = new Array(length);
          let keyCount = 0;
          let callbackCount = 0;
          let req;
          const successHandler = (event) => {
            const req2 = event.target;
            if ((result[req2._pos] = req2.result) != null)
              ;
            if (++callbackCount === keyCount)
              resolve(result);
          };
          const errorHandler = eventRejectHandler(reject);
          for (let i = 0; i < length; ++i) {
            const key = keys2[i];
            if (key != null) {
              req = store.get(keys2[i]);
              req._pos = i;
              req.onsuccess = successHandler;
              req.onerror = errorHandler;
              ++keyCount;
            }
          }
          if (keyCount === 0)
            resolve(result);
        });
      },
      get({ trans, key }) {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const req = store.get(key);
          req.onsuccess = (event) => resolve(event.target.result);
          req.onerror = eventRejectHandler(reject);
        });
      },
      query: query(hasGetAll),
      openCursor: openCursor2,
      count({ query: query2, trans }) {
        const { index, range } = query2;
        return new Promise((resolve, reject) => {
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
          req.onsuccess = wrap((ev) => resolve(ev.target.result));
          req.onerror = eventRejectHandler(reject);
        });
      }
    };
  }
  const { schema, hasGetAll } = extractSchema(db, tmpTrans);
  const tables = schema.tables.map((tableSchema) => createDbCoreTable(tableSchema));
  const tableMap = {};
  tables.forEach((table) => tableMap[table.name] = table);
  return {
    stack: "dbcore",
    transaction: db.transaction.bind(db),
    table(name) {
      const result = tableMap[name];
      if (!result)
        throw new Error(`Table '${name}' not found`);
      return tableMap[name];
    },
    MIN_KEY: -Infinity,
    MAX_KEY: getMaxKey(IdbKeyRange),
    schema
  };
}
function createMiddlewareStack(stackImpl, middlewares) {
  return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB: indexedDB2 }, tmpTrans) {
  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
  return {
    dbcore
  };
}
function generateMiddlewareStacks({ _novip: db }, tmpTrans) {
  const idbdb = tmpTrans.db;
  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
  db.core = stacks.dbcore;
  db.tables.forEach((table) => {
    const tableName = table.name;
    if (db.core.schema.tables.some((tbl) => tbl.name === tableName)) {
      table.core = db.core.table(tableName);
      if (db[tableName] instanceof db.Table) {
        db[tableName].core = table.core;
      }
    }
  });
}
function setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {
  tableNames.forEach((tableName) => {
    const schema = dbschema[tableName];
    objs.forEach((obj) => {
      const propDesc = getPropertyDescriptor(obj, tableName);
      if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
          setProp(obj, tableName, {
            get() {
              return this.table(tableName);
            },
            set(value) {
              defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
            }
          });
        } else {
          obj[tableName] = new db.Table(tableName, schema);
        }
      }
    });
  });
}
function removeTablesApi({ _novip: db }, objs) {
  objs.forEach((obj) => {
    for (let key in obj) {
      if (obj[key] instanceof db.Table)
        delete obj[key];
    }
  });
}
function lowerVersionFirst(a3, b) {
  return a3._cfg.version - b._cfg.version;
}
function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
  const globalSchema = db._dbSchema;
  const trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
  trans.create(idbUpgradeTrans);
  trans._completion.catch(reject);
  const rejectTransaction = trans._reject.bind(trans);
  const transless = PSD.transless || PSD;
  newScope(() => {
    PSD.trans = trans;
    PSD.transless = transless;
    if (oldVersion === 0) {
      keys(globalSchema).forEach((tableName) => {
        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
      });
      generateMiddlewareStacks(db, idbUpgradeTrans);
      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
    } else
      updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
  });
}
function updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {
  const queue = [];
  const versions = db._versions;
  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
  let anyContentUpgraderHasRun = false;
  const versToRun = versions.filter((v3) => v3._cfg.version >= oldVersion);
  versToRun.forEach((version) => {
    queue.push(() => {
      const oldSchema = globalSchema;
      const newSchema = version._cfg.dbschema;
      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
      globalSchema = db._dbSchema = newSchema;
      const diff = getSchemaDiff(oldSchema, newSchema);
      diff.add.forEach((tuple) => {
        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
      });
      diff.change.forEach((change) => {
        if (change.recreate) {
          throw new exceptions.Upgrade("Not yet support for changing primary key");
        } else {
          const store = idbUpgradeTrans.objectStore(change.name);
          change.add.forEach((idx) => addIndex(store, idx));
          change.change.forEach((idx) => {
            store.deleteIndex(idx.name);
            addIndex(store, idx);
          });
          change.del.forEach((idxName) => store.deleteIndex(idxName));
        }
      });
      const contentUpgrade = version._cfg.contentUpgrade;
      if (contentUpgrade && version._cfg.version > oldVersion) {
        generateMiddlewareStacks(db, idbUpgradeTrans);
        trans._memoizedTables = {};
        anyContentUpgraderHasRun = true;
        let upgradeSchema = shallowClone(newSchema);
        diff.del.forEach((table) => {
          upgradeSchema[table] = oldSchema[table];
        });
        removeTablesApi(db, [db.Transaction.prototype]);
        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);
        trans.schema = upgradeSchema;
        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
        if (contentUpgradeIsAsync) {
          incrementExpectedAwaits();
        }
        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
          returnValue = contentUpgrade(trans);
          if (returnValue) {
            if (contentUpgradeIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            }
          }
        });
        return returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);
      }
    });
    queue.push((idbtrans) => {
      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
        const newSchema = version._cfg.dbschema;
        deleteRemovedTables(newSchema, idbtrans);
      }
      removeTablesApi(db, [db.Transaction.prototype]);
      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
      trans.schema = db._dbSchema;
    });
  });
  function runQueue() {
    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
  }
  return runQueue().then(() => {
    createMissingTables(globalSchema, idbUpgradeTrans);
  });
}
function getSchemaDiff(oldSchema, newSchema) {
  const diff = {
    del: [],
    add: [],
    change: []
  };
  let table;
  for (table in oldSchema) {
    if (!newSchema[table])
      diff.del.push(table);
  }
  for (table in newSchema) {
    const oldDef = oldSchema[table], newDef = newSchema[table];
    if (!oldDef) {
      diff.add.push([table, newDef]);
    } else {
      const change = {
        name: table,
        def: newDef,
        recreate: false,
        del: [],
        add: [],
        change: []
      };
      if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
        change.recreate = true;
        diff.change.push(change);
      } else {
        const oldIndexes = oldDef.idxByName;
        const newIndexes = newDef.idxByName;
        let idxName;
        for (idxName in oldIndexes) {
          if (!newIndexes[idxName])
            change.del.push(idxName);
        }
        for (idxName in newIndexes) {
          const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
          if (!oldIdx)
            change.add.push(newIdx);
          else if (oldIdx.src !== newIdx.src)
            change.change.push(newIdx);
        }
        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
          diff.change.push(change);
        }
      }
    }
  }
  return diff;
}
function createTable(idbtrans, tableName, primKey, indexes) {
  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
  indexes.forEach((idx) => addIndex(store, idx));
  return store;
}
function createMissingTables(newSchema, idbtrans) {
  keys(newSchema).forEach((tableName) => {
    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    }
  });
}
function deleteRemovedTables(newSchema, idbtrans) {
  [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName) => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}
function addIndex(store, idx) {
  store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
}
function buildGlobalSchema(db, idbdb, tmpTrans) {
  const globalSchema = {};
  const dbStoreNames = slice(idbdb.objectStoreNames, 0);
  dbStoreNames.forEach((storeName) => {
    const store = tmpTrans.objectStore(storeName);
    let keyPath = store.keyPath;
    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
    const indexes = [];
    for (let j = 0; j < store.indexNames.length; ++j) {
      const idbindex = store.index(store.indexNames[j]);
      keyPath = idbindex.keyPath;
      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
      indexes.push(index);
    }
    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
  });
  return globalSchema;
}
function readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {
  db.verno = idbdb.version / 10;
  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
  db._storeNames = slice(idbdb.objectStoreNames, 0);
  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
}
function verifyInstalledSchema(db, tmpTrans) {
  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
  const diff = getSchemaDiff(installedSchema, db._dbSchema);
  return !(diff.add.length || diff.change.some((ch) => ch.add.length || ch.change.length));
}
function adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {
  const storeNames = idbtrans.db.objectStoreNames;
  for (let i = 0; i < storeNames.length; ++i) {
    const storeName = storeNames[i];
    const store = idbtrans.objectStore(storeName);
    db._hasGetAll = "getAll" in store;
    for (let j = 0; j < store.indexNames.length; ++j) {
      const indexName = store.indexNames[j];
      const keyPath = store.index(indexName).keyPath;
      const dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
      if (schema[storeName]) {
        const indexSpec = schema[storeName].idxByName[dexieName];
        if (indexSpec) {
          indexSpec.name = indexName;
          delete schema[storeName].idxByName[dexieName];
          schema[storeName].idxByName[indexName] = indexSpec;
        }
      }
    }
  }
  if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
    db._hasGetAll = false;
  }
}
function parseIndexSyntax(primKeyAndIndexes) {
  return primKeyAndIndexes.split(",").map((index, indexNum) => {
    index = index.trim();
    const name = index.replace(/([&*]|\+\+)/g, "");
    const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
  });
}
var Version = class {
  _parseStoresSpec(stores, outSchema) {
    keys(stores).forEach((tableName) => {
      if (stores[tableName] !== null) {
        var indexes = parseIndexSyntax(stores[tableName]);
        var primKey = indexes.shift();
        if (primKey.multi)
          throw new exceptions.Schema("Primary key cannot be multi-valued");
        indexes.forEach((idx) => {
          if (idx.auto)
            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!idx.keyPath)
            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
        });
        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
      }
    });
  }
  stores(stores) {
    const db = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
    const versions = db._versions;
    const storesSpec = {};
    let dbschema = {};
    versions.forEach((version) => {
      extend(storesSpec, version._cfg.storesSource);
      dbschema = version._cfg.dbschema = {};
      version._parseStoresSpec(storesSpec, dbschema);
    });
    db._dbSchema = dbschema;
    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
    db._storeNames = keys(dbschema);
    return this;
  }
  upgrade(upgradeFunction) {
    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
    return this;
  }
};
function createVersionConstructor(db) {
  return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
    this.db = db;
    this._cfg = {
      version: versionNumber,
      storesSource: null,
      dbschema: {},
      tables: {},
      contentUpgrade: null
    };
  });
}
function getDbNamesTable(indexedDB2, IDBKeyRange) {
  let dbNamesDB = indexedDB2["_dbNamesDB"];
  if (!dbNamesDB) {
    dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
      addons: [],
      indexedDB: indexedDB2,
      IDBKeyRange
    });
    dbNamesDB.version(1).stores({ dbnames: "name" });
  }
  return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB2) {
  return indexedDB2 && typeof indexedDB2.databases === "function";
}
function getDatabaseNames({ indexedDB: indexedDB2, IDBKeyRange }) {
  return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then((infos) => infos.map((info) => info.name).filter((name) => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();
}
function _onDatabaseCreated({ indexedDB: indexedDB2, IDBKeyRange }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({ name }).catch(nop);
}
function _onDatabaseDeleted({ indexedDB: indexedDB2, IDBKeyRange }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);
}
function vip(fn) {
  return newScope(function() {
    PSD.letThrough = true;
    return fn();
  });
}
function idbReady() {
  var isSafari2 = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari2 || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
function dexieOpen(db) {
  const state = db._state;
  const { indexedDB: indexedDB2 } = db._deps;
  if (state.isBeingOpened || db.idbdb)
    return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);
  debug && (state.openCanceller._stackHolder = getErrorWithStack());
  state.isBeingOpened = true;
  state.dbOpenError = null;
  state.openComplete = false;
  const openCanceller = state.openCanceller;
  function throwIfCancelled() {
    if (state.openCanceller !== openCanceller)
      throw new exceptions.DatabaseClosed("db.open() was cancelled");
  }
  let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
  return DexiePromise.race([openCanceller, (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {
    throwIfCancelled();
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    const dbName = db.name;
    const req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db.verno * 10));
    if (!req)
      throw new exceptions.MissingAPI();
    req.onerror = eventRejectHandler(reject);
    req.onblocked = wrap(db._fireOnBlocked);
    req.onupgradeneeded = wrap((e) => {
      upgradeTransaction = req.transaction;
      if (state.autoSchema && !db._options.allowEmptyDB) {
        req.onerror = preventDefault;
        upgradeTransaction.abort();
        req.result.close();
        const delreq = indexedDB2.deleteDatabase(dbName);
        delreq.onsuccess = delreq.onerror = wrap(() => {
          reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
        });
      } else {
        upgradeTransaction.onerror = eventRejectHandler(reject);
        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
        wasCreated = oldVer < 1;
        db._novip.idbdb = req.result;
        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
      }
    }, reject);
    req.onsuccess = wrap(() => {
      upgradeTransaction = null;
      const idbdb = db._novip.idbdb = req.result;
      const objectStoreNames = slice(idbdb.objectStoreNames);
      if (objectStoreNames.length > 0)
        try {
          const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
          if (state.autoSchema)
            readGlobalSchema(db, idbdb, tmpTrans);
          else {
            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
            if (!verifyInstalledSchema(db, tmpTrans)) {
              console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
            }
          }
          generateMiddlewareStacks(db, tmpTrans);
        } catch (e) {
        }
      connections.push(db);
      idbdb.onversionchange = wrap((ev) => {
        state.vcFired = true;
        db.on("versionchange").fire(ev);
      });
      idbdb.onclose = wrap((ev) => {
        db.on("close").fire(ev);
      });
      if (wasCreated)
        _onDatabaseCreated(db._deps, dbName);
      resolve();
    }, reject);
  }))]).then(() => {
    throwIfCancelled();
    state.onReadyBeingFired = [];
    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
      if (state.onReadyBeingFired.length > 0) {
        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
      }
    });
  }).finally(() => {
    state.onReadyBeingFired = null;
    state.isBeingOpened = false;
  }).then(() => {
    return db;
  }).catch((err) => {
    state.dbOpenError = err;
    try {
      upgradeTransaction && upgradeTransaction.abort();
    } catch (_a) {
    }
    if (openCanceller === state.openCanceller) {
      db._close();
    }
    return rejection(err);
  }).finally(() => {
    state.openComplete = true;
    resolveDbReady();
  });
}
function awaitIterator(iterator) {
  var callNext = (result) => iterator.next(result), doThrow = (error) => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);
  function step(getNext) {
    return (val) => {
      var next = getNext(val), value = next.value;
      return next.done ? value : !value || typeof value.then !== "function" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
    };
  }
  return step(callNext)();
}
function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
  var i = arguments.length;
  if (i < 2)
    throw new exceptions.InvalidArgument("Too few arguments");
  var args = new Array(i - 1);
  while (--i)
    args[i - 1] = arguments[i];
  scopeFunc = args.pop();
  var tables = flatten(args);
  return [mode, tables, scopeFunc];
}
function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
  return DexiePromise.resolve().then(() => {
    const transless = PSD.transless || PSD;
    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
    const zoneProps = {
      trans,
      transless
    };
    if (parentTransaction) {
      trans.idbtrans = parentTransaction.idbtrans;
    } else {
      try {
        trans.create();
        db._state.PR1398_maxLoop = 3;
      } catch (ex) {
        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
          console.warn("Dexie: Need to reopen db");
          db._close();
          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
        }
        return rejection(ex);
      }
    }
    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
    if (scopeFuncIsAsync) {
      incrementExpectedAwaits();
    }
    let returnValue;
    const promiseFollowed = DexiePromise.follow(() => {
      returnValue = scopeFunc.call(trans, trans);
      if (returnValue) {
        if (scopeFuncIsAsync) {
          var decrementor = decrementExpectedAwaits.bind(null, null);
          returnValue.then(decrementor, decrementor);
        } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
          returnValue = awaitIterator(returnValue);
        }
      }
    }, zoneProps);
    return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then((x) => trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : promiseFollowed.then(() => returnValue)).then((x) => {
      if (parentTransaction)
        trans._resolve();
      return trans._completion.then(() => x);
    }).catch((e) => {
      trans._reject(e);
      return rejection(e);
    });
  });
}
function pad(a3, value, count) {
  const result = isArray(a3) ? a3.slice() : [a3];
  for (let i = 0; i < count; ++i)
    result.push(value);
  return result;
}
function createVirtualIndexMiddleware(down) {
  return {
    ...down,
    table(tableName) {
      const table = down.table(tableName);
      const { schema } = table;
      const indexLookup = {};
      const allVirtualIndexes = [];
      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
        const keyPathAlias = getKeyPathAlias(keyPath);
        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
        const keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
        const isVirtual = keyTail > 0;
        const virtualIndex = {
          ...lowLevelIndex,
          isVirtual,
          keyTail,
          keyLength,
          extractKey: getKeyExtractor(keyPath),
          unique: !isVirtual && lowLevelIndex.unique
        };
        indexList.push(virtualIndex);
        if (!virtualIndex.isPrimaryKey) {
          allVirtualIndexes.push(virtualIndex);
        }
        if (keyLength > 1) {
          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
        }
        indexList.sort((a3, b) => a3.keyTail - b.keyTail);
        return virtualIndex;
      }
      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
      indexLookup[":id"] = [primaryKey];
      for (const index of schema.indexes) {
        addVirtualIndexes(index.keyPath, 0, index);
      }
      function findBestIndex(keyPath) {
        const result2 = indexLookup[getKeyPathAlias(keyPath)];
        return result2 && result2[0];
      }
      function translateRange(range, keyTail) {
        return {
          type: range.type === 1 ? 2 : range.type,
          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
          lowerOpen: true,
          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
          upperOpen: true
        };
      }
      function translateRequest(req) {
        const index = req.query.index;
        return index.isVirtual ? {
          ...req,
          query: {
            index,
            range: translateRange(req.query.range, index.keyTail)
          }
        } : req;
      }
      const result = {
        ...table,
        schema: {
          ...schema,
          primaryKey,
          indexes: allVirtualIndexes,
          getIndexByKeyPath: findBestIndex
        },
        count(req) {
          return table.count(translateRequest(req));
        },
        query(req) {
          return table.query(translateRequest(req));
        },
        openCursor(req) {
          const { keyTail, isVirtual, keyLength } = req.query.index;
          if (!isVirtual)
            return table.openCursor(req);
          function createVirtualCursor(cursor) {
            function _continue(key) {
              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
            }
            const virtualCursor = Object.create(cursor, {
              continue: { value: _continue },
              continuePrimaryKey: {
                value(key, primaryKey2) {
                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                }
              },
              primaryKey: {
                get() {
                  return cursor.primaryKey;
                }
              },
              key: {
                get() {
                  const key = cursor.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }
              },
              value: {
                get() {
                  return cursor.value;
                }
              }
            });
            return virtualCursor;
          }
          return table.openCursor(translateRequest(req)).then((cursor) => cursor && createVirtualCursor(cursor));
        }
      };
      return result;
    }
  };
}
var virtualIndexMiddleware = {
  stack: "dbcore",
  name: "VirtualIndexMiddleware",
  level: 1,
  create: createVirtualIndexMiddleware
};
function getObjectDiff(a3, b, rv, prfx) {
  rv = rv || {};
  prfx = prfx || "";
  keys(a3).forEach((prop) => {
    if (!hasOwn(b, prop)) {
      rv[prfx + prop] = void 0;
    } else {
      var ap = a3[prop], bp = b[prop];
      if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
        const apTypeName = toStringTag(ap);
        const bpTypeName = toStringTag(bp);
        if (apTypeName !== bpTypeName) {
          rv[prfx + prop] = b[prop];
        } else if (apTypeName === "Object") {
          getObjectDiff(ap, bp, rv, prfx + prop + ".");
        } else if (ap !== bp) {
          rv[prfx + prop] = b[prop];
        }
      } else if (ap !== bp)
        rv[prfx + prop] = b[prop];
    }
  });
  keys(b).forEach((prop) => {
    if (!hasOwn(a3, prop)) {
      rv[prfx + prop] = b[prop];
    }
  });
  return rv;
}
function getEffectiveKeys(primaryKey, req) {
  if (req.type === "delete")
    return req.keys;
  return req.keys || req.values.map(primaryKey.extractKey);
}
var hooksMiddleware = {
  stack: "dbcore",
  name: "HooksMiddleware",
  level: 2,
  create: (downCore) => ({
    ...downCore,
    table(tableName) {
      const downTable = downCore.table(tableName);
      const { primaryKey } = downTable.schema;
      const tableMiddleware = {
        ...downTable,
        mutate(req) {
          const dxTrans = PSD.trans;
          const { deleting, creating, updating } = dxTrans.table(tableName).hook;
          switch (req.type) {
            case "add":
              if (creating.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "put":
              if (creating.fire === nop && updating.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "delete":
              if (deleting.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "deleteRange":
              if (deleting.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => deleteRange(req), true);
          }
          return downTable.mutate(req);
          function addPutOrDelete(req2) {
            const dxTrans2 = PSD.trans;
            const keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);
            if (!keys2)
              throw new Error("Keys missing");
            req2 = req2.type === "add" || req2.type === "put" ? { ...req2, keys: keys2 } : { ...req2 };
            if (req2.type !== "delete")
              req2.values = [...req2.values];
            if (req2.keys)
              req2.keys = [...req2.keys];
            return getExistingValues(downTable, req2, keys2).then((existingValues) => {
              const contexts = keys2.map((key, i) => {
                const existingValue = existingValues[i];
                const ctx = { onerror: null, onsuccess: null };
                if (req2.type === "delete") {
                  deleting.fire.call(ctx, key, existingValue, dxTrans2);
                } else if (req2.type === "add" || existingValue === void 0) {
                  const generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                  if (key == null && generatedPrimaryKey != null) {
                    key = generatedPrimaryKey;
                    req2.keys[i] = key;
                    if (!primaryKey.outbound) {
                      setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                    }
                  }
                } else {
                  const objectDiff = getObjectDiff(existingValue, req2.values[i]);
                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                  if (additionalChanges) {
                    const requestedValue = req2.values[i];
                    Object.keys(additionalChanges).forEach((keyPath) => {
                      if (hasOwn(requestedValue, keyPath)) {
                        requestedValue[keyPath] = additionalChanges[keyPath];
                      } else {
                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                      }
                    });
                  }
                }
                return ctx;
              });
              return downTable.mutate(req2).then(({ failures, results, numFailures, lastResult }) => {
                for (let i = 0; i < keys2.length; ++i) {
                  const primKey = results ? results[i] : keys2[i];
                  const ctx = contexts[i];
                  if (primKey == null) {
                    ctx.onerror && ctx.onerror(failures[i]);
                  } else {
                    ctx.onsuccess && ctx.onsuccess(
                      req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                    );
                  }
                }
                return { failures, results, numFailures, lastResult };
              }).catch((error) => {
                contexts.forEach((ctx) => ctx.onerror && ctx.onerror(error));
                return Promise.reject(error);
              });
            });
          }
          function deleteRange(req2) {
            return deleteNextChunk(req2.trans, req2.range, 1e4);
          }
          function deleteNextChunk(trans, range, limit) {
            return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(({ result }) => {
              return addPutOrDelete({ type: "delete", keys: result, trans }).then((res) => {
                if (res.numFailures > 0)
                  return Promise.reject(res.failures[0]);
                if (result.length < limit) {
                  return { failures: [], numFailures: 0, lastResult: void 0 };
                } else {
                  return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);
                }
              });
            });
          }
        }
      };
      return tableMiddleware;
    }
  })
};
function getExistingValues(table, req, effectiveKeys) {
  return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
}
function getFromTransactionCache(keys2, cache, clone2) {
  try {
    if (!cache)
      return null;
    if (cache.keys.length < keys2.length)
      return null;
    const result = [];
    for (let i = 0, j = 0; i < cache.keys.length && j < keys2.length; ++i) {
      if (cmp(cache.keys[i], keys2[j]) !== 0)
        continue;
      result.push(clone2 ? deepClone(cache.values[i]) : cache.values[i]);
      ++j;
    }
    return result.length === keys2.length ? result : null;
  } catch (_a) {
    return null;
  }
}
var cacheExistingValuesMiddleware = {
  stack: "dbcore",
  level: -1,
  create: (core) => {
    return {
      table: (tableName) => {
        const table = core.table(tableName);
        return {
          ...table,
          getMany: (req) => {
            if (!req.cache) {
              return table.getMany(req);
            }
            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
            if (cachedResult) {
              return DexiePromise.resolve(cachedResult);
            }
            return table.getMany(req).then((res) => {
              req.trans["_cache"] = {
                keys: req.keys,
                values: req.cache === "clone" ? deepClone(res) : res
              };
              return res;
            });
          },
          mutate: (req) => {
            if (req.type !== "add")
              req.trans["_cache"] = null;
            return table.mutate(req);
          }
        };
      }
    };
  }
};
function isEmptyRange(node) {
  return !("from" in node);
}
var RangeSet = function(fromOrTree, to) {
  if (this) {
    extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
  } else {
    const rv = new RangeSet();
    if (fromOrTree && "d" in fromOrTree) {
      extend(rv, fromOrTree);
    }
    return rv;
  }
};
props(RangeSet.prototype, {
  add(rangeSet) {
    mergeRanges(this, rangeSet);
    return this;
  },
  addKey(key) {
    addRange(this, key, key);
    return this;
  },
  addKeys(keys2) {
    keys2.forEach((key) => addRange(this, key, key));
    return this;
  },
  [iteratorSymbol]() {
    return getRangeSetIterator(this);
  }
});
function addRange(target, from, to) {
  const diff = cmp(from, to);
  if (isNaN(diff))
    return;
  if (diff > 0)
    throw RangeError();
  if (isEmptyRange(target))
    return extend(target, { from, to, d: 1 });
  const left = target.l;
  const right = target.r;
  if (cmp(to, target.from) < 0) {
    left ? addRange(left, from, to) : target.l = { from, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from, target.to) > 0) {
    right ? addRange(right, from, to) : target.r = { from, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from, target.from) < 0) {
    target.from = from;
    target.l = null;
    target.d = right ? right.d + 1 : 1;
  }
  if (cmp(to, target.to) > 0) {
    target.to = to;
    target.r = null;
    target.d = target.l ? target.l.d + 1 : 1;
  }
  const rightWasCutOff = !target.r;
  if (left && !target.l) {
    mergeRanges(target, left);
  }
  if (right && rightWasCutOff) {
    mergeRanges(target, right);
  }
}
function mergeRanges(target, newSet) {
  function _addRangeSet(target2, { from, to, l, r }) {
    addRange(target2, from, to);
    if (l)
      _addRangeSet(target2, l);
    if (r)
      _addRangeSet(target2, r);
  }
  if (!isEmptyRange(newSet))
    _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
  const i1 = getRangeSetIterator(rangeSet2);
  let nextResult1 = i1.next();
  if (nextResult1.done)
    return false;
  let a3 = nextResult1.value;
  const i2 = getRangeSetIterator(rangeSet1);
  let nextResult2 = i2.next(a3.from);
  let b = nextResult2.value;
  while (!nextResult1.done && !nextResult2.done) {
    if (cmp(b.from, a3.to) <= 0 && cmp(b.to, a3.from) >= 0)
      return true;
    cmp(a3.from, b.from) < 0 ? a3 = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a3.from)).value;
  }
  return false;
}
function getRangeSetIterator(node) {
  let state = isEmptyRange(node) ? null : { s: 0, n: node };
  return {
    next(key) {
      const keyProvided = arguments.length > 0;
      while (state) {
        switch (state.s) {
          case 0:
            state.s = 1;
            if (keyProvided) {
              while (state.n.l && cmp(key, state.n.from) < 0)
                state = { up: state, n: state.n.l, s: 1 };
            } else {
              while (state.n.l)
                state = { up: state, n: state.n.l, s: 1 };
            }
          case 1:
            state.s = 2;
            if (!keyProvided || cmp(key, state.n.to) <= 0)
              return { value: state.n, done: false };
          case 2:
            if (state.n.r) {
              state.s = 3;
              state = { up: state, n: state.n.r, s: 0 };
              continue;
            }
          case 3:
            state = state.up;
        }
      }
      return { done: true };
    }
  };
}
function rebalance(target) {
  var _a, _b;
  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
  const r = diff > 1 ? "r" : diff < -1 ? "l" : "";
  if (r) {
    const l = r === "r" ? "l" : "r";
    const rootClone = { ...target };
    const oldRootRight = target[r];
    target.from = oldRootRight.from;
    target.to = oldRootRight.to;
    target[r] = oldRootRight[r];
    rootClone[r] = oldRootRight[l];
    target[l] = rootClone;
    rootClone.d = computeDepth(rootClone);
  }
  target.d = computeDepth(target);
}
function computeDepth({ r, l }) {
  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
}
var observabilityMiddleware = {
  stack: "dbcore",
  level: 0,
  create: (core) => {
    const dbName = core.schema.name;
    const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
    return {
      ...core,
      table: (tableName) => {
        const table = core.table(tableName);
        const { schema } = table;
        const { primaryKey } = schema;
        const { extractKey, outbound } = primaryKey;
        const tableClone = {
          ...table,
          mutate: (req) => {
            const trans = req.trans;
            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
            const getRangeSet = (indexName) => {
              const part = `idb://${dbName}/${tableName}/${indexName}`;
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
            };
            const pkRangeSet = getRangeSet("");
            const delsRangeSet = getRangeSet(":dels");
            const { type: type2 } = req;
            let [keys2, newObjs] = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];
            const oldCache = req.trans["_cache"];
            return table.mutate(req).then((res) => {
              if (isArray(keys2)) {
                if (type2 !== "delete")
                  keys2 = res.results;
                pkRangeSet.addKeys(keys2);
                const oldObjs = getFromTransactionCache(keys2, oldCache);
                if (!oldObjs && type2 !== "add") {
                  delsRangeSet.addKeys(keys2);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys2) {
                const range = { from: keys2.lower, to: keys2.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach((idx) => getRangeSet(idx.name).add(FULL_RANGE));
              }
              return res;
            });
          }
        };
        const getRange = ({ query: { index, range } }) => {
          var _a, _b;
          return [
            index,
            new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)
          ];
        };
        const readSubscribers = {
          get: (req) => [primaryKey, new RangeSet(req.key)],
          getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],
          count: getRange,
          query: getRange,
          openCursor: getRange
        };
        keys(readSubscribers).forEach((method) => {
          tableClone[method] = function(req) {
            const { subscr } = PSD;
            if (subscr) {
              const getRangeSet = (indexName) => {
                const part = `idb://${dbName}/${tableName}/${indexName}`;
                return subscr[part] || (subscr[part] = new RangeSet());
              };
              const pkRangeSet = getRangeSet("");
              const delsRangeSet = getRangeSet(":dels");
              const [queriedIndex, queriedRanges] = readSubscribers[method](req);
              getRangeSet(queriedIndex.name || "").add(queriedRanges);
              if (!queriedIndex.isPrimaryKey) {
                if (method === "count") {
                  delsRangeSet.add(FULL_RANGE);
                } else {
                  const keysPromise = method === "query" && outbound && req.values && table.query({
                    ...req,
                    values: false
                  });
                  return table[method].apply(this, arguments).then((res) => {
                    if (method === "query") {
                      if (outbound && req.values) {
                        return keysPromise.then(({ result: resultingKeys }) => {
                          pkRangeSet.addKeys(resultingKeys);
                          return res;
                        });
                      }
                      const pKeys = req.values ? res.result.map(extractKey) : res.result;
                      if (req.values) {
                        pkRangeSet.addKeys(pKeys);
                      } else {
                        delsRangeSet.addKeys(pKeys);
                      }
                    } else if (method === "openCursor") {
                      const cursor = res;
                      const wantValues = req.values;
                      return cursor && Object.create(cursor, {
                        key: {
                          get() {
                            delsRangeSet.addKey(cursor.primaryKey);
                            return cursor.key;
                          }
                        },
                        primaryKey: {
                          get() {
                            const pkey = cursor.primaryKey;
                            delsRangeSet.addKey(pkey);
                            return pkey;
                          }
                        },
                        value: {
                          get() {
                            wantValues && pkRangeSet.addKey(cursor.primaryKey);
                            return cursor.value;
                          }
                        }
                      });
                    }
                    return res;
                  });
                }
              }
            }
            return table[method].apply(this, arguments);
          };
        });
        return tableClone;
      }
    };
  }
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
  function addAffectedIndex(ix) {
    const rangeSet = getRangeSet(ix.name || "");
    function extractKey(obj) {
      return obj != null ? ix.extractKey(obj) : null;
    }
    const addKeyOrKeys = (key) => ix.multiEntry && isArray(key) ? key.forEach((key2) => rangeSet.addKey(key2)) : rangeSet.addKey(key);
    (oldObjs || newObjs).forEach((_, i) => {
      const oldKey = oldObjs && extractKey(oldObjs[i]);
      const newKey = newObjs && extractKey(newObjs[i]);
      if (cmp(oldKey, newKey) !== 0) {
        if (oldKey != null)
          addKeyOrKeys(oldKey);
        if (newKey != null)
          addKeyOrKeys(newKey);
      }
    });
  }
  schema.indexes.forEach(addAffectedIndex);
}
var Dexie$1 = class {
  constructor(name, options) {
    this._middlewares = {};
    this.verno = 0;
    const deps = Dexie$1.dependencies;
    this._options = options = {
      addons: Dexie$1.addons,
      autoOpen: true,
      indexedDB: deps.indexedDB,
      IDBKeyRange: deps.IDBKeyRange,
      ...options
    };
    this._deps = {
      indexedDB: options.indexedDB,
      IDBKeyRange: options.IDBKeyRange
    };
    const { addons } = options;
    this._dbSchema = {};
    this._versions = [];
    this._storeNames = [];
    this._allTables = {};
    this.idbdb = null;
    this._novip = this;
    const state = {
      dbOpenError: null,
      isBeingOpened: false,
      onReadyBeingFired: null,
      openComplete: false,
      dbReadyResolve: nop,
      dbReadyPromise: null,
      cancelOpen: nop,
      openCanceller: null,
      autoSchema: true,
      PR1398_maxLoop: 3
    };
    state.dbReadyPromise = new DexiePromise((resolve) => {
      state.dbReadyResolve = resolve;
    });
    state.openCanceller = new DexiePromise((_, reject) => {
      state.cancelOpen = reject;
    });
    this._state = state;
    this.name = name;
    this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
    this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe) => {
      return (subscriber, bSticky) => {
        Dexie$1.vip(() => {
          const state2 = this._state;
          if (state2.openComplete) {
            if (!state2.dbOpenError)
              DexiePromise.resolve().then(subscriber);
            if (bSticky)
              subscribe(subscriber);
          } else if (state2.onReadyBeingFired) {
            state2.onReadyBeingFired.push(subscriber);
            if (bSticky)
              subscribe(subscriber);
          } else {
            subscribe(subscriber);
            const db = this;
            if (!bSticky)
              subscribe(function unsubscribe() {
                db.on.ready.unsubscribe(subscriber);
                db.on.ready.unsubscribe(unsubscribe);
              });
          }
        });
      };
    });
    this.Collection = createCollectionConstructor(this);
    this.Table = createTableConstructor(this);
    this.Transaction = createTransactionConstructor(this);
    this.Version = createVersionConstructor(this);
    this.WhereClause = createWhereClauseConstructor(this);
    this.on("versionchange", (ev) => {
      if (ev.newVersion > 0)
        console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
      else
        console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
      this.close();
    });
    this.on("blocked", (ev) => {
      if (!ev.newVersion || ev.newVersion < ev.oldVersion)
        console.warn(`Dexie.delete('${this.name}') was blocked`);
      else
        console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
    });
    this._maxKey = getMaxKey(options.IDBKeyRange);
    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
    this._fireOnBlocked = (ev) => {
      this.on("blocked").fire(ev);
      connections.filter((c) => c.name === this.name && c !== this && !c._state.vcFired).map((c) => c.on("versionchange").fire(ev));
    };
    this.use(virtualIndexMiddleware);
    this.use(hooksMiddleware);
    this.use(observabilityMiddleware);
    this.use(cacheExistingValuesMiddleware);
    this.vip = Object.create(this, { _vip: { value: true } });
    addons.forEach((addon) => addon(this));
  }
  version(versionNumber) {
    if (isNaN(versionNumber) || versionNumber < 0.1)
      throw new exceptions.Type(`Given version is not a positive number`);
    versionNumber = Math.round(versionNumber * 10) / 10;
    if (this.idbdb || this._state.isBeingOpened)
      throw new exceptions.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, versionNumber);
    const versions = this._versions;
    var versionInstance = versions.filter((v3) => v3._cfg.version === versionNumber)[0];
    if (versionInstance)
      return versionInstance;
    versionInstance = new this.Version(versionNumber);
    versions.push(versionInstance);
    versions.sort(lowerVersionFirst);
    versionInstance.stores({});
    this._state.autoSchema = false;
    return versionInstance;
  }
  _whenReady(fn) {
    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject) => {
      if (this._state.openComplete) {
        return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));
      }
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen) {
          reject(new exceptions.DatabaseClosed());
          return;
        }
        this.open().catch(nop);
      }
      this._state.dbReadyPromise.then(resolve, reject);
    }).then(fn);
  }
  use({ stack, create, level, name }) {
    if (name)
      this.unuse({ stack, name });
    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
    middlewares.push({ stack, create, level: level == null ? 10 : level, name });
    middlewares.sort((a3, b) => a3.level - b.level);
    return this;
  }
  unuse({ stack, name, create }) {
    if (stack && this._middlewares[stack]) {
      this._middlewares[stack] = this._middlewares[stack].filter((mw) => create ? mw.create !== create : name ? mw.name !== name : false);
    }
    return this;
  }
  open() {
    return dexieOpen(this);
  }
  _close() {
    const state = this._state;
    const idx = connections.indexOf(this);
    if (idx >= 0)
      connections.splice(idx, 1);
    if (this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e) {
      }
      this._novip.idbdb = null;
    }
    state.dbReadyPromise = new DexiePromise((resolve) => {
      state.dbReadyResolve = resolve;
    });
    state.openCanceller = new DexiePromise((_, reject) => {
      state.cancelOpen = reject;
    });
  }
  close() {
    this._close();
    const state = this._state;
    this._options.autoOpen = false;
    state.dbOpenError = new exceptions.DatabaseClosed();
    if (state.isBeingOpened)
      state.cancelOpen(state.dbOpenError);
  }
  delete() {
    const hasArguments = arguments.length > 0;
    const state = this._state;
    return new DexiePromise((resolve, reject) => {
      const doDelete = () => {
        this.close();
        var req = this._deps.indexedDB.deleteDatabase(this.name);
        req.onsuccess = wrap(() => {
          _onDatabaseDeleted(this._deps, this.name);
          resolve();
        });
        req.onerror = eventRejectHandler(reject);
        req.onblocked = this._fireOnBlocked;
      };
      if (hasArguments)
        throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
      if (state.isBeingOpened) {
        state.dbReadyPromise.then(doDelete);
      } else {
        doDelete();
      }
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const dbOpenError = this._state.dbOpenError;
    return dbOpenError && dbOpenError.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return keys(this._allTables).map((name) => this._allTables[name]);
  }
  transaction() {
    const args = extractTransactionArgs.apply(this, arguments);
    return this._transaction.apply(this, args);
  }
  _transaction(mode, tables, scopeFunc) {
    let parentTransaction = PSD.trans;
    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
      parentTransaction = null;
    const onlyIfCompatible = mode.indexOf("?") !== -1;
    mode = mode.replace("!", "").replace("?", "");
    let idbMode, storeNames;
    try {
      storeNames = tables.map((table) => {
        var storeName = table instanceof this.Table ? table.name : table;
        if (typeof storeName !== "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return storeName;
      });
      if (mode == "r" || mode === READONLY)
        idbMode = READONLY;
      else if (mode == "rw" || mode == READWRITE)
        idbMode = READWRITE;
      else
        throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
      if (parentTransaction) {
        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
          if (onlyIfCompatible) {
            parentTransaction = null;
          } else
            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
        }
        if (parentTransaction) {
          storeNames.forEach((storeName) => {
            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
              if (onlyIfCompatible) {
                parentTransaction = null;
              } else
                throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
            }
          });
        }
        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
          parentTransaction = null;
        }
      }
    } catch (e) {
      return parentTransaction ? parentTransaction._promise(null, (_, reject) => {
        reject(e);
      }) : rejection(e);
    }
    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);
  }
  table(tableName) {
    if (!hasOwn(this._allTables, tableName)) {
      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
    }
    return this._allTables[tableName];
  }
};
var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
var Observable = class {
  constructor(subscribe) {
    this._subscribe = subscribe;
  }
  subscribe(x, error, complete) {
    return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
  }
  [symbolObservable]() {
    return this;
  }
};
function extendObservabilitySet(target, newSet) {
  keys(newSet).forEach((part) => {
    const rangeSet = target[part] || (target[part] = new RangeSet());
    mergeRanges(rangeSet, newSet[part]);
  });
  return target;
}
function liveQuery(querier) {
  return new Observable((observer) => {
    const scopeFuncIsAsync = isAsyncFunction(querier);
    function execute(subscr) {
      if (scopeFuncIsAsync) {
        incrementExpectedAwaits();
      }
      const exec = () => newScope(querier, { subscr, trans: null });
      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
      if (scopeFuncIsAsync) {
        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
      }
      return rv;
    }
    let closed = false;
    let accumMuts = {};
    let currentObs = {};
    const subscription = {
      get closed() {
        return closed;
      },
      unsubscribe: () => {
        closed = true;
        globalEvents.storagemutated.unsubscribe(mutationListener);
      }
    };
    observer.start && observer.start(subscription);
    let querying = false, startedListening = false;
    function shouldNotify() {
      return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
    }
    const mutationListener = (parts) => {
      extendObservabilitySet(accumMuts, parts);
      if (shouldNotify()) {
        doQuery();
      }
    };
    const doQuery = () => {
      if (querying || closed)
        return;
      accumMuts = {};
      const subscr = {};
      const ret = execute(subscr);
      if (!startedListening) {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
        startedListening = true;
      }
      querying = true;
      Promise.resolve(ret).then((result) => {
        querying = false;
        if (closed)
          return;
        if (shouldNotify()) {
          doQuery();
        } else {
          accumMuts = {};
          currentObs = subscr;
          observer.next && observer.next(result);
        }
      }, (err) => {
        querying = false;
        observer.error && observer.error(err);
        subscription.unsubscribe();
      });
    };
    doQuery();
    return subscription;
  });
}
var domDeps;
try {
  domDeps = {
    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
  };
} catch (e) {
  domDeps = { indexedDB: null, IDBKeyRange: null };
}
var Dexie = Dexie$1;
props(Dexie, {
  ...fullNameExceptions,
  delete(databaseName) {
    const db = new Dexie(databaseName, { addons: [] });
    return db.delete();
  },
  exists(name) {
    return new Dexie(name, { addons: [] }).open().then((db) => {
      db.close();
      return true;
    }).catch("NoSuchDatabaseError", () => false);
  },
  getDatabaseNames(cb) {
    try {
      return getDatabaseNames(Dexie.dependencies).then(cb);
    } catch (_a) {
      return rejection(new exceptions.MissingAPI());
    }
  },
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return Class;
  },
  ignoreTransaction(scopeFunc) {
    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
  },
  vip,
  async: function(generatorFn) {
    return function() {
      try {
        var rv = awaitIterator(generatorFn.apply(this, arguments));
        if (!rv || typeof rv.then !== "function")
          return DexiePromise.resolve(rv);
        return rv;
      } catch (e) {
        return rejection(e);
      }
    };
  },
  spawn: function(generatorFn, args, thiz) {
    try {
      var rv = awaitIterator(generatorFn.apply(thiz, args || []));
      if (!rv || typeof rv.then !== "function")
        return DexiePromise.resolve(rv);
      return rv;
    } catch (e) {
      return rejection(e);
    }
  },
  currentTransaction: {
    get: () => PSD.trans || null
  },
  waitFor: function(promiseOrFunction, optionalTimeout) {
    const promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
  },
  Promise: DexiePromise,
  debug: {
    get: () => debug,
    set: (value) => {
      setDebug(value, value === "dexie" ? () => true : dexieStackFrameFilter);
    }
  },
  derive,
  extend,
  props,
  override,
  Events,
  on: globalEvents,
  liveQuery,
  extendObservabilitySet,
  getByKeyPath,
  setByKeyPath,
  delByKeyPath,
  shallowClone,
  deepClone,
  getObjectDiff,
  cmp,
  asap: asap$1,
  minKey,
  addons: [],
  connections,
  errnames,
  dependencies: domDeps,
  semVer: DEXIE_VERSION,
  version: DEXIE_VERSION.split(".").map((n) => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))
});
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts) => {
    if (!propagatingLocally) {
      let event;
      if (isIEOrEdge) {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
      } else {
        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
          detail: updatedParts
        });
      }
      propagatingLocally = true;
      dispatchEvent(event);
      propagatingLocally = false;
    }
  });
  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
    if (!propagatingLocally) {
      propagateLocally(detail);
    }
  });
}
function propagateLocally(updateParts) {
  let wasMe = propagatingLocally;
  try {
    propagatingLocally = true;
    globalEvents.storagemutated.fire(updateParts);
  } finally {
    propagatingLocally = wasMe;
  }
}
var propagatingLocally = false;
if (typeof BroadcastChannel !== "undefined") {
  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    if (!propagatingLocally) {
      bc.postMessage(changedParts);
    }
  });
  bc.onmessage = (ev) => {
    if (ev.data)
      propagateLocally(ev.data);
  };
} else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    try {
      if (!propagatingLocally) {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
            trig: Math.random(),
            changedParts
          }));
        }
        if (typeof self["clients"] === "object") {
          [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
            type: STORAGE_MUTATED_DOM_EVENT_NAME,
            changedParts
          }));
        }
      }
    } catch (_a) {
    }
  });
  if (typeof addEventListener !== "undefined") {
    addEventListener("storage", (ev) => {
      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
        const data = JSON.parse(ev.newValue);
        if (data)
          propagateLocally(data.changedParts);
      }
    });
  }
  const swContainer = self.document && navigator.serviceWorker;
  if (swContainer) {
    swContainer.addEventListener("message", propagateMessageLocally);
  }
}
function propagateMessageLocally({ data }) {
  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
    propagateLocally(data.changedParts);
  }
}
DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);

// inline-worker:E:\projects\web\cesium-measure\packages\workers\triangle-split.ts
var triangle_split_default = "data:application/javascript;base64,InVzZSBzdHJpY3QiOwooKCkgPT4gewogIHZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7CiAgdmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsKICB2YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CiAgdmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7CiAgdmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsKICB2YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsKICB2YXIgX19yZXF1aXJlID0gLyogQF9fUFVSRV9fICovICgoeCkgPT4gdHlwZW9mIHJlcXVpcmUgIT09ICJ1bmRlZmluZWQiID8gcmVxdWlyZSA6IHR5cGVvZiBQcm94eSAhPT0gInVuZGVmaW5lZCIgPyBuZXcgUHJveHkoeCwgewogICAgZ2V0OiAoYTMsIGIpID0+ICh0eXBlb2YgcmVxdWlyZSAhPT0gInVuZGVmaW5lZCIgPyByZXF1aXJlIDogYTMpW2JdCiAgfSkgOiB4KShmdW5jdGlvbih4KSB7CiAgICBpZiAodHlwZW9mIHJlcXVpcmUgIT09ICJ1bmRlZmluZWQiKQogICAgICByZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgdGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmUgb2YgIicgKyB4ICsgJyIgaXMgbm90IHN1cHBvcnRlZCcpOwogIH0pOwogIHZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZTIoKSB7CiAgICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0czsKICB9OwogIHZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7CiAgICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGZyb20gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKQogICAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpCiAgICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7CiAgICB9CiAgICByZXR1cm4gdG87CiAgfTsKICB2YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKAogICAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsICJkZWZhdWx0IiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LAogICAgbW9kCiAgKSk7CiAgdmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7CiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHsKICAgICAgICB0cnkgewogICAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7CiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTsKICAgIH0pOwogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK21lcnNlbm5lLXR3aXN0ZXJAMS4xLjAvbm9kZV9tb2R1bGVzL21lcnNlbm5lLXR3aXN0ZXIvc3JjL21lcnNlbm5lLXR3aXN0ZXIuanMKICB2YXIgcmVxdWlyZV9tZXJzZW5uZV90d2lzdGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rbWVyc2VubmUtdHdpc3RlckAxLjEuMC9ub2RlX21vZHVsZXMvbWVyc2VubmUtdHdpc3Rlci9zcmMvbWVyc2VubmUtdHdpc3Rlci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIHZhciBNZXJzZW5uZVR3aXN0ZXIyID0gZnVuY3Rpb24oc2VlZCkgewogICAgICAgIGlmIChzZWVkID09IHZvaWQgMCkgewogICAgICAgICAgc2VlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOwogICAgICAgIH0KICAgICAgICB0aGlzLk4gPSA2MjQ7CiAgICAgICAgdGhpcy5NID0gMzk3OwogICAgICAgIHRoaXMuTUFUUklYX0EgPSAyNTY3NDgzNjE1OwogICAgICAgIHRoaXMuVVBQRVJfTUFTSyA9IDIxNDc0ODM2NDg7CiAgICAgICAgdGhpcy5MT1dFUl9NQVNLID0gMjE0NzQ4MzY0NzsKICAgICAgICB0aGlzLm10ID0gbmV3IEFycmF5KHRoaXMuTik7CiAgICAgICAgdGhpcy5tdGkgPSB0aGlzLk4gKyAxOwogICAgICAgIGlmIChzZWVkLmNvbnN0cnVjdG9yID09IEFycmF5KSB7CiAgICAgICAgICB0aGlzLmluaXRfYnlfYXJyYXkoc2VlZCwgc2VlZC5sZW5ndGgpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLmluaXRfc2VlZChzZWVkKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIE1lcnNlbm5lVHdpc3RlcjIucHJvdG90eXBlLmluaXRfc2VlZCA9IGZ1bmN0aW9uKHMpIHsKICAgICAgICB0aGlzLm10WzBdID0gcyA+Pj4gMDsKICAgICAgICBmb3IgKHRoaXMubXRpID0gMTsgdGhpcy5tdGkgPCB0aGlzLk47IHRoaXMubXRpKyspIHsKICAgICAgICAgIHZhciBzID0gdGhpcy5tdFt0aGlzLm10aSAtIDFdIF4gdGhpcy5tdFt0aGlzLm10aSAtIDFdID4+PiAzMDsKICAgICAgICAgIHRoaXMubXRbdGhpcy5tdGldID0gKCgocyAmIDQyOTQ5MDE3NjApID4+PiAxNikgKiAxODEyNDMzMjUzIDw8IDE2KSArIChzICYgNjU1MzUpICogMTgxMjQzMzI1MyArIHRoaXMubXRpOwogICAgICAgICAgdGhpcy5tdFt0aGlzLm10aV0gPj4+PSAwOwogICAgICAgIH0KICAgICAgfTsKICAgICAgTWVyc2VubmVUd2lzdGVyMi5wcm90b3R5cGUuaW5pdF9ieV9hcnJheSA9IGZ1bmN0aW9uKGluaXRfa2V5LCBrZXlfbGVuZ3RoKSB7CiAgICAgICAgdmFyIGksIGosIGs7CiAgICAgICAgdGhpcy5pbml0X3NlZWQoMTk2NTAyMTgpOwogICAgICAgIGkgPSAxOwogICAgICAgIGogPSAwOwogICAgICAgIGsgPSB0aGlzLk4gPiBrZXlfbGVuZ3RoID8gdGhpcy5OIDoga2V5X2xlbmd0aDsKICAgICAgICBmb3IgKDsgazsgay0tKSB7CiAgICAgICAgICB2YXIgcyA9IHRoaXMubXRbaSAtIDFdIF4gdGhpcy5tdFtpIC0gMV0gPj4+IDMwOwogICAgICAgICAgdGhpcy5tdFtpXSA9ICh0aGlzLm10W2ldIF4gKCgocyAmIDQyOTQ5MDE3NjApID4+PiAxNikgKiAxNjY0NTI1IDw8IDE2KSArIChzICYgNjU1MzUpICogMTY2NDUyNSkgKyBpbml0X2tleVtqXSArIGo7CiAgICAgICAgICB0aGlzLm10W2ldID4+Pj0gMDsKICAgICAgICAgIGkrKzsKICAgICAgICAgIGorKzsKICAgICAgICAgIGlmIChpID49IHRoaXMuTikgewogICAgICAgICAgICB0aGlzLm10WzBdID0gdGhpcy5tdFt0aGlzLk4gLSAxXTsKICAgICAgICAgICAgaSA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaiA+PSBrZXlfbGVuZ3RoKQogICAgICAgICAgICBqID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChrID0gdGhpcy5OIC0gMTsgazsgay0tKSB7CiAgICAgICAgICB2YXIgcyA9IHRoaXMubXRbaSAtIDFdIF4gdGhpcy5tdFtpIC0gMV0gPj4+IDMwOwogICAgICAgICAgdGhpcy5tdFtpXSA9ICh0aGlzLm10W2ldIF4gKCgocyAmIDQyOTQ5MDE3NjApID4+PiAxNikgKiAxNTY2MDgzOTQxIDw8IDE2KSArIChzICYgNjU1MzUpICogMTU2NjA4Mzk0MSkgLSBpOwogICAgICAgICAgdGhpcy5tdFtpXSA+Pj49IDA7CiAgICAgICAgICBpKys7CiAgICAgICAgICBpZiAoaSA+PSB0aGlzLk4pIHsKICAgICAgICAgICAgdGhpcy5tdFswXSA9IHRoaXMubXRbdGhpcy5OIC0gMV07CiAgICAgICAgICAgIGkgPSAxOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLm10WzBdID0gMjE0NzQ4MzY0ODsKICAgICAgfTsKICAgICAgTWVyc2VubmVUd2lzdGVyMi5wcm90b3R5cGUucmFuZG9tX2ludCA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciB5OwogICAgICAgIHZhciBtYWcwMSA9IG5ldyBBcnJheSgwLCB0aGlzLk1BVFJJWF9BKTsKICAgICAgICBpZiAodGhpcy5tdGkgPj0gdGhpcy5OKSB7CiAgICAgICAgICB2YXIga2s7CiAgICAgICAgICBpZiAodGhpcy5tdGkgPT0gdGhpcy5OICsgMSkKICAgICAgICAgICAgdGhpcy5pbml0X3NlZWQoNTQ4OSk7CiAgICAgICAgICBmb3IgKGtrID0gMDsga2sgPCB0aGlzLk4gLSB0aGlzLk07IGtrKyspIHsKICAgICAgICAgICAgeSA9IHRoaXMubXRba2tdICYgdGhpcy5VUFBFUl9NQVNLIHwgdGhpcy5tdFtrayArIDFdICYgdGhpcy5MT1dFUl9NQVNLOwogICAgICAgICAgICB0aGlzLm10W2trXSA9IHRoaXMubXRba2sgKyB0aGlzLk1dIF4geSA+Pj4gMSBeIG1hZzAxW3kgJiAxXTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoOyBrayA8IHRoaXMuTiAtIDE7IGtrKyspIHsKICAgICAgICAgICAgeSA9IHRoaXMubXRba2tdICYgdGhpcy5VUFBFUl9NQVNLIHwgdGhpcy5tdFtrayArIDFdICYgdGhpcy5MT1dFUl9NQVNLOwogICAgICAgICAgICB0aGlzLm10W2trXSA9IHRoaXMubXRba2sgKyAodGhpcy5NIC0gdGhpcy5OKV0gXiB5ID4+PiAxIF4gbWFnMDFbeSAmIDFdOwogICAgICAgICAgfQogICAgICAgICAgeSA9IHRoaXMubXRbdGhpcy5OIC0gMV0gJiB0aGlzLlVQUEVSX01BU0sgfCB0aGlzLm10WzBdICYgdGhpcy5MT1dFUl9NQVNLOwogICAgICAgICAgdGhpcy5tdFt0aGlzLk4gLSAxXSA9IHRoaXMubXRbdGhpcy5NIC0gMV0gXiB5ID4+PiAxIF4gbWFnMDFbeSAmIDFdOwogICAgICAgICAgdGhpcy5tdGkgPSAwOwogICAgICAgIH0KICAgICAgICB5ID0gdGhpcy5tdFt0aGlzLm10aSsrXTsKICAgICAgICB5IF49IHkgPj4+IDExOwogICAgICAgIHkgXj0geSA8PCA3ICYgMjYzNjkyODY0MDsKICAgICAgICB5IF49IHkgPDwgMTUgJiA0MDIyNzMwNzUyOwogICAgICAgIHkgXj0geSA+Pj4gMTg7CiAgICAgICAgcmV0dXJuIHkgPj4+IDA7CiAgICAgIH07CiAgICAgIE1lcnNlbm5lVHdpc3RlcjIucHJvdG90eXBlLnJhbmRvbV9pbnQzMSA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLnJhbmRvbV9pbnQoKSA+Pj4gMTsKICAgICAgfTsKICAgICAgTWVyc2VubmVUd2lzdGVyMi5wcm90b3R5cGUucmFuZG9tX2luY2wgPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21faW50KCkgKiAoMSAvIDQyOTQ5NjcyOTUpOwogICAgICB9OwogICAgICBNZXJzZW5uZVR3aXN0ZXIyLnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21faW50KCkgKiAoMSAvIDQyOTQ5NjcyOTYpOwogICAgICB9OwogICAgICBNZXJzZW5uZVR3aXN0ZXIyLnByb3RvdHlwZS5yYW5kb21fZXhjbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAodGhpcy5yYW5kb21faW50KCkgKyAwLjUpICogKDEgLyA0Mjk0OTY3Mjk2KTsKICAgICAgfTsKICAgICAgTWVyc2VubmVUd2lzdGVyMi5wcm90b3R5cGUucmFuZG9tX2xvbmcgPSBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgYTMgPSB0aGlzLnJhbmRvbV9pbnQoKSA+Pj4gNSwgYiA9IHRoaXMucmFuZG9tX2ludCgpID4+PiA2OwogICAgICAgIHJldHVybiAoYTMgKiA2NzEwODg2NCArIGIpICogKDEgLyA5MDA3MTk5MjU0NzQwOTkyKTsKICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBNZXJzZW5uZVR3aXN0ZXIyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbSt1cmlqc0AxLjE5LjExL25vZGVfbW9kdWxlcy91cmlqcy9zcmMvcHVueWNvZGUuanMKICB2YXIgcmVxdWlyZV9wdW55Y29kZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3VyaWpzQDEuMTkuMTEvbm9kZV9tb2R1bGVzL3VyaWpzL3NyYy9wdW55Y29kZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIChmdW5jdGlvbihyb290KSB7CiAgICAgICAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gIm9iamVjdCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwogICAgICAgIHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgICAgICAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICJvYmplY3QiICYmIGdsb2JhbDsKICAgICAgICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSB7CiAgICAgICAgICByb290ID0gZnJlZUdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdmFyIHB1bnljb2RlLCBtYXhJbnQgPSAyMTQ3NDgzNjQ3LCBiYXNlID0gMzYsIHRNaW4gPSAxLCB0TWF4ID0gMjYsIHNrZXcgPSAzOCwgZGFtcCA9IDcwMCwgaW5pdGlhbEJpYXMgPSA3MiwgaW5pdGlhbE4gPSAxMjgsIGRlbGltaXRlciA9ICItIiwgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sIHJlZ2V4Tm9uQVNDSUkgPSAvW15ceDIwLVx4N0VdLywgcmVnZXhTZXBhcmF0b3JzID0gL1tceDJFXHUzMDAyXHVGRjBFXHVGRjYxXS9nLCBlcnJvcnMgPSB7CiAgICAgICAgICAib3ZlcmZsb3ciOiAiT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MiLAogICAgICAgICAgIm5vdC1iYXNpYyI6ICJJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpIiwKICAgICAgICAgICJpbnZhbGlkLWlucHV0IjogIkludmFsaWQgaW5wdXQiCiAgICAgICAgfSwgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLCBmbG9vciA9IE1hdGguZmxvb3IsIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsIGtleTsKICAgICAgICBmdW5jdGlvbiBlcnJvcih0eXBlKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7CiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogICAgICAgICAgdmFyIHJlc3VsdCA9IFtdOwogICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7CiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikgewogICAgICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCJAIik7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkgewogICAgICAgICAgICByZXN1bHQgPSBwYXJ0c1swXSArICJAIjsKICAgICAgICAgICAgc3RyaW5nID0gcGFydHNbMV07CiAgICAgICAgICB9CiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICIuIik7CiAgICAgICAgICB2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCIuIik7CiAgICAgICAgICB2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCIuIik7CiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHsKICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSwgY291bnRlciA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsIHZhbHVlLCBleHRyYTsKICAgICAgICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7CiAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTsKICAgICAgICAgICAgaWYgKHZhbHVlID49IDU1Mjk2ICYmIHZhbHVlIDw9IDU2MzE5ICYmIGNvdW50ZXIgPCBsZW5ndGgpIHsKICAgICAgICAgICAgICBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7CiAgICAgICAgICAgICAgaWYgKChleHRyYSAmIDY0NTEyKSA9PSA1NjMyMCkgewogICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDEwMjMpIDw8IDEwKSArIChleHRyYSAmIDEwMjMpICsgNjU1MzYpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7CiAgICAgICAgICAgICAgICBjb3VudGVyLS07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG91dHB1dDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkgewogICAgICAgICAgcmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgdmFyIG91dHB1dCA9ICIiOwogICAgICAgICAgICBpZiAodmFsdWUgPiA2NTUzNSkgewogICAgICAgICAgICAgIHZhbHVlIC09IDY1NTM2OwogICAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMTAyMyB8IDU1Mjk2KTsKICAgICAgICAgICAgICB2YWx1ZSA9IDU2MzIwIHwgdmFsdWUgJiAxMDIzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpOwogICAgICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgICAgICAgfSkuam9pbigiIik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7CiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSAyMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7CiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA2NTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7CiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA5NzsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBiYXNlOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHsKICAgICAgICAgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkgewogICAgICAgICAgdmFyIGsgPSAwOwogICAgICAgICAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTsKICAgICAgICAgIGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTsKICAgICAgICAgIGZvciAoOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkgewogICAgICAgICAgICBkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7CiAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLCBvdXQsIGkgPSAwLCBuID0gaW5pdGlhbE4sIGJpYXMgPSBpbml0aWFsQmlhcywgYmFzaWMsIGosIGluZGV4LCBvbGRpLCB3LCBrLCBkaWdpdCwgdCwgYmFzZU1pbnVzVDsKICAgICAgICAgIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTsKICAgICAgICAgIGlmIChiYXNpYyA8IDApIHsKICAgICAgICAgICAgYmFzaWMgPSAwOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHsKICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMTI4KSB7CiAgICAgICAgICAgICAgZXJyb3IoIm5vdC1iYXNpYyIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7ICkgewogICAgICAgICAgICBmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IDsgayArPSBiYXNlKSB7CiAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBlcnJvcigiaW52YWxpZC1pbnB1dCIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTsKICAgICAgICAgICAgICBpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7CiAgICAgICAgICAgICAgICBlcnJvcigib3ZlcmZsb3ciKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaSArPSBkaWdpdCAqIHc7CiAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzOwogICAgICAgICAgICAgIGlmIChkaWdpdCA8IHQpIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBiYXNlTWludXNUID0gYmFzZSAtIHQ7CiAgICAgICAgICAgICAgaWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkgewogICAgICAgICAgICAgICAgZXJyb3IoIm92ZXJmbG93Iik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHcgKj0gYmFzZU1pbnVzVDsKICAgICAgICAgICAgfQogICAgICAgICAgICBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTsKICAgICAgICAgICAgYmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7CiAgICAgICAgICAgIGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHsKICAgICAgICAgICAgICBlcnJvcigib3ZlcmZsb3ciKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBuICs9IGZsb29yKGkgLyBvdXQpOwogICAgICAgICAgICBpICU9IG91dDsKICAgICAgICAgICAgb3V0cHV0LnNwbGljZShpKyssIDAsIG4pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7CiAgICAgICAgICB2YXIgbiwgZGVsdGEsIGhhbmRsZWRDUENvdW50LCBiYXNpY0xlbmd0aCwgYmlhcywgaiwgbSwgcSwgaywgdCwgY3VycmVudFZhbHVlLCBvdXRwdXQgPSBbXSwgaW5wdXRMZW5ndGgsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgYmFzZU1pbnVzVCwgcU1pbnVzVDsKICAgICAgICAgIGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7CiAgICAgICAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDsKICAgICAgICAgIG4gPSBpbml0aWFsTjsKICAgICAgICAgIGRlbHRhID0gMDsKICAgICAgICAgIGJpYXMgPSBpbml0aWFsQmlhczsKICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdOwogICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgMTI4KSB7CiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDsKICAgICAgICAgIGlmIChiYXNpY0xlbmd0aCkgewogICAgICAgICAgICBvdXRwdXQucHVzaChkZWxpbWl0ZXIpOwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHsKICAgICAgICAgICAgZm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHsKICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTsKICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkgewogICAgICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxOwogICAgICAgICAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkgewogICAgICAgICAgICAgIGVycm9yKCJvdmVyZmxvdyIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7CiAgICAgICAgICAgIG4gPSBtOwogICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikgewogICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdOwogICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHsKICAgICAgICAgICAgICAgIGVycm9yKCJvdmVyZmxvdyIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHsKICAgICAgICAgICAgICAgIGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgOyBrICs9IGJhc2UpIHsKICAgICAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzOwogICAgICAgICAgICAgICAgICBpZiAocSA8IHQpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBxTWludXNUID0gcSAtIHQ7CiAgICAgICAgICAgICAgICAgIGJhc2VNaW51c1QgPSBiYXNlIC0gdDsKICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goCiAgICAgICAgICAgICAgICAgICAgc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKQogICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICBxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpOwogICAgICAgICAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTsKICAgICAgICAgICAgICAgIGRlbHRhID0gMDsKICAgICAgICAgICAgICAgICsraGFuZGxlZENQQ291bnQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgICsrZGVsdGE7CiAgICAgICAgICAgICsrbjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBvdXRwdXQuam9pbigiIik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkgewogICAgICAgICAgcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7CiAgICAgICAgICAgIHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkgewogICAgICAgICAgcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7CiAgICAgICAgICAgIHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICJ4bi0tIiArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIHB1bnljb2RlID0gewogICAgICAgICAgInZlcnNpb24iOiAiMS4zLjIiLAogICAgICAgICAgInVjczIiOiB7CiAgICAgICAgICAgICJkZWNvZGUiOiB1Y3MyZGVjb2RlLAogICAgICAgICAgICAiZW5jb2RlIjogdWNzMmVuY29kZQogICAgICAgICAgfSwKICAgICAgICAgICJkZWNvZGUiOiBkZWNvZGUsCiAgICAgICAgICAiZW5jb2RlIjogZW5jb2RlLAogICAgICAgICAgInRvQVNDSUkiOiB0b0FTQ0lJLAogICAgICAgICAgInRvVW5pY29kZSI6IHRvVW5pY29kZQogICAgICAgIH07CiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gImZ1bmN0aW9uIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAib2JqZWN0IiAmJiBkZWZpbmUuYW1kKSB7CiAgICAgICAgICBkZWZpbmUoInB1bnljb2RlIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiBwdW55Y29kZTsKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkgewogICAgICAgICAgaWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7CiAgICAgICAgICAgIGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZm9yIChrZXkgaW4gcHVueWNvZGUpIHsKICAgICAgICAgICAgICBwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgcm9vdC5wdW55Y29kZSA9IHB1bnljb2RlOwogICAgICAgIH0KICAgICAgfSkoZXhwb3J0cyk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3VyaWpzQDEuMTkuMTEvbm9kZV9tb2R1bGVzL3VyaWpzL3NyYy9JUHY2LmpzCiAgdmFyIHJlcXVpcmVfSVB2NiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3VyaWpzQDEuMTkuMTEvbm9kZV9tb2R1bGVzL3VyaWpzL3NyYy9JUHY2LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHsKICAgICAgICAidXNlIHN0cmljdCI7CiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICJvYmplY3QiICYmIG1vZHVsZS5leHBvcnRzKSB7CiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICJmdW5jdGlvbiIgJiYgZGVmaW5lLmFtZCkgewogICAgICAgICAgZGVmaW5lKGZhY3RvcnkpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByb290LklQdjYgPSBmYWN0b3J5KHJvb3QpOwogICAgICAgIH0KICAgICAgfSkoZXhwb3J0cywgZnVuY3Rpb24ocm9vdCkgewogICAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgICB2YXIgX0lQdjYgPSByb290ICYmIHJvb3QuSVB2NjsKICAgICAgICBmdW5jdGlvbiBiZXN0UHJlc2VudGF0aW9uKGFkZHJlc3MpIHsKICAgICAgICAgIHZhciBfYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIHZhciBzZWdtZW50cyA9IF9hZGRyZXNzLnNwbGl0KCI6Iik7CiAgICAgICAgICB2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoOwogICAgICAgICAgdmFyIHRvdGFsID0gODsKICAgICAgICAgIGlmIChzZWdtZW50c1swXSA9PT0gIiIgJiYgc2VnbWVudHNbMV0gPT09ICIiICYmIHNlZ21lbnRzWzJdID09PSAiIikgewogICAgICAgICAgICBzZWdtZW50cy5zaGlmdCgpOwogICAgICAgICAgICBzZWdtZW50cy5zaGlmdCgpOwogICAgICAgICAgfSBlbHNlIGlmIChzZWdtZW50c1swXSA9PT0gIiIgJiYgc2VnbWVudHNbMV0gPT09ICIiKSB7CiAgICAgICAgICAgIHNlZ21lbnRzLnNoaWZ0KCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHNlZ21lbnRzW2xlbmd0aCAtIDFdID09PSAiIiAmJiBzZWdtZW50c1tsZW5ndGggLSAyXSA9PT0gIiIpIHsKICAgICAgICAgICAgc2VnbWVudHMucG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7CiAgICAgICAgICBpZiAoc2VnbWVudHNbbGVuZ3RoIC0gMV0uaW5kZXhPZigiLiIpICE9PSAtMSkgewogICAgICAgICAgICB0b3RhbCA9IDc7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcG9zOwogICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCBsZW5ndGg7IHBvcysrKSB7CiAgICAgICAgICAgIGlmIChzZWdtZW50c1twb3NdID09PSAiIikgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocG9zIDwgdG90YWwpIHsKICAgICAgICAgICAgc2VnbWVudHMuc3BsaWNlKHBvcywgMSwgIjAwMDAiKTsKICAgICAgICAgICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCA8IHRvdGFsKSB7CiAgICAgICAgICAgICAgc2VnbWVudHMuc3BsaWNlKHBvcywgMCwgIjAwMDAiKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgdmFyIF9zZWdtZW50czsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKykgewogICAgICAgICAgICBfc2VnbWVudHMgPSBzZWdtZW50c1tpXS5zcGxpdCgiIik7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7CiAgICAgICAgICAgICAgaWYgKF9zZWdtZW50c1swXSA9PT0gIjAiICYmIF9zZWdtZW50cy5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgICAgICBfc2VnbWVudHMuc3BsaWNlKDAsIDEpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2VnbWVudHNbaV0gPSBfc2VnbWVudHMuam9pbigiIik7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgYmVzdCA9IC0xOwogICAgICAgICAgdmFyIF9iZXN0ID0gMDsKICAgICAgICAgIHZhciBfY3VycmVudCA9IDA7CiAgICAgICAgICB2YXIgY3VycmVudCA9IC0xOwogICAgICAgICAgdmFyIGluemVyb2VzID0gZmFsc2U7CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWw7IGkrKykgewogICAgICAgICAgICBpZiAoaW56ZXJvZXMpIHsKICAgICAgICAgICAgICBpZiAoc2VnbWVudHNbaV0gPT09ICIwIikgewogICAgICAgICAgICAgICAgX2N1cnJlbnQgKz0gMTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgaW56ZXJvZXMgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGlmIChfY3VycmVudCA+IF9iZXN0KSB7CiAgICAgICAgICAgICAgICAgIGJlc3QgPSBjdXJyZW50OwogICAgICAgICAgICAgICAgICBfYmVzdCA9IF9jdXJyZW50OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoc2VnbWVudHNbaV0gPT09ICIwIikgewogICAgICAgICAgICAgICAgaW56ZXJvZXMgPSB0cnVlOwogICAgICAgICAgICAgICAgY3VycmVudCA9IGk7CiAgICAgICAgICAgICAgICBfY3VycmVudCA9IDE7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoX2N1cnJlbnQgPiBfYmVzdCkgewogICAgICAgICAgICBiZXN0ID0gY3VycmVudDsKICAgICAgICAgICAgX2Jlc3QgPSBfY3VycmVudDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChfYmVzdCA+IDEpIHsKICAgICAgICAgICAgc2VnbWVudHMuc3BsaWNlKGJlc3QsIF9iZXN0LCAiIik7CiAgICAgICAgICB9CiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgICBpZiAoc2VnbWVudHNbMF0gPT09ICIiKSB7CiAgICAgICAgICAgIHJlc3VsdCA9ICI6IjsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICByZXN1bHQgKz0gc2VnbWVudHNbaV07CiAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGggLSAxKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0ICs9ICI6IjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzZWdtZW50c1tsZW5ndGggLSAxXSA9PT0gIiIpIHsKICAgICAgICAgICAgcmVzdWx0ICs9ICI6IjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7CiAgICAgICAgICBpZiAocm9vdC5JUHY2ID09PSB0aGlzKSB7CiAgICAgICAgICAgIHJvb3QuSVB2NiA9IF9JUHY2OwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIHJldHVybiB7CiAgICAgICAgICBiZXN0OiBiZXN0UHJlc2VudGF0aW9uLAogICAgICAgICAgbm9Db25mbGljdAogICAgICAgIH07CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbSt1cmlqc0AxLjE5LjExL25vZGVfbW9kdWxlcy91cmlqcy9zcmMvU2Vjb25kTGV2ZWxEb21haW5zLmpzCiAgdmFyIHJlcXVpcmVfU2Vjb25kTGV2ZWxEb21haW5zID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rdXJpanNAMS4xOS4xMS9ub2RlX21vZHVsZXMvdXJpanMvc3JjL1NlY29uZExldmVsRG9tYWlucy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7CiAgICAgICAgInVzZSBzdHJpY3QiOwogICAgICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAib2JqZWN0IiAmJiBtb2R1bGUuZXhwb3J0cykgewogICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAiZnVuY3Rpb24iICYmIGRlZmluZS5hbWQpIHsKICAgICAgICAgIGRlZmluZShmYWN0b3J5KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcm9vdC5TZWNvbmRMZXZlbERvbWFpbnMgPSBmYWN0b3J5KHJvb3QpOwogICAgICAgIH0KICAgICAgfSkoZXhwb3J0cywgZnVuY3Rpb24ocm9vdCkgewogICAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgICB2YXIgX1NlY29uZExldmVsRG9tYWlucyA9IHJvb3QgJiYgcm9vdC5TZWNvbmRMZXZlbERvbWFpbnM7CiAgICAgICAgdmFyIFNMRCA9IHsKICAgICAgICAgIGxpc3Q6IHsKICAgICAgICAgICAgImFjIjogIiBjb20gZ292IG1pbCBuZXQgb3JnICIsCiAgICAgICAgICAgICJhZSI6ICIgYWMgY28gZ292IG1pbCBuYW1lIG5ldCBvcmcgcHJvIHNjaCAiLAogICAgICAgICAgICAiYWYiOiAiIGNvbSBlZHUgZ292IG5ldCBvcmcgIiwKICAgICAgICAgICAgImFsIjogIiBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAiLAogICAgICAgICAgICAiYW8iOiAiIGNvIGVkIGd2IGl0IG9nIHBiICIsCiAgICAgICAgICAgICJhciI6ICIgY29tIGVkdSBnb2IgZ292IGludCBtaWwgbmV0IG9yZyB0dXIgIiwKICAgICAgICAgICAgImF0IjogIiBhYyBjbyBndiBvciAiLAogICAgICAgICAgICAiYXUiOiAiIGFzbiBjb20gY3Npcm8gZWR1IGdvdiBpZCBuZXQgb3JnICIsCiAgICAgICAgICAgICJiYSI6ICIgY28gY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgcnMgdW5iaSB1bm1vIHVuc2EgdW50eiB1bnplICIsCiAgICAgICAgICAgICJiYiI6ICIgYml6IGNvIGNvbSBlZHUgZ292IGluZm8gbmV0IG9yZyBzdG9yZSB0diAiLAogICAgICAgICAgICAiYmgiOiAiIGJpeiBjYyBjb20gZWR1IGdvdiBpbmZvIG5ldCBvcmcgIiwKICAgICAgICAgICAgImJuIjogIiBjb20gZWR1IGdvdiBuZXQgb3JnICIsCiAgICAgICAgICAgICJibyI6ICIgY29tIGVkdSBnb2IgZ292IGludCBtaWwgbmV0IG9yZyB0diAiLAogICAgICAgICAgICAiYnIiOiAiIGFkbSBhZHYgYWdyIGFtIGFycSBhcnQgYXRvIGIgYmlvIGJsb2cgYm1kIGNpbSBjbmcgY250IGNvbSBjb29wIGVjbiBlZHUgZW5nIGVzcCBldGMgZXRpIGZhciBmbG9nIGZtIGZuZCBmb3QgZnN0IGcxMiBnZ2YgZ292IGltYiBpbmQgaW5mIGpvciBqdXMgbGVsIG1hdCBtZWQgbWlsIG11cyBuZXQgbm9tIG5vdCBudHIgb2RvIG9yZyBwcGcgcHJvIHBzYyBwc2kgcXNsIHJlYyBzbGcgc3J2IHRtcCB0cmQgdHVyIHR2IHZldCB2bG9nIHdpa2kgemxnICIsCiAgICAgICAgICAgICJicyI6ICIgY29tIGVkdSBnb3YgbmV0IG9yZyAiLAogICAgICAgICAgICAiYnoiOiAiIGR1IGV0IG9tIG92IHJnICIsCiAgICAgICAgICAgICJjYSI6ICIgYWIgYmMgbWIgbmIgbmYgbmwgbnMgbnQgbnUgb24gcGUgcWMgc2sgeWsgIiwKICAgICAgICAgICAgImNrIjogIiBiaXogY28gZWR1IGdlbiBnb3YgaW5mbyBuZXQgb3JnICIsCiAgICAgICAgICAgICJjbiI6ICIgYWMgYWggYmogY29tIGNxIGVkdSBmaiBnZCBnb3YgZ3MgZ3ggZ3ogaGEgaGIgaGUgaGkgaGwgaG4gamwganMganggbG4gbWlsIG5ldCBubSBueCBvcmcgcWggc2Mgc2Qgc2ggc24gc3ggdGogdHcgeGogeHogeW4gemogIiwKICAgICAgICAgICAgImNvIjogIiBjb20gZWR1IGdvdiBtaWwgbmV0IG5vbSBvcmcgIiwKICAgICAgICAgICAgImNyIjogIiBhYyBjIGNvIGVkIGZpIGdvIG9yIHNhICIsCiAgICAgICAgICAgICJjeSI6ICIgYWMgYml6IGNvbSBla2xvZ2VzIGdvdiBsdGQgbmFtZSBuZXQgb3JnIHBhcmxpYW1lbnQgcHJlc3MgcHJvIHRtICIsCiAgICAgICAgICAgICJkbyI6ICIgYXJ0IGNvbSBlZHUgZ29iIGdvdiBtaWwgbmV0IG9yZyBzbGQgd2ViICIsCiAgICAgICAgICAgICJkeiI6ICIgYXJ0IGFzc28gY29tIGVkdSBnb3YgbmV0IG9yZyBwb2wgIiwKICAgICAgICAgICAgImVjIjogIiBjb20gZWR1IGZpbiBnb3YgaW5mbyBtZWQgbWlsIG5ldCBvcmcgcHJvICIsCiAgICAgICAgICAgICJlZyI6ICIgY29tIGVkdSBldW4gZ292IG1pbCBuYW1lIG5ldCBvcmcgc2NpICIsCiAgICAgICAgICAgICJlciI6ICIgY29tIGVkdSBnb3YgaW5kIG1pbCBuZXQgb3JnIHJvY2hlc3QgdyAiLAogICAgICAgICAgICAiZXMiOiAiIGNvbSBlZHUgZ29iIG5vbSBvcmcgIiwKICAgICAgICAgICAgImV0IjogIiBiaXogY29tIGVkdSBnb3YgaW5mbyBuYW1lIG5ldCBvcmcgIiwKICAgICAgICAgICAgImZqIjogIiBhYyBiaXogY29tIGluZm8gbWlsIG5hbWUgbmV0IG9yZyBwcm8gIiwKICAgICAgICAgICAgImZrIjogIiBhYyBjbyBnb3YgbmV0IG5vbSBvcmcgIiwKICAgICAgICAgICAgImZyIjogIiBhc3NvIGNvbSBmIGdvdXYgbm9tIHByZCBwcmVzc2UgdG0gIiwKICAgICAgICAgICAgImdnIjogIiBjbyBuZXQgb3JnICIsCiAgICAgICAgICAgICJnaCI6ICIgY29tIGVkdSBnb3YgbWlsIG9yZyAiLAogICAgICAgICAgICAiZ24iOiAiIGFjIGNvbSBnb3YgbmV0IG9yZyAiLAogICAgICAgICAgICAiZ3IiOiAiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICIsCiAgICAgICAgICAgICJndCI6ICIgY29tIGVkdSBnb2IgaW5kIG1pbCBuZXQgb3JnICIsCiAgICAgICAgICAgICJndSI6ICIgY29tIGVkdSBnb3YgbmV0IG9yZyAiLAogICAgICAgICAgICAiaGsiOiAiIGNvbSBlZHUgZ292IGlkdiBuZXQgb3JnICIsCiAgICAgICAgICAgICJodSI6ICIgMjAwMCBhZ3JhciBib2x0IGNhc2lubyBjaXR5IGNvIGVyb3RpY2EgZXJvdGlrYSBmaWxtIGZvcnVtIGdhbWVzIGhvdGVsIGluZm8gaW5nYXRsYW4gam9nYXN6IGtvbnl2ZWxvIGxha2FzIG1lZGlhIG5ld3Mgb3JnIHByaXYgcmVrbGFtIHNleCBzaG9wIHNwb3J0IHN1bGkgc3pleCB0bSB0b3pzZGUgdXRhemFzIHZpZGVvICIsCiAgICAgICAgICAgICJpZCI6ICIgYWMgY28gZ28gbWlsIG5ldCBvciBzY2ggd2ViICIsCiAgICAgICAgICAgICJpbCI6ICIgYWMgY28gZ292IGlkZiBrMTIgbXVuaSBuZXQgb3JnICIsCiAgICAgICAgICAgICJpbiI6ICIgYWMgY28gZWR1IGVybmV0IGZpcm0gZ2VuIGdvdiBpIGluZCBtaWwgbmV0IG5pYyBvcmcgcmVzICIsCiAgICAgICAgICAgICJpcSI6ICIgY29tIGVkdSBnb3YgaSBtaWwgbmV0IG9yZyAiLAogICAgICAgICAgICAiaXIiOiAiIGFjIGNvIGRuc3NlYyBnb3YgaSBpZCBuZXQgb3JnIHNjaCAiLAogICAgICAgICAgICAiaXQiOiAiIGVkdSBnb3YgIiwKICAgICAgICAgICAgImplIjogIiBjbyBuZXQgb3JnICIsCiAgICAgICAgICAgICJqbyI6ICIgY29tIGVkdSBnb3YgbWlsIG5hbWUgbmV0IG9yZyBzY2ggIiwKICAgICAgICAgICAgImpwIjogIiBhYyBhZCBjbyBlZCBnbyBnciBsZyBuZSBvciAiLAogICAgICAgICAgICAia2UiOiAiIGFjIGNvIGdvIGluZm8gbWUgbW9iaSBuZSBvciBzYyAiLAogICAgICAgICAgICAia2giOiAiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnIHBlciAiLAogICAgICAgICAgICAia2kiOiAiIGJpeiBjb20gZGUgZWR1IGdvdiBpbmZvIG1vYiBuZXQgb3JnIHRlbCAiLAogICAgICAgICAgICAia20iOiAiIGFzc28gY29tIGNvb3AgZWR1IGdvdXYgayBtZWRlY2luIG1pbCBub20gbm90YWlyZXMgcGhhcm1hY2llbnMgcHJlc3NlIHRtIHZldGVyaW5haXJlICIsCiAgICAgICAgICAgICJrbiI6ICIgZWR1IGdvdiBuZXQgb3JnICIsCiAgICAgICAgICAgICJrciI6ICIgYWMgYnVzYW4gY2h1bmdidWsgY2h1bmduYW0gY28gZGFlZ3UgZGFlamVvbiBlcyBnYW5nd29uIGdvIGd3YW5nanUgZ3llb25nYnVrIGd5ZW9uZ2dpIGd5ZW9uZ25hbSBocyBpbmNoZW9uIGplanUgamVvbmJ1ayBqZW9ubmFtIGsga2cgbWlsIG1zIG5lIG9yIHBlIHJlIHNjIHNlb3VsIHVsc2FuICIsCiAgICAgICAgICAgICJrdyI6ICIgY29tIGVkdSBnb3YgbmV0IG9yZyAiLAogICAgICAgICAgICAia3kiOiAiIGNvbSBlZHUgZ292IG5ldCBvcmcgIiwKICAgICAgICAgICAgImt6IjogIiBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAiLAogICAgICAgICAgICAibGIiOiAiIGNvbSBlZHUgZ292IG5ldCBvcmcgIiwKICAgICAgICAgICAgImxrIjogIiBhc3NuIGNvbSBlZHUgZ292IGdycCBob3RlbCBpbnQgbHRkIG5ldCBuZ28gb3JnIHNjaCBzb2Mgd2ViICIsCiAgICAgICAgICAgICJsciI6ICIgY29tIGVkdSBnb3YgbmV0IG9yZyAiLAogICAgICAgICAgICAibHYiOiAiIGFzbiBjb20gY29uZiBlZHUgZ292IGlkIG1pbCBuZXQgb3JnICIsCiAgICAgICAgICAgICJseSI6ICIgY29tIGVkdSBnb3YgaWQgbWVkIG5ldCBvcmcgcGxjIHNjaCAiLAogICAgICAgICAgICAibWEiOiAiIGFjIGNvIGdvdiBtIG5ldCBvcmcgcHJlc3MgIiwKICAgICAgICAgICAgIm1jIjogIiBhc3NvIHRtICIsCiAgICAgICAgICAgICJtZSI6ICIgYWMgY28gZWR1IGdvdiBpdHMgbmV0IG9yZyBwcml2ICIsCiAgICAgICAgICAgICJtZyI6ICIgY29tIGVkdSBnb3YgbWlsIG5vbSBvcmcgcHJkIHRtICIsCiAgICAgICAgICAgICJtayI6ICIgY29tIGVkdSBnb3YgaW5mIG5hbWUgbmV0IG9yZyBwcm8gIiwKICAgICAgICAgICAgIm1sIjogIiBjb20gZWR1IGdvdiBuZXQgb3JnIHByZXNzZSAiLAogICAgICAgICAgICAibW4iOiAiIGVkdSBnb3Ygb3JnICIsCiAgICAgICAgICAgICJtbyI6ICIgY29tIGVkdSBnb3YgbmV0IG9yZyAiLAogICAgICAgICAgICAibXQiOiAiIGNvbSBlZHUgZ292IG5ldCBvcmcgIiwKICAgICAgICAgICAgIm12IjogIiBhZXJvIGJpeiBjb20gY29vcCBlZHUgZ292IGluZm8gaW50IG1pbCBtdXNldW0gbmFtZSBuZXQgb3JnIHBybyAiLAogICAgICAgICAgICAibXciOiAiIGFjIGNvIGNvbSBjb29wIGVkdSBnb3YgaW50IG11c2V1bSBuZXQgb3JnICIsCiAgICAgICAgICAgICJteCI6ICIgY29tIGVkdSBnb2IgbmV0IG9yZyAiLAogICAgICAgICAgICAibXkiOiAiIGNvbSBlZHUgZ292IG1pbCBuYW1lIG5ldCBvcmcgc2NoICIsCiAgICAgICAgICAgICJuZiI6ICIgYXJ0cyBjb20gZmlybSBpbmZvIG5ldCBvdGhlciBwZXIgcmVjIHN0b3JlIHdlYiAiLAogICAgICAgICAgICAibmciOiAiIGJpeiBjb20gZWR1IGdvdiBtaWwgbW9iaSBuYW1lIG5ldCBvcmcgc2NoICIsCiAgICAgICAgICAgICJuaSI6ICIgYWMgY28gY29tIGVkdSBnb2IgbWlsIG5ldCBub20gb3JnICIsCiAgICAgICAgICAgICJucCI6ICIgY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgIiwKICAgICAgICAgICAgIm5yIjogIiBiaXogY29tIGVkdSBnb3YgaW5mbyBuZXQgb3JnICIsCiAgICAgICAgICAgICJvbSI6ICIgYWMgYml6IGNvIGNvbSBlZHUgZ292IG1lZCBtaWwgbXVzZXVtIG5ldCBvcmcgcHJvIHNjaCAiLAogICAgICAgICAgICAicGUiOiAiIGNvbSBlZHUgZ29iIG1pbCBuZXQgbm9tIG9yZyBzbGQgIiwKICAgICAgICAgICAgInBoIjogIiBjb20gZWR1IGdvdiBpIG1pbCBuZXQgbmdvIG9yZyAiLAogICAgICAgICAgICAicGsiOiAiIGJpeiBjb20gZWR1IGZhbSBnb2IgZ29rIGdvbiBnb3AgZ29zIGdvdiBuZXQgb3JnIHdlYiAiLAogICAgICAgICAgICAicGwiOiAiIGFydCBiaWFseXN0b2sgYml6IGNvbSBlZHUgZ2RhIGdkYW5zayBnb3J6b3cgZ292IGluZm8ga2F0b3dpY2Uga3Jha293IGxvZHogbHVibGluIG1pbCBuZXQgbmdvIG9sc3p0eW4gb3JnIHBvem5hbiBwd3IgcmFkb20gc2x1cHNrIHN6Y3plY2luIHRvcnVuIHdhcnN6YXdhIHdhdyB3cm9jIHdyb2NsYXcgemdvcmEgIiwKICAgICAgICAgICAgInByIjogIiBhYyBiaXogY29tIGVkdSBlc3QgZ292IGluZm8gaXNsYSBuYW1lIG5ldCBvcmcgcHJvIHByb2YgIiwKICAgICAgICAgICAgInBzIjogIiBjb20gZWR1IGdvdiBuZXQgb3JnIHBsbyBzZWMgIiwKICAgICAgICAgICAgInB3IjogIiBiZWxhdSBjbyBlZCBnbyBuZSBvciAiLAogICAgICAgICAgICAicm8iOiAiIGFydHMgY29tIGZpcm0gaW5mbyBub20gbnQgb3JnIHJlYyBzdG9yZSB0bSB3d3cgIiwKICAgICAgICAgICAgInJzIjogIiBhYyBjbyBlZHUgZ292IGluIG9yZyAiLAogICAgICAgICAgICAic2IiOiAiIGNvbSBlZHUgZ292IG5ldCBvcmcgIiwKICAgICAgICAgICAgInNjIjogIiBjb20gZWR1IGdvdiBuZXQgb3JnICIsCiAgICAgICAgICAgICJzaCI6ICIgY28gY29tIGVkdSBnb3YgbmV0IG5vbSBvcmcgIiwKICAgICAgICAgICAgInNsIjogIiBjb20gZWR1IGdvdiBuZXQgb3JnICIsCiAgICAgICAgICAgICJzdCI6ICIgY28gY29tIGNvbnN1bGFkbyBlZHUgZW1iYWl4YWRhIGdvdiBtaWwgbmV0IG9yZyBwcmluY2lwZSBzYW90b21lIHN0b3JlICIsCiAgICAgICAgICAgICJzdiI6ICIgY29tIGVkdSBnb2Igb3JnIHJlZCAiLAogICAgICAgICAgICAic3oiOiAiIGFjIGNvIG9yZyAiLAogICAgICAgICAgICAidHIiOiAiIGF2IGJicyBiZWwgYml6IGNvbSBkciBlZHUgZ2VuIGdvdiBpbmZvIGsxMiBuYW1lIG5ldCBvcmcgcG9sIHRlbCB0c2sgdHYgd2ViICIsCiAgICAgICAgICAgICJ0dCI6ICIgYWVybyBiaXogY2F0IGNvIGNvbSBjb29wIGVkdSBnb3YgaW5mbyBpbnQgam9icyBtaWwgbW9iaSBtdXNldW0gbmFtZSBuZXQgb3JnIHBybyB0ZWwgdHJhdmVsICIsCiAgICAgICAgICAgICJ0dyI6ICIgY2x1YiBjb20gZWJpeiBlZHUgZ2FtZSBnb3YgaWR2IG1pbCBuZXQgb3JnICIsCiAgICAgICAgICAgICJtdSI6ICIgYWMgY28gY29tIGdvdiBuZXQgb3Igb3JnICIsCiAgICAgICAgICAgICJteiI6ICIgYWMgY28gZWR1IGdvdiBvcmcgIiwKICAgICAgICAgICAgIm5hIjogIiBjbyBjb20gIiwKICAgICAgICAgICAgIm56IjogIiBhYyBjbyBjcmkgZ2VlayBnZW4gZ292dCBoZWFsdGggaXdpIG1hb3JpIG1pbCBuZXQgb3JnIHBhcmxpYW1lbnQgc2Nob29sICIsCiAgICAgICAgICAgICJwYSI6ICIgYWJvIGFjIGNvbSBlZHUgZ29iIGluZyBtZWQgbmV0IG5vbSBvcmcgc2xkICIsCiAgICAgICAgICAgICJwdCI6ICIgY29tIGVkdSBnb3YgaW50IG5ldCBub21lIG9yZyBwdWJsICIsCiAgICAgICAgICAgICJweSI6ICIgY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgIiwKICAgICAgICAgICAgInFhIjogIiBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAiLAogICAgICAgICAgICAicmUiOiAiIGFzc28gY29tIG5vbSAiLAogICAgICAgICAgICAicnUiOiAiIGFjIGFkeWdleWEgYWx0YWkgYW11ciBhcmtoYW5nZWxzayBhc3RyYWtoYW4gYmFzaGtpcmlhIGJlbGdvcm9kIGJpciBicnlhbnNrIGJ1cnlhdGlhIGNiZyBjaGVsIGNoZWx5YWJpbnNrIGNoaXRhIGNodWtvdGthIGNodXZhc2hpYSBjb20gZGFnZXN0YW4gZS1idXJnIGVkdSBnb3YgZ3Jvem55IGludCBpcmt1dHNrIGl2YW5vdm8gaXpoZXZzayBqYXIgam9zaGthci1vbGEga2FsbXlraWEga2FsdWdhIGthbWNoYXRrYSBrYXJlbGlhIGthemFuIGtjaHIga2VtZXJvdm8ga2hhYmFyb3ZzayBraGFrYXNzaWEga2h2IGtpcm92IGtvZW5pZyBrb21pIGtvc3Ryb21hIGtyYW5veWFyc2sga3ViYW4ga3VyZ2FuIGt1cnNrIGxpcGV0c2sgbWFnYWRhbiBtYXJpIG1hcmktZWwgbWFyaW5lIG1pbCBtb3Jkb3ZpYSBtb3NyZWcgbXNrIG11cm1hbnNrIG5hbGNoaWsgbmV0IG5ub3Ygbm92IG5vdm9zaWJpcnNrIG5zayBvbXNrIG9yZW5idXJnIG9yZyBvcnlvbCBwZW56YSBwZXJtIHBwIHBza292IHB0eiBybmQgcnlhemFuIHNha2hhbGluIHNhbWFyYSBzYXJhdG92IHNpbWJpcnNrIHNtb2xlbnNrIHNwYiBzdGF2cm9wb2wgc3R2IHN1cmd1dCB0YW1ib3YgdGF0YXJzdGFuIHRvbSB0b21zayB0c2FyaXRzeW4gdHNrIHR1bGEgdHV2YSB0dmVyIHR5dW1lbiB1ZG0gdWRtdXJ0aWEgdWxhbi11ZGUgdmxhZGlrYXZrYXogdmxhZGltaXIgdmxhZGl2b3N0b2sgdm9sZ29ncmFkIHZvbG9nZGEgdm9yb25lemggdnJuIHZ5YXRrYSB5YWt1dGlhIHlhbWFsIHlla2F0ZXJpbmJ1cmcgeXV6aG5vLXNha2hhbGluc2sgIiwKICAgICAgICAgICAgInJ3IjogIiBhYyBjbyBjb20gZWR1IGdvdXYgZ292IGludCBtaWwgbmV0ICIsCiAgICAgICAgICAgICJzYSI6ICIgY29tIGVkdSBnb3YgbWVkIG5ldCBvcmcgcHViIHNjaCAiLAogICAgICAgICAgICAic2QiOiAiIGNvbSBlZHUgZ292IGluZm8gbWVkIG5ldCBvcmcgdHYgIiwKICAgICAgICAgICAgInNlIjogIiBhIGFjIGIgYmQgYyBkIGUgZiBnIGggaSBrIGwgbSBuIG8gb3JnIHAgcGFydGkgcHAgcHJlc3MgciBzIHQgdG0gdSB3IHggeSB6ICIsCiAgICAgICAgICAgICJzZyI6ICIgY29tIGVkdSBnb3YgaWRuIG5ldCBvcmcgcGVyICIsCiAgICAgICAgICAgICJzbiI6ICIgYXJ0IGNvbSBlZHUgZ291diBvcmcgcGVyc28gdW5pdiAiLAogICAgICAgICAgICAic3kiOiAiIGNvbSBlZHUgZ292IG1pbCBuZXQgbmV3cyBvcmcgIiwKICAgICAgICAgICAgInRoIjogIiBhYyBjbyBnbyBpbiBtaSBuZXQgb3IgIiwKICAgICAgICAgICAgInRqIjogIiBhYyBiaXogY28gY29tIGVkdSBnbyBnb3YgaW5mbyBpbnQgbWlsIG5hbWUgbmV0IG5pYyBvcmcgdGVzdCB3ZWIgIiwKICAgICAgICAgICAgInRuIjogIiBhZ3JpbmV0IGNvbSBkZWZlbnNlIGVkdW5ldCBlbnMgZmluIGdvdiBpbmQgaW5mbyBpbnRsIG1pbmNvbSBuYXQgbmV0IG9yZyBwZXJzbyBybnJ0IHJucyBybnUgdG91cmlzbSAiLAogICAgICAgICAgICAidHoiOiAiIGFjIGNvIGdvIG5lIG9yICIsCiAgICAgICAgICAgICJ1YSI6ICIgYml6IGNoZXJrYXNzeSBjaGVybmlnb3YgY2hlcm5vdnRzeSBjayBjbiBjbyBjb20gY3JpbWVhIGN2IGRuIGRuZXByb3BldHJvdnNrIGRvbmV0c2sgZHAgZWR1IGdvdiBpZiBpbiBpdmFuby1mcmFua2l2c2sga2gga2hhcmtvdiBraGVyc29uIGtobWVsbml0c2tpeSBraWV2IGtpcm92b2dyYWQga20ga3Iga3Mga3YgbGcgbHVnYW5zayBsdXRzayBsdml2IG1lIG1rIG5ldCBuaWtvbGFldiBvZCBvZGVzc2Egb3JnIHBsIHBvbHRhdmEgcHAgcm92bm8gcnYgc2ViYXN0b3BvbCBzdW15IHRlIHRlcm5vcGlsIHV6aGdvcm9kIHZpbm5pY2Egdm4gemFwb3Jpemh6aGUgemhpdG9taXIgenAgenQgIiwKICAgICAgICAgICAgInVnIjogIiBhYyBjbyBnbyBuZSBvciBvcmcgc2MgIiwKICAgICAgICAgICAgInVrIjogIiBhYyBibCBicml0aXNoLWxpYnJhcnkgY28gY3ltIGdvdiBnb3Z0IGljbmV0IGpldCBsZWEgbHRkIG1lIG1pbCBtb2QgbmF0aW9uYWwtbGlicmFyeS1zY290bGFuZCBuZWwgbmV0IG5ocyBuaWMgbmxzIG9yZyBvcmduIHBhcmxpYW1lbnQgcGxjIHBvbGljZSBzY2ggc2NvdCBzb2MgIiwKICAgICAgICAgICAgInVzIjogIiBkbmkgZmVkIGlzYSBraWRzIG5zbiAiLAogICAgICAgICAgICAidXkiOiAiIGNvbSBlZHUgZ3ViIG1pbCBuZXQgb3JnICIsCiAgICAgICAgICAgICJ2ZSI6ICIgY28gY29tIGVkdSBnb2IgaW5mbyBtaWwgbmV0IG9yZyB3ZWIgIiwKICAgICAgICAgICAgInZpIjogIiBjbyBjb20gazEyIG5ldCBvcmcgIiwKICAgICAgICAgICAgInZuIjogIiBhYyBiaXogY29tIGVkdSBnb3YgaGVhbHRoIGluZm8gaW50IG5hbWUgbmV0IG9yZyBwcm8gIiwKICAgICAgICAgICAgInllIjogIiBjbyBjb20gZ292IGx0ZCBtZSBuZXQgb3JnIHBsYyAiLAogICAgICAgICAgICAieXUiOiAiIGFjIGNvIGVkdSBnb3Ygb3JnICIsCiAgICAgICAgICAgICJ6YSI6ICIgYWMgYWdyaWMgYWx0IGJvdXJzZSBjaXR5IGNvIGN5YmVybmV0IGRiIGVkdSBnb3YgZ3JvbmRhciBpYWNjZXNzIGltdCBpbmNhIGxhbmRlc2lnbiBsYXcgbWlsIG5ldCBuZ28gbmlzIG5vbSBvbGl2ZXR0aSBvcmcgcGl4IHNjaG9vbCB0bSB3ZWIgIiwKICAgICAgICAgICAgInptIjogIiBhYyBjbyBjb20gZWR1IGdvdiBuZXQgb3JnIHNjaCAiLAogICAgICAgICAgICAiY29tIjogImFyIGJyIGNuIGRlIGV1IGdiIGdyIGh1IGpwbiBrciBubyBxYyBydSBzYSBzZSB1ayB1cyB1eSB6YSAiLAogICAgICAgICAgICAibmV0IjogImdiIGpwIHNlIHVrICIsCiAgICAgICAgICAgICJvcmciOiAiYWUiLAogICAgICAgICAgICAiZGUiOiAiY29tICIKICAgICAgICAgIH0sCiAgICAgICAgICBoYXM6IGZ1bmN0aW9uKGRvbWFpbikgewogICAgICAgICAgICB2YXIgdGxkT2Zmc2V0ID0gZG9tYWluLmxhc3RJbmRleE9mKCIuIik7CiAgICAgICAgICAgIGlmICh0bGRPZmZzZXQgPD0gMCB8fCB0bGRPZmZzZXQgPj0gZG9tYWluLmxlbmd0aCAtIDEpIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNsZE9mZnNldCA9IGRvbWFpbi5sYXN0SW5kZXhPZigiLiIsIHRsZE9mZnNldCAtIDEpOwogICAgICAgICAgICBpZiAoc2xkT2Zmc2V0IDw9IDAgfHwgc2xkT2Zmc2V0ID49IHRsZE9mZnNldCAtIDEpIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNsZExpc3QgPSBTTEQubGlzdFtkb21haW4uc2xpY2UodGxkT2Zmc2V0ICsgMSldOwogICAgICAgICAgICBpZiAoIXNsZExpc3QpIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHNsZExpc3QuaW5kZXhPZigiICIgKyBkb21haW4uc2xpY2Uoc2xkT2Zmc2V0ICsgMSwgdGxkT2Zmc2V0KSArICIgIikgPj0gMDsKICAgICAgICAgIH0sCiAgICAgICAgICBpczogZnVuY3Rpb24oZG9tYWluKSB7CiAgICAgICAgICAgIHZhciB0bGRPZmZzZXQgPSBkb21haW4ubGFzdEluZGV4T2YoIi4iKTsKICAgICAgICAgICAgaWYgKHRsZE9mZnNldCA8PSAwIHx8IHRsZE9mZnNldCA+PSBkb21haW4ubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgc2xkT2Zmc2V0ID0gZG9tYWluLmxhc3RJbmRleE9mKCIuIiwgdGxkT2Zmc2V0IC0gMSk7CiAgICAgICAgICAgIGlmIChzbGRPZmZzZXQgPj0gMCkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgc2xkTGlzdCA9IFNMRC5saXN0W2RvbWFpbi5zbGljZSh0bGRPZmZzZXQgKyAxKV07CiAgICAgICAgICAgIGlmICghc2xkTGlzdCkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gc2xkTGlzdC5pbmRleE9mKCIgIiArIGRvbWFpbi5zbGljZSgwLCB0bGRPZmZzZXQpICsgIiAiKSA+PSAwOwogICAgICAgICAgfSwKICAgICAgICAgIGdldDogZnVuY3Rpb24oZG9tYWluKSB7CiAgICAgICAgICAgIHZhciB0bGRPZmZzZXQgPSBkb21haW4ubGFzdEluZGV4T2YoIi4iKTsKICAgICAgICAgICAgaWYgKHRsZE9mZnNldCA8PSAwIHx8IHRsZE9mZnNldCA+PSBkb21haW4ubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzbGRPZmZzZXQgPSBkb21haW4ubGFzdEluZGV4T2YoIi4iLCB0bGRPZmZzZXQgLSAxKTsKICAgICAgICAgICAgaWYgKHNsZE9mZnNldCA8PSAwIHx8IHNsZE9mZnNldCA+PSB0bGRPZmZzZXQgLSAxKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNsZExpc3QgPSBTTEQubGlzdFtkb21haW4uc2xpY2UodGxkT2Zmc2V0ICsgMSldOwogICAgICAgICAgICBpZiAoIXNsZExpc3QpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc2xkTGlzdC5pbmRleE9mKCIgIiArIGRvbWFpbi5zbGljZShzbGRPZmZzZXQgKyAxLCB0bGRPZmZzZXQpICsgIiAiKSA8IDApIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZG9tYWluLnNsaWNlKHNsZE9mZnNldCArIDEpOwogICAgICAgICAgfSwKICAgICAgICAgIG5vQ29uZmxpY3Q6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICBpZiAocm9vdC5TZWNvbmRMZXZlbERvbWFpbnMgPT09IHRoaXMpIHsKICAgICAgICAgICAgICByb290LlNlY29uZExldmVsRG9tYWlucyA9IF9TZWNvbmRMZXZlbERvbWFpbnM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gU0xEOwogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rdXJpanNAMS4xOS4xMS9ub2RlX21vZHVsZXMvdXJpanMvc3JjL1VSSS5qcwogIHZhciByZXF1aXJlX1VSSSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3VyaWpzQDEuMTkuMTEvbm9kZV9tb2R1bGVzL3VyaWpzL3NyYy9VUkkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkgewogICAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gIm9iamVjdCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsKICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlX3B1bnljb2RlKCksIHJlcXVpcmVfSVB2NigpLCByZXF1aXJlX1NlY29uZExldmVsRG9tYWlucygpKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICJmdW5jdGlvbiIgJiYgZGVmaW5lLmFtZCkgewogICAgICAgICAgZGVmaW5lKFsiLi9wdW55Y29kZSIsICIuL0lQdjYiLCAiLi9TZWNvbmRMZXZlbERvbWFpbnMiXSwgZmFjdG9yeSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJvb3QuVVJJID0gZmFjdG9yeShyb290LnB1bnljb2RlLCByb290LklQdjYsIHJvb3QuU2Vjb25kTGV2ZWxEb21haW5zLCByb290KTsKICAgICAgICB9CiAgICAgIH0pKGV4cG9ydHMsIGZ1bmN0aW9uKHB1bnljb2RlLCBJUHY2LCBTTEQsIHJvb3QpIHsKICAgICAgICAidXNlIHN0cmljdCI7CiAgICAgICAgdmFyIF9VUkkgPSByb290ICYmIHJvb3QuVVJJOwogICAgICAgIGZ1bmN0aW9uIFVSSSh1cmwsIGJhc2UpIHsKICAgICAgICAgIHZhciBfdXJsU3VwcGxpZWQgPSBhcmd1bWVudHMubGVuZ3RoID49IDE7CiAgICAgICAgICB2YXIgX2Jhc2VTdXBwbGllZCA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMjsKICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUkkpKSB7CiAgICAgICAgICAgIGlmIChfdXJsU3VwcGxpZWQpIHsKICAgICAgICAgICAgICBpZiAoX2Jhc2VTdXBwbGllZCkgewogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkkodXJsLCBiYXNlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkkodXJsKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IFVSSSgpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHVybCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGlmIChfdXJsU3VwcGxpZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJ1bmRlZmluZWQgaXMgbm90IGEgdmFsaWQgYXJndW1lbnQgZm9yIFVSSSIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgdXJsID0gbG9jYXRpb24uaHJlZiArICIiOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHVybCA9ICIiOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodXJsID09PSBudWxsKSB7CiAgICAgICAgICAgIGlmIChfdXJsU3VwcGxpZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJudWxsIGlzIG5vdCBhIHZhbGlkIGFyZ3VtZW50IGZvciBVUkkiKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgdGhpcy5ocmVmKHVybCk7CiAgICAgICAgICBpZiAoYmFzZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmFic29sdXRlVG8oYmFzZSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gL15bMC05XSskLy50ZXN0KHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgVVJJLnZlcnNpb24gPSAiMS4xOS4xMSI7CiAgICAgICAgdmFyIHAgPSBVUkkucHJvdG90eXBlOwogICAgICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5OwogICAgICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4KHN0cmluZykgewogICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xdXC9cXF0pL2csICJcXCQxIik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHsKICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiAiVW5kZWZpbmVkIjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBTdHJpbmcoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSkuc2xpY2UoOCwgLTEpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpc0FycmF5KG9iaikgewogICAgICAgICAgcmV0dXJuIGdldFR5cGUob2JqKSA9PT0gIkFycmF5IjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZmlsdGVyQXJyYXlWYWx1ZXMoZGF0YSwgdmFsdWUpIHsKICAgICAgICAgIHZhciBsb29rdXAgPSB7fTsKICAgICAgICAgIHZhciBpLCBsZW5ndGg7CiAgICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICJSZWdFeHAiKSB7CiAgICAgICAgICAgIGxvb2t1cCA9IG51bGw7CiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7CiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgbG9va3VwW3ZhbHVlW2ldXSA9IHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGxvb2t1cFt2YWx1ZV0gPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICB2YXIgX21hdGNoID0gbG9va3VwICYmIGxvb2t1cFtkYXRhW2ldXSAhPT0gdm9pZCAwIHx8ICFsb29rdXAgJiYgdmFsdWUudGVzdChkYXRhW2ldKTsKICAgICAgICAgICAgaWYgKF9tYXRjaCkgewogICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGksIDEpOwogICAgICAgICAgICAgIGxlbmd0aC0tOwogICAgICAgICAgICAgIGktLTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFycmF5Q29udGFpbnMobGlzdCwgdmFsdWUpIHsKICAgICAgICAgIHZhciBpLCBsZW5ndGg7CiAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHsKICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICBpZiAoIWFycmF5Q29udGFpbnMobGlzdCwgdmFsdWVbaV0pKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgdmFyIF90eXBlID0gZ2V0VHlwZSh2YWx1ZSk7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChfdHlwZSA9PT0gIlJlZ0V4cCIpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RbaV0gPT09ICJzdHJpbmciICYmIGxpc3RbaV0ubWF0Y2godmFsdWUpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFtpXSA9PT0gdmFsdWUpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBhcnJheXNFcXVhbChvbmUsIHR3bykgewogICAgICAgICAgaWYgKCFpc0FycmF5KG9uZSkgfHwgIWlzQXJyYXkodHdvKSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAob25lLmxlbmd0aCAhPT0gdHdvLmxlbmd0aCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBvbmUuc29ydCgpOwogICAgICAgICAgdHdvLnNvcnQoKTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb25lLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBpZiAob25lW2ldICE9PSB0d29baV0pIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0cmltU2xhc2hlcyh0ZXh0KSB7CiAgICAgICAgICB2YXIgdHJpbV9leHByZXNzaW9uID0gL15cLyt8XC8rJC9nOwogICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSh0cmltX2V4cHJlc3Npb24sICIiKTsKICAgICAgICB9CiAgICAgICAgVVJJLl9wYXJ0cyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgcHJvdG9jb2w6IG51bGwsCiAgICAgICAgICAgIHVzZXJuYW1lOiBudWxsLAogICAgICAgICAgICBwYXNzd29yZDogbnVsbCwKICAgICAgICAgICAgaG9zdG5hbWU6IG51bGwsCiAgICAgICAgICAgIHVybjogbnVsbCwKICAgICAgICAgICAgcG9ydDogbnVsbCwKICAgICAgICAgICAgcGF0aDogbnVsbCwKICAgICAgICAgICAgcXVlcnk6IG51bGwsCiAgICAgICAgICAgIGZyYWdtZW50OiBudWxsLAogICAgICAgICAgICBwcmV2ZW50SW52YWxpZEhvc3RuYW1lOiBVUkkucHJldmVudEludmFsaWRIb3N0bmFtZSwKICAgICAgICAgICAgZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzOiBVUkkuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLAogICAgICAgICAgICBlc2NhcGVRdWVyeVNwYWNlOiBVUkkuZXNjYXBlUXVlcnlTcGFjZQogICAgICAgICAgfTsKICAgICAgICB9OwogICAgICAgIFVSSS5wcmV2ZW50SW52YWxpZEhvc3RuYW1lID0gZmFsc2U7CiAgICAgICAgVVJJLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycyA9IGZhbHNlOwogICAgICAgIFVSSS5lc2NhcGVRdWVyeVNwYWNlID0gdHJ1ZTsKICAgICAgICBVUkkucHJvdG9jb2xfZXhwcmVzc2lvbiA9IC9eW2Etel1bYS16MC05ListXSokL2k7CiAgICAgICAgVVJJLmlkbl9leHByZXNzaW9uID0gL1teYS16MC05XC5fLV0vaTsKICAgICAgICBVUkkucHVueWNvZGVfZXhwcmVzc2lvbiA9IC8oeG4tLSkvaTsKICAgICAgICBVUkkuaXA0X2V4cHJlc3Npb24gPSAvXlxkezEsM31cLlxkezEsM31cLlxkezEsM31cLlxkezEsM30kLzsKICAgICAgICBVUkkuaXA2X2V4cHJlc3Npb24gPSAvXlxzKigoKFswLTlBLUZhLWZdezEsNH06KXs3fShbMC05QS1GYS1mXXsxLDR9fDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs2fSg6WzAtOUEtRmEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKFwuKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezV9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKFwuKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezR9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsM30pfCgoOlswLTlBLUZhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKFwuKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXszfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkoXC4oMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezJ9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNX0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxkfDFcZFxkfFsxLTldP1xkKShcLigyNVswLTVdfDJbMC00XVxkfDFcZFxkfFsxLTldP1xkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7MX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKFwuKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKXszfSkpfDopKXwoOigoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkoXC4oMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkpezN9KSl8OikpKSglLispP1xzKiQvOwogICAgICAgIFVSSS5maW5kX3VyaV9leHByZXNzaW9uID0gL1xiKCg/OlthLXpdW1x3LV0rOig/OlwvezEsM318W2EtejAtOSVdKXx3d3dcZHswLDN9Wy5dfFthLXowLTkuXC1dK1suXVthLXpdezIsNH1cLykoPzpbXlxzKCk8Pl0rfFwoKFteXHMoKTw+XSt8KFwoW15ccygpPD5dK1wpKSkqXCkpKyg/OlwoKFteXHMoKTw+XSt8KFwoW15ccygpPD5dK1wpKSkqXCl8W15cc2AhKClcW1xde307OiciLiw8Pj/Cq8K74oCc4oCd4oCY4oCZXSkpL2lnOwogICAgICAgIFVSSS5maW5kVXJpID0gewogICAgICAgICAgc3RhcnQ6IC9cYig/OihbYS16XVthLXowLTkuKy1dKjpcL1wvKXx3d3dcLikvZ2ksCiAgICAgICAgICBlbmQ6IC9bXHNcclxuXXwkLywKICAgICAgICAgIHRyaW06IC9bYCEoKVxbXF17fTs6JyIuLDw+P8KrwrvigJzigJ3igJ7igJjigJldKyQvLAogICAgICAgICAgcGFyZW5zOiAvKFwoW15cKV0qXCl8XFtbXlxdXSpcXXxce1tefV0qXH18PFtePl0qPikvZwogICAgICAgIH07CiAgICAgICAgVVJJLmxlYWRpbmdfd2hpdGVzcGFjZV9leHByZXNzaW9uID0gL15bXHgwMC1ceDIwXHUwMGEwXHUxNjgwXHUyMDAwLVx1MjAwYVx1MjAyOFx1MjAyOVx1MjAyZlx1MjA1Zlx1MzAwMFx1ZmVmZl0rLzsKICAgICAgICBVUkkuYXNjaWlfdGFiX3doaXRlc3BhY2UgPSAvW1x1MDAwOVx1MDAwQVx1MDAwRF0rL2c7CiAgICAgICAgVVJJLmRlZmF1bHRQb3J0cyA9IHsKICAgICAgICAgIGh0dHA6ICI4MCIsCiAgICAgICAgICBodHRwczogIjQ0MyIsCiAgICAgICAgICBmdHA6ICIyMSIsCiAgICAgICAgICBnb3BoZXI6ICI3MCIsCiAgICAgICAgICB3czogIjgwIiwKICAgICAgICAgIHdzczogIjQ0MyIKICAgICAgICB9OwogICAgICAgIFVSSS5ob3N0UHJvdG9jb2xzID0gWwogICAgICAgICAgImh0dHAiLAogICAgICAgICAgImh0dHBzIgogICAgICAgIF07CiAgICAgICAgVVJJLmludmFsaWRfaG9zdG5hbWVfY2hhcmFjdGVycyA9IC9bXmEtekEtWjAtOVwuXC06X10vOwogICAgICAgIFVSSS5kb21BdHRyaWJ1dGVzID0gewogICAgICAgICAgImEiOiAiaHJlZiIsCiAgICAgICAgICAiYmxvY2txdW90ZSI6ICJjaXRlIiwKICAgICAgICAgICJsaW5rIjogImhyZWYiLAogICAgICAgICAgImJhc2UiOiAiaHJlZiIsCiAgICAgICAgICAic2NyaXB0IjogInNyYyIsCiAgICAgICAgICAiZm9ybSI6ICJhY3Rpb24iLAogICAgICAgICAgImltZyI6ICJzcmMiLAogICAgICAgICAgImFyZWEiOiAiaHJlZiIsCiAgICAgICAgICAiaWZyYW1lIjogInNyYyIsCiAgICAgICAgICAiZW1iZWQiOiAic3JjIiwKICAgICAgICAgICJzb3VyY2UiOiAic3JjIiwKICAgICAgICAgICJ0cmFjayI6ICJzcmMiLAogICAgICAgICAgImlucHV0IjogInNyYyIsCiAgICAgICAgICAiYXVkaW8iOiAic3JjIiwKICAgICAgICAgICJ2aWRlbyI6ICJzcmMiCiAgICAgICAgfTsKICAgICAgICBVUkkuZ2V0RG9tQXR0cmlidXRlID0gZnVuY3Rpb24obm9kZSkgewogICAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLm5vZGVOYW1lKSB7CiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICJpbnB1dCIgJiYgbm9kZS50eXBlICE9PSAiaW1hZ2UiKSB7CiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gVVJJLmRvbUF0dHJpYnV0ZXNbbm9kZU5hbWVdOwogICAgICAgIH07CiAgICAgICAgZnVuY3Rpb24gZXNjYXBlRm9yRHVtYkZpcmVmb3gzNih2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIGVzY2FwZSh2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHN0cmljdEVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpIHsKICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKS5yZXBsYWNlKC9bIScoKSpdL2csIGVzY2FwZUZvckR1bWJGaXJlZm94MzYpLnJlcGxhY2UoL1wqL2csICIlMkEiKTsKICAgICAgICB9CiAgICAgICAgVVJJLmVuY29kZSA9IHN0cmljdEVuY29kZVVSSUNvbXBvbmVudDsKICAgICAgICBVUkkuZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50OwogICAgICAgIFVSSS5pc284ODU5ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICBVUkkuZW5jb2RlID0gZXNjYXBlOwogICAgICAgICAgVVJJLmRlY29kZSA9IHVuZXNjYXBlOwogICAgICAgIH07CiAgICAgICAgVVJJLnVuaWNvZGUgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIFVSSS5lbmNvZGUgPSBzdHJpY3RFbmNvZGVVUklDb21wb25lbnQ7CiAgICAgICAgICBVUkkuZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50OwogICAgICAgIH07CiAgICAgICAgVVJJLmNoYXJhY3RlcnMgPSB7CiAgICAgICAgICBwYXRobmFtZTogewogICAgICAgICAgICBlbmNvZGU6IHsKICAgICAgICAgICAgICBleHByZXNzaW9uOiAvJSgyNHwyNnwyQnwyQ3wzQnwzRHwzQXw0MCkvaWcsCiAgICAgICAgICAgICAgbWFwOiB7CiAgICAgICAgICAgICAgICAiJTI0IjogIiQiLAogICAgICAgICAgICAgICAgIiUyNiI6ICImIiwKICAgICAgICAgICAgICAgICIlMkIiOiAiKyIsCiAgICAgICAgICAgICAgICAiJTJDIjogIiwiLAogICAgICAgICAgICAgICAgIiUzQiI6ICI7IiwKICAgICAgICAgICAgICAgICIlM0QiOiAiPSIsCiAgICAgICAgICAgICAgICAiJTNBIjogIjoiLAogICAgICAgICAgICAgICAgIiU0MCI6ICJAIgogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZGVjb2RlOiB7CiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogL1tcL1w/I10vZywKICAgICAgICAgICAgICBtYXA6IHsKICAgICAgICAgICAgICAgICIvIjogIiUyRiIsCiAgICAgICAgICAgICAgICAiPyI6ICIlM0YiLAogICAgICAgICAgICAgICAgIiMiOiAiJTIzIgogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgIHJlc2VydmVkOiB7CiAgICAgICAgICAgIGVuY29kZTogewogICAgICAgICAgICAgIGV4cHJlc3Npb246IC8lKDIxfDIzfDI0fDI2fDI3fDI4fDI5fDJBfDJCfDJDfDJGfDNBfDNCfDNEfDNGfDQwfDVCfDVEKS9pZywKICAgICAgICAgICAgICBtYXA6IHsKICAgICAgICAgICAgICAgICIlM0EiOiAiOiIsCiAgICAgICAgICAgICAgICAiJTJGIjogIi8iLAogICAgICAgICAgICAgICAgIiUzRiI6ICI/IiwKICAgICAgICAgICAgICAgICIlMjMiOiAiIyIsCiAgICAgICAgICAgICAgICAiJTVCIjogIlsiLAogICAgICAgICAgICAgICAgIiU1RCI6ICJdIiwKICAgICAgICAgICAgICAgICIlNDAiOiAiQCIsCiAgICAgICAgICAgICAgICAiJTIxIjogIiEiLAogICAgICAgICAgICAgICAgIiUyNCI6ICIkIiwKICAgICAgICAgICAgICAgICIlMjYiOiAiJiIsCiAgICAgICAgICAgICAgICAiJTI3IjogIiciLAogICAgICAgICAgICAgICAgIiUyOCI6ICIoIiwKICAgICAgICAgICAgICAgICIlMjkiOiAiKSIsCiAgICAgICAgICAgICAgICAiJTJBIjogIioiLAogICAgICAgICAgICAgICAgIiUyQiI6ICIrIiwKICAgICAgICAgICAgICAgICIlMkMiOiAiLCIsCiAgICAgICAgICAgICAgICAiJTNCIjogIjsiLAogICAgICAgICAgICAgICAgIiUzRCI6ICI9IgogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgIHVybnBhdGg6IHsKICAgICAgICAgICAgZW5jb2RlOiB7CiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogLyUoMjF8MjR8Mjd8Mjh8Mjl8MkF8MkJ8MkN8M0J8M0R8NDApL2lnLAogICAgICAgICAgICAgIG1hcDogewogICAgICAgICAgICAgICAgIiUyMSI6ICIhIiwKICAgICAgICAgICAgICAgICIlMjQiOiAiJCIsCiAgICAgICAgICAgICAgICAiJTI3IjogIiciLAogICAgICAgICAgICAgICAgIiUyOCI6ICIoIiwKICAgICAgICAgICAgICAgICIlMjkiOiAiKSIsCiAgICAgICAgICAgICAgICAiJTJBIjogIioiLAogICAgICAgICAgICAgICAgIiUyQiI6ICIrIiwKICAgICAgICAgICAgICAgICIlMkMiOiAiLCIsCiAgICAgICAgICAgICAgICAiJTNCIjogIjsiLAogICAgICAgICAgICAgICAgIiUzRCI6ICI9IiwKICAgICAgICAgICAgICAgICIlNDAiOiAiQCIKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGRlY29kZTogewogICAgICAgICAgICAgIGV4cHJlc3Npb246IC9bXC9cPyM6XS9nLAogICAgICAgICAgICAgIG1hcDogewogICAgICAgICAgICAgICAgIi8iOiAiJTJGIiwKICAgICAgICAgICAgICAgICI/IjogIiUzRiIsCiAgICAgICAgICAgICAgICAiIyI6ICIlMjMiLAogICAgICAgICAgICAgICAgIjoiOiAiJTNBIgogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgVVJJLmVuY29kZVF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nLCBlc2NhcGVRdWVyeVNwYWNlKSB7CiAgICAgICAgICB2YXIgZXNjYXBlZCA9IFVSSS5lbmNvZGUoc3RyaW5nICsgIiIpOwogICAgICAgICAgaWYgKGVzY2FwZVF1ZXJ5U3BhY2UgPT09IHZvaWQgMCkgewogICAgICAgICAgICBlc2NhcGVRdWVyeVNwYWNlID0gVVJJLmVzY2FwZVF1ZXJ5U3BhY2U7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZXNjYXBlUXVlcnlTcGFjZSA/IGVzY2FwZWQucmVwbGFjZSgvJTIwL2csICIrIikgOiBlc2NhcGVkOwogICAgICAgIH07CiAgICAgICAgVVJJLmRlY29kZVF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nLCBlc2NhcGVRdWVyeVNwYWNlKSB7CiAgICAgICAgICBzdHJpbmcgKz0gIiI7CiAgICAgICAgICBpZiAoZXNjYXBlUXVlcnlTcGFjZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGVzY2FwZVF1ZXJ5U3BhY2UgPSBVUkkuZXNjYXBlUXVlcnlTcGFjZTsKICAgICAgICAgIH0KICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiBVUkkuZGVjb2RlKGVzY2FwZVF1ZXJ5U3BhY2UgPyBzdHJpbmcucmVwbGFjZSgvXCsvZywgIiUyMCIpIDogc3RyaW5nKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgcmV0dXJuIHN0cmluZzsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIHZhciBfcGFydHMgPSB7ICJlbmNvZGUiOiAiZW5jb2RlIiwgImRlY29kZSI6ICJkZWNvZGUiIH07CiAgICAgICAgdmFyIF9wYXJ0OwogICAgICAgIHZhciBnZW5lcmF0ZUFjY2Vzc29yID0gZnVuY3Rpb24oX2dyb3VwLCBfcGFydDIpIHsKICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICByZXR1cm4gVVJJW19wYXJ0Ml0oc3RyaW5nICsgIiIpLnJlcGxhY2UoVVJJLmNoYXJhY3RlcnNbX2dyb3VwXVtfcGFydDJdLmV4cHJlc3Npb24sIGZ1bmN0aW9uKGMpIHsKICAgICAgICAgICAgICAgIHJldHVybiBVUkkuY2hhcmFjdGVyc1tfZ3JvdXBdW19wYXJ0Ml0ubWFwW2NdOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZzsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICB9OwogICAgICAgIGZvciAoX3BhcnQgaW4gX3BhcnRzKSB7CiAgICAgICAgICBVUklbX3BhcnQgKyAiUGF0aFNlZ21lbnQiXSA9IGdlbmVyYXRlQWNjZXNzb3IoInBhdGhuYW1lIiwgX3BhcnRzW19wYXJ0XSk7CiAgICAgICAgICBVUklbX3BhcnQgKyAiVXJuUGF0aFNlZ21lbnQiXSA9IGdlbmVyYXRlQWNjZXNzb3IoInVybnBhdGgiLCBfcGFydHNbX3BhcnRdKTsKICAgICAgICB9CiAgICAgICAgdmFyIGdlbmVyYXRlU2VnbWVudGVkUGF0aEZ1bmN0aW9uID0gZnVuY3Rpb24oX3NlcCwgX2NvZGluZ0Z1bmNOYW1lLCBfaW5uZXJDb2RpbmdGdW5jTmFtZSkgewogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykgewogICAgICAgICAgICB2YXIgYWN0dWFsQ29kaW5nRnVuYzsKICAgICAgICAgICAgaWYgKCFfaW5uZXJDb2RpbmdGdW5jTmFtZSkgewogICAgICAgICAgICAgIGFjdHVhbENvZGluZ0Z1bmMgPSBVUklbX2NvZGluZ0Z1bmNOYW1lXTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBhY3R1YWxDb2RpbmdGdW5jID0gZnVuY3Rpb24oc3RyaW5nMikgewogICAgICAgICAgICAgICAgcmV0dXJuIFVSSVtfY29kaW5nRnVuY05hbWVdKFVSSVtfaW5uZXJDb2RpbmdGdW5jTmFtZV0oc3RyaW5nMikpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gKHN0cmluZyArICIiKS5zcGxpdChfc2VwKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgc2VnbWVudHNbaV0gPSBhY3R1YWxDb2RpbmdGdW5jKHNlZ21lbnRzW2ldKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gc2VnbWVudHMuam9pbihfc2VwKTsKICAgICAgICAgIH07CiAgICAgICAgfTsKICAgICAgICBVUkkuZGVjb2RlUGF0aCA9IGdlbmVyYXRlU2VnbWVudGVkUGF0aEZ1bmN0aW9uKCIvIiwgImRlY29kZVBhdGhTZWdtZW50Iik7CiAgICAgICAgVVJJLmRlY29kZVVyblBhdGggPSBnZW5lcmF0ZVNlZ21lbnRlZFBhdGhGdW5jdGlvbigiOiIsICJkZWNvZGVVcm5QYXRoU2VnbWVudCIpOwogICAgICAgIFVSSS5yZWNvZGVQYXRoID0gZ2VuZXJhdGVTZWdtZW50ZWRQYXRoRnVuY3Rpb24oIi8iLCAiZW5jb2RlUGF0aFNlZ21lbnQiLCAiZGVjb2RlIik7CiAgICAgICAgVVJJLnJlY29kZVVyblBhdGggPSBnZW5lcmF0ZVNlZ21lbnRlZFBhdGhGdW5jdGlvbigiOiIsICJlbmNvZGVVcm5QYXRoU2VnbWVudCIsICJkZWNvZGUiKTsKICAgICAgICBVUkkuZW5jb2RlUmVzZXJ2ZWQgPSBnZW5lcmF0ZUFjY2Vzc29yKCJyZXNlcnZlZCIsICJlbmNvZGUiKTsKICAgICAgICBVUkkucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7CiAgICAgICAgICB2YXIgcG9zOwogICAgICAgICAgaWYgKCFwYXJ0cykgewogICAgICAgICAgICBwYXJ0cyA9IHsKICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZEhvc3RuYW1lOiBVUkkucHJldmVudEludmFsaWRIb3N0bmFtZQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoVVJJLmxlYWRpbmdfd2hpdGVzcGFjZV9leHByZXNzaW9uLCAiIik7CiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShVUkkuYXNjaWlfdGFiX3doaXRlc3BhY2UsICIiKTsKICAgICAgICAgIHBvcyA9IHN0cmluZy5pbmRleE9mKCIjIik7CiAgICAgICAgICBpZiAocG9zID4gLTEpIHsKICAgICAgICAgICAgcGFydHMuZnJhZ21lbnQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEpIHx8IG51bGw7CiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoMCwgcG9zKTsKICAgICAgICAgIH0KICAgICAgICAgIHBvcyA9IHN0cmluZy5pbmRleE9mKCI/Iik7CiAgICAgICAgICBpZiAocG9zID4gLTEpIHsKICAgICAgICAgICAgcGFydHMucXVlcnkgPSBzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEpIHx8IG51bGw7CiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoMCwgcG9zKTsKICAgICAgICAgIH0KICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKGh0dHBzP3xmdHB8d3NzPyk/OitbL1xcXSovaSwgIiQxOi8vIik7CiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXlsvXFxdezIsfS9pLCAiLy8iKTsKICAgICAgICAgIGlmIChzdHJpbmcuc3Vic3RyaW5nKDAsIDIpID09PSAiLy8iKSB7CiAgICAgICAgICAgIHBhcnRzLnByb3RvY29sID0gbnVsbDsKICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZygyKTsKICAgICAgICAgICAgc3RyaW5nID0gVVJJLnBhcnNlQXV0aG9yaXR5KHN0cmluZywgcGFydHMpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcG9zID0gc3RyaW5nLmluZGV4T2YoIjoiKTsKICAgICAgICAgICAgaWYgKHBvcyA+IC0xKSB7CiAgICAgICAgICAgICAgcGFydHMucHJvdG9jb2wgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcykgfHwgbnVsbDsKICAgICAgICAgICAgICBpZiAocGFydHMucHJvdG9jb2wgJiYgIXBhcnRzLnByb3RvY29sLm1hdGNoKFVSSS5wcm90b2NvbF9leHByZXNzaW9uKSkgewogICAgICAgICAgICAgICAgcGFydHMucHJvdG9jb2wgPSB2b2lkIDA7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEsIHBvcyArIDMpLnJlcGxhY2UoL1xcL2csICIvIikgPT09ICIvLyIpIHsKICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcocG9zICsgMyk7CiAgICAgICAgICAgICAgICBzdHJpbmcgPSBVUkkucGFyc2VBdXRob3JpdHkoc3RyaW5nLCBwYXJ0cyk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcocG9zICsgMSk7CiAgICAgICAgICAgICAgICBwYXJ0cy51cm4gPSB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcGFydHMucGF0aCA9IHN0cmluZzsKICAgICAgICAgIHJldHVybiBwYXJ0czsKICAgICAgICB9OwogICAgICAgIFVSSS5wYXJzZUhvc3QgPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7CiAgICAgICAgICBpZiAoIXN0cmluZykgewogICAgICAgICAgICBzdHJpbmcgPSAiIjsKICAgICAgICAgIH0KICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXC9nLCAiLyIpOwogICAgICAgICAgdmFyIHBvcyA9IHN0cmluZy5pbmRleE9mKCIvIik7CiAgICAgICAgICB2YXIgYnJhY2tldFBvczsKICAgICAgICAgIHZhciB0OwogICAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHsKICAgICAgICAgICAgcG9zID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJpbmcuY2hhckF0KDApID09PSAiWyIpIHsKICAgICAgICAgICAgYnJhY2tldFBvcyA9IHN0cmluZy5pbmRleE9mKCJdIik7CiAgICAgICAgICAgIHBhcnRzLmhvc3RuYW1lID0gc3RyaW5nLnN1YnN0cmluZygxLCBicmFja2V0UG9zKSB8fCBudWxsOwogICAgICAgICAgICBwYXJ0cy5wb3J0ID0gc3RyaW5nLnN1YnN0cmluZyhicmFja2V0UG9zICsgMiwgcG9zKSB8fCBudWxsOwogICAgICAgICAgICBpZiAocGFydHMucG9ydCA9PT0gIi8iKSB7CiAgICAgICAgICAgICAgcGFydHMucG9ydCA9IG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBmaXJzdENvbG9uID0gc3RyaW5nLmluZGV4T2YoIjoiKTsKICAgICAgICAgICAgdmFyIGZpcnN0U2xhc2ggPSBzdHJpbmcuaW5kZXhPZigiLyIpOwogICAgICAgICAgICB2YXIgbmV4dENvbG9uID0gc3RyaW5nLmluZGV4T2YoIjoiLCBmaXJzdENvbG9uICsgMSk7CiAgICAgICAgICAgIGlmIChuZXh0Q29sb24gIT09IC0xICYmIChmaXJzdFNsYXNoID09PSAtMSB8fCBuZXh0Q29sb24gPCBmaXJzdFNsYXNoKSkgewogICAgICAgICAgICAgIHBhcnRzLmhvc3RuYW1lID0gc3RyaW5nLnN1YnN0cmluZygwLCBwb3MpIHx8IG51bGw7CiAgICAgICAgICAgICAgcGFydHMucG9ydCA9IG51bGw7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdCA9IHN0cmluZy5zdWJzdHJpbmcoMCwgcG9zKS5zcGxpdCgiOiIpOwogICAgICAgICAgICAgIHBhcnRzLmhvc3RuYW1lID0gdFswXSB8fCBudWxsOwogICAgICAgICAgICAgIHBhcnRzLnBvcnQgPSB0WzFdIHx8IG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChwYXJ0cy5ob3N0bmFtZSAmJiBzdHJpbmcuc3Vic3RyaW5nKHBvcykuY2hhckF0KDApICE9PSAiLyIpIHsKICAgICAgICAgICAgcG9zKys7CiAgICAgICAgICAgIHN0cmluZyA9ICIvIiArIHN0cmluZzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChwYXJ0cy5wcmV2ZW50SW52YWxpZEhvc3RuYW1lKSB7CiAgICAgICAgICAgIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lKHBhcnRzLmhvc3RuYW1lLCBwYXJ0cy5wcm90b2NvbCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocGFydHMucG9ydCkgewogICAgICAgICAgICBVUkkuZW5zdXJlVmFsaWRQb3J0KHBhcnRzLnBvcnQpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcocG9zKSB8fCAiLyI7CiAgICAgICAgfTsKICAgICAgICBVUkkucGFyc2VBdXRob3JpdHkgPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7CiAgICAgICAgICBzdHJpbmcgPSBVUkkucGFyc2VVc2VyaW5mbyhzdHJpbmcsIHBhcnRzKTsKICAgICAgICAgIHJldHVybiBVUkkucGFyc2VIb3N0KHN0cmluZywgcGFydHMpOwogICAgICAgIH07CiAgICAgICAgVVJJLnBhcnNlVXNlcmluZm8gPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7CiAgICAgICAgICB2YXIgX3N0cmluZyA9IHN0cmluZzsKICAgICAgICAgIHZhciBmaXJzdEJhY2tTbGFzaCA9IHN0cmluZy5pbmRleE9mKCJcXCIpOwogICAgICAgICAgaWYgKGZpcnN0QmFja1NsYXNoICE9PSAtMSkgewogICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwvZywgIi8iKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBmaXJzdFNsYXNoID0gc3RyaW5nLmluZGV4T2YoIi8iKTsKICAgICAgICAgIHZhciBwb3MgPSBzdHJpbmcubGFzdEluZGV4T2YoIkAiLCBmaXJzdFNsYXNoID4gLTEgPyBmaXJzdFNsYXNoIDogc3RyaW5nLmxlbmd0aCAtIDEpOwogICAgICAgICAgdmFyIHQ7CiAgICAgICAgICBpZiAocG9zID4gLTEgJiYgKGZpcnN0U2xhc2ggPT09IC0xIHx8IHBvcyA8IGZpcnN0U2xhc2gpKSB7CiAgICAgICAgICAgIHQgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcykuc3BsaXQoIjoiKTsKICAgICAgICAgICAgcGFydHMudXNlcm5hbWUgPSB0WzBdID8gVVJJLmRlY29kZSh0WzBdKSA6IG51bGw7CiAgICAgICAgICAgIHQuc2hpZnQoKTsKICAgICAgICAgICAgcGFydHMucGFzc3dvcmQgPSB0WzBdID8gVVJJLmRlY29kZSh0LmpvaW4oIjoiKSkgOiBudWxsOwogICAgICAgICAgICBzdHJpbmcgPSBfc3RyaW5nLnN1YnN0cmluZyhwb3MgKyAxKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBhcnRzLnVzZXJuYW1lID0gbnVsbDsKICAgICAgICAgICAgcGFydHMucGFzc3dvcmQgPSBudWxsOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHN0cmluZzsKICAgICAgICB9OwogICAgICAgIFVSSS5wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nLCBlc2NhcGVRdWVyeVNwYWNlKSB7CiAgICAgICAgICBpZiAoIXN0cmluZykgewogICAgICAgICAgICByZXR1cm4ge307CiAgICAgICAgICB9CiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvJisvZywgIiYiKS5yZXBsYWNlKC9eXD8qJip8JiskL2csICIiKTsKICAgICAgICAgIGlmICghc3RyaW5nKSB7CiAgICAgICAgICAgIHJldHVybiB7fTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpdGVtcyA9IHt9OwogICAgICAgICAgdmFyIHNwbGl0cyA9IHN0cmluZy5zcGxpdCgiJiIpOwogICAgICAgICAgdmFyIGxlbmd0aCA9IHNwbGl0cy5sZW5ndGg7CiAgICAgICAgICB2YXIgdjIsIG5hbWUsIHZhbHVlOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICB2MiA9IHNwbGl0c1tpXS5zcGxpdCgiPSIpOwogICAgICAgICAgICBuYW1lID0gVVJJLmRlY29kZVF1ZXJ5KHYyLnNoaWZ0KCksIGVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgICB2YWx1ZSA9IHYyLmxlbmd0aCA/IFVSSS5kZWNvZGVRdWVyeSh2Mi5qb2luKCI9IiksIGVzY2FwZVF1ZXJ5U3BhY2UpIDogbnVsbDsKICAgICAgICAgICAgaWYgKG5hbWUgPT09ICJfX3Byb3RvX18iKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duLmNhbGwoaXRlbXMsIG5hbWUpKSB7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtc1tuYW1lXSA9PT0gInN0cmluZyIgfHwgaXRlbXNbbmFtZV0gPT09IG51bGwpIHsKICAgICAgICAgICAgICAgIGl0ZW1zW25hbWVdID0gW2l0ZW1zW25hbWVdXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaXRlbXNbbmFtZV0ucHVzaCh2YWx1ZSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaXRlbXNbbmFtZV0gPSB2YWx1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGl0ZW1zOwogICAgICAgIH07CiAgICAgICAgVVJJLmJ1aWxkID0gZnVuY3Rpb24ocGFydHMpIHsKICAgICAgICAgIHZhciB0ID0gIiI7CiAgICAgICAgICB2YXIgcmVxdWlyZUFic29sdXRlUGF0aCA9IGZhbHNlOwogICAgICAgICAgaWYgKHBhcnRzLnByb3RvY29sKSB7CiAgICAgICAgICAgIHQgKz0gcGFydHMucHJvdG9jb2wgKyAiOiI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIXBhcnRzLnVybiAmJiAodCB8fCBwYXJ0cy5ob3N0bmFtZSkpIHsKICAgICAgICAgICAgdCArPSAiLy8iOwogICAgICAgICAgICByZXF1aXJlQWJzb2x1dGVQYXRoID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIHQgKz0gVVJJLmJ1aWxkQXV0aG9yaXR5KHBhcnRzKSB8fCAiIjsKICAgICAgICAgIGlmICh0eXBlb2YgcGFydHMucGF0aCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgaWYgKHBhcnRzLnBhdGguY2hhckF0KDApICE9PSAiLyIgJiYgcmVxdWlyZUFic29sdXRlUGF0aCkgewogICAgICAgICAgICAgIHQgKz0gIi8iOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHQgKz0gcGFydHMucGF0aDsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgcGFydHMucXVlcnkgPT09ICJzdHJpbmciICYmIHBhcnRzLnF1ZXJ5KSB7CiAgICAgICAgICAgIHQgKz0gIj8iICsgcGFydHMucXVlcnk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIHBhcnRzLmZyYWdtZW50ID09PSAic3RyaW5nIiAmJiBwYXJ0cy5mcmFnbWVudCkgewogICAgICAgICAgICB0ICs9ICIjIiArIHBhcnRzLmZyYWdtZW50OwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgfTsKICAgICAgICBVUkkuYnVpbGRIb3N0ID0gZnVuY3Rpb24ocGFydHMpIHsKICAgICAgICAgIHZhciB0ID0gIiI7CiAgICAgICAgICBpZiAoIXBhcnRzLmhvc3RuYW1lKSB7CiAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICAgIH0gZWxzZSBpZiAoVVJJLmlwNl9leHByZXNzaW9uLnRlc3QocGFydHMuaG9zdG5hbWUpKSB7CiAgICAgICAgICAgIHQgKz0gIlsiICsgcGFydHMuaG9zdG5hbWUgKyAiXSI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0ICs9IHBhcnRzLmhvc3RuYW1lOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHBhcnRzLnBvcnQpIHsKICAgICAgICAgICAgdCArPSAiOiIgKyBwYXJ0cy5wb3J0OwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgfTsKICAgICAgICBVUkkuYnVpbGRBdXRob3JpdHkgPSBmdW5jdGlvbihwYXJ0cykgewogICAgICAgICAgcmV0dXJuIFVSSS5idWlsZFVzZXJpbmZvKHBhcnRzKSArIFVSSS5idWlsZEhvc3QocGFydHMpOwogICAgICAgIH07CiAgICAgICAgVVJJLmJ1aWxkVXNlcmluZm8gPSBmdW5jdGlvbihwYXJ0cykgewogICAgICAgICAgdmFyIHQgPSAiIjsKICAgICAgICAgIGlmIChwYXJ0cy51c2VybmFtZSkgewogICAgICAgICAgICB0ICs9IFVSSS5lbmNvZGUocGFydHMudXNlcm5hbWUpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHBhcnRzLnBhc3N3b3JkKSB7CiAgICAgICAgICAgIHQgKz0gIjoiICsgVVJJLmVuY29kZShwYXJ0cy5wYXNzd29yZCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodCkgewogICAgICAgICAgICB0ICs9ICJAIjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0OwogICAgICAgIH07CiAgICAgICAgVVJJLmJ1aWxkUXVlcnkgPSBmdW5jdGlvbihkYXRhLCBkdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsIGVzY2FwZVF1ZXJ5U3BhY2UpIHsKICAgICAgICAgIHZhciB0ID0gIiI7CiAgICAgICAgICB2YXIgdW5pcXVlLCBrZXksIGksIGxlbmd0aDsKICAgICAgICAgIGZvciAoa2V5IGluIGRhdGEpIHsKICAgICAgICAgICAgaWYgKGtleSA9PT0gIl9fcHJvdG9fXyIpIHsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd24uY2FsbChkYXRhLCBrZXkpKSB7CiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoZGF0YVtrZXldKSkgewogICAgICAgICAgICAgICAgdW5pcXVlID0ge307CiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBkYXRhW2tleV0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgaWYgKGRhdGFba2V5XVtpXSAhPT0gdm9pZCAwICYmIHVuaXF1ZVtkYXRhW2tleV1baV0gKyAiIl0gPT09IHZvaWQgMCkgewogICAgICAgICAgICAgICAgICAgIHQgKz0gIiYiICsgVVJJLmJ1aWxkUXVlcnlQYXJhbWV0ZXIoa2V5LCBkYXRhW2tleV1baV0sIGVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMgIT09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZVtkYXRhW2tleV1baV0gKyAiIl0gPSB0cnVlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVtrZXldICE9PSB2b2lkIDApIHsKICAgICAgICAgICAgICAgIHQgKz0gIiYiICsgVVJJLmJ1aWxkUXVlcnlQYXJhbWV0ZXIoa2V5LCBkYXRhW2tleV0sIGVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHQuc3Vic3RyaW5nKDEpOwogICAgICAgIH07CiAgICAgICAgVVJJLmJ1aWxkUXVlcnlQYXJhbWV0ZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZXNjYXBlUXVlcnlTcGFjZSkgewogICAgICAgICAgcmV0dXJuIFVSSS5lbmNvZGVRdWVyeShuYW1lLCBlc2NhcGVRdWVyeVNwYWNlKSArICh2YWx1ZSAhPT0gbnVsbCA/ICI9IiArIFVSSS5lbmNvZGVRdWVyeSh2YWx1ZSwgZXNjYXBlUXVlcnlTcGFjZSkgOiAiIik7CiAgICAgICAgfTsKICAgICAgICBVUkkuYWRkUXVlcnkgPSBmdW5jdGlvbihkYXRhLCBuYW1lLCB2YWx1ZSkgewogICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAib2JqZWN0IikgewogICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkgewogICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChuYW1lLCBrZXkpKSB7CiAgICAgICAgICAgICAgICBVUkkuYWRkUXVlcnkoZGF0YSwga2V5LCBuYW1lW2tleV0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgaWYgKGRhdGFbbmFtZV0gPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSB2YWx1ZTsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFbbmFtZV0gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgZGF0YVtuYW1lXSA9IFtkYXRhW25hbWVdXTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7CiAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGRhdGFbbmFtZV0gPSAoZGF0YVtuYW1lXSB8fCBbXSkuY29uY2F0KHZhbHVlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVSSS5hZGRRdWVyeSgpIGFjY2VwdHMgYW4gb2JqZWN0LCBzdHJpbmcgYXMgdGhlIG5hbWUgcGFyYW1ldGVyIik7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBVUkkuc2V0UXVlcnkgPSBmdW5jdGlvbihkYXRhLCBuYW1lLCB2YWx1ZSkgewogICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAib2JqZWN0IikgewogICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkgewogICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChuYW1lLCBrZXkpKSB7CiAgICAgICAgICAgICAgICBVUkkuc2V0UXVlcnkoZGF0YSwga2V5LCBuYW1lW2tleV0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHZhbHVlID09PSB2b2lkIDAgPyBudWxsIDogdmFsdWU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVUkkuc2V0UXVlcnkoKSBhY2NlcHRzIGFuIG9iamVjdCwgc3RyaW5nIGFzIHRoZSBuYW1lIHBhcmFtZXRlciIpOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgVVJJLnJlbW92ZVF1ZXJ5ID0gZnVuY3Rpb24oZGF0YSwgbmFtZSwgdmFsdWUpIHsKICAgICAgICAgIHZhciBpLCBsZW5ndGgsIGtleTsKICAgICAgICAgIGlmIChpc0FycmF5KG5hbWUpKSB7CiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG5hbWUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICBkYXRhW25hbWVbaV1dID0gdm9pZCAwOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGdldFR5cGUobmFtZSkgPT09ICJSZWdFeHAiKSB7CiAgICAgICAgICAgIGZvciAoa2V5IGluIGRhdGEpIHsKICAgICAgICAgICAgICBpZiAobmFtZS50ZXN0KGtleSkpIHsKICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IHZvaWQgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICJvYmplY3QiKSB7CiAgICAgICAgICAgIGZvciAoa2V5IGluIG5hbWUpIHsKICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwobmFtZSwga2V5KSkgewogICAgICAgICAgICAgICAgVVJJLnJlbW92ZVF1ZXJ5KGRhdGEsIGtleSwgbmFtZVtrZXldKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgaWYgKGdldFR5cGUodmFsdWUpID09PSAiUmVnRXhwIikgewogICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGRhdGFbbmFtZV0pICYmIHZhbHVlLnRlc3QoZGF0YVtuYW1lXSkpIHsKICAgICAgICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHZvaWQgMDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSBmaWx0ZXJBcnJheVZhbHVlcyhkYXRhW25hbWVdLCB2YWx1ZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW25hbWVdID09PSBTdHJpbmcodmFsdWUpICYmICghaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAxKSkgewogICAgICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHZvaWQgMDsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YVtuYW1lXSkpIHsKICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSBmaWx0ZXJBcnJheVZhbHVlcyhkYXRhW25hbWVdLCB2YWx1ZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSB2b2lkIDA7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVSSS5yZW1vdmVRdWVyeSgpIGFjY2VwdHMgYW4gb2JqZWN0LCBzdHJpbmcsIFJlZ0V4cCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIik7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBVUkkuaGFzUXVlcnkgPSBmdW5jdGlvbihkYXRhLCBuYW1lLCB2YWx1ZSwgd2l0aGluQXJyYXkpIHsKICAgICAgICAgIHN3aXRjaCAoZ2V0VHlwZShuYW1lKSkgewogICAgICAgICAgICBjYXNlICJTdHJpbmciOgogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlICJSZWdFeHAiOgogICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7CiAgICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoZGF0YSwga2V5KSkgewogICAgICAgICAgICAgICAgICBpZiAobmFtZS50ZXN0KGtleSkgJiYgKHZhbHVlID09PSB2b2lkIDAgfHwgVVJJLmhhc1F1ZXJ5KGRhdGEsIGtleSwgdmFsdWUpKSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgY2FzZSAiT2JqZWN0IjoKICAgICAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIG5hbWUpIHsKICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChuYW1lLCBfa2V5KSkgewogICAgICAgICAgICAgICAgICBpZiAoIVVSSS5oYXNRdWVyeShkYXRhLCBfa2V5LCBuYW1lW19rZXldKSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVUkkuaGFzUXVlcnkoKSBhY2NlcHRzIGEgc3RyaW5nLCByZWd1bGFyIGV4cHJlc3Npb24gb3Igb2JqZWN0IGFzIHRoZSBuYW1lIHBhcmFtZXRlciIpOwogICAgICAgICAgfQogICAgICAgICAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkgewogICAgICAgICAgICBjYXNlICJVbmRlZmluZWQiOgogICAgICAgICAgICAgIHJldHVybiBuYW1lIGluIGRhdGE7CiAgICAgICAgICAgIGNhc2UgIkJvb2xlYW4iOgogICAgICAgICAgICAgIHZhciBfYm9vbHkgPSBCb29sZWFuKGlzQXJyYXkoZGF0YVtuYW1lXSkgPyBkYXRhW25hbWVdLmxlbmd0aCA6IGRhdGFbbmFtZV0pOwogICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gX2Jvb2x5OwogICAgICAgICAgICBjYXNlICJGdW5jdGlvbiI6CiAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWUoZGF0YVtuYW1lXSwgbmFtZSwgZGF0YSk7CiAgICAgICAgICAgIGNhc2UgIkFycmF5IjoKICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YVtuYW1lXSkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIG9wID0gd2l0aGluQXJyYXkgPyBhcnJheUNvbnRhaW5zIDogYXJyYXlzRXF1YWw7CiAgICAgICAgICAgICAgcmV0dXJuIG9wKGRhdGFbbmFtZV0sIHZhbHVlKTsKICAgICAgICAgICAgY2FzZSAiUmVnRXhwIjoKICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YVtuYW1lXSkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRhdGFbbmFtZV0gJiYgZGF0YVtuYW1lXS5tYXRjaCh2YWx1ZSkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIXdpdGhpbkFycmF5KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBhcnJheUNvbnRhaW5zKGRhdGFbbmFtZV0sIHZhbHVlKTsKICAgICAgICAgICAgY2FzZSAiTnVtYmVyIjoKICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7CiAgICAgICAgICAgIGNhc2UgIlN0cmluZyI6CiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGRhdGFbbmFtZV0pKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtuYW1lXSA9PT0gdmFsdWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghd2l0aGluQXJyYXkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5Q29udGFpbnMoZGF0YVtuYW1lXSwgdmFsdWUpOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVSSS5oYXNRdWVyeSgpIGFjY2VwdHMgdW5kZWZpbmVkLCBib29sZWFuLCBzdHJpbmcsIG51bWJlciwgUmVnRXhwLCBGdW5jdGlvbiBhcyB0aGUgdmFsdWUgcGFyYW1ldGVyIik7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBVUkkuam9pblBhdGhzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgaW5wdXQgPSBbXTsKICAgICAgICAgIHZhciBzZWdtZW50cyA9IFtdOwogICAgICAgICAgdmFyIG5vbkVtcHR5U2VnbWVudHMgPSAwOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgdmFyIHVybCA9IG5ldyBVUkkoYXJndW1lbnRzW2ldKTsKICAgICAgICAgICAgaW5wdXQucHVzaCh1cmwpOwogICAgICAgICAgICB2YXIgX3NlZ21lbnRzID0gdXJsLnNlZ21lbnQoKTsKICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBfc2VnbWVudHMubGVuZ3RoOyBzKyspIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIF9zZWdtZW50c1tzXSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goX3NlZ21lbnRzW3NdKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKF9zZWdtZW50c1tzXSkgewogICAgICAgICAgICAgICAgbm9uRW1wdHlTZWdtZW50cysrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKCFzZWdtZW50cy5sZW5ndGggfHwgIW5vbkVtcHR5U2VnbWVudHMpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkkoIiIpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHVyaSA9IG5ldyBVUkkoIiIpLnNlZ21lbnQoc2VnbWVudHMpOwogICAgICAgICAgaWYgKGlucHV0WzBdLnBhdGgoKSA9PT0gIiIgfHwgaW5wdXRbMF0ucGF0aCgpLnNsaWNlKDAsIDEpID09PSAiLyIpIHsKICAgICAgICAgICAgdXJpLnBhdGgoIi8iICsgdXJpLnBhdGgoKSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdXJpLm5vcm1hbGl6ZSgpOwogICAgICAgIH07CiAgICAgICAgVVJJLmNvbW1vblBhdGggPSBmdW5jdGlvbihvbmUsIHR3bykgewogICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKG9uZS5sZW5ndGgsIHR3by5sZW5ndGgpOwogICAgICAgICAgdmFyIHBvczsKICAgICAgICAgIGZvciAocG9zID0gMDsgcG9zIDwgbGVuZ3RoOyBwb3MrKykgewogICAgICAgICAgICBpZiAob25lLmNoYXJBdChwb3MpICE9PSB0d28uY2hhckF0KHBvcykpIHsKICAgICAgICAgICAgICBwb3MtLTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHBvcyA8IDEpIHsKICAgICAgICAgICAgcmV0dXJuIG9uZS5jaGFyQXQoMCkgPT09IHR3by5jaGFyQXQoMCkgJiYgb25lLmNoYXJBdCgwKSA9PT0gIi8iID8gIi8iIDogIiI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAob25lLmNoYXJBdChwb3MpICE9PSAiLyIgfHwgdHdvLmNoYXJBdChwb3MpICE9PSAiLyIpIHsKICAgICAgICAgICAgcG9zID0gb25lLnN1YnN0cmluZygwLCBwb3MpLmxhc3RJbmRleE9mKCIvIik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gb25lLnN1YnN0cmluZygwLCBwb3MgKyAxKTsKICAgICAgICB9OwogICAgICAgIFVSSS53aXRoaW5TdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCBvcHRpb25zKSB7CiAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pOwogICAgICAgICAgdmFyIF9zdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgVVJJLmZpbmRVcmkuc3RhcnQ7CiAgICAgICAgICB2YXIgX2VuZCA9IG9wdGlvbnMuZW5kIHx8IFVSSS5maW5kVXJpLmVuZDsKICAgICAgICAgIHZhciBfdHJpbSA9IG9wdGlvbnMudHJpbSB8fCBVUkkuZmluZFVyaS50cmltOwogICAgICAgICAgdmFyIF9wYXJlbnMgPSBvcHRpb25zLnBhcmVucyB8fCBVUkkuZmluZFVyaS5wYXJlbnM7CiAgICAgICAgICB2YXIgX2F0dHJpYnV0ZU9wZW4gPSAvW2EtejAtOS1dPVsiJ10/JC9pOwogICAgICAgICAgX3N0YXJ0Lmxhc3RJbmRleCA9IDA7CiAgICAgICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgICAgICB2YXIgbWF0Y2ggPSBfc3RhcnQuZXhlYyhzdHJpbmcpOwogICAgICAgICAgICBpZiAoIW1hdGNoKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWF0Y2guaW5kZXg7CiAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUh0bWwpIHsKICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlT3BlbiA9IHN0cmluZy5zbGljZShNYXRoLm1heChzdGFydCAtIDMsIDApLCBzdGFydCk7CiAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU9wZW4gJiYgX2F0dHJpYnV0ZU9wZW4udGVzdChhdHRyaWJ1dGVPcGVuKSkgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIHN0cmluZy5zbGljZShzdGFydCkuc2VhcmNoKF9lbmQpOwogICAgICAgICAgICB2YXIgc2xpY2UgPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIHZhciBwYXJlbnNFbmQgPSAtMTsKICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgICAgICB2YXIgcGFyZW5zTWF0Y2ggPSBfcGFyZW5zLmV4ZWMoc2xpY2UpOwogICAgICAgICAgICAgIGlmICghcGFyZW5zTWF0Y2gpIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgcGFyZW5zTWF0Y2hFbmQgPSBwYXJlbnNNYXRjaC5pbmRleCArIHBhcmVuc01hdGNoWzBdLmxlbmd0aDsKICAgICAgICAgICAgICBwYXJlbnNFbmQgPSBNYXRoLm1heChwYXJlbnNFbmQsIHBhcmVuc01hdGNoRW5kKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocGFyZW5zRW5kID4gLTEpIHsKICAgICAgICAgICAgICBzbGljZSA9IHNsaWNlLnNsaWNlKDAsIHBhcmVuc0VuZCkgKyBzbGljZS5zbGljZShwYXJlbnNFbmQpLnJlcGxhY2UoX3RyaW0sICIiKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzbGljZSA9IHNsaWNlLnJlcGxhY2UoX3RyaW0sICIiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc2xpY2UubGVuZ3RoIDw9IG1hdGNoWzBdLmxlbmd0aCkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZSAmJiBvcHRpb25zLmlnbm9yZS50ZXN0KHNsaWNlKSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgc2xpY2UubGVuZ3RoOwogICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soc2xpY2UsIHN0YXJ0LCBlbmQsIHN0cmluZyk7CiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIF9zdGFydC5sYXN0SW5kZXggPSBlbmQ7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nKHJlc3VsdCk7CiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBzdGFydCkgKyByZXN1bHQgKyBzdHJpbmcuc2xpY2UoZW5kKTsKICAgICAgICAgICAgX3N0YXJ0Lmxhc3RJbmRleCA9IHN0YXJ0ICsgcmVzdWx0Lmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIF9zdGFydC5sYXN0SW5kZXggPSAwOwogICAgICAgICAgcmV0dXJuIHN0cmluZzsKICAgICAgICB9OwogICAgICAgIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lID0gZnVuY3Rpb24odjIsIHByb3RvY29sKSB7CiAgICAgICAgICB2YXIgaGFzSG9zdG5hbWUgPSAhIXYyOwogICAgICAgICAgdmFyIGhhc1Byb3RvY29sID0gISFwcm90b2NvbDsKICAgICAgICAgIHZhciByZWplY3RFbXB0eUhvc3RuYW1lID0gZmFsc2U7CiAgICAgICAgICBpZiAoaGFzUHJvdG9jb2wpIHsKICAgICAgICAgICAgcmVqZWN0RW1wdHlIb3N0bmFtZSA9IGFycmF5Q29udGFpbnMoVVJJLmhvc3RQcm90b2NvbHMsIHByb3RvY29sKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChyZWplY3RFbXB0eUhvc3RuYW1lICYmICFoYXNIb3N0bmFtZSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJIb3N0bmFtZSBjYW5ub3QgYmUgZW1wdHksIGlmIHByb3RvY29sIGlzICIgKyBwcm90b2NvbCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHYyICYmIHYyLm1hdGNoKFVSSS5pbnZhbGlkX2hvc3RuYW1lX2NoYXJhY3RlcnMpKSB7CiAgICAgICAgICAgIGlmICghcHVueWNvZGUpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIb3N0bmFtZSAiJyArIHYyICsgJyIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTkuLTpfXSBhbmQgUHVueWNvZGUuanMgaXMgbm90IGF2YWlsYWJsZScpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChwdW55Y29kZS50b0FTQ0lJKHYyKS5tYXRjaChVUkkuaW52YWxpZF9ob3N0bmFtZV9jaGFyYWN0ZXJzKSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hvc3RuYW1lICInICsgdjIgKyAnIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tOl9dJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIFVSSS5lbnN1cmVWYWxpZFBvcnQgPSBmdW5jdGlvbih2MikgewogICAgICAgICAgaWYgKCF2MikgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcG9ydCA9IE51bWJlcih2Mik7CiAgICAgICAgICBpZiAoaXNJbnRlZ2VyKHBvcnQpICYmIHBvcnQgPiAwICYmIHBvcnQgPCA2NTUzNikgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3J0ICInICsgdjIgKyAnIiBpcyBub3QgYSB2YWxpZCBwb3J0Jyk7CiAgICAgICAgfTsKICAgICAgICBVUkkubm9Db25mbGljdCA9IGZ1bmN0aW9uKHJlbW92ZUFsbCkgewogICAgICAgICAgaWYgKHJlbW92ZUFsbCkgewogICAgICAgICAgICB2YXIgdW5jb25mbGljdGVkID0gewogICAgICAgICAgICAgIFVSSTogdGhpcy5ub0NvbmZsaWN0KCkKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHJvb3QuVVJJVGVtcGxhdGUgJiYgdHlwZW9mIHJvb3QuVVJJVGVtcGxhdGUubm9Db25mbGljdCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgIHVuY29uZmxpY3RlZC5VUklUZW1wbGF0ZSA9IHJvb3QuVVJJVGVtcGxhdGUubm9Db25mbGljdCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChyb290LklQdjYgJiYgdHlwZW9mIHJvb3QuSVB2Ni5ub0NvbmZsaWN0ID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgICAgdW5jb25mbGljdGVkLklQdjYgPSByb290LklQdjYubm9Db25mbGljdCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChyb290LlNlY29uZExldmVsRG9tYWlucyAmJiB0eXBlb2Ygcm9vdC5TZWNvbmRMZXZlbERvbWFpbnMubm9Db25mbGljdCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgIHVuY29uZmxpY3RlZC5TZWNvbmRMZXZlbERvbWFpbnMgPSByb290LlNlY29uZExldmVsRG9tYWlucy5ub0NvbmZsaWN0KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHVuY29uZmxpY3RlZDsKICAgICAgICAgIH0gZWxzZSBpZiAocm9vdC5VUkkgPT09IHRoaXMpIHsKICAgICAgICAgICAgcm9vdC5VUkkgPSBfVVJJOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfTsKICAgICAgICBwLmJ1aWxkID0gZnVuY3Rpb24oZGVmZXJCdWlsZCkgewogICAgICAgICAgaWYgKGRlZmVyQnVpbGQgPT09IHRydWUpIHsKICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWRfYnVpbGQgPSB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmIChkZWZlckJ1aWxkID09PSB2b2lkIDAgfHwgdGhpcy5fZGVmZXJyZWRfYnVpbGQpIHsKICAgICAgICAgICAgdGhpcy5fc3RyaW5nID0gVVJJLmJ1aWxkKHRoaXMuX3BhcnRzKTsKICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWRfYnVpbGQgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH07CiAgICAgICAgcC5jbG9uZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIG5ldyBVUkkodGhpcyk7CiAgICAgICAgfTsKICAgICAgICBwLnZhbHVlT2YgPSBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChmYWxzZSkuX3N0cmluZzsKICAgICAgICB9OwogICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoX3BhcnQyKSB7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odjIsIGJ1aWxkKSB7CiAgICAgICAgICAgIGlmICh2MiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzW19wYXJ0Ml0gfHwgIiI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy5fcGFydHNbX3BhcnQyXSA9IHYyIHx8IG51bGw7CiAgICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZVByZWZpeEFjY2Vzc29yKF9wYXJ0MiwgX2tleSkgewogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYyLCBidWlsZCkgewogICAgICAgICAgICBpZiAodjIgPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0c1tfcGFydDJdIHx8ICIiOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmICh2MiAhPT0gbnVsbCkgewogICAgICAgICAgICAgICAgdjIgPSB2MiArICIiOwogICAgICAgICAgICAgICAgaWYgKHYyLmNoYXJBdCgwKSA9PT0gX2tleSkgewogICAgICAgICAgICAgICAgICB2MiA9IHYyLnN1YnN0cmluZygxKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGhpcy5fcGFydHNbX3BhcnQyXSA9IHYyOwogICAgICAgICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTsKICAgICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcC5wcm90b2NvbCA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoInByb3RvY29sIik7CiAgICAgICAgcC51c2VybmFtZSA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoInVzZXJuYW1lIik7CiAgICAgICAgcC5wYXNzd29yZCA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoInBhc3N3b3JkIik7CiAgICAgICAgcC5ob3N0bmFtZSA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoImhvc3RuYW1lIik7CiAgICAgICAgcC5wb3J0ID0gZ2VuZXJhdGVTaW1wbGVBY2Nlc3NvcigicG9ydCIpOwogICAgICAgIHAucXVlcnkgPSBnZW5lcmF0ZVByZWZpeEFjY2Vzc29yKCJxdWVyeSIsICI/Iik7CiAgICAgICAgcC5mcmFnbWVudCA9IGdlbmVyYXRlUHJlZml4QWNjZXNzb3IoImZyYWdtZW50IiwgIiMiKTsKICAgICAgICBwLnNlYXJjaCA9IGZ1bmN0aW9uKHYyLCBidWlsZCkgewogICAgICAgICAgdmFyIHQgPSB0aGlzLnF1ZXJ5KHYyLCBidWlsZCk7CiAgICAgICAgICByZXR1cm4gdHlwZW9mIHQgPT09ICJzdHJpbmciICYmIHQubGVuZ3RoID8gIj8iICsgdCA6IHQ7CiAgICAgICAgfTsKICAgICAgICBwLmhhc2ggPSBmdW5jdGlvbih2MiwgYnVpbGQpIHsKICAgICAgICAgIHZhciB0ID0gdGhpcy5mcmFnbWVudCh2MiwgYnVpbGQpOwogICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ID09PSAic3RyaW5nIiAmJiB0Lmxlbmd0aCA/ICIjIiArIHQgOiB0OwogICAgICAgIH07CiAgICAgICAgcC5wYXRobmFtZSA9IGZ1bmN0aW9uKHYyLCBidWlsZCkgewogICAgICAgICAgaWYgKHYyID09PSB2b2lkIDAgfHwgdjIgPT09IHRydWUpIHsKICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3BhcnRzLnBhdGggfHwgKHRoaXMuX3BhcnRzLmhvc3RuYW1lID8gIi8iIDogIiIpOwogICAgICAgICAgICByZXR1cm4gdjIgPyAodGhpcy5fcGFydHMudXJuID8gVVJJLmRlY29kZVVyblBhdGggOiBVUkkuZGVjb2RlUGF0aCkocmVzKSA6IHJlczsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHsKICAgICAgICAgICAgICB0aGlzLl9wYXJ0cy5wYXRoID0gdjIgPyBVUkkucmVjb2RlVXJuUGF0aCh2MikgOiAiIjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLl9wYXJ0cy5wYXRoID0gdjIgPyBVUkkucmVjb2RlUGF0aCh2MikgOiAiLyI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIHAucGF0aCA9IHAucGF0aG5hbWU7CiAgICAgICAgcC5ocmVmID0gZnVuY3Rpb24oaHJlZiwgYnVpbGQpIHsKICAgICAgICAgIHZhciBrZXk7CiAgICAgICAgICBpZiAoaHJlZiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl9zdHJpbmcgPSAiIjsKICAgICAgICAgIHRoaXMuX3BhcnRzID0gVVJJLl9wYXJ0cygpOwogICAgICAgICAgdmFyIF9VUkkyID0gaHJlZiBpbnN0YW5jZW9mIFVSSTsKICAgICAgICAgIHZhciBfb2JqZWN0ID0gdHlwZW9mIGhyZWYgPT09ICJvYmplY3QiICYmIChocmVmLmhvc3RuYW1lIHx8IGhyZWYucGF0aCB8fCBocmVmLnBhdGhuYW1lKTsKICAgICAgICAgIGlmIChocmVmLm5vZGVOYW1lKSB7CiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBVUkkuZ2V0RG9tQXR0cmlidXRlKGhyZWYpOwogICAgICAgICAgICBocmVmID0gaHJlZlthdHRyaWJ1dGVdIHx8ICIiOwogICAgICAgICAgICBfb2JqZWN0ID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIV9VUkkyICYmIF9vYmplY3QgJiYgaHJlZi5wYXRobmFtZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGhyZWYgPSBocmVmLnRvU3RyaW5nKCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGhyZWYgPT09ICJzdHJpbmciIHx8IGhyZWYgaW5zdGFuY2VvZiBTdHJpbmcpIHsKICAgICAgICAgICAgdGhpcy5fcGFydHMgPSBVUkkucGFyc2UoU3RyaW5nKGhyZWYpLCB0aGlzLl9wYXJ0cyk7CiAgICAgICAgICB9IGVsc2UgaWYgKF9VUkkyIHx8IF9vYmplY3QpIHsKICAgICAgICAgICAgdmFyIHNyYyA9IF9VUkkyID8gaHJlZi5fcGFydHMgOiBocmVmOwogICAgICAgICAgICBmb3IgKGtleSBpbiBzcmMpIHsKICAgICAgICAgICAgICBpZiAoa2V5ID09PSAicXVlcnkiKSB7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKHRoaXMuX3BhcnRzLCBrZXkpKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0c1trZXldID0gc3JjW2tleV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzcmMucXVlcnkpIHsKICAgICAgICAgICAgICB0aGlzLnF1ZXJ5KHNyYy5xdWVyeSwgZmFsc2UpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIGlucHV0Iik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAuaXMgPSBmdW5jdGlvbih3aGF0KSB7CiAgICAgICAgICB2YXIgaXAgPSBmYWxzZTsKICAgICAgICAgIHZhciBpcDQgPSBmYWxzZTsKICAgICAgICAgIHZhciBpcDYgPSBmYWxzZTsKICAgICAgICAgIHZhciBuYW1lID0gZmFsc2U7CiAgICAgICAgICB2YXIgc2xkID0gZmFsc2U7CiAgICAgICAgICB2YXIgaWRuID0gZmFsc2U7CiAgICAgICAgICB2YXIgcHVueWNvZGUyID0gZmFsc2U7CiAgICAgICAgICB2YXIgcmVsYXRpdmUgPSAhdGhpcy5fcGFydHMudXJuOwogICAgICAgICAgaWYgKHRoaXMuX3BhcnRzLmhvc3RuYW1lKSB7CiAgICAgICAgICAgIHJlbGF0aXZlID0gZmFsc2U7CiAgICAgICAgICAgIGlwNCA9IFVSSS5pcDRfZXhwcmVzc2lvbi50ZXN0KHRoaXMuX3BhcnRzLmhvc3RuYW1lKTsKICAgICAgICAgICAgaXA2ID0gVVJJLmlwNl9leHByZXNzaW9uLnRlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpOwogICAgICAgICAgICBpcCA9IGlwNCB8fCBpcDY7CiAgICAgICAgICAgIG5hbWUgPSAhaXA7CiAgICAgICAgICAgIHNsZCA9IG5hbWUgJiYgU0xEICYmIFNMRC5oYXModGhpcy5fcGFydHMuaG9zdG5hbWUpOwogICAgICAgICAgICBpZG4gPSBuYW1lICYmIFVSSS5pZG5fZXhwcmVzc2lvbi50ZXN0KHRoaXMuX3BhcnRzLmhvc3RuYW1lKTsKICAgICAgICAgICAgcHVueWNvZGUyID0gbmFtZSAmJiBVUkkucHVueWNvZGVfZXhwcmVzc2lvbi50ZXN0KHRoaXMuX3BhcnRzLmhvc3RuYW1lKTsKICAgICAgICAgIH0KICAgICAgICAgIHN3aXRjaCAod2hhdC50b0xvd2VyQ2FzZSgpKSB7CiAgICAgICAgICAgIGNhc2UgInJlbGF0aXZlIjoKICAgICAgICAgICAgICByZXR1cm4gcmVsYXRpdmU7CiAgICAgICAgICAgIGNhc2UgImFic29sdXRlIjoKICAgICAgICAgICAgICByZXR1cm4gIXJlbGF0aXZlOwogICAgICAgICAgICBjYXNlICJkb21haW4iOgogICAgICAgICAgICBjYXNlICJuYW1lIjoKICAgICAgICAgICAgICByZXR1cm4gbmFtZTsKICAgICAgICAgICAgY2FzZSAic2xkIjoKICAgICAgICAgICAgICByZXR1cm4gc2xkOwogICAgICAgICAgICBjYXNlICJpcCI6CiAgICAgICAgICAgICAgcmV0dXJuIGlwOwogICAgICAgICAgICBjYXNlICJpcDQiOgogICAgICAgICAgICBjYXNlICJpcHY0IjoKICAgICAgICAgICAgY2FzZSAiaW5ldDQiOgogICAgICAgICAgICAgIHJldHVybiBpcDQ7CiAgICAgICAgICAgIGNhc2UgImlwNiI6CiAgICAgICAgICAgIGNhc2UgImlwdjYiOgogICAgICAgICAgICBjYXNlICJpbmV0NiI6CiAgICAgICAgICAgICAgcmV0dXJuIGlwNjsKICAgICAgICAgICAgY2FzZSAiaWRuIjoKICAgICAgICAgICAgICByZXR1cm4gaWRuOwogICAgICAgICAgICBjYXNlICJ1cmwiOgogICAgICAgICAgICAgIHJldHVybiAhdGhpcy5fcGFydHMudXJuOwogICAgICAgICAgICBjYXNlICJ1cm4iOgogICAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX3BhcnRzLnVybjsKICAgICAgICAgICAgY2FzZSAicHVueWNvZGUiOgogICAgICAgICAgICAgIHJldHVybiBwdW55Y29kZTI7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9OwogICAgICAgIHZhciBfcHJvdG9jb2wgPSBwLnByb3RvY29sOwogICAgICAgIHZhciBfcG9ydCA9IHAucG9ydDsKICAgICAgICB2YXIgX2hvc3RuYW1lID0gcC5ob3N0bmFtZTsKICAgICAgICBwLnByb3RvY29sID0gZnVuY3Rpb24odjIsIGJ1aWxkKSB7CiAgICAgICAgICBpZiAodjIpIHsKICAgICAgICAgICAgdjIgPSB2Mi5yZXBsYWNlKC86KFwvXC8pPyQvLCAiIik7CiAgICAgICAgICAgIGlmICghdjIubWF0Y2goVVJJLnByb3RvY29sX2V4cHJlc3Npb24pKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdG9jb2wgIicgKyB2MiArIGAiIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05ListXSBvciBkb2Vzbid0IHN0YXJ0IHdpdGggW0EtWl1gKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIF9wcm90b2NvbC5jYWxsKHRoaXMsIHYyLCBidWlsZCk7CiAgICAgICAgfTsKICAgICAgICBwLnNjaGVtZSA9IHAucHJvdG9jb2w7CiAgICAgICAgcC5wb3J0ID0gZnVuY3Rpb24odjIsIGJ1aWxkKSB7CiAgICAgICAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHJldHVybiB2MiA9PT0gdm9pZCAwID8gIiIgOiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHYyICE9PSB2b2lkIDApIHsKICAgICAgICAgICAgaWYgKHYyID09PSAwKSB7CiAgICAgICAgICAgICAgdjIgPSBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2MikgewogICAgICAgICAgICAgIHYyICs9ICIiOwogICAgICAgICAgICAgIGlmICh2Mi5jaGFyQXQoMCkgPT09ICI6IikgewogICAgICAgICAgICAgICAgdjIgPSB2Mi5zdWJzdHJpbmcoMSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIFVSSS5lbnN1cmVWYWxpZFBvcnQodjIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gX3BvcnQuY2FsbCh0aGlzLCB2MiwgYnVpbGQpOwogICAgICAgIH07CiAgICAgICAgcC5ob3N0bmFtZSA9IGZ1bmN0aW9uKHYyLCBidWlsZCkgewogICAgICAgICAgaWYgKHRoaXMuX3BhcnRzLnVybikgewogICAgICAgICAgICByZXR1cm4gdjIgPT09IHZvaWQgMCA/ICIiIDogdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2MiAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHZhciB4ID0geyBwcmV2ZW50SW52YWxpZEhvc3RuYW1lOiB0aGlzLl9wYXJ0cy5wcmV2ZW50SW52YWxpZEhvc3RuYW1lIH07CiAgICAgICAgICAgIHZhciByZXMgPSBVUkkucGFyc2VIb3N0KHYyLCB4KTsKICAgICAgICAgICAgaWYgKHJlcyAhPT0gIi8iKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgIicgKyB2MiArICciIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05Li1dJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdjIgPSB4Lmhvc3RuYW1lOwogICAgICAgICAgICBpZiAodGhpcy5fcGFydHMucHJldmVudEludmFsaWRIb3N0bmFtZSkgewogICAgICAgICAgICAgIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lKHYyLCB0aGlzLl9wYXJ0cy5wcm90b2NvbCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfaG9zdG5hbWUuY2FsbCh0aGlzLCB2MiwgYnVpbGQpOwogICAgICAgIH07CiAgICAgICAgcC5vcmlnaW4gPSBmdW5jdGlvbih2MiwgYnVpbGQpIHsKICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHsKICAgICAgICAgICAgcmV0dXJuIHYyID09PSB2b2lkIDAgPyAiIiA6IHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodjIgPT09IHZvaWQgMCkgewogICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sKCk7CiAgICAgICAgICAgIHZhciBhdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eSgpOwogICAgICAgICAgICBpZiAoIWF1dGhvcml0eSkgewogICAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gKHByb3RvY29sID8gcHJvdG9jb2wgKyAiOi8vIiA6ICIiKSArIHRoaXMuYXV0aG9yaXR5KCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgb3JpZ2luID0gVVJJKHYyKTsKICAgICAgICAgICAgdGhpcy5wcm90b2NvbChvcmlnaW4ucHJvdG9jb2woKSkuYXV0aG9yaXR5KG9yaWdpbi5hdXRob3JpdHkoKSkuYnVpbGQoIWJ1aWxkKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBwLmhvc3QgPSBmdW5jdGlvbih2MiwgYnVpbGQpIHsKICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHsKICAgICAgICAgICAgcmV0dXJuIHYyID09PSB2b2lkIDAgPyAiIiA6IHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodjIgPT09IHZvaWQgMCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydHMuaG9zdG5hbWUgPyBVUkkuYnVpbGRIb3N0KHRoaXMuX3BhcnRzKSA6ICIiOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIHJlcyA9IFVSSS5wYXJzZUhvc3QodjIsIHRoaXMuX3BhcnRzKTsKICAgICAgICAgICAgaWYgKHJlcyAhPT0gIi8iKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgIicgKyB2MiArICciIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05Li1dJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIHAuYXV0aG9yaXR5ID0gZnVuY3Rpb24odjIsIGJ1aWxkKSB7CiAgICAgICAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHJldHVybiB2MiA9PT0gdm9pZCAwID8gIiIgOiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHYyID09PSB2b2lkIDApIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLmhvc3RuYW1lID8gVVJJLmJ1aWxkQXV0aG9yaXR5KHRoaXMuX3BhcnRzKSA6ICIiOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIHJlcyA9IFVSSS5wYXJzZUF1dGhvcml0eSh2MiwgdGhpcy5fcGFydHMpOwogICAgICAgICAgICBpZiAocmVzICE9PSAiLyIpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIb3N0bmFtZSAiJyArIHYyICsgJyIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTkuLV0nKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgcC51c2VyaW5mbyA9IGZ1bmN0aW9uKHYyLCBidWlsZCkgewogICAgICAgICAgaWYgKHRoaXMuX3BhcnRzLnVybikgewogICAgICAgICAgICByZXR1cm4gdjIgPT09IHZvaWQgMCA/ICIiIDogdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2MiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHZhciB0ID0gVVJJLmJ1aWxkVXNlcmluZm8odGhpcy5fcGFydHMpOwogICAgICAgICAgICByZXR1cm4gdCA/IHQuc3Vic3RyaW5nKDAsIHQubGVuZ3RoIC0gMSkgOiB0OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKHYyW3YyLmxlbmd0aCAtIDFdICE9PSAiQCIpIHsKICAgICAgICAgICAgICB2MiArPSAiQCI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgVVJJLnBhcnNlVXNlcmluZm8odjIsIHRoaXMuX3BhcnRzKTsKICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIHAucmVzb3VyY2UgPSBmdW5jdGlvbih2MiwgYnVpbGQpIHsKICAgICAgICAgIHZhciBwYXJ0czsKICAgICAgICAgIGlmICh2MiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgoKSArIHRoaXMuc2VhcmNoKCkgKyB0aGlzLmhhc2goKTsKICAgICAgICAgIH0KICAgICAgICAgIHBhcnRzID0gVVJJLnBhcnNlKHYyKTsKICAgICAgICAgIHRoaXMuX3BhcnRzLnBhdGggPSBwYXJ0cy5wYXRoOwogICAgICAgICAgdGhpcy5fcGFydHMucXVlcnkgPSBwYXJ0cy5xdWVyeTsKICAgICAgICAgIHRoaXMuX3BhcnRzLmZyYWdtZW50ID0gcGFydHMuZnJhZ21lbnQ7CiAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAuc3ViZG9tYWluID0gZnVuY3Rpb24odjIsIGJ1aWxkKSB7CiAgICAgICAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHJldHVybiB2MiA9PT0gdm9pZCAwID8gIiIgOiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHYyID09PSB2b2lkIDApIHsKICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5ob3N0bmFtZSB8fCB0aGlzLmlzKCJJUCIpKSB7CiAgICAgICAgICAgICAgcmV0dXJuICIiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5sZW5ndGggLSB0aGlzLmRvbWFpbigpLmxlbmd0aCAtIDE7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoMCwgZW5kKSB8fCAiIjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBlID0gdGhpcy5fcGFydHMuaG9zdG5hbWUubGVuZ3RoIC0gdGhpcy5kb21haW4oKS5sZW5ndGg7CiAgICAgICAgICAgIHZhciBzdWIgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoMCwgZSk7CiAgICAgICAgICAgIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cCgiXiIgKyBlc2NhcGVSZWdFeChzdWIpKTsKICAgICAgICAgICAgaWYgKHYyICYmIHYyLmNoYXJBdCh2Mi5sZW5ndGggLSAxKSAhPT0gIi4iKSB7CiAgICAgICAgICAgICAgdjIgKz0gIi4iOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2Mi5pbmRleE9mKCI6IikgIT09IC0xKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRG9tYWlucyBjYW5ub3QgY29udGFpbiBjb2xvbnMiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodjIpIHsKICAgICAgICAgICAgICBVUkkuZW5zdXJlVmFsaWRIb3N0bmFtZSh2MiwgdGhpcy5fcGFydHMucHJvdG9jb2wpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gdGhpcy5fcGFydHMuaG9zdG5hbWUucmVwbGFjZShyZXBsYWNlLCB2Mik7CiAgICAgICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBwLmRvbWFpbiA9IGZ1bmN0aW9uKHYyLCBidWlsZCkgewogICAgICAgICAgaWYgKHRoaXMuX3BhcnRzLnVybikgewogICAgICAgICAgICByZXR1cm4gdjIgPT09IHZvaWQgMCA/ICIiIDogdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgdjIgPT09ICJib29sZWFuIikgewogICAgICAgICAgICBidWlsZCA9IHYyOwogICAgICAgICAgICB2MiA9IHZvaWQgMDsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2MiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5fcGFydHMuaG9zdG5hbWUgfHwgdGhpcy5pcygiSVAiKSkgewogICAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgdCA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLm1hdGNoKC9cLi9nKTsKICAgICAgICAgICAgaWYgKHQgJiYgdC5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLmhvc3RuYW1lOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5sZW5ndGggLSB0aGlzLnRsZChidWlsZCkubGVuZ3RoIC0gMTsKICAgICAgICAgICAgZW5kID0gdGhpcy5fcGFydHMuaG9zdG5hbWUubGFzdEluZGV4T2YoIi4iLCBlbmQgLSAxKSArIDE7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoZW5kKSB8fCAiIjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmICghdjIpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYW5ub3Qgc2V0IGRvbWFpbiBlbXB0eSIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2Mi5pbmRleE9mKCI6IikgIT09IC0xKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRG9tYWlucyBjYW5ub3QgY29udGFpbiBjb2xvbnMiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBVUkkuZW5zdXJlVmFsaWRIb3N0bmFtZSh2MiwgdGhpcy5fcGFydHMucHJvdG9jb2wpOwogICAgICAgICAgICBpZiAoIXRoaXMuX3BhcnRzLmhvc3RuYW1lIHx8IHRoaXMuaXMoIklQIikpIHsKICAgICAgICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IHYyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeCh0aGlzLmRvbWFpbigpKSArICIkIik7CiAgICAgICAgICAgICAgdGhpcy5fcGFydHMuaG9zdG5hbWUgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5yZXBsYWNlKHJlcGxhY2UsIHYyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgcC50bGQgPSBmdW5jdGlvbih2MiwgYnVpbGQpIHsKICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHsKICAgICAgICAgICAgcmV0dXJuIHYyID09PSB2b2lkIDAgPyAiIiA6IHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIHYyID09PSAiYm9vbGVhbiIpIHsKICAgICAgICAgICAgYnVpbGQgPSB2MjsKICAgICAgICAgICAgdjIgPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodjIgPT09IHZvaWQgMCkgewogICAgICAgICAgICBpZiAoIXRoaXMuX3BhcnRzLmhvc3RuYW1lIHx8IHRoaXMuaXMoIklQIikpIHsKICAgICAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLmxhc3RJbmRleE9mKCIuIik7CiAgICAgICAgICAgIHZhciB0bGQgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcocG9zICsgMSk7CiAgICAgICAgICAgIGlmIChidWlsZCAhPT0gdHJ1ZSAmJiBTTEQgJiYgU0xELmxpc3RbdGxkLnRvTG93ZXJDYXNlKCldKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFNMRC5nZXQodGhpcy5fcGFydHMuaG9zdG5hbWUpIHx8IHRsZDsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGxkOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIHJlcGxhY2U7CiAgICAgICAgICAgIGlmICghdjIpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYW5ub3Qgc2V0IFRMRCBlbXB0eSIpOwogICAgICAgICAgICB9IGVsc2UgaWYgKHYyLm1hdGNoKC9bXmEtekEtWjAtOS1dLykpIHsKICAgICAgICAgICAgICBpZiAoU0xEICYmIFNMRC5pcyh2MikpIHsKICAgICAgICAgICAgICAgIHJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4KHRoaXMudGxkKCkpICsgIiQiKTsKICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gdGhpcy5fcGFydHMuaG9zdG5hbWUucmVwbGFjZShyZXBsYWNlLCB2Mik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RMRCAiJyArIHYyICsgJyIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTldJyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wYXJ0cy5ob3N0bmFtZSB8fCB0aGlzLmlzKCJJUCIpKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCJjYW5ub3Qgc2V0IFRMRCBvbiBub24tZG9tYWluIGhvc3QiKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeCh0aGlzLnRsZCgpKSArICIkIik7CiAgICAgICAgICAgICAgdGhpcy5fcGFydHMuaG9zdG5hbWUgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5yZXBsYWNlKHJlcGxhY2UsIHYyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgcC5kaXJlY3RvcnkgPSBmdW5jdGlvbih2MiwgYnVpbGQpIHsKICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHsKICAgICAgICAgICAgcmV0dXJuIHYyID09PSB2b2lkIDAgPyAiIiA6IHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodjIgPT09IHZvaWQgMCB8fCB2MiA9PT0gdHJ1ZSkgewogICAgICAgICAgICBpZiAoIXRoaXMuX3BhcnRzLnBhdGggJiYgIXRoaXMuX3BhcnRzLmhvc3RuYW1lKSB7CiAgICAgICAgICAgICAgcmV0dXJuICIiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy5wYXRoID09PSAiLyIpIHsKICAgICAgICAgICAgICByZXR1cm4gIi8iOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9wYXJ0cy5wYXRoLmxlbmd0aCAtIHRoaXMuZmlsZW5hbWUoKS5sZW5ndGggLSAxOwogICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fcGFydHMucGF0aC5zdWJzdHJpbmcoMCwgZW5kKSB8fCAodGhpcy5fcGFydHMuaG9zdG5hbWUgPyAiLyIgOiAiIik7CiAgICAgICAgICAgIHJldHVybiB2MiA/IFVSSS5kZWNvZGVQYXRoKHJlcykgOiByZXM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgZSA9IHRoaXMuX3BhcnRzLnBhdGgubGVuZ3RoIC0gdGhpcy5maWxlbmFtZSgpLmxlbmd0aDsKICAgICAgICAgICAgdmFyIGRpcmVjdG9yeSA9IHRoaXMuX3BhcnRzLnBhdGguc3Vic3RyaW5nKDAsIGUpOwogICAgICAgICAgICB2YXIgcmVwbGFjZSA9IG5ldyBSZWdFeHAoIl4iICsgZXNjYXBlUmVnRXgoZGlyZWN0b3J5KSk7CiAgICAgICAgICAgIGlmICghdGhpcy5pcygicmVsYXRpdmUiKSkgewogICAgICAgICAgICAgIGlmICghdjIpIHsKICAgICAgICAgICAgICAgIHYyID0gIi8iOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAodjIuY2hhckF0KDApICE9PSAiLyIpIHsKICAgICAgICAgICAgICAgIHYyID0gIi8iICsgdjI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2MiAmJiB2Mi5jaGFyQXQodjIubGVuZ3RoIC0gMSkgIT09ICIvIikgewogICAgICAgICAgICAgIHYyICs9ICIvIjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2MiA9IFVSSS5yZWNvZGVQYXRoKHYyKTsKICAgICAgICAgICAgdGhpcy5fcGFydHMucGF0aCA9IHRoaXMuX3BhcnRzLnBhdGgucmVwbGFjZShyZXBsYWNlLCB2Mik7CiAgICAgICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBwLmZpbGVuYW1lID0gZnVuY3Rpb24odjIsIGJ1aWxkKSB7CiAgICAgICAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHJldHVybiB2MiA9PT0gdm9pZCAwID8gIiIgOiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiB2MiAhPT0gInN0cmluZyIpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5wYXRoIHx8IHRoaXMuX3BhcnRzLnBhdGggPT09ICIvIikgewogICAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5fcGFydHMucGF0aC5sYXN0SW5kZXhPZigiLyIpOwogICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fcGFydHMucGF0aC5zdWJzdHJpbmcocG9zICsgMSk7CiAgICAgICAgICAgIHJldHVybiB2MiA/IFVSSS5kZWNvZGVQYXRoU2VnbWVudChyZXMpIDogcmVzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIG11dGF0ZWREaXJlY3RvcnkgPSBmYWxzZTsKICAgICAgICAgICAgaWYgKHYyLmNoYXJBdCgwKSA9PT0gIi8iKSB7CiAgICAgICAgICAgICAgdjIgPSB2Mi5zdWJzdHJpbmcoMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHYyLm1hdGNoKC9cLj9cLy8pKSB7CiAgICAgICAgICAgICAgbXV0YXRlZERpcmVjdG9yeSA9IHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4KHRoaXMuZmlsZW5hbWUoKSkgKyAiJCIpOwogICAgICAgICAgICB2MiA9IFVSSS5yZWNvZGVQYXRoKHYyKTsKICAgICAgICAgICAgdGhpcy5fcGFydHMucGF0aCA9IHRoaXMuX3BhcnRzLnBhdGgucmVwbGFjZShyZXBsYWNlLCB2Mik7CiAgICAgICAgICAgIGlmIChtdXRhdGVkRGlyZWN0b3J5KSB7CiAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVQYXRoKGJ1aWxkKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBwLnN1ZmZpeCA9IGZ1bmN0aW9uKHYyLCBidWlsZCkgewogICAgICAgICAgaWYgKHRoaXMuX3BhcnRzLnVybikgewogICAgICAgICAgICByZXR1cm4gdjIgPT09IHZvaWQgMCA/ICIiIDogdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2MiA9PT0gdm9pZCAwIHx8IHYyID09PSB0cnVlKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5fcGFydHMucGF0aCB8fCB0aGlzLl9wYXJ0cy5wYXRoID09PSAiLyIpIHsKICAgICAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gdGhpcy5maWxlbmFtZSgpOwogICAgICAgICAgICB2YXIgcG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoIi4iKTsKICAgICAgICAgICAgdmFyIHMsIHJlczsKICAgICAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHsKICAgICAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcyA9IGZpbGVuYW1lLnN1YnN0cmluZyhwb3MgKyAxKTsKICAgICAgICAgICAgcmVzID0gL15bYS16MC05JV0rJC9pLnRlc3QocykgPyBzIDogIiI7CiAgICAgICAgICAgIHJldHVybiB2MiA/IFVSSS5kZWNvZGVQYXRoU2VnbWVudChyZXMpIDogcmVzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKHYyLmNoYXJBdCgwKSA9PT0gIi4iKSB7CiAgICAgICAgICAgICAgdjIgPSB2Mi5zdWJzdHJpbmcoMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHRoaXMuc3VmZml4KCk7CiAgICAgICAgICAgIHZhciByZXBsYWNlOwogICAgICAgICAgICBpZiAoIXN1ZmZpeCkgewogICAgICAgICAgICAgIGlmICghdjIpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB0aGlzLl9wYXJ0cy5wYXRoICs9ICIuIiArIFVSSS5yZWNvZGVQYXRoKHYyKTsKICAgICAgICAgICAgfSBlbHNlIGlmICghdjIpIHsKICAgICAgICAgICAgICByZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeCgiLiIgKyBzdWZmaXgpICsgIiQiKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeChzdWZmaXgpICsgIiQiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocmVwbGFjZSkgewogICAgICAgICAgICAgIHYyID0gVVJJLnJlY29kZVBhdGgodjIpOwogICAgICAgICAgICAgIHRoaXMuX3BhcnRzLnBhdGggPSB0aGlzLl9wYXJ0cy5wYXRoLnJlcGxhY2UocmVwbGFjZSwgdjIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBwLnNlZ21lbnQgPSBmdW5jdGlvbihzZWdtZW50LCB2MiwgYnVpbGQpIHsKICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSB0aGlzLl9wYXJ0cy51cm4gPyAiOiIgOiAiLyI7CiAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCgpOwogICAgICAgICAgdmFyIGFic29sdXRlID0gcGF0aC5zdWJzdHJpbmcoMCwgMSkgPT09ICIvIjsKICAgICAgICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoc2VwYXJhdG9yKTsKICAgICAgICAgIGlmIChzZWdtZW50ICE9PSB2b2lkIDAgJiYgdHlwZW9mIHNlZ21lbnQgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICAgIGJ1aWxkID0gdjI7CiAgICAgICAgICAgIHYyID0gc2VnbWVudDsKICAgICAgICAgICAgc2VnbWVudCA9IHZvaWQgMDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzZWdtZW50ICE9PSB2b2lkIDAgJiYgdHlwZW9mIHNlZ21lbnQgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHNlZ21lbnQgIicgKyBzZWdtZW50ICsgJyIsIG11c3QgYmUgMC1iYXNlZCBpbnRlZ2VyJyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYWJzb2x1dGUpIHsKICAgICAgICAgICAgc2VnbWVudHMuc2hpZnQoKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzZWdtZW50IDwgMCkgewogICAgICAgICAgICBzZWdtZW50ID0gTWF0aC5tYXgoc2VnbWVudHMubGVuZ3RoICsgc2VnbWVudCwgMCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodjIgPT09IHZvaWQgMCkgewogICAgICAgICAgICByZXR1cm4gc2VnbWVudCA9PT0gdm9pZCAwID8gc2VnbWVudHMgOiBzZWdtZW50c1tzZWdtZW50XTsKICAgICAgICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gbnVsbCB8fCBzZWdtZW50c1tzZWdtZW50XSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGlmIChpc0FycmF5KHYyKSkgewogICAgICAgICAgICAgIHNlZ21lbnRzID0gW107CiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2Mi5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICAgIGlmICghdjJbaV0ubGVuZ3RoICYmICghc2VnbWVudHMubGVuZ3RoIHx8ICFzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5sZW5ndGgpKSB7CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCAmJiAhc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh0cmltU2xhc2hlcyh2MltpXSkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIGlmICh2MiB8fCB0eXBlb2YgdjIgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgdjIgPSB0cmltU2xhc2hlcyh2Mik7CiAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID09PSAiIikgewogICAgICAgICAgICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0gPSB2MjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh2Mik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBpZiAodjIpIHsKICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50XSA9IHRyaW1TbGFzaGVzKHYyKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzZWdtZW50cy5zcGxpY2Uoc2VnbWVudCwgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChhYnNvbHV0ZSkgewogICAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KCIiKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgoc2VnbWVudHMuam9pbihzZXBhcmF0b3IpLCBidWlsZCk7CiAgICAgICAgfTsKICAgICAgICBwLnNlZ21lbnRDb2RlZCA9IGZ1bmN0aW9uKHNlZ21lbnQsIHYyLCBidWlsZCkgewogICAgICAgICAgdmFyIHNlZ21lbnRzLCBpLCBsOwogICAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ICE9PSAibnVtYmVyIikgewogICAgICAgICAgICBidWlsZCA9IHYyOwogICAgICAgICAgICB2MiA9IHNlZ21lbnQ7CiAgICAgICAgICAgIHNlZ21lbnQgPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodjIgPT09IHZvaWQgMCkgewogICAgICAgICAgICBzZWdtZW50cyA9IHRoaXMuc2VnbWVudChzZWdtZW50LCB2MiwgYnVpbGQpOwogICAgICAgICAgICBpZiAoIWlzQXJyYXkoc2VnbWVudHMpKSB7CiAgICAgICAgICAgICAgc2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdm9pZCAwID8gVVJJLmRlY29kZShzZWdtZW50cykgOiB2b2lkIDA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgICAgc2VnbWVudHNbaV0gPSBVUkkuZGVjb2RlKHNlZ21lbnRzW2ldKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRzOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCFpc0FycmF5KHYyKSkgewogICAgICAgICAgICB2MiA9IHR5cGVvZiB2MiA9PT0gInN0cmluZyIgfHwgdjIgaW5zdGFuY2VvZiBTdHJpbmcgPyBVUkkuZW5jb2RlKHYyKSA6IHYyOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHYyLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHYyW2ldID0gVVJJLmVuY29kZSh2MltpXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnQoc2VnbWVudCwgdjIsIGJ1aWxkKTsKICAgICAgICB9OwogICAgICAgIHZhciBxID0gcC5xdWVyeTsKICAgICAgICBwLnF1ZXJ5ID0gZnVuY3Rpb24odjIsIGJ1aWxkKSB7CiAgICAgICAgICBpZiAodjIgPT09IHRydWUpIHsKICAgICAgICAgICAgcmV0dXJuIFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIHZhciBkYXRhID0gVVJJLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgICB2YXIgcmVzdWx0ID0gdjIuY2FsbCh0aGlzLCBkYXRhKTsKICAgICAgICAgICAgdGhpcy5fcGFydHMucXVlcnkgPSBVUkkuYnVpbGRRdWVyeShyZXN1bHQgfHwgZGF0YSwgdGhpcy5fcGFydHMuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTsKICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0gZWxzZSBpZiAodjIgIT09IHZvaWQgMCAmJiB0eXBlb2YgdjIgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMuX3BhcnRzLnF1ZXJ5ID0gVVJJLmJ1aWxkUXVlcnkodjIsIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7CiAgICAgICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gcS5jYWxsKHRoaXMsIHYyLCBidWlsZCk7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBwLnNldFF1ZXJ5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIGJ1aWxkKSB7CiAgICAgICAgICB2YXIgZGF0YSA9IFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTsKICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gInN0cmluZyIgfHwgbmFtZSBpbnN0YW5jZW9mIFN0cmluZykgewogICAgICAgICAgICBkYXRhW25hbWVdID0gdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogbnVsbDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICJvYmplY3QiKSB7CiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7CiAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG5hbWUsIGtleSkpIHsKICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IG5hbWVba2V5XTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVSSS5hZGRRdWVyeSgpIGFjY2VwdHMgYW4gb2JqZWN0LCBzdHJpbmcgYXMgdGhlIG5hbWUgcGFyYW1ldGVyIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl9wYXJ0cy5xdWVyeSA9IFVSSS5idWlsZFF1ZXJ5KGRhdGEsIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7CiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGJ1aWxkID0gdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAuYWRkUXVlcnkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgYnVpbGQpIHsKICAgICAgICAgIHZhciBkYXRhID0gVVJJLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgVVJJLmFkZFF1ZXJ5KGRhdGEsIG5hbWUsIHZhbHVlID09PSB2b2lkIDAgPyBudWxsIDogdmFsdWUpOwogICAgICAgICAgdGhpcy5fcGFydHMucXVlcnkgPSBVUkkuYnVpbGRRdWVyeShkYXRhLCB0aGlzLl9wYXJ0cy5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAic3RyaW5nIikgewogICAgICAgICAgICBidWlsZCA9IHZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfTsKICAgICAgICBwLnJlbW92ZVF1ZXJ5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIGJ1aWxkKSB7CiAgICAgICAgICB2YXIgZGF0YSA9IFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTsKICAgICAgICAgIFVSSS5yZW1vdmVRdWVyeShkYXRhLCBuYW1lLCB2YWx1ZSk7CiAgICAgICAgICB0aGlzLl9wYXJ0cy5xdWVyeSA9IFVSSS5idWlsZFF1ZXJ5KGRhdGEsIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7CiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGJ1aWxkID0gdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAuaGFzUXVlcnkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgd2l0aGluQXJyYXkpIHsKICAgICAgICAgIHZhciBkYXRhID0gVVJJLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgcmV0dXJuIFVSSS5oYXNRdWVyeShkYXRhLCBuYW1lLCB2YWx1ZSwgd2l0aGluQXJyYXkpOwogICAgICAgIH07CiAgICAgICAgcC5zZXRTZWFyY2ggPSBwLnNldFF1ZXJ5OwogICAgICAgIHAuYWRkU2VhcmNoID0gcC5hZGRRdWVyeTsKICAgICAgICBwLnJlbW92ZVNlYXJjaCA9IHAucmVtb3ZlUXVlcnk7CiAgICAgICAgcC5oYXNTZWFyY2ggPSBwLmhhc1F1ZXJ5OwogICAgICAgIHAubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZVByb3RvY29sKGZhbHNlKS5ub3JtYWxpemVQYXRoKGZhbHNlKS5ub3JtYWxpemVRdWVyeShmYWxzZSkubm9ybWFsaXplRnJhZ21lbnQoZmFsc2UpLmJ1aWxkKCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVQcm90b2NvbChmYWxzZSkubm9ybWFsaXplSG9zdG5hbWUoZmFsc2UpLm5vcm1hbGl6ZVBvcnQoZmFsc2UpLm5vcm1hbGl6ZVBhdGgoZmFsc2UpLm5vcm1hbGl6ZVF1ZXJ5KGZhbHNlKS5ub3JtYWxpemVGcmFnbWVudChmYWxzZSkuYnVpbGQoKTsKICAgICAgICB9OwogICAgICAgIHAubm9ybWFsaXplUHJvdG9jb2wgPSBmdW5jdGlvbihidWlsZCkgewogICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9wYXJ0cy5wcm90b2NvbCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhpcy5fcGFydHMucHJvdG9jb2wgPSB0aGlzLl9wYXJ0cy5wcm90b2NvbC50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAubm9ybWFsaXplSG9zdG5hbWUgPSBmdW5jdGlvbihidWlsZCkgewogICAgICAgICAgaWYgKHRoaXMuX3BhcnRzLmhvc3RuYW1lKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmlzKCJJRE4iKSAmJiBwdW55Y29kZSkgewogICAgICAgICAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLl9wYXJ0cy5ob3N0bmFtZSk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pcygiSVB2NiIpICYmIElQdjYpIHsKICAgICAgICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IElQdjYuYmVzdCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5fcGFydHMuaG9zdG5hbWUgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAubm9ybWFsaXplUG9ydCA9IGZ1bmN0aW9uKGJ1aWxkKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3BhcnRzLnByb3RvY29sID09PSAic3RyaW5nIiAmJiB0aGlzLl9wYXJ0cy5wb3J0ID09PSBVUkkuZGVmYXVsdFBvcnRzW3RoaXMuX3BhcnRzLnByb3RvY29sXSkgewogICAgICAgICAgICB0aGlzLl9wYXJ0cy5wb3J0ID0gbnVsbDsKICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfTsKICAgICAgICBwLm5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbihidWlsZCkgewogICAgICAgICAgdmFyIF9wYXRoID0gdGhpcy5fcGFydHMucGF0aDsKICAgICAgICAgIGlmICghX3BhdGgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHRoaXMuX3BhcnRzLnBhdGggPSBVUkkucmVjb2RlVXJuUGF0aCh0aGlzLl9wYXJ0cy5wYXRoKTsKICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy5wYXRoID09PSAiLyIpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICBfcGF0aCA9IFVSSS5yZWNvZGVQYXRoKF9wYXRoKTsKICAgICAgICAgIHZhciBfd2FzX3JlbGF0aXZlOwogICAgICAgICAgdmFyIF9sZWFkaW5nUGFyZW50cyA9ICIiOwogICAgICAgICAgdmFyIF9wYXJlbnQsIF9wb3M7CiAgICAgICAgICBpZiAoX3BhdGguY2hhckF0KDApICE9PSAiLyIpIHsKICAgICAgICAgICAgX3dhc19yZWxhdGl2ZSA9IHRydWU7CiAgICAgICAgICAgIF9wYXRoID0gIi8iICsgX3BhdGg7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoX3BhdGguc2xpY2UoLTMpID09PSAiLy4uIiB8fCBfcGF0aC5zbGljZSgtMikgPT09ICIvLiIpIHsKICAgICAgICAgICAgX3BhdGggKz0gIi8iOwogICAgICAgICAgfQogICAgICAgICAgX3BhdGggPSBfcGF0aC5yZXBsYWNlKC8oXC8oXC5cLykrKXwoXC9cLiQpL2csICIvIikucmVwbGFjZSgvXC97Mix9L2csICIvIik7CiAgICAgICAgICBpZiAoX3dhc19yZWxhdGl2ZSkgewogICAgICAgICAgICBfbGVhZGluZ1BhcmVudHMgPSBfcGF0aC5zdWJzdHJpbmcoMSkubWF0Y2goL14oXC5cLlwvKSsvKSB8fCAiIjsKICAgICAgICAgICAgaWYgKF9sZWFkaW5nUGFyZW50cykgewogICAgICAgICAgICAgIF9sZWFkaW5nUGFyZW50cyA9IF9sZWFkaW5nUGFyZW50c1swXTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgICAgX3BhcmVudCA9IF9wYXRoLnNlYXJjaCgvXC9cLlwuKFwvfCQpLyk7CiAgICAgICAgICAgIGlmIChfcGFyZW50ID09PSAtMSkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9IGVsc2UgaWYgKF9wYXJlbnQgPT09IDApIHsKICAgICAgICAgICAgICBfcGF0aCA9IF9wYXRoLnN1YnN0cmluZygzKTsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBfcG9zID0gX3BhdGguc3Vic3RyaW5nKDAsIF9wYXJlbnQpLmxhc3RJbmRleE9mKCIvIik7CiAgICAgICAgICAgIGlmIChfcG9zID09PSAtMSkgewogICAgICAgICAgICAgIF9wb3MgPSBfcGFyZW50OwogICAgICAgICAgICB9CiAgICAgICAgICAgIF9wYXRoID0gX3BhdGguc3Vic3RyaW5nKDAsIF9wb3MpICsgX3BhdGguc3Vic3RyaW5nKF9wYXJlbnQgKyAzKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChfd2FzX3JlbGF0aXZlICYmIHRoaXMuaXMoInJlbGF0aXZlIikpIHsKICAgICAgICAgICAgX3BhdGggPSBfbGVhZGluZ1BhcmVudHMgKyBfcGF0aC5zdWJzdHJpbmcoMSk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl9wYXJ0cy5wYXRoID0gX3BhdGg7CiAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAubm9ybWFsaXplUGF0aG5hbWUgPSBwLm5vcm1hbGl6ZVBhdGg7CiAgICAgICAgcC5ub3JtYWxpemVRdWVyeSA9IGZ1bmN0aW9uKGJ1aWxkKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3BhcnRzLnF1ZXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBpZiAoIXRoaXMuX3BhcnRzLnF1ZXJ5Lmxlbmd0aCkgewogICAgICAgICAgICAgIHRoaXMuX3BhcnRzLnF1ZXJ5ID0gbnVsbDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLnF1ZXJ5KFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfTsKICAgICAgICBwLm5vcm1hbGl6ZUZyYWdtZW50ID0gZnVuY3Rpb24oYnVpbGQpIHsKICAgICAgICAgIGlmICghdGhpcy5fcGFydHMuZnJhZ21lbnQpIHsKICAgICAgICAgICAgdGhpcy5fcGFydHMuZnJhZ21lbnQgPSBudWxsOwogICAgICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAubm9ybWFsaXplU2VhcmNoID0gcC5ub3JtYWxpemVRdWVyeTsKICAgICAgICBwLm5vcm1hbGl6ZUhhc2ggPSBwLm5vcm1hbGl6ZUZyYWdtZW50OwogICAgICAgIHAuaXNvODg1OSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIGUgPSBVUkkuZW5jb2RlOwogICAgICAgICAgdmFyIGQgPSBVUkkuZGVjb2RlOwogICAgICAgICAgVVJJLmVuY29kZSA9IGVzY2FwZTsKICAgICAgICAgIFVSSS5kZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgVVJJLmVuY29kZSA9IGU7CiAgICAgICAgICAgIFVSSS5kZWNvZGUgPSBkOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfTsKICAgICAgICBwLnVuaWNvZGUgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBlID0gVVJJLmVuY29kZTsKICAgICAgICAgIHZhciBkID0gVVJJLmRlY29kZTsKICAgICAgICAgIFVSSS5lbmNvZGUgPSBzdHJpY3RFbmNvZGVVUklDb21wb25lbnQ7CiAgICAgICAgICBVUkkuZGVjb2RlID0gdW5lc2NhcGU7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgVVJJLmVuY29kZSA9IGU7CiAgICAgICAgICAgIFVSSS5kZWNvZGUgPSBkOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfTsKICAgICAgICBwLnJlYWRhYmxlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgdXJpID0gdGhpcy5jbG9uZSgpOwogICAgICAgICAgdXJpLnVzZXJuYW1lKCIiKS5wYXNzd29yZCgiIikubm9ybWFsaXplKCk7CiAgICAgICAgICB2YXIgdCA9ICIiOwogICAgICAgICAgaWYgKHVyaS5fcGFydHMucHJvdG9jb2wpIHsKICAgICAgICAgICAgdCArPSB1cmkuX3BhcnRzLnByb3RvY29sICsgIjovLyI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodXJpLl9wYXJ0cy5ob3N0bmFtZSkgewogICAgICAgICAgICBpZiAodXJpLmlzKCJwdW55Y29kZSIpICYmIHB1bnljb2RlKSB7CiAgICAgICAgICAgICAgdCArPSBwdW55Y29kZS50b1VuaWNvZGUodXJpLl9wYXJ0cy5ob3N0bmFtZSk7CiAgICAgICAgICAgICAgaWYgKHVyaS5fcGFydHMucG9ydCkgewogICAgICAgICAgICAgICAgdCArPSAiOiIgKyB1cmkuX3BhcnRzLnBvcnQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHQgKz0gdXJpLmhvc3QoKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHVyaS5fcGFydHMuaG9zdG5hbWUgJiYgdXJpLl9wYXJ0cy5wYXRoICYmIHVyaS5fcGFydHMucGF0aC5jaGFyQXQoMCkgIT09ICIvIikgewogICAgICAgICAgICB0ICs9ICIvIjsKICAgICAgICAgIH0KICAgICAgICAgIHQgKz0gdXJpLnBhdGgodHJ1ZSk7CiAgICAgICAgICBpZiAodXJpLl9wYXJ0cy5xdWVyeSkgewogICAgICAgICAgICB2YXIgcTIgPSAiIjsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHFwID0gdXJpLl9wYXJ0cy5xdWVyeS5zcGxpdCgiJiIpLCBsID0gcXAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgICAgdmFyIGt2ID0gKHFwW2ldIHx8ICIiKS5zcGxpdCgiPSIpOwogICAgICAgICAgICAgIHEyICs9ICImIiArIFVSSS5kZWNvZGVRdWVyeShrdlswXSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSkucmVwbGFjZSgvJi9nLCAiJTI2Iik7CiAgICAgICAgICAgICAgaWYgKGt2WzFdICE9PSB2b2lkIDApIHsKICAgICAgICAgICAgICAgIHEyICs9ICI9IiArIFVSSS5kZWNvZGVRdWVyeShrdlsxXSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSkucmVwbGFjZSgvJi9nLCAiJTI2Iik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHQgKz0gIj8iICsgcTIuc3Vic3RyaW5nKDEpOwogICAgICAgICAgfQogICAgICAgICAgdCArPSBVUkkuZGVjb2RlUXVlcnkodXJpLmhhc2goKSwgdHJ1ZSk7CiAgICAgICAgICByZXR1cm4gdDsKICAgICAgICB9OwogICAgICAgIHAuYWJzb2x1dGVUbyA9IGZ1bmN0aW9uKGJhc2UpIHsKICAgICAgICAgIHZhciByZXNvbHZlZCA9IHRoaXMuY2xvbmUoKTsKICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gWyJwcm90b2NvbCIsICJ1c2VybmFtZSIsICJwYXNzd29yZCIsICJob3N0bmFtZSIsICJwb3J0Il07CiAgICAgICAgICB2YXIgYmFzZWRpciwgaSwgcDI7CiAgICAgICAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiVVJOcyBkbyBub3QgaGF2ZSBhbnkgZ2VuZXJhbGx5IGRlZmluZWQgaGllcmFyY2hpY2FsIGNvbXBvbmVudHMiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghKGJhc2UgaW5zdGFuY2VvZiBVUkkpKSB7CiAgICAgICAgICAgIGJhc2UgPSBuZXcgVVJJKGJhc2UpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHJlc29sdmVkLl9wYXJ0cy5wcm90b2NvbCkgewogICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXNvbHZlZC5fcGFydHMucHJvdG9jb2wgPSBiYXNlLl9wYXJ0cy5wcm90b2NvbDsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLl9wYXJ0cy5ob3N0bmFtZSkgewogICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGkgPSAwOyBwMiA9IHByb3BlcnRpZXNbaV07IGkrKykgewogICAgICAgICAgICByZXNvbHZlZC5fcGFydHNbcDJdID0gYmFzZS5fcGFydHNbcDJdOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCFyZXNvbHZlZC5fcGFydHMucGF0aCkgewogICAgICAgICAgICByZXNvbHZlZC5fcGFydHMucGF0aCA9IGJhc2UuX3BhcnRzLnBhdGg7CiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQuX3BhcnRzLnF1ZXJ5KSB7CiAgICAgICAgICAgICAgcmVzb2x2ZWQuX3BhcnRzLnF1ZXJ5ID0gYmFzZS5fcGFydHMucXVlcnk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmIChyZXNvbHZlZC5fcGFydHMucGF0aC5zdWJzdHJpbmcoLTIpID09PSAiLi4iKSB7CiAgICAgICAgICAgICAgcmVzb2x2ZWQuX3BhcnRzLnBhdGggKz0gIi8iOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChyZXNvbHZlZC5wYXRoKCkuY2hhckF0KDApICE9PSAiLyIpIHsKICAgICAgICAgICAgICBiYXNlZGlyID0gYmFzZS5kaXJlY3RvcnkoKTsKICAgICAgICAgICAgICBiYXNlZGlyID0gYmFzZWRpciA/IGJhc2VkaXIgOiBiYXNlLnBhdGgoKS5pbmRleE9mKCIvIikgPT09IDAgPyAiLyIgOiAiIjsKICAgICAgICAgICAgICByZXNvbHZlZC5fcGFydHMucGF0aCA9IChiYXNlZGlyID8gYmFzZWRpciArICIvIiA6ICIiKSArIHJlc29sdmVkLl9wYXJ0cy5wYXRoOwogICAgICAgICAgICAgIHJlc29sdmVkLm5vcm1hbGl6ZVBhdGgoKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmVzb2x2ZWQuYnVpbGQoKTsKICAgICAgICAgIHJldHVybiByZXNvbHZlZDsKICAgICAgICB9OwogICAgICAgIHAucmVsYXRpdmVUbyA9IGZ1bmN0aW9uKGJhc2UpIHsKICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHRoaXMuY2xvbmUoKS5ub3JtYWxpemUoKTsKICAgICAgICAgIHZhciByZWxhdGl2ZVBhcnRzLCBiYXNlUGFydHMsIGNvbW1vbiwgcmVsYXRpdmVQYXRoLCBiYXNlUGF0aDsKICAgICAgICAgIGlmIChyZWxhdGl2ZS5fcGFydHMudXJuKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiVVJOcyBkbyBub3QgaGF2ZSBhbnkgZ2VuZXJhbGx5IGRlZmluZWQgaGllcmFyY2hpY2FsIGNvbXBvbmVudHMiKTsKICAgICAgICAgIH0KICAgICAgICAgIGJhc2UgPSBuZXcgVVJJKGJhc2UpLm5vcm1hbGl6ZSgpOwogICAgICAgICAgcmVsYXRpdmVQYXJ0cyA9IHJlbGF0aXZlLl9wYXJ0czsKICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2UuX3BhcnRzOwogICAgICAgICAgcmVsYXRpdmVQYXRoID0gcmVsYXRpdmUucGF0aCgpOwogICAgICAgICAgYmFzZVBhdGggPSBiYXNlLnBhdGgoKTsKICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGguY2hhckF0KDApICE9PSAiLyIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVUkkgaXMgYWxyZWFkeSByZWxhdGl2ZSIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJhc2VQYXRoLmNoYXJBdCgwKSAhPT0gIi8iKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQ2Fubm90IGNhbGN1bGF0ZSBhIFVSSSByZWxhdGl2ZSB0byBhbm90aGVyIHJlbGF0aXZlIFVSSSIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucHJvdG9jb2wgPT09IGJhc2VQYXJ0cy5wcm90b2NvbCkgewogICAgICAgICAgICByZWxhdGl2ZVBhcnRzLnByb3RvY29sID0gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnVzZXJuYW1lICE9PSBiYXNlUGFydHMudXNlcm5hbWUgfHwgcmVsYXRpdmVQYXJ0cy5wYXNzd29yZCAhPT0gYmFzZVBhcnRzLnBhc3N3b3JkKSB7CiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucHJvdG9jb2wgIT09IG51bGwgfHwgcmVsYXRpdmVQYXJ0cy51c2VybmFtZSAhPT0gbnVsbCB8fCByZWxhdGl2ZVBhcnRzLnBhc3N3b3JkICE9PSBudWxsKSB7CiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMuaG9zdG5hbWUgPT09IGJhc2VQYXJ0cy5ob3N0bmFtZSAmJiByZWxhdGl2ZVBhcnRzLnBvcnQgPT09IGJhc2VQYXJ0cy5wb3J0KSB7CiAgICAgICAgICAgIHJlbGF0aXZlUGFydHMuaG9zdG5hbWUgPSBudWxsOwogICAgICAgICAgICByZWxhdGl2ZVBhcnRzLnBvcnQgPSBudWxsOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlLmJ1aWxkKCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocmVsYXRpdmVQYXRoID09PSBiYXNlUGF0aCkgewogICAgICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSAiIjsKICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlLmJ1aWxkKCk7CiAgICAgICAgICB9CiAgICAgICAgICBjb21tb24gPSBVUkkuY29tbW9uUGF0aChyZWxhdGl2ZVBhdGgsIGJhc2VQYXRoKTsKICAgICAgICAgIGlmICghY29tbW9uKSB7CiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHBhcmVudHMgPSBiYXNlUGFydHMucGF0aC5zdWJzdHJpbmcoY29tbW9uLmxlbmd0aCkucmVwbGFjZSgvW15cL10qJC8sICIiKS5yZXBsYWNlKC8uKj9cLy9nLCAiLi4vIik7CiAgICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBwYXJlbnRzICsgcmVsYXRpdmVQYXJ0cy5wYXRoLnN1YnN0cmluZyhjb21tb24ubGVuZ3RoKSB8fCAiLi8iOwogICAgICAgICAgcmV0dXJuIHJlbGF0aXZlLmJ1aWxkKCk7CiAgICAgICAgfTsKICAgICAgICBwLmVxdWFscyA9IGZ1bmN0aW9uKHVyaSkgewogICAgICAgICAgdmFyIG9uZSA9IHRoaXMuY2xvbmUoKTsKICAgICAgICAgIHZhciB0d28gPSBuZXcgVVJJKHVyaSk7CiAgICAgICAgICB2YXIgb25lX21hcCA9IHt9OwogICAgICAgICAgdmFyIHR3b19tYXAgPSB7fTsKICAgICAgICAgIHZhciBjaGVja2VkID0ge307CiAgICAgICAgICB2YXIgb25lX3F1ZXJ5LCB0d29fcXVlcnksIGtleTsKICAgICAgICAgIG9uZS5ub3JtYWxpemUoKTsKICAgICAgICAgIHR3by5ub3JtYWxpemUoKTsKICAgICAgICAgIGlmIChvbmUudG9TdHJpbmcoKSA9PT0gdHdvLnRvU3RyaW5nKCkpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgICBvbmVfcXVlcnkgPSBvbmUucXVlcnkoKTsKICAgICAgICAgIHR3b19xdWVyeSA9IHR3by5xdWVyeSgpOwogICAgICAgICAgb25lLnF1ZXJ5KCIiKTsKICAgICAgICAgIHR3by5xdWVyeSgiIik7CiAgICAgICAgICBpZiAob25lLnRvU3RyaW5nKCkgIT09IHR3by50b1N0cmluZygpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvbmVfcXVlcnkubGVuZ3RoICE9PSB0d29fcXVlcnkubGVuZ3RoKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIG9uZV9tYXAgPSBVUkkucGFyc2VRdWVyeShvbmVfcXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpOwogICAgICAgICAgdHdvX21hcCA9IFVSSS5wYXJzZVF1ZXJ5KHR3b19xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7CiAgICAgICAgICBmb3IgKGtleSBpbiBvbmVfbWFwKSB7CiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvbmVfbWFwLCBrZXkpKSB7CiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KG9uZV9tYXBba2V5XSkpIHsKICAgICAgICAgICAgICAgIGlmIChvbmVfbWFwW2tleV0gIT09IHR3b19tYXBba2V5XSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIGlmICghYXJyYXlzRXF1YWwob25lX21hcFtrZXldLCB0d29fbWFwW2tleV0pKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNoZWNrZWRba2V5XSA9IHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZvciAoa2V5IGluIHR3b19tYXApIHsKICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKHR3b19tYXAsIGtleSkpIHsKICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRba2V5XSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfTsKICAgICAgICBwLnByZXZlbnRJbnZhbGlkSG9zdG5hbWUgPSBmdW5jdGlvbih2MikgewogICAgICAgICAgdGhpcy5fcGFydHMucHJldmVudEludmFsaWRIb3N0bmFtZSA9ICEhdjI7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzID0gZnVuY3Rpb24odjIpIHsKICAgICAgICAgIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycyA9ICEhdjI7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9OwogICAgICAgIHAuZXNjYXBlUXVlcnlTcGFjZSA9IGZ1bmN0aW9uKHYyKSB7CiAgICAgICAgICB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlID0gISF2MjsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIFVSSTsKICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3B1bnljb2RlQDEuMy4yL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcwogIHZhciByZXF1aXJlX3B1bnljb2RlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3B1bnljb2RlQDEuMy4yL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIChmdW5jdGlvbihyb290KSB7CiAgICAgICAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gIm9iamVjdCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwogICAgICAgIHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgICAgICAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICJvYmplY3QiICYmIGdsb2JhbDsKICAgICAgICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSB7CiAgICAgICAgICByb290ID0gZnJlZUdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdmFyIHB1bnljb2RlLCBtYXhJbnQgPSAyMTQ3NDgzNjQ3LCBiYXNlID0gMzYsIHRNaW4gPSAxLCB0TWF4ID0gMjYsIHNrZXcgPSAzOCwgZGFtcCA9IDcwMCwgaW5pdGlhbEJpYXMgPSA3MiwgaW5pdGlhbE4gPSAxMjgsIGRlbGltaXRlciA9ICItIiwgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sIHJlZ2V4Tm9uQVNDSUkgPSAvW15ceDIwLVx4N0VdLywgcmVnZXhTZXBhcmF0b3JzID0gL1tceDJFXHUzMDAyXHVGRjBFXHVGRjYxXS9nLCBlcnJvcnMgPSB7CiAgICAgICAgICAib3ZlcmZsb3ciOiAiT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MiLAogICAgICAgICAgIm5vdC1iYXNpYyI6ICJJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpIiwKICAgICAgICAgICJpbnZhbGlkLWlucHV0IjogIkludmFsaWQgaW5wdXQiCiAgICAgICAgfSwgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLCBmbG9vciA9IE1hdGguZmxvb3IsIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsIGtleTsKICAgICAgICBmdW5jdGlvbiBlcnJvcih0eXBlKSB7CiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHsKICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7CiAgICAgICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoIkAiKTsKICAgICAgICAgIHZhciByZXN1bHQgPSAiIjsKICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdICsgIkAiOwogICAgICAgICAgICBzdHJpbmcgPSBwYXJ0c1sxXTsKICAgICAgICAgIH0KICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgIi4iKTsKICAgICAgICAgIHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoIi4iKTsKICAgICAgICAgIHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oIi4iKTsKICAgICAgICAgIHJldHVybiByZXN1bHQgKyBlbmNvZGVkOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykgewogICAgICAgICAgdmFyIG91dHB1dCA9IFtdLCBjb3VudGVyID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCwgdmFsdWUsIGV4dHJhOwogICAgICAgICAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHsKICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspOwogICAgICAgICAgICBpZiAodmFsdWUgPj0gNTUyOTYgJiYgdmFsdWUgPD0gNTYzMTkgJiYgY291bnRlciA8IGxlbmd0aCkgewogICAgICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTsKICAgICAgICAgICAgICBpZiAoKGV4dHJhICYgNjQ1MTIpID09IDU2MzIwKSB7CiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMTAyMykgPDwgMTApICsgKGV4dHJhICYgMTAyMykgKyA2NTUzNik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTsKICAgICAgICAgICAgICAgIGNvdW50ZXItLTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7CiAgICAgICAgICByZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkgewogICAgICAgICAgICB2YXIgb3V0cHV0ID0gIiI7CiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDY1NTM1KSB7CiAgICAgICAgICAgICAgdmFsdWUgLT0gNjU1MzY7CiAgICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpOwogICAgICAgICAgICAgIHZhbHVlID0gNTYzMjAgfCB2YWx1ZSAmIDEwMjM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7CiAgICAgICAgICB9KS5qb2luKCIiKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkgewogICAgICAgICAgaWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHsKICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDIyOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHsKICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDY1OwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHsKICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDk3OwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGJhc2U7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykgewogICAgICAgICAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7CiAgICAgICAgICB2YXIgayA9IDA7CiAgICAgICAgICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxOwogICAgICAgICAgZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpOwogICAgICAgICAgZm9yICg7IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7CiAgICAgICAgICAgIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHsKICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSwgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsIG91dCwgaSA9IDAsIG4gPSBpbml0aWFsTiwgYmlhcyA9IGluaXRpYWxCaWFzLCBiYXNpYywgaiwgaW5kZXgsIG9sZGksIHcsIGssIGRpZ2l0LCB0LCBiYXNlTWludXNUOwogICAgICAgICAgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpOwogICAgICAgICAgaWYgKGJhc2ljIDwgMCkgewogICAgICAgICAgICBiYXNpYyA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikgewogICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAxMjgpIHsKICAgICAgICAgICAgICBlcnJvcigibm90LWJhc2ljIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgb3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgKSB7CiAgICAgICAgICAgIGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgOyBrICs9IGJhc2UpIHsKICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHsKICAgICAgICAgICAgICAgIGVycm9yKCJpbnZhbGlkLWlucHV0Iik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpOwogICAgICAgICAgICAgIGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHsKICAgICAgICAgICAgICAgIGVycm9yKCJvdmVyZmxvdyIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpICs9IGRpZ2l0ICogdzsKICAgICAgICAgICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7CiAgICAgICAgICAgICAgaWYgKGRpZ2l0IDwgdCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJhc2VNaW51c1QgPSBiYXNlIC0gdDsKICAgICAgICAgICAgICBpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7CiAgICAgICAgICAgICAgICBlcnJvcigib3ZlcmZsb3ciKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdyAqPSBiYXNlTWludXNUOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG91dCA9IG91dHB1dC5sZW5ndGggKyAxOwogICAgICAgICAgICBiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTsKICAgICAgICAgICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikgewogICAgICAgICAgICAgIGVycm9yKCJvdmVyZmxvdyIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG4gKz0gZmxvb3IoaSAvIG91dCk7CiAgICAgICAgICAgIGkgJT0gb3V0OwogICAgICAgICAgICBvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHsKICAgICAgICAgIHZhciBuLCBkZWx0YSwgaGFuZGxlZENQQ291bnQsIGJhc2ljTGVuZ3RoLCBiaWFzLCBqLCBtLCBxLCBrLCB0LCBjdXJyZW50VmFsdWUsIG91dHB1dCA9IFtdLCBpbnB1dExlbmd0aCwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBiYXNlTWludXNULCBxTWludXNUOwogICAgICAgICAgaW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTsKICAgICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoOwogICAgICAgICAgbiA9IGluaXRpYWxOOwogICAgICAgICAgZGVsdGEgPSAwOwogICAgICAgICAgYmlhcyA9IGluaXRpYWxCaWFzOwogICAgICAgICAgZm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHsKICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07CiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCAxMjgpIHsKICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoOwogICAgICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7CiAgICAgICAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkgewogICAgICAgICAgICBmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikgewogICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdOwogICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7CiAgICAgICAgICAgICAgICBtID0gY3VycmVudFZhbHVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7CiAgICAgICAgICAgIGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7CiAgICAgICAgICAgICAgZXJyb3IoIm92ZXJmbG93Iik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTsKICAgICAgICAgICAgbiA9IG07CiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CiAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07CiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkgewogICAgICAgICAgICAgICAgZXJyb3IoIm92ZXJmbG93Iik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikgewogICAgICAgICAgICAgICAgZm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyA7IGsgKz0gYmFzZSkgewogICAgICAgICAgICAgICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7CiAgICAgICAgICAgICAgICAgIGlmIChxIDwgdCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHFNaW51c1QgPSBxIC0gdDsKICAgICAgICAgICAgICAgICAgYmFzZU1pbnVzVCA9IGJhc2UgLSB0OwogICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgKICAgICAgICAgICAgICAgICAgICBzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7CiAgICAgICAgICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpOwogICAgICAgICAgICAgICAgZGVsdGEgPSAwOwogICAgICAgICAgICAgICAgKytoYW5kbGVkQ1BDb3VudDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgKytkZWx0YTsKICAgICAgICAgICAgKytuOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCIiKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7CiAgICAgICAgICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHsKICAgICAgICAgICAgcmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZzsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7CiAgICAgICAgICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHsKICAgICAgICAgICAgcmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpID8gInhuLS0iICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcHVueWNvZGUgPSB7CiAgICAgICAgICAidmVyc2lvbiI6ICIxLjMuMiIsCiAgICAgICAgICAidWNzMiI6IHsKICAgICAgICAgICAgImRlY29kZSI6IHVjczJkZWNvZGUsCiAgICAgICAgICAgICJlbmNvZGUiOiB1Y3MyZW5jb2RlCiAgICAgICAgICB9LAogICAgICAgICAgImRlY29kZSI6IGRlY29kZSwKICAgICAgICAgICJlbmNvZGUiOiBlbmNvZGUsCiAgICAgICAgICAidG9BU0NJSSI6IHRvQVNDSUksCiAgICAgICAgICAidG9Vbmljb2RlIjogdG9Vbmljb2RlCiAgICAgICAgfTsKICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PSAiZnVuY3Rpb24iICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICJvYmplY3QiICYmIGRlZmluZS5hbWQpIHsKICAgICAgICAgIGRlZmluZSgicHVueWNvZGUiLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIHB1bnljb2RlOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7CiAgICAgICAgICBpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsKICAgICAgICAgICAgZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBmb3IgKGtleSBpbiBwdW55Y29kZSkgewogICAgICAgICAgICAgIHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByb290LnB1bnljb2RlID0gcHVueWNvZGU7CiAgICAgICAgfQogICAgICB9KShleHBvcnRzKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rdXJsQDAuMTEuMC9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMKICB2YXIgcmVxdWlyZV91dGlsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rdXJsQDAuMTEuMC9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gewogICAgICAgIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHsKICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAic3RyaW5nIjsKICAgICAgICB9LAogICAgICAgIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHsKICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAib2JqZWN0IiAmJiBhcmcgIT09IG51bGw7CiAgICAgICAgfSwKICAgICAgICBpc051bGw6IGZ1bmN0aW9uKGFyZykgewogICAgICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbDsKICAgICAgICB9LAogICAgICAgIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHsKICAgICAgICAgIHJldHVybiBhcmcgPT0gbnVsbDsKICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3F1ZXJ5c3RyaW5nQDAuMi4wL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMKICB2YXIgcmVxdWlyZV9kZWNvZGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStxdWVyeXN0cmluZ0AwLjIuMC9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHsKICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykgewogICAgICAgIHNlcCA9IHNlcCB8fCAiJiI7CiAgICAgICAgZXEgPSBlcSB8fCAiPSI7CiAgICAgICAgdmFyIG9iaiA9IHt9OwogICAgICAgIGlmICh0eXBlb2YgcXMgIT09ICJzdHJpbmciIHx8IHFzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CiAgICAgICAgdmFyIHJlZ2V4cCA9IC9cKy9nOwogICAgICAgIHFzID0gcXMuc3BsaXQoc2VwKTsKICAgICAgICB2YXIgbWF4S2V5cyA9IDFlMzsKICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAibnVtYmVyIikgewogICAgICAgICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5czsKICAgICAgICB9CiAgICAgICAgdmFyIGxlbiA9IHFzLmxlbmd0aDsKICAgICAgICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykgewogICAgICAgICAgbGVuID0gbWF4S2V5czsKICAgICAgICB9CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgIiUyMCIpLCBpZHggPSB4LmluZGV4T2YoZXEpLCBrc3RyLCB2c3RyLCBrLCB2MjsKICAgICAgICAgIGlmIChpZHggPj0gMCkgewogICAgICAgICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTsKICAgICAgICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAga3N0ciA9IHg7CiAgICAgICAgICAgIHZzdHIgPSAiIjsKICAgICAgICAgIH0KICAgICAgICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7CiAgICAgICAgICB2MiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTsKICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkgewogICAgICAgICAgICBvYmpba10gPSB2MjsKICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7CiAgICAgICAgICAgIG9ialtrXS5wdXNoKHYyKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG9ialtrXSA9IFtvYmpba10sIHYyXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rcXVlcnlzdHJpbmdAMC4yLjAvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcwogIHZhciByZXF1aXJlX2VuY29kZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3F1ZXJ5c3RyaW5nQDAuMi4wL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2MikgewogICAgICAgIHN3aXRjaCAodHlwZW9mIHYyKSB7CiAgICAgICAgICBjYXNlICJzdHJpbmciOgogICAgICAgICAgICByZXR1cm4gdjI7CiAgICAgICAgICBjYXNlICJib29sZWFuIjoKICAgICAgICAgICAgcmV0dXJuIHYyID8gInRydWUiIDogImZhbHNlIjsKICAgICAgICAgIGNhc2UgIm51bWJlciI6CiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2MikgPyB2MiA6ICIiOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHsKICAgICAgICBzZXAgPSBzZXAgfHwgIiYiOwogICAgICAgIGVxID0gZXEgfHwgIj0iOwogICAgICAgIGlmIChvYmogPT09IG51bGwpIHsKICAgICAgICAgIG9iaiA9IHZvaWQgMDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICJvYmplY3QiKSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykgewogICAgICAgICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxOwogICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odjIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodjIpKTsKICAgICAgICAgICAgICB9KS5qb2luKHNlcCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSkuam9pbihzZXApOwogICAgICAgIH0KICAgICAgICBpZiAoIW5hbWUpCiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStxdWVyeXN0cmluZ0AwLjIuMC9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMKICB2YXIgcmVxdWlyZV9xdWVyeXN0cmluZyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK3F1ZXJ5c3RyaW5nQDAuMi4wL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIoZXhwb3J0cykgewogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmVfZGVjb2RlKCk7CiAgICAgIGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlX2VuY29kZSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbSt1cmxAMC4xMS4wL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzCiAgdmFyIHJlcXVpcmVfdXJsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rdXJsQDAuMTEuMC9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIoZXhwb3J0cykgewogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBwdW55Y29kZSA9IHJlcXVpcmVfcHVueWNvZGUyKCk7CiAgICAgIHZhciB1dGlsID0gcmVxdWlyZV91dGlsKCk7CiAgICAgIGV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTsKICAgICAgZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTsKICAgICAgZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDsKICAgICAgZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7CiAgICAgIGV4cG9ydHMuVXJsID0gVXJsOwogICAgICBmdW5jdGlvbiBVcmwoKSB7CiAgICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGw7CiAgICAgICAgdGhpcy5zbGFzaGVzID0gbnVsbDsKICAgICAgICB0aGlzLmF1dGggPSBudWxsOwogICAgICAgIHRoaXMuaG9zdCA9IG51bGw7CiAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDsKICAgICAgICB0aGlzLmhvc3RuYW1lID0gbnVsbDsKICAgICAgICB0aGlzLmhhc2ggPSBudWxsOwogICAgICAgIHRoaXMuc2VhcmNoID0gbnVsbDsKICAgICAgICB0aGlzLnF1ZXJ5ID0gbnVsbDsKICAgICAgICB0aGlzLnBhdGhuYW1lID0gbnVsbDsKICAgICAgICB0aGlzLnBhdGggPSBudWxsOwogICAgICAgIHRoaXMuaHJlZiA9IG51bGw7CiAgICAgIH0KICAgICAgdmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2k7CiAgICAgIHZhciBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC87CiAgICAgIHZhciBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFwvXC8/KD8hXC8pW15cP1xzXSopKFw/W15cc10qKT8kLzsKICAgICAgdmFyIGRlbGltcyA9IFsiPCIsICI+IiwgJyInLCAiYCIsICIgIiwgIlxyIiwgIlxuIiwgIgkiXTsKICAgICAgdmFyIHVud2lzZSA9IFsieyIsICJ9IiwgInwiLCAiXFwiLCAiXiIsICJgIl0uY29uY2F0KGRlbGltcyk7CiAgICAgIHZhciBhdXRvRXNjYXBlID0gWyInIl0uY29uY2F0KHVud2lzZSk7CiAgICAgIHZhciBub25Ib3N0Q2hhcnMgPSBbIiUiLCAiLyIsICI/IiwgIjsiLCAiIyJdLmNvbmNhdChhdXRvRXNjYXBlKTsKICAgICAgdmFyIGhvc3RFbmRpbmdDaGFycyA9IFsiLyIsICI/IiwgIiMiXTsKICAgICAgdmFyIGhvc3RuYW1lTWF4TGVuID0gMjU1OwogICAgICB2YXIgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLzsKICAgICAgdmFyIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvOwogICAgICB2YXIgdW5zYWZlUHJvdG9jb2wgPSB7CiAgICAgICAgImphdmFzY3JpcHQiOiB0cnVlLAogICAgICAgICJqYXZhc2NyaXB0OiI6IHRydWUKICAgICAgfTsKICAgICAgdmFyIGhvc3RsZXNzUHJvdG9jb2wgPSB7CiAgICAgICAgImphdmFzY3JpcHQiOiB0cnVlLAogICAgICAgICJqYXZhc2NyaXB0OiI6IHRydWUKICAgICAgfTsKICAgICAgdmFyIHNsYXNoZWRQcm90b2NvbCA9IHsKICAgICAgICAiaHR0cCI6IHRydWUsCiAgICAgICAgImh0dHBzIjogdHJ1ZSwKICAgICAgICAiZnRwIjogdHJ1ZSwKICAgICAgICAiZ29waGVyIjogdHJ1ZSwKICAgICAgICAiZmlsZSI6IHRydWUsCiAgICAgICAgImh0dHA6IjogdHJ1ZSwKICAgICAgICAiaHR0cHM6IjogdHJ1ZSwKICAgICAgICAiZnRwOiI6IHRydWUsCiAgICAgICAgImdvcGhlcjoiOiB0cnVlLAogICAgICAgICJmaWxlOiI6IHRydWUKICAgICAgfTsKICAgICAgdmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZV9xdWVyeXN0cmluZygpOwogICAgICBmdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7CiAgICAgICAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKQogICAgICAgICAgcmV0dXJuIHVybDsKICAgICAgICB2YXIgdTIgPSBuZXcgVXJsKCk7CiAgICAgICAgdTIucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7CiAgICAgICAgcmV0dXJuIHUyOwogICAgICB9CiAgICAgIFVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7CiAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgIiArIHR5cGVvZiB1cmwpOwogICAgICAgIH0KICAgICAgICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCI/IiksIHNwbGl0dGVyID0gcXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCIjIikgPyAiPyIgOiAiIyIsIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksIHNsYXNoUmVnZXggPSAvXFwvZzsKICAgICAgICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAiLyIpOwogICAgICAgIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTsKICAgICAgICB2YXIgcmVzdCA9IHVybDsKICAgICAgICByZXN0ID0gcmVzdC50cmltKCk7CiAgICAgICAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoIiMiKS5sZW5ndGggPT09IDEpIHsKICAgICAgICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTsKICAgICAgICAgIGlmIChzaW1wbGVQYXRoKSB7CiAgICAgICAgICAgIHRoaXMucGF0aCA9IHJlc3Q7CiAgICAgICAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7CiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdOwogICAgICAgICAgICBpZiAoc2ltcGxlUGF0aFsyXSkgewogICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTsKICAgICAgICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykgewogICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHsKICAgICAgICAgICAgICB0aGlzLnNlYXJjaCA9ICIiOwogICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7CiAgICAgICAgaWYgKHByb3RvKSB7CiAgICAgICAgICBwcm90byA9IHByb3RvWzBdOwogICAgICAgICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87CiAgICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cL1wvW15AXC9dK0BbXkBcL10rLykpIHsKICAgICAgICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICIvLyI7CiAgICAgICAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkgewogICAgICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7CiAgICAgICAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiYgKHNsYXNoZXMgfHwgcHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSB7CiAgICAgICAgICB2YXIgaG9zdEVuZCA9IC0xOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pOwogICAgICAgICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpCiAgICAgICAgICAgICAgaG9zdEVuZCA9IGhlYzsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBhdXRoLCBhdFNpZ247CiAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHsKICAgICAgICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZigiQCIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZigiQCIsIGhvc3RFbmQpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGF0U2lnbiAhPT0gLTEpIHsKICAgICAgICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTsKICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7CiAgICAgICAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTsKICAgICAgICAgIH0KICAgICAgICAgIGhvc3RFbmQgPSAtMTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTsKICAgICAgICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKQogICAgICAgICAgICAgIGhvc3RFbmQgPSBoZWM7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpCiAgICAgICAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDsKICAgICAgICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7CiAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTsKICAgICAgICAgIHRoaXMucGFyc2VIb3N0KCk7CiAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAiIjsKICAgICAgICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAiWyIgJiYgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAiXSI7CiAgICAgICAgICBpZiAoIWlwdjZIb3N0bmFtZSkgewogICAgICAgICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXC4vKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07CiAgICAgICAgICAgICAgaWYgKCFwYXJ0KQogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7CiAgICAgICAgICAgICAgICB2YXIgbmV3cGFydCA9ICIiOwogICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykgewogICAgICAgICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7CiAgICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSAieCI7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHsKICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7CiAgICAgICAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTsKICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpOwogICAgICAgICAgICAgICAgICBpZiAoYml0KSB7CiAgICAgICAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7CiAgICAgICAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdCA9ICIvIiArIG5vdEhvc3Quam9pbigiLiIpICsgcmVzdDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCIuIik7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHsKICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9ICIiOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7CiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAiOiIgKyB0aGlzLnBvcnQgOiAiIjsKICAgICAgICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAiIjsKICAgICAgICAgIHRoaXMuaG9zdCA9IGggKyBwOwogICAgICAgICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDsKICAgICAgICAgIGlmIChpcHY2SG9zdG5hbWUpIHsKICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7CiAgICAgICAgICAgIGlmIChyZXN0WzBdICE9PSAiLyIpIHsKICAgICAgICAgICAgICByZXN0ID0gIi8iICsgcmVzdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07CiAgICAgICAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSkKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7CiAgICAgICAgICAgIGlmIChlc2MgPT09IGFlKSB7CiAgICAgICAgICAgICAgZXNjID0gZXNjYXBlKGFlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZigiIyIpOwogICAgICAgIGlmIChoYXNoICE9PSAtMSkgewogICAgICAgICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7CiAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTsKICAgICAgICB9CiAgICAgICAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCI/Iik7CiAgICAgICAgaWYgKHFtICE9PSAtMSkgewogICAgICAgICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7CiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTsKICAgICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7CiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTsKICAgICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHsKICAgICAgICAgIHRoaXMuc2VhcmNoID0gIiI7CiAgICAgICAgICB0aGlzLnF1ZXJ5ID0ge307CiAgICAgICAgfQogICAgICAgIGlmIChyZXN0KQogICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHJlc3Q7CiAgICAgICAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJiB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7CiAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gIi8iOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkgewogICAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICIiOwogICAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAiIjsKICAgICAgICAgIHRoaXMucGF0aCA9IHAgKyBzOwogICAgICAgIH0KICAgICAgICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBmdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7CiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkKICAgICAgICAgIG9iaiA9IHVybFBhcnNlKG9iaik7CiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkKICAgICAgICAgIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7CiAgICAgICAgcmV0dXJuIG9iai5mb3JtYXQoKTsKICAgICAgfQogICAgICBVcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICIiOwogICAgICAgIGlmIChhdXRoKSB7CiAgICAgICAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpOwogICAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICI6Iik7CiAgICAgICAgICBhdXRoICs9ICJAIjsKICAgICAgICB9CiAgICAgICAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAiIiwgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICIiLCBoYXNoID0gdGhpcy5oYXNoIHx8ICIiLCBob3N0ID0gZmFsc2UsIHF1ZXJ5ID0gIiI7CiAgICAgICAgaWYgKHRoaXMuaG9zdCkgewogICAgICAgICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7CiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7CiAgICAgICAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoIjoiKSA9PT0gLTEgPyB0aGlzLmhvc3RuYW1lIDogIlsiICsgdGhpcy5ob3N0bmFtZSArICJdIik7CiAgICAgICAgICBpZiAodGhpcy5wb3J0KSB7CiAgICAgICAgICAgIGhvc3QgKz0gIjoiICsgdGhpcy5wb3J0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5xdWVyeSAmJiB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkgewogICAgICAgICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7CiAgICAgICAgfQogICAgICAgIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCBxdWVyeSAmJiAiPyIgKyBxdWVyeSB8fCAiIjsKICAgICAgICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gIjoiKQogICAgICAgICAgcHJvdG9jb2wgKz0gIjoiOwogICAgICAgIGlmICh0aGlzLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkgewogICAgICAgICAgaG9zdCA9ICIvLyIgKyAoaG9zdCB8fCAiIik7CiAgICAgICAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAiLyIpCiAgICAgICAgICAgIHBhdGhuYW1lID0gIi8iICsgcGF0aG5hbWU7CiAgICAgICAgfSBlbHNlIGlmICghaG9zdCkgewogICAgICAgICAgaG9zdCA9ICIiOwogICAgICAgIH0KICAgICAgICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gIiMiKQogICAgICAgICAgaGFzaCA9ICIjIiArIGhhc2g7CiAgICAgICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAiPyIpCiAgICAgICAgICBzZWFyY2ggPSAiPyIgKyBzZWFyY2g7CiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7CiAgICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTsKICAgICAgICB9KTsKICAgICAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgiIyIsICIlMjMiKTsKICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoOwogICAgICB9OwogICAgICBmdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHsKICAgICAgICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7CiAgICAgIH0KICAgICAgVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHsKICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpOwogICAgICB9OwogICAgICBmdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHsKICAgICAgICBpZiAoIXNvdXJjZSkKICAgICAgICAgIHJldHVybiByZWxhdGl2ZTsKICAgICAgICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7CiAgICAgIH0KICAgICAgVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHsKICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHsKICAgICAgICAgIHZhciByZWwgPSBuZXcgVXJsKCk7CiAgICAgICAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTsKICAgICAgICAgIHJlbGF0aXZlID0gcmVsOwogICAgICAgIH0KICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpOwogICAgICAgIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpOwogICAgICAgIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHsKICAgICAgICAgIHZhciB0a2V5ID0gdGtleXNbdGtdOwogICAgICAgICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTsKICAgICAgICB9CiAgICAgICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoOwogICAgICAgIGlmIChyZWxhdGl2ZS5ocmVmID09PSAiIikgewogICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHsKICAgICAgICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTsKICAgICAgICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHsKICAgICAgICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107CiAgICAgICAgICAgIGlmIChya2V5ICE9PSAicHJvdG9jb2wiKQogICAgICAgICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7CiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gIi8iOwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkgewogICAgICAgICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7CiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpOwogICAgICAgICAgICBmb3IgKHZhciB2MiA9IDA7IHYyIDwga2V5cy5sZW5ndGg7IHYyKyspIHsKICAgICAgICAgICAgICB2YXIgayA9IGtleXNbdjJdOwogICAgICAgICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpOwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7CiAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7CiAgICAgICAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICIiKS5zcGxpdCgiLyIpOwogICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkKICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gIiI7CiAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpCiAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSAiIjsKICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICIiKQogICAgICAgICAgICAgIHJlbFBhdGgudW5zaGlmdCgiIik7CiAgICAgICAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpCiAgICAgICAgICAgICAgcmVsUGF0aC51bnNoaWZ0KCIiKTsKICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCIvIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7CiAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTsKICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAiIjsKICAgICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDsKICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7CiAgICAgICAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7CiAgICAgICAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHsKICAgICAgICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgIiI7CiAgICAgICAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAiIjsKICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBwICsgczsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlczsKICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpOwogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgdmFyIGlzU291cmNlQWJzID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICIvIiwgaXNSZWxBYnMgPSByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gIi8iLCBtdXN0RW5kQWJzID0gaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHwgcmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUsIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLCBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgiLyIpIHx8IFtdLCByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoIi8iKSB8fCBbXSwgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTsKICAgICAgICBpZiAocHN5Y2hvdGljKSB7CiAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSAiIjsKICAgICAgICAgIHJlc3VsdC5wb3J0ID0gbnVsbDsKICAgICAgICAgIGlmIChyZXN1bHQuaG9zdCkgewogICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gIiIpCiAgICAgICAgICAgICAgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0OwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5ob3N0ID0gIiI7CiAgICAgICAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHsKICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsOwogICAgICAgICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDsKICAgICAgICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHsKICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gIiIpCiAgICAgICAgICAgICAgICByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gIiIgfHwgc3JjUGF0aFswXSA9PT0gIiIpOwogICAgICAgIH0KICAgICAgICBpZiAoaXNSZWxBYnMpIHsKICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAiIiA/IHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDsKICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAiIiA/IHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lOwogICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDsKICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5OwogICAgICAgICAgc3JjUGF0aCA9IHJlbFBhdGg7CiAgICAgICAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkgewogICAgICAgICAgaWYgKCFzcmNQYXRoKQogICAgICAgICAgICBzcmNQYXRoID0gW107CiAgICAgICAgICBzcmNQYXRoLnBvcCgpOwogICAgICAgICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpOwogICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDsKICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5OwogICAgICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkgewogICAgICAgICAgaWYgKHBzeWNob3RpYykgewogICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTsKICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCJAIikgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoIkAiKSA6IGZhbHNlOwogICAgICAgICAgICBpZiAoYXV0aEluSG9zdCkgewogICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpOwogICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoOwogICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7CiAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7CiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICIiKSArIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICIiKTsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpOwogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgaWYgKCFzcmNQYXRoLmxlbmd0aCkgewogICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDsKICAgICAgICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7CiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gIi8iICsgcmVzdWx0LnNlYXJjaDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpOwogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTsKICAgICAgICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiYgKGxhc3QgPT09ICIuIiB8fCBsYXN0ID09PSAiLi4iKSB8fCBsYXN0ID09PSAiIjsKICAgICAgICB2YXIgdXAgPSAwOwogICAgICAgIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHsKICAgICAgICAgIGxhc3QgPSBzcmNQYXRoW2ldOwogICAgICAgICAgaWYgKGxhc3QgPT09ICIuIikgewogICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTsKICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gIi4uIikgewogICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgdXArKzsKICAgICAgICAgIH0gZWxzZSBpZiAodXApIHsKICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7CiAgICAgICAgICAgIHVwLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykgewogICAgICAgICAgZm9yICg7IHVwLS07IHVwKSB7CiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgiLi4iKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gIiIgJiYgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAiLyIpKSB7CiAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoIiIpOwogICAgICAgIH0KICAgICAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiBzcmNQYXRoLmpvaW4oIi8iKS5zdWJzdHIoLTEpICE9PSAiLyIpIHsKICAgICAgICAgIHNyY1BhdGgucHVzaCgiIik7CiAgICAgICAgfQogICAgICAgIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gIiIgfHwgc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gIi8iOwogICAgICAgIGlmIChwc3ljaG90aWMpIHsKICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICIiIDogc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAiIjsKICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZigiQCIpID4gMCA/IHJlc3VsdC5ob3N0LnNwbGl0KCJAIikgOiBmYWxzZTsKICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7CiAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpOwogICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgcmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGg7CiAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHsKICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgiIik7CiAgICAgICAgfQogICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHsKICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7CiAgICAgICAgICByZXN1bHQucGF0aCA9IG51bGw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbigiLyIpOwogICAgICAgIH0KICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7CiAgICAgICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAiIikgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAiIik7CiAgICAgICAgfQogICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDsKICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7CiAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfTsKICAgICAgVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDsKICAgICAgICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7CiAgICAgICAgaWYgKHBvcnQpIHsKICAgICAgICAgIHBvcnQgPSBwb3J0WzBdOwogICAgICAgICAgaWYgKHBvcnQgIT09ICI6IikgewogICAgICAgICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTsKICAgICAgICAgIH0KICAgICAgICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKGhvc3QpCiAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rZG9tcHVyaWZ5QDIuNC4xL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuanMKICB2YXIgcmVxdWlyZV9wdXJpZnkgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStkb21wdXJpZnlAMi40LjEvbm9kZV9tb2R1bGVzL2RvbXB1cmlmeS9kaXN0L3B1cmlmeS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIChmdW5jdGlvbihnbG9iYWwyLCBmYWN0b3J5KSB7CiAgICAgICAgdHlwZW9mIGV4cG9ydHMgPT09ICJvYmplY3QiICYmIHR5cGVvZiBtb2R1bGUgIT09ICJ1bmRlZmluZWQiID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOiB0eXBlb2YgZGVmaW5lID09PSAiZnVuY3Rpb24iICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOiAoZ2xvYmFsMiA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbFRoaXMgOiBnbG9iYWwyIHx8IHNlbGYsIGdsb2JhbDIuRE9NUHVyaWZ5ID0gZmFjdG9yeSgpKTsKICAgICAgfSkoZXhwb3J0cywgZnVuY3Rpb24oKSB7CiAgICAgICAgInVzZSBzdHJpY3QiOwogICAgICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7CiAgICAgICAgICAiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2YiOwogICAgICAgICAgcmV0dXJuIF90eXBlb2YgPSAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYgInN5bWJvbCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iajIpIHsKICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmoyOwogICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iajIpIHsKICAgICAgICAgICAgcmV0dXJuIG9iajIgJiYgImZ1bmN0aW9uIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iajIuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmoyICE9PSBTeW1ib2wucHJvdG90eXBlID8gInN5bWJvbCIgOiB0eXBlb2Ygb2JqMjsKICAgICAgICAgIH0sIF90eXBlb2Yob2JqKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgICBvMi5fX3Byb3RvX18gPSBwMjsKICAgICAgICAgICAgcmV0dXJuIG8yOwogICAgICAgICAgfTsKICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsKICAgICAgICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsKICAgICAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QyKFBhcmVudDIsIGFyZ3MyLCBDbGFzczIpIHsKICAgICAgICAgICAgICB2YXIgYTMgPSBbbnVsbF07CiAgICAgICAgICAgICAgYTMucHVzaC5hcHBseShhMywgYXJnczIpOwogICAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50MiwgYTMpOwogICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOwogICAgICAgICAgICAgIGlmIChDbGFzczIpCiAgICAgICAgICAgICAgICBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzMi5wcm90b3R5cGUpOwogICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsKICAgICAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsKICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpCiAgICAgICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsKICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyWyJAQGl0ZXJhdG9yIl0gIT0gbnVsbCkKICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsKICAgICAgICAgIGlmICghbykKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgaWYgKHR5cGVvZiBvID09PSAic3RyaW5nIikKICAgICAgICAgICAgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7CiAgICAgICAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7CiAgICAgICAgICBpZiAobiA9PT0gIk9iamVjdCIgJiYgby5jb25zdHJ1Y3RvcikKICAgICAgICAgICAgbiA9IG8uY29uc3RydWN0b3IubmFtZTsKICAgICAgICAgIGlmIChuID09PSAiTWFwIiB8fCBuID09PSAiU2V0IikKICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obyk7CiAgICAgICAgICBpZiAobiA9PT0gIkFyZ3VtZW50cyIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpCiAgICAgICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgewogICAgICAgICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpCiAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspCiAgICAgICAgICAgIGFycjJbaV0gPSBhcnJbaV07CiAgICAgICAgICByZXR1cm4gYXJyMjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuIik7CiAgICAgICAgfQogICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSwgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsIGlzRnJvemVuID0gT2JqZWN0LmlzRnJvemVuLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsKICAgICAgICB2YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZSwgc2VhbCA9IE9iamVjdC5zZWFsLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogICAgICAgIHZhciBfcmVmID0gdHlwZW9mIFJlZmxlY3QgIT09ICJ1bmRlZmluZWQiICYmIFJlZmxlY3QsIGFwcGx5ID0gX3JlZi5hcHBseSwgY29uc3RydWN0ID0gX3JlZi5jb25zdHJ1Y3Q7CiAgICAgICAgaWYgKCFhcHBseSkgewogICAgICAgICAgYXBwbHkgPSBmdW5jdGlvbiBhcHBseTIoZnVuLCB0aGlzVmFsdWUsIGFyZ3MpIHsKICAgICAgICAgICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgaWYgKCFmcmVlemUpIHsKICAgICAgICAgIGZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZTIoeCkgewogICAgICAgICAgICByZXR1cm4geDsKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGlmICghc2VhbCkgewogICAgICAgICAgc2VhbCA9IGZ1bmN0aW9uIHNlYWwyKHgpIHsKICAgICAgICAgICAgcmV0dXJuIHg7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICBpZiAoIWNvbnN0cnVjdCkgewogICAgICAgICAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0MihGdW5jLCBhcmdzKSB7CiAgICAgICAgICAgIHJldHVybiBfY29uc3RydWN0KEZ1bmMsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgYXJyYXlGb3JFYWNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7CiAgICAgICAgdmFyIGFycmF5UG9wID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucG9wKTsKICAgICAgICB2YXIgYXJyYXlQdXNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucHVzaCk7CiAgICAgICAgdmFyIHN0cmluZ1RvTG93ZXJDYXNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKTsKICAgICAgICB2YXIgc3RyaW5nVG9TdHJpbmcgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcpOwogICAgICAgIHZhciBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7CiAgICAgICAgdmFyIHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7CiAgICAgICAgdmFyIHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7CiAgICAgICAgdmFyIHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7CiAgICAgICAgdmFyIHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7CiAgICAgICAgdmFyIHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7CiAgICAgICAgZnVuY3Rpb24gdW5hcHBseShmdW5jKSB7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odGhpc0FyZykgewogICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7CiAgICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdW5jb25zdHJ1Y3QoZnVuYykgewogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHsKICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdChmdW5jLCBhcmdzKTsKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXksIHRyYW5zZm9ybUNhc2VGdW5jKSB7CiAgICAgICAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IHRyYW5zZm9ybUNhc2VGdW5jID8gdHJhbnNmb3JtQ2FzZUZ1bmMgOiBzdHJpbmdUb0xvd2VyQ2FzZTsKICAgICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgewogICAgICAgICAgICBzZXRQcm90b3R5cGVPZihzZXQsIG51bGwpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7CiAgICAgICAgICB3aGlsZSAobC0tKSB7CiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gYXJyYXlbbF07CiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICB2YXIgbGNFbGVtZW50ID0gdHJhbnNmb3JtQ2FzZUZ1bmMoZWxlbWVudCk7CiAgICAgICAgICAgICAgaWYgKGxjRWxlbWVudCAhPT0gZWxlbWVudCkgewogICAgICAgICAgICAgICAgaWYgKCFpc0Zyb3plbihhcnJheSkpIHsKICAgICAgICAgICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGNFbGVtZW50OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBzZXRbZWxlbWVudF0gPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHNldDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2xvbmUyKG9iamVjdCkgewogICAgICAgICAgdmFyIG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTsKICAgICAgICAgIHZhciBwcm9wZXJ0eTsKICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7CiAgICAgICAgICAgIGlmIChhcHBseShoYXNPd25Qcm9wZXJ0eSwgb2JqZWN0LCBbcHJvcGVydHldKSkgewogICAgICAgICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBvYmplY3RbcHJvcGVydHldOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbmV3T2JqZWN0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wKSB7CiAgICAgICAgICB3aGlsZSAob2JqZWN0ICE9PSBudWxsKSB7CiAgICAgICAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7CiAgICAgICAgICAgIGlmIChkZXNjKSB7CiAgICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy52YWx1ZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBmYWxsYmFja1ZhbHVlKGVsZW1lbnQpIHsKICAgICAgICAgICAgY29uc29sZS53YXJuKCJmYWxsYmFjayB2YWx1ZSBmb3IiLCBlbGVtZW50KTsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTsKICAgICAgICB9CiAgICAgICAgdmFyIGh0bWwkMSA9IGZyZWV6ZShbImEiLCAiYWJiciIsICJhY3JvbnltIiwgImFkZHJlc3MiLCAiYXJlYSIsICJhcnRpY2xlIiwgImFzaWRlIiwgImF1ZGlvIiwgImIiLCAiYmRpIiwgImJkbyIsICJiaWciLCAiYmxpbmsiLCAiYmxvY2txdW90ZSIsICJib2R5IiwgImJyIiwgImJ1dHRvbiIsICJjYW52YXMiLCAiY2FwdGlvbiIsICJjZW50ZXIiLCAiY2l0ZSIsICJjb2RlIiwgImNvbCIsICJjb2xncm91cCIsICJjb250ZW50IiwgImRhdGEiLCAiZGF0YWxpc3QiLCAiZGQiLCAiZGVjb3JhdG9yIiwgImRlbCIsICJkZXRhaWxzIiwgImRmbiIsICJkaWFsb2ciLCAiZGlyIiwgImRpdiIsICJkbCIsICJkdCIsICJlbGVtZW50IiwgImVtIiwgImZpZWxkc2V0IiwgImZpZ2NhcHRpb24iLCAiZmlndXJlIiwgImZvbnQiLCAiZm9vdGVyIiwgImZvcm0iLCAiaDEiLCAiaDIiLCAiaDMiLCAiaDQiLCAiaDUiLCAiaDYiLCAiaGVhZCIsICJoZWFkZXIiLCAiaGdyb3VwIiwgImhyIiwgImh0bWwiLCAiaSIsICJpbWciLCAiaW5wdXQiLCAiaW5zIiwgImtiZCIsICJsYWJlbCIsICJsZWdlbmQiLCAibGkiLCAibWFpbiIsICJtYXAiLCAibWFyayIsICJtYXJxdWVlIiwgIm1lbnUiLCAibWVudWl0ZW0iLCAibWV0ZXIiLCAibmF2IiwgIm5vYnIiLCAib2wiLCAib3B0Z3JvdXAiLCAib3B0aW9uIiwgIm91dHB1dCIsICJwIiwgInBpY3R1cmUiLCAicHJlIiwgInByb2dyZXNzIiwgInEiLCAicnAiLCAicnQiLCAicnVieSIsICJzIiwgInNhbXAiLCAic2VjdGlvbiIsICJzZWxlY3QiLCAic2hhZG93IiwgInNtYWxsIiwgInNvdXJjZSIsICJzcGFjZXIiLCAic3BhbiIsICJzdHJpa2UiLCAic3Ryb25nIiwgInN0eWxlIiwgInN1YiIsICJzdW1tYXJ5IiwgInN1cCIsICJ0YWJsZSIsICJ0Ym9keSIsICJ0ZCIsICJ0ZW1wbGF0ZSIsICJ0ZXh0YXJlYSIsICJ0Zm9vdCIsICJ0aCIsICJ0aGVhZCIsICJ0aW1lIiwgInRyIiwgInRyYWNrIiwgInR0IiwgInUiLCAidWwiLCAidmFyIiwgInZpZGVvIiwgIndiciJdKTsKICAgICAgICB2YXIgc3ZnJDEgPSBmcmVlemUoWyJzdmciLCAiYSIsICJhbHRnbHlwaCIsICJhbHRnbHlwaGRlZiIsICJhbHRnbHlwaGl0ZW0iLCAiYW5pbWF0ZWNvbG9yIiwgImFuaW1hdGVtb3Rpb24iLCAiYW5pbWF0ZXRyYW5zZm9ybSIsICJjaXJjbGUiLCAiY2xpcHBhdGgiLCAiZGVmcyIsICJkZXNjIiwgImVsbGlwc2UiLCAiZmlsdGVyIiwgImZvbnQiLCAiZyIsICJnbHlwaCIsICJnbHlwaHJlZiIsICJoa2VybiIsICJpbWFnZSIsICJsaW5lIiwgImxpbmVhcmdyYWRpZW50IiwgIm1hcmtlciIsICJtYXNrIiwgIm1ldGFkYXRhIiwgIm1wYXRoIiwgInBhdGgiLCAicGF0dGVybiIsICJwb2x5Z29uIiwgInBvbHlsaW5lIiwgInJhZGlhbGdyYWRpZW50IiwgInJlY3QiLCAic3RvcCIsICJzdHlsZSIsICJzd2l0Y2giLCAic3ltYm9sIiwgInRleHQiLCAidGV4dHBhdGgiLCAidGl0bGUiLCAidHJlZiIsICJ0c3BhbiIsICJ2aWV3IiwgInZrZXJuIl0pOwogICAgICAgIHZhciBzdmdGaWx0ZXJzID0gZnJlZXplKFsiZmVCbGVuZCIsICJmZUNvbG9yTWF0cml4IiwgImZlQ29tcG9uZW50VHJhbnNmZXIiLCAiZmVDb21wb3NpdGUiLCAiZmVDb252b2x2ZU1hdHJpeCIsICJmZURpZmZ1c2VMaWdodGluZyIsICJmZURpc3BsYWNlbWVudE1hcCIsICJmZURpc3RhbnRMaWdodCIsICJmZUZsb29kIiwgImZlRnVuY0EiLCAiZmVGdW5jQiIsICJmZUZ1bmNHIiwgImZlRnVuY1IiLCAiZmVHYXVzc2lhbkJsdXIiLCAiZmVJbWFnZSIsICJmZU1lcmdlIiwgImZlTWVyZ2VOb2RlIiwgImZlTW9ycGhvbG9neSIsICJmZU9mZnNldCIsICJmZVBvaW50TGlnaHQiLCAiZmVTcGVjdWxhckxpZ2h0aW5nIiwgImZlU3BvdExpZ2h0IiwgImZlVGlsZSIsICJmZVR1cmJ1bGVuY2UiXSk7CiAgICAgICAgdmFyIHN2Z0Rpc2FsbG93ZWQgPSBmcmVlemUoWyJhbmltYXRlIiwgImNvbG9yLXByb2ZpbGUiLCAiY3Vyc29yIiwgImRpc2NhcmQiLCAiZmVkcm9wc2hhZG93IiwgImZvbnQtZmFjZSIsICJmb250LWZhY2UtZm9ybWF0IiwgImZvbnQtZmFjZS1uYW1lIiwgImZvbnQtZmFjZS1zcmMiLCAiZm9udC1mYWNlLXVyaSIsICJmb3JlaWdub2JqZWN0IiwgImhhdGNoIiwgImhhdGNocGF0aCIsICJtZXNoIiwgIm1lc2hncmFkaWVudCIsICJtZXNocGF0Y2giLCAibWVzaHJvdyIsICJtaXNzaW5nLWdseXBoIiwgInNjcmlwdCIsICJzZXQiLCAic29saWRjb2xvciIsICJ1bmtub3duIiwgInVzZSJdKTsKICAgICAgICB2YXIgbWF0aE1sJDEgPSBmcmVlemUoWyJtYXRoIiwgIm1lbmNsb3NlIiwgIm1lcnJvciIsICJtZmVuY2VkIiwgIm1mcmFjIiwgIm1nbHlwaCIsICJtaSIsICJtbGFiZWxlZHRyIiwgIm1tdWx0aXNjcmlwdHMiLCAibW4iLCAibW8iLCAibW92ZXIiLCAibXBhZGRlZCIsICJtcGhhbnRvbSIsICJtcm9vdCIsICJtcm93IiwgIm1zIiwgIm1zcGFjZSIsICJtc3FydCIsICJtc3R5bGUiLCAibXN1YiIsICJtc3VwIiwgIm1zdWJzdXAiLCAibXRhYmxlIiwgIm10ZCIsICJtdGV4dCIsICJtdHIiLCAibXVuZGVyIiwgIm11bmRlcm92ZXIiXSk7CiAgICAgICAgdmFyIG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWyJtYWN0aW9uIiwgIm1hbGlnbmdyb3VwIiwgIm1hbGlnbm1hcmsiLCAibWxvbmdkaXYiLCAibXNjYXJyaWVzIiwgIm1zY2FycnkiLCAibXNncm91cCIsICJtc3RhY2siLCAibXNsaW5lIiwgIm1zcm93IiwgInNlbWFudGljcyIsICJhbm5vdGF0aW9uIiwgImFubm90YXRpb24teG1sIiwgIm1wcmVzY3JpcHRzIiwgIm5vbmUiXSk7CiAgICAgICAgdmFyIHRleHQgPSBmcmVlemUoWyIjdGV4dCJdKTsKICAgICAgICB2YXIgaHRtbCA9IGZyZWV6ZShbImFjY2VwdCIsICJhY3Rpb24iLCAiYWxpZ24iLCAiYWx0IiwgImF1dG9jYXBpdGFsaXplIiwgImF1dG9jb21wbGV0ZSIsICJhdXRvcGljdHVyZWlucGljdHVyZSIsICJhdXRvcGxheSIsICJiYWNrZ3JvdW5kIiwgImJnY29sb3IiLCAiYm9yZGVyIiwgImNhcHR1cmUiLCAiY2VsbHBhZGRpbmciLCAiY2VsbHNwYWNpbmciLCAiY2hlY2tlZCIsICJjaXRlIiwgImNsYXNzIiwgImNsZWFyIiwgImNvbG9yIiwgImNvbHMiLCAiY29sc3BhbiIsICJjb250cm9scyIsICJjb250cm9sc2xpc3QiLCAiY29vcmRzIiwgImNyb3Nzb3JpZ2luIiwgImRhdGV0aW1lIiwgImRlY29kaW5nIiwgImRlZmF1bHQiLCAiZGlyIiwgImRpc2FibGVkIiwgImRpc2FibGVwaWN0dXJlaW5waWN0dXJlIiwgImRpc2FibGVyZW1vdGVwbGF5YmFjayIsICJkb3dubG9hZCIsICJkcmFnZ2FibGUiLCAiZW5jdHlwZSIsICJlbnRlcmtleWhpbnQiLCAiZmFjZSIsICJmb3IiLCAiaGVhZGVycyIsICJoZWlnaHQiLCAiaGlkZGVuIiwgImhpZ2giLCAiaHJlZiIsICJocmVmbGFuZyIsICJpZCIsICJpbnB1dG1vZGUiLCAiaW50ZWdyaXR5IiwgImlzbWFwIiwgImtpbmQiLCAibGFiZWwiLCAibGFuZyIsICJsaXN0IiwgImxvYWRpbmciLCAibG9vcCIsICJsb3ciLCAibWF4IiwgIm1heGxlbmd0aCIsICJtZWRpYSIsICJtZXRob2QiLCAibWluIiwgIm1pbmxlbmd0aCIsICJtdWx0aXBsZSIsICJtdXRlZCIsICJuYW1lIiwgIm5vbmNlIiwgIm5vc2hhZGUiLCAibm92YWxpZGF0ZSIsICJub3dyYXAiLCAib3BlbiIsICJvcHRpbXVtIiwgInBhdHRlcm4iLCAicGxhY2Vob2xkZXIiLCAicGxheXNpbmxpbmUiLCAicG9zdGVyIiwgInByZWxvYWQiLCAicHViZGF0ZSIsICJyYWRpb2dyb3VwIiwgInJlYWRvbmx5IiwgInJlbCIsICJyZXF1aXJlZCIsICJyZXYiLCAicmV2ZXJzZWQiLCAicm9sZSIsICJyb3dzIiwgInJvd3NwYW4iLCAic3BlbGxjaGVjayIsICJzY29wZSIsICJzZWxlY3RlZCIsICJzaGFwZSIsICJzaXplIiwgInNpemVzIiwgInNwYW4iLCAic3JjbGFuZyIsICJzdGFydCIsICJzcmMiLCAic3Jjc2V0IiwgInN0ZXAiLCAic3R5bGUiLCAic3VtbWFyeSIsICJ0YWJpbmRleCIsICJ0aXRsZSIsICJ0cmFuc2xhdGUiLCAidHlwZSIsICJ1c2VtYXAiLCAidmFsaWduIiwgInZhbHVlIiwgIndpZHRoIiwgInhtbG5zIiwgInNsb3QiXSk7CiAgICAgICAgdmFyIHN2ZyA9IGZyZWV6ZShbImFjY2VudC1oZWlnaHQiLCAiYWNjdW11bGF0ZSIsICJhZGRpdGl2ZSIsICJhbGlnbm1lbnQtYmFzZWxpbmUiLCAiYXNjZW50IiwgImF0dHJpYnV0ZW5hbWUiLCAiYXR0cmlidXRldHlwZSIsICJhemltdXRoIiwgImJhc2VmcmVxdWVuY3kiLCAiYmFzZWxpbmUtc2hpZnQiLCAiYmVnaW4iLCAiYmlhcyIsICJieSIsICJjbGFzcyIsICJjbGlwIiwgImNsaXBwYXRodW5pdHMiLCAiY2xpcC1wYXRoIiwgImNsaXAtcnVsZSIsICJjb2xvciIsICJjb2xvci1pbnRlcnBvbGF0aW9uIiwgImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyIsICJjb2xvci1wcm9maWxlIiwgImNvbG9yLXJlbmRlcmluZyIsICJjeCIsICJjeSIsICJkIiwgImR4IiwgImR5IiwgImRpZmZ1c2Vjb25zdGFudCIsICJkaXJlY3Rpb24iLCAiZGlzcGxheSIsICJkaXZpc29yIiwgImR1ciIsICJlZGdlbW9kZSIsICJlbGV2YXRpb24iLCAiZW5kIiwgImZpbGwiLCAiZmlsbC1vcGFjaXR5IiwgImZpbGwtcnVsZSIsICJmaWx0ZXIiLCAiZmlsdGVydW5pdHMiLCAiZmxvb2QtY29sb3IiLCAiZmxvb2Qtb3BhY2l0eSIsICJmb250LWZhbWlseSIsICJmb250LXNpemUiLCAiZm9udC1zaXplLWFkanVzdCIsICJmb250LXN0cmV0Y2giLCAiZm9udC1zdHlsZSIsICJmb250LXZhcmlhbnQiLCAiZm9udC13ZWlnaHQiLCAiZngiLCAiZnkiLCAiZzEiLCAiZzIiLCAiZ2x5cGgtbmFtZSIsICJnbHlwaHJlZiIsICJncmFkaWVudHVuaXRzIiwgImdyYWRpZW50dHJhbnNmb3JtIiwgImhlaWdodCIsICJocmVmIiwgImlkIiwgImltYWdlLXJlbmRlcmluZyIsICJpbiIsICJpbjIiLCAiayIsICJrMSIsICJrMiIsICJrMyIsICJrNCIsICJrZXJuaW5nIiwgImtleXBvaW50cyIsICJrZXlzcGxpbmVzIiwgImtleXRpbWVzIiwgImxhbmciLCAibGVuZ3RoYWRqdXN0IiwgImxldHRlci1zcGFjaW5nIiwgImtlcm5lbG1hdHJpeCIsICJrZXJuZWx1bml0bGVuZ3RoIiwgImxpZ2h0aW5nLWNvbG9yIiwgImxvY2FsIiwgIm1hcmtlci1lbmQiLCAibWFya2VyLW1pZCIsICJtYXJrZXItc3RhcnQiLCAibWFya2VyaGVpZ2h0IiwgIm1hcmtlcnVuaXRzIiwgIm1hcmtlcndpZHRoIiwgIm1hc2tjb250ZW50dW5pdHMiLCAibWFza3VuaXRzIiwgIm1heCIsICJtYXNrIiwgIm1lZGlhIiwgIm1ldGhvZCIsICJtb2RlIiwgIm1pbiIsICJuYW1lIiwgIm51bW9jdGF2ZXMiLCAib2Zmc2V0IiwgIm9wZXJhdG9yIiwgIm9wYWNpdHkiLCAib3JkZXIiLCAib3JpZW50IiwgIm9yaWVudGF0aW9uIiwgIm9yaWdpbiIsICJvdmVyZmxvdyIsICJwYWludC1vcmRlciIsICJwYXRoIiwgInBhdGhsZW5ndGgiLCAicGF0dGVybmNvbnRlbnR1bml0cyIsICJwYXR0ZXJudHJhbnNmb3JtIiwgInBhdHRlcm51bml0cyIsICJwb2ludHMiLCAicHJlc2VydmVhbHBoYSIsICJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwgInByaW1pdGl2ZXVuaXRzIiwgInIiLCAicngiLCAicnkiLCAicmFkaXVzIiwgInJlZngiLCAicmVmeSIsICJyZXBlYXRjb3VudCIsICJyZXBlYXRkdXIiLCAicmVzdGFydCIsICJyZXN1bHQiLCAicm90YXRlIiwgInNjYWxlIiwgInNlZWQiLCAic2hhcGUtcmVuZGVyaW5nIiwgInNwZWN1bGFyY29uc3RhbnQiLCAic3BlY3VsYXJleHBvbmVudCIsICJzcHJlYWRtZXRob2QiLCAic3RhcnRvZmZzZXQiLCAic3RkZGV2aWF0aW9uIiwgInN0aXRjaHRpbGVzIiwgInN0b3AtY29sb3IiLCAic3RvcC1vcGFjaXR5IiwgInN0cm9rZS1kYXNoYXJyYXkiLCAic3Ryb2tlLWRhc2hvZmZzZXQiLCAic3Ryb2tlLWxpbmVjYXAiLCAic3Ryb2tlLWxpbmVqb2luIiwgInN0cm9rZS1taXRlcmxpbWl0IiwgInN0cm9rZS1vcGFjaXR5IiwgInN0cm9rZSIsICJzdHJva2Utd2lkdGgiLCAic3R5bGUiLCAic3VyZmFjZXNjYWxlIiwgInN5c3RlbWxhbmd1YWdlIiwgInRhYmluZGV4IiwgInRhcmdldHgiLCAidGFyZ2V0eSIsICJ0cmFuc2Zvcm0iLCAidHJhbnNmb3JtLW9yaWdpbiIsICJ0ZXh0LWFuY2hvciIsICJ0ZXh0LWRlY29yYXRpb24iLCAidGV4dC1yZW5kZXJpbmciLCAidGV4dGxlbmd0aCIsICJ0eXBlIiwgInUxIiwgInUyIiwgInVuaWNvZGUiLCAidmFsdWVzIiwgInZpZXdib3giLCAidmlzaWJpbGl0eSIsICJ2ZXJzaW9uIiwgInZlcnQtYWR2LXkiLCAidmVydC1vcmlnaW4teCIsICJ2ZXJ0LW9yaWdpbi15IiwgIndpZHRoIiwgIndvcmQtc3BhY2luZyIsICJ3cmFwIiwgIndyaXRpbmctbW9kZSIsICJ4Y2hhbm5lbHNlbGVjdG9yIiwgInljaGFubmVsc2VsZWN0b3IiLCAieCIsICJ4MSIsICJ4MiIsICJ4bWxucyIsICJ5IiwgInkxIiwgInkyIiwgInoiLCAiem9vbWFuZHBhbiJdKTsKICAgICAgICB2YXIgbWF0aE1sID0gZnJlZXplKFsiYWNjZW50IiwgImFjY2VudHVuZGVyIiwgImFsaWduIiwgImJldmVsbGVkIiwgImNsb3NlIiwgImNvbHVtbnNhbGlnbiIsICJjb2x1bW5saW5lcyIsICJjb2x1bW5zcGFuIiwgImRlbm9tYWxpZ24iLCAiZGVwdGgiLCAiZGlyIiwgImRpc3BsYXkiLCAiZGlzcGxheXN0eWxlIiwgImVuY29kaW5nIiwgImZlbmNlIiwgImZyYW1lIiwgImhlaWdodCIsICJocmVmIiwgImlkIiwgImxhcmdlb3AiLCAibGVuZ3RoIiwgImxpbmV0aGlja25lc3MiLCAibHNwYWNlIiwgImxxdW90ZSIsICJtYXRoYmFja2dyb3VuZCIsICJtYXRoY29sb3IiLCAibWF0aHNpemUiLCAibWF0aHZhcmlhbnQiLCAibWF4c2l6ZSIsICJtaW5zaXplIiwgIm1vdmFibGVsaW1pdHMiLCAibm90YXRpb24iLCAibnVtYWxpZ24iLCAib3BlbiIsICJyb3dhbGlnbiIsICJyb3dsaW5lcyIsICJyb3dzcGFjaW5nIiwgInJvd3NwYW4iLCAicnNwYWNlIiwgInJxdW90ZSIsICJzY3JpcHRsZXZlbCIsICJzY3JpcHRtaW5zaXplIiwgInNjcmlwdHNpemVtdWx0aXBsaWVyIiwgInNlbGVjdGlvbiIsICJzZXBhcmF0b3IiLCAic2VwYXJhdG9ycyIsICJzdHJldGNoeSIsICJzdWJzY3JpcHRzaGlmdCIsICJzdXBzY3JpcHRzaGlmdCIsICJzeW1tZXRyaWMiLCAidm9mZnNldCIsICJ3aWR0aCIsICJ4bWxucyJdKTsKICAgICAgICB2YXIgeG1sID0gZnJlZXplKFsieGxpbms6aHJlZiIsICJ4bWw6aWQiLCAieGxpbms6dGl0bGUiLCAieG1sOnNwYWNlIiwgInhtbG5zOnhsaW5rIl0pOwogICAgICAgIHZhciBNVVNUQUNIRV9FWFBSID0gc2VhbCgvXHtce1tcd1xXXSp8W1x3XFddKlx9XH0vZ20pOwogICAgICAgIHZhciBFUkJfRVhQUiA9IHNlYWwoLzwlW1x3XFddKnxbXHdcV10qJT4vZ20pOwogICAgICAgIHZhciBUTVBMSVRfRVhQUiA9IHNlYWwoL1wke1tcd1xXXSp9L2dtKTsKICAgICAgICB2YXIgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1wtXHcuXHUwMEI3LVx1RkZGRl0vKTsKICAgICAgICB2YXIgQVJJQV9BVFRSID0gc2VhbCgvXmFyaWEtW1wtXHddKyQvKTsKICAgICAgICB2YXIgSVNfQUxMT1dFRF9VUkkgPSBzZWFsKAogICAgICAgICAgL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHApOnxbXmEtel18W2EteisuXC1dKyg/OlteYS16Ky5cLTpdfCQpKS9pCiAgICAgICAgKTsKICAgICAgICB2YXIgSVNfU0NSSVBUX09SX0RBVEEgPSBzZWFsKC9eKD86XHcrc2NyaXB0fGRhdGEpOi9pKTsKICAgICAgICB2YXIgQVRUUl9XSElURVNQQUNFID0gc2VhbCgKICAgICAgICAgIC9bXHUwMDAwLVx1MDAyMFx1MDBBMFx1MTY4MFx1MTgwRVx1MjAwMC1cdTIwMjlcdTIwNUZcdTMwMDBdL2cKICAgICAgICApOwogICAgICAgIHZhciBET0NUWVBFX05BTUUgPSBzZWFsKC9eaHRtbCQvaSk7CiAgICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbDIoKSB7CiAgICAgICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gInVuZGVmaW5lZCIgPyBudWxsIDogd2luZG93OwogICAgICAgIH07CiAgICAgICAgdmFyIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kgPSBmdW5jdGlvbiBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5Mih0cnVzdGVkVHlwZXMsIGRvY3VtZW50MikgewogICAgICAgICAgaWYgKF90eXBlb2YodHJ1c3RlZFR5cGVzKSAhPT0gIm9iamVjdCIgfHwgdHlwZW9mIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgc3VmZml4ID0gbnVsbDsKICAgICAgICAgIHZhciBBVFRSX05BTUUgPSAiZGF0YS10dC1wb2xpY3ktc3VmZml4IjsKICAgICAgICAgIGlmIChkb2N1bWVudDIuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudDIuY3VycmVudFNjcmlwdC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSkgewogICAgICAgICAgICBzdWZmaXggPSBkb2N1bWVudDIuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBwb2xpY3lOYW1lID0gImRvbXB1cmlmeSIgKyAoc3VmZml4ID8gIiMiICsgc3VmZml4IDogIiIpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwgewogICAgICAgICAgICAgIGNyZWF0ZUhUTUw6IGZ1bmN0aW9uIGNyZWF0ZUhUTUwoaHRtbDIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBodG1sMjsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFVSTDogZnVuY3Rpb24gY3JlYXRlU2NyaXB0VVJMKHNjcmlwdFVybCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFVybDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBjYXRjaCAoXykgewogICAgICAgICAgICBjb25zb2xlLndhcm4oIlRydXN0ZWRUeXBlcyBwb2xpY3kgIiArIHBvbGljeU5hbWUgKyAiIGNvdWxkIG5vdCBiZSBjcmVhdGVkLiIpOwogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURPTVB1cmlmeSgpIHsKICAgICAgICAgIHZhciB3aW5kb3cyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBnZXRHbG9iYWwoKTsKICAgICAgICAgIHZhciBET01QdXJpZnkyID0gZnVuY3Rpb24gRE9NUHVyaWZ5Myhyb290KSB7CiAgICAgICAgICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7CiAgICAgICAgICB9OwogICAgICAgICAgRE9NUHVyaWZ5Mi52ZXJzaW9uID0gIjIuNC4xIjsKICAgICAgICAgIERPTVB1cmlmeTIucmVtb3ZlZCA9IFtdOwogICAgICAgICAgaWYgKCF3aW5kb3cyIHx8ICF3aW5kb3cyLmRvY3VtZW50IHx8IHdpbmRvdzIuZG9jdW1lbnQubm9kZVR5cGUgIT09IDkpIHsKICAgICAgICAgICAgRE9NUHVyaWZ5Mi5pc1N1cHBvcnRlZCA9IGZhbHNlOwogICAgICAgICAgICByZXR1cm4gRE9NUHVyaWZ5MjsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBvcmlnaW5hbERvY3VtZW50ID0gd2luZG93Mi5kb2N1bWVudDsKICAgICAgICAgIHZhciBkb2N1bWVudDIgPSB3aW5kb3cyLmRvY3VtZW50OwogICAgICAgICAgdmFyIERvY3VtZW50RnJhZ21lbnQyID0gd2luZG93Mi5Eb2N1bWVudEZyYWdtZW50LCBIVE1MVGVtcGxhdGVFbGVtZW50ID0gd2luZG93Mi5IVE1MVGVtcGxhdGVFbGVtZW50LCBOb2RlID0gd2luZG93Mi5Ob2RlLCBFbGVtZW50ID0gd2luZG93Mi5FbGVtZW50LCBOb2RlRmlsdGVyID0gd2luZG93Mi5Ob2RlRmlsdGVyLCBfd2luZG93JE5hbWVkTm9kZU1hcCA9IHdpbmRvdzIuTmFtZWROb2RlTWFwLCBOYW1lZE5vZGVNYXAgPSBfd2luZG93JE5hbWVkTm9kZU1hcCA9PT0gdm9pZCAwID8gd2luZG93Mi5OYW1lZE5vZGVNYXAgfHwgd2luZG93Mi5Nb3pOYW1lZEF0dHJNYXAgOiBfd2luZG93JE5hbWVkTm9kZU1hcCwgSFRNTEZvcm1FbGVtZW50ID0gd2luZG93Mi5IVE1MRm9ybUVsZW1lbnQsIERPTVBhcnNlcjIgPSB3aW5kb3cyLkRPTVBhcnNlciwgdHJ1c3RlZFR5cGVzID0gd2luZG93Mi50cnVzdGVkVHlwZXM7CiAgICAgICAgICB2YXIgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlOwogICAgICAgICAgdmFyIGNsb25lTm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAiY2xvbmVOb2RlIik7CiAgICAgICAgICB2YXIgZ2V0TmV4dFNpYmxpbmcgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgIm5leHRTaWJsaW5nIik7CiAgICAgICAgICB2YXIgZ2V0Q2hpbGROb2RlcyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAiY2hpbGROb2RlcyIpOwogICAgICAgICAgdmFyIGdldFBhcmVudE5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgInBhcmVudE5vZGUiKTsKICAgICAgICAgIGlmICh0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBkb2N1bWVudDIuY3JlYXRlRWxlbWVudCgidGVtcGxhdGUiKTsKICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7CiAgICAgICAgICAgICAgZG9jdW1lbnQyID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIG9yaWdpbmFsRG9jdW1lbnQpOwogICAgICAgICAgdmFyIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCIiKSA6ICIiOwogICAgICAgICAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50MiwgaW1wbGVtZW50YXRpb24yID0gX2RvY3VtZW50LmltcGxlbWVudGF0aW9uLCBjcmVhdGVOb2RlSXRlcmF0b3IgPSBfZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yLCBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lOwogICAgICAgICAgdmFyIGltcG9ydE5vZGUgPSBvcmlnaW5hbERvY3VtZW50LmltcG9ydE5vZGU7CiAgICAgICAgICB2YXIgZG9jdW1lbnRNb2RlID0ge307CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBkb2N1bWVudE1vZGUgPSBjbG9uZTIoZG9jdW1lbnQyKS5kb2N1bWVudE1vZGUgPyBkb2N1bWVudDIuZG9jdW1lbnRNb2RlIDoge307CiAgICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgaG9va3MgPSB7fTsKICAgICAgICAgIERPTVB1cmlmeTIuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbjIgJiYgdHlwZW9mIGltcGxlbWVudGF0aW9uMi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09ICJ1bmRlZmluZWQiICYmIGRvY3VtZW50TW9kZSAhPT0gOTsKICAgICAgICAgIHZhciBNVVNUQUNIRV9FWFBSJDEgPSBNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiQxID0gRVJCX0VYUFIsIFRNUExJVF9FWFBSJDEgPSBUTVBMSVRfRVhQUiwgREFUQV9BVFRSJDEgPSBEQVRBX0FUVFIsIEFSSUFfQVRUUiQxID0gQVJJQV9BVFRSLCBJU19TQ1JJUFRfT1JfREFUQSQxID0gSVNfU0NSSVBUX09SX0RBVEEsIEFUVFJfV0hJVEVTUEFDRSQxID0gQVRUUl9XSElURVNQQUNFOwogICAgICAgICAgdmFyIElTX0FMTE9XRURfVVJJJDEgPSBJU19BTExPV0VEX1VSSTsKICAgICAgICAgIHZhciBBTExPV0VEX1RBR1MgPSBudWxsOwogICAgICAgICAgdmFyIERFRkFVTFRfQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaHRtbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5KHN2ZyQxKSwgX3RvQ29uc3VtYWJsZUFycmF5KHN2Z0ZpbHRlcnMpLCBfdG9Db25zdW1hYmxlQXJyYXkobWF0aE1sJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkodGV4dCkpKTsKICAgICAgICAgIHZhciBBTExPV0VEX0FUVFIgPSBudWxsOwogICAgICAgICAgdmFyIERFRkFVTFRfQUxMT1dFRF9BVFRSID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaHRtbCksIF90b0NvbnN1bWFibGVBcnJheShzdmcpLCBfdG9Db25zdW1hYmxlQXJyYXkobWF0aE1sKSwgX3RvQ29uc3VtYWJsZUFycmF5KHhtbCkpKTsKICAgICAgICAgIHZhciBDVVNUT01fRUxFTUVOVF9IQU5ETElORyA9IE9iamVjdC5zZWFsKE9iamVjdC5jcmVhdGUobnVsbCwgewogICAgICAgICAgICB0YWdOYW1lQ2hlY2s6IHsKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLAogICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgICAgICAgdmFsdWU6IG51bGwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgYXR0cmlidXRlTmFtZUNoZWNrOiB7CiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgIHZhbHVlOiBudWxsCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50czogewogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UKICAgICAgICAgICAgfQogICAgICAgICAgfSkpOwogICAgICAgICAgdmFyIEZPUkJJRF9UQUdTID0gbnVsbDsKICAgICAgICAgIHZhciBGT1JCSURfQVRUUiA9IG51bGw7CiAgICAgICAgICB2YXIgQUxMT1dfQVJJQV9BVFRSID0gdHJ1ZTsKICAgICAgICAgIHZhciBBTExPV19EQVRBX0FUVFIgPSB0cnVlOwogICAgICAgICAgdmFyIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gZmFsc2U7CiAgICAgICAgICB2YXIgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7CiAgICAgICAgICB2YXIgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTsKICAgICAgICAgIHZhciBTRVRfQ09ORklHID0gZmFsc2U7CiAgICAgICAgICB2YXIgRk9SQ0VfQk9EWSA9IGZhbHNlOwogICAgICAgICAgdmFyIFJFVFVSTl9ET00gPSBmYWxzZTsKICAgICAgICAgIHZhciBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gZmFsc2U7CiAgICAgICAgICB2YXIgUkVUVVJOX1RSVVNURURfVFlQRSA9IGZhbHNlOwogICAgICAgICAgdmFyIFNBTklUSVpFX0RPTSA9IHRydWU7CiAgICAgICAgICB2YXIgU0FOSVRJWkVfTkFNRURfUFJPUFMgPSBmYWxzZTsKICAgICAgICAgIHZhciBTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVggPSAidXNlci1jb250ZW50LSI7CiAgICAgICAgICB2YXIgS0VFUF9DT05URU5UID0gdHJ1ZTsKICAgICAgICAgIHZhciBJTl9QTEFDRSA9IGZhbHNlOwogICAgICAgICAgdmFyIFVTRV9QUk9GSUxFUyA9IHt9OwogICAgICAgICAgdmFyIEZPUkJJRF9DT05URU5UUyA9IG51bGw7CiAgICAgICAgICB2YXIgREVGQVVMVF9GT1JCSURfQ09OVEVOVFMgPSBhZGRUb1NldCh7fSwgWyJhbm5vdGF0aW9uLXhtbCIsICJhdWRpbyIsICJjb2xncm91cCIsICJkZXNjIiwgImZvcmVpZ25vYmplY3QiLCAiaGVhZCIsICJpZnJhbWUiLCAibWF0aCIsICJtaSIsICJtbiIsICJtbyIsICJtcyIsICJtdGV4dCIsICJub2VtYmVkIiwgIm5vZnJhbWVzIiwgIm5vc2NyaXB0IiwgInBsYWludGV4dCIsICJzY3JpcHQiLCAic3R5bGUiLCAic3ZnIiwgInRlbXBsYXRlIiwgInRoZWFkIiwgInRpdGxlIiwgInZpZGVvIiwgInhtcCJdKTsKICAgICAgICAgIHZhciBEQVRBX1VSSV9UQUdTID0gbnVsbDsKICAgICAgICAgIHZhciBERUZBVUxUX0RBVEFfVVJJX1RBR1MgPSBhZGRUb1NldCh7fSwgWyJhdWRpbyIsICJ2aWRlbyIsICJpbWciLCAic291cmNlIiwgImltYWdlIiwgInRyYWNrIl0pOwogICAgICAgICAgdmFyIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsOwogICAgICAgICAgdmFyIERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyA9IGFkZFRvU2V0KHt9LCBbImFsdCIsICJjbGFzcyIsICJmb3IiLCAiaWQiLCAibGFiZWwiLCAibmFtZSIsICJwYXR0ZXJuIiwgInBsYWNlaG9sZGVyIiwgInJvbGUiLCAic3VtbWFyeSIsICJ0aXRsZSIsICJ2YWx1ZSIsICJzdHlsZSIsICJ4bWxucyJdKTsKICAgICAgICAgIHZhciBNQVRITUxfTkFNRVNQQUNFID0gImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwiOwogICAgICAgICAgdmFyIFNWR19OQU1FU1BBQ0UgPSAiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciOwogICAgICAgICAgdmFyIEhUTUxfTkFNRVNQQUNFID0gImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiOwogICAgICAgICAgdmFyIE5BTUVTUEFDRSA9IEhUTUxfTkFNRVNQQUNFOwogICAgICAgICAgdmFyIElTX0VNUFRZX0lOUFVUID0gZmFsc2U7CiAgICAgICAgICB2YXIgQUxMT1dFRF9OQU1FU1BBQ0VTID0gbnVsbDsKICAgICAgICAgIHZhciBERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUyA9IGFkZFRvU2V0KHt9LCBbTUFUSE1MX05BTUVTUEFDRSwgU1ZHX05BTUVTUEFDRSwgSFRNTF9OQU1FU1BBQ0VdLCBzdHJpbmdUb1N0cmluZyk7CiAgICAgICAgICB2YXIgUEFSU0VSX01FRElBX1RZUEU7CiAgICAgICAgICB2YXIgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsiYXBwbGljYXRpb24veGh0bWwreG1sIiwgInRleHQvaHRtbCJdOwogICAgICAgICAgdmFyIERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgPSAidGV4dC9odG1sIjsKICAgICAgICAgIHZhciB0cmFuc2Zvcm1DYXNlRnVuYzsKICAgICAgICAgIHZhciBDT05GSUcgPSBudWxsOwogICAgICAgICAgdmFyIGZvcm1FbGVtZW50ID0gZG9jdW1lbnQyLmNyZWF0ZUVsZW1lbnQoImZvcm0iKTsKICAgICAgICAgIHZhciBpc1JlZ2V4T3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzUmVnZXhPckZ1bmN0aW9uMih0ZXN0VmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuIHRlc3RWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0ZXN0VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbjsKICAgICAgICAgIH07CiAgICAgICAgICB2YXIgX3BhcnNlQ29uZmlnID0gZnVuY3Rpb24gX3BhcnNlQ29uZmlnMihjZmcpIHsKICAgICAgICAgICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIWNmZyB8fCBfdHlwZW9mKGNmZykgIT09ICJvYmplY3QiKSB7CiAgICAgICAgICAgICAgY2ZnID0ge307CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2ZnID0gY2xvbmUyKGNmZyk7CiAgICAgICAgICAgIFBBUlNFUl9NRURJQV9UWVBFID0gU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUy5pbmRleE9mKGNmZy5QQVJTRVJfTUVESUFfVFlQRSkgPT09IC0xID8gUEFSU0VSX01FRElBX1RZUEUgPSBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogUEFSU0VSX01FRElBX1RZUEUgPSBjZmcuUEFSU0VSX01FRElBX1RZUEU7CiAgICAgICAgICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICJhcHBsaWNhdGlvbi94aHRtbCt4bWwiID8gc3RyaW5nVG9TdHJpbmcgOiBzdHJpbmdUb0xvd2VyQ2FzZTsKICAgICAgICAgICAgQUxMT1dFRF9UQUdTID0gIkFMTE9XRURfVEFHUyIgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTOwogICAgICAgICAgICBBTExPV0VEX0FUVFIgPSAiQUxMT1dFRF9BVFRSIiBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9BTExPV0VEX0FUVFI7CiAgICAgICAgICAgIEFMTE9XRURfTkFNRVNQQUNFUyA9ICJBTExPV0VEX05BTUVTUEFDRVMiIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9OQU1FU1BBQ0VTLCBzdHJpbmdUb1N0cmluZykgOiBERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUzsKICAgICAgICAgICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9ICJBRERfVVJJX1NBRkVfQVRUUiIgaW4gY2ZnID8gYWRkVG9TZXQoCiAgICAgICAgICAgICAgY2xvbmUyKERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyksCiAgICAgICAgICAgICAgY2ZnLkFERF9VUklfU0FGRV9BVFRSLAogICAgICAgICAgICAgIHRyYW5zZm9ybUNhc2VGdW5jCiAgICAgICAgICAgICkgOiBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVM7CiAgICAgICAgICAgIERBVEFfVVJJX1RBR1MgPSAiQUREX0RBVEFfVVJJX1RBR1MiIGluIGNmZyA/IGFkZFRvU2V0KAogICAgICAgICAgICAgIGNsb25lMihERUZBVUxUX0RBVEFfVVJJX1RBR1MpLAogICAgICAgICAgICAgIGNmZy5BRERfREFUQV9VUklfVEFHUywKICAgICAgICAgICAgICB0cmFuc2Zvcm1DYXNlRnVuYwogICAgICAgICAgICApIDogREVGQVVMVF9EQVRBX1VSSV9UQUdTOwogICAgICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSAiRk9SQklEX0NPTlRFTlRTIiBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9DT05URU5UUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9GT1JCSURfQ09OVEVOVFM7CiAgICAgICAgICAgIEZPUkJJRF9UQUdTID0gIkZPUkJJRF9UQUdTIiBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiB7fTsKICAgICAgICAgICAgRk9SQklEX0FUVFIgPSAiRk9SQklEX0FUVFIiIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IHt9OwogICAgICAgICAgICBVU0VfUFJPRklMRVMgPSAiVVNFX1BST0ZJTEVTIiBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7CiAgICAgICAgICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOwogICAgICAgICAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsKICAgICAgICAgICAgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBjZmcuQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgfHwgZmFsc2U7CiAgICAgICAgICAgIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGNmZy5TQUZFX0ZPUl9URU1QTEFURVMgfHwgZmFsc2U7CiAgICAgICAgICAgIFdIT0xFX0RPQ1VNRU5UID0gY2ZnLldIT0xFX0RPQ1VNRU5UIHx8IGZhbHNlOwogICAgICAgICAgICBSRVRVUk5fRE9NID0gY2ZnLlJFVFVSTl9ET00gfHwgZmFsc2U7CiAgICAgICAgICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTsKICAgICAgICAgICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlOwogICAgICAgICAgICBGT1JDRV9CT0RZID0gY2ZnLkZPUkNFX0JPRFkgfHwgZmFsc2U7CiAgICAgICAgICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOwogICAgICAgICAgICBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGNmZy5TQU5JVElaRV9OQU1FRF9QUk9QUyB8fCBmYWxzZTsKICAgICAgICAgICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7CiAgICAgICAgICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlOwogICAgICAgICAgICBJU19BTExPV0VEX1VSSSQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQxOwogICAgICAgICAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFOwogICAgICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spKSB7CiAgICAgICAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjazsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2spKSB7CiAgICAgICAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjazsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIHR5cGVvZiBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzID09PSAiYm9vbGVhbiIpIHsKICAgICAgICAgICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHsKICAgICAgICAgICAgICBBTExPV19EQVRBX0FUVFIgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkgewogICAgICAgICAgICAgIFJFVFVSTl9ET00gPSB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChVU0VfUFJPRklMRVMpIHsKICAgICAgICAgICAgICBBTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgX3RvQ29uc3VtYWJsZUFycmF5KHRleHQpKTsKICAgICAgICAgICAgICBBTExPV0VEX0FUVFIgPSBbXTsKICAgICAgICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLmh0bWwgPT09IHRydWUpIHsKICAgICAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgaHRtbCQxKTsKICAgICAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnID09PSB0cnVlKSB7CiAgICAgICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2ZyQxKTsKICAgICAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTsKICAgICAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7CiAgICAgICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Z0ZpbHRlcnMpOwogICAgICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmcpOwogICAgICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBtYXRoTWwkMSk7CiAgICAgICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIG1hdGhNbCk7CiAgICAgICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjZmcuQUREX1RBR1MpIHsKICAgICAgICAgICAgICBpZiAoQUxMT1dFRF9UQUdTID09PSBERUZBVUxUX0FMTE9XRURfVEFHUykgewogICAgICAgICAgICAgICAgQUxMT1dFRF9UQUdTID0gY2xvbmUyKEFMTE9XRURfVEFHUyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNmZy5BRERfQVRUUikgewogICAgICAgICAgICAgIGlmIChBTExPV0VEX0FUVFIgPT09IERFRkFVTFRfQUxMT1dFRF9BVFRSKSB7CiAgICAgICAgICAgICAgICBBTExPV0VEX0FUVFIgPSBjbG9uZTIoQUxMT1dFRF9BVFRSKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBjZmcuQUREX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2ZnLkFERF9VUklfU0FGRV9BVFRSKSB7CiAgICAgICAgICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNmZy5GT1JCSURfQ09OVEVOVFMpIHsKICAgICAgICAgICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykgewogICAgICAgICAgICAgICAgRk9SQklEX0NPTlRFTlRTID0gY2xvbmUyKEZPUkJJRF9DT05URU5UUyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGFkZFRvU2V0KEZPUkJJRF9DT05URU5UUywgY2ZnLkZPUkJJRF9DT05URU5UUywgdHJhbnNmb3JtQ2FzZUZ1bmMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChLRUVQX0NPTlRFTlQpIHsKICAgICAgICAgICAgICBBTExPV0VEX1RBR1NbIiN0ZXh0Il0gPSB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChXSE9MRV9ET0NVTUVOVCkgewogICAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyJodG1sIiwgImhlYWQiLCAiYm9keSJdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoQUxMT1dFRF9UQUdTLnRhYmxlKSB7CiAgICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbInRib2R5Il0pOwogICAgICAgICAgICAgIGRlbGV0ZSBGT1JCSURfVEFHUy50Ym9keTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZnJlZXplKSB7CiAgICAgICAgICAgICAgZnJlZXplKGNmZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgQ09ORklHID0gY2ZnOwogICAgICAgICAgfTsKICAgICAgICAgIHZhciBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWyJtaSIsICJtbyIsICJtbiIsICJtcyIsICJtdGV4dCJdKTsKICAgICAgICAgIHZhciBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbImZvcmVpZ25vYmplY3QiLCAiZGVzYyIsICJ0aXRsZSIsICJhbm5vdGF0aW9uLXhtbCJdKTsKICAgICAgICAgIHZhciBDT01NT05fU1ZHX0FORF9IVE1MX0VMRU1FTlRTID0gYWRkVG9TZXQoe30sIFsidGl0bGUiLCAic3R5bGUiLCAiZm9udCIsICJhIiwgInNjcmlwdCJdKTsKICAgICAgICAgIHZhciBBTExfU1ZHX1RBR1MgPSBhZGRUb1NldCh7fSwgc3ZnJDEpOwogICAgICAgICAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTsKICAgICAgICAgIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRGlzYWxsb3dlZCk7CiAgICAgICAgICB2YXIgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIG1hdGhNbCQxKTsKICAgICAgICAgIGFkZFRvU2V0KEFMTF9NQVRITUxfVEFHUywgbWF0aE1sRGlzYWxsb3dlZCk7CiAgICAgICAgICB2YXIgX2NoZWNrVmFsaWROYW1lc3BhY2UgPSBmdW5jdGlvbiBfY2hlY2tWYWxpZE5hbWVzcGFjZTIoZWxlbWVudCkgewogICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTsKICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7CiAgICAgICAgICAgICAgcGFyZW50ID0gewogICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBOQU1FU1BBQ0UsCiAgICAgICAgICAgICAgICB0YWdOYW1lOiAidGVtcGxhdGUiCiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7CiAgICAgICAgICAgIHZhciBwYXJlbnRUYWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UocGFyZW50LnRhZ05hbWUpOwogICAgICAgICAgICBpZiAoIUFMTE9XRURfTkFNRVNQQUNFU1tlbGVtZW50Lm5hbWVzcGFjZVVSSV0pIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7CiAgICAgICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gInN2ZyI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gInN2ZyIgJiYgKHBhcmVudFRhZ05hbWUgPT09ICJhbm5vdGF0aW9uLXhtbCIgfHwgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHsKICAgICAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAibWF0aCI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gIm1hdGgiICYmIEhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHsKICAgICAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSAmJiAhSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UgJiYgIU1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UU1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoUEFSU0VSX01FRElBX1RZUEUgPT09ICJhcHBsaWNhdGlvbi94aHRtbCt4bWwiICYmIEFMTE9XRURfTkFNRVNQQUNFU1tlbGVtZW50Lm5hbWVzcGFjZVVSSV0pIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIF9mb3JjZVJlbW92ZSA9IGZ1bmN0aW9uIF9mb3JjZVJlbW92ZTIobm9kZSkgewogICAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5Mi5yZW1vdmVkLCB7CiAgICAgICAgICAgICAgZWxlbWVudDogbm9kZQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSBlbXB0eUhUTUw7CiAgICAgICAgICAgICAgfSBjYXRjaCAoXzIpIHsKICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIF9yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfcmVtb3ZlQXR0cmlidXRlMihuYW1lLCBub2RlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeTIucmVtb3ZlZCwgewogICAgICAgICAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksCiAgICAgICAgICAgICAgICBmcm9tOiBub2RlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHsKICAgICAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5Mi5yZW1vdmVkLCB7CiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IG51bGwsCiAgICAgICAgICAgICAgICBmcm9tOiBub2RlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7CiAgICAgICAgICAgIGlmIChuYW1lID09PSAiaXMiICYmICFBTExPV0VEX0FUVFJbbmFtZV0pIHsKICAgICAgICAgICAgICBpZiAoUkVUVVJOX0RPTSB8fCBSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICBfZm9yY2VSZW1vdmUobm9kZSk7CiAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICIiKTsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICB2YXIgX2luaXREb2N1bWVudCA9IGZ1bmN0aW9uIF9pbml0RG9jdW1lbnQyKGRpcnR5KSB7CiAgICAgICAgICAgIHZhciBkb2M7CiAgICAgICAgICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZTsKICAgICAgICAgICAgaWYgKEZPUkNFX0JPRFkpIHsKICAgICAgICAgICAgICBkaXJ0eSA9ICI8cmVtb3ZlPjwvcmVtb3ZlPiIgKyBkaXJ0eTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHN0cmluZ01hdGNoKGRpcnR5LCAvXltcclxuXHQgXSsvKTsKICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoUEFSU0VSX01FRElBX1RZUEUgPT09ICJhcHBsaWNhdGlvbi94aHRtbCt4bWwiICYmIE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHsKICAgICAgICAgICAgICBkaXJ0eSA9ICc8aHRtbCB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PGhlYWQ+PC9oZWFkPjxib2R5PicgKyBkaXJ0eSArICI8L2JvZHk+PC9odG1sPiI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGRpcnR5UGF5bG9hZCA9IHRydXN0ZWRUeXBlc1BvbGljeSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5OwogICAgICAgICAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyMigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsIFBBUlNFUl9NRURJQV9UWVBFKTsKICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7CiAgICAgICAgICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24yLmNyZWF0ZURvY3VtZW50KE5BTUVTUEFDRSwgInRlbXBsYXRlIiwgbnVsbCk7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyAiIiA6IGRpcnR5UGF5bG9hZDsKICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBib2R5ID0gZG9jLmJvZHkgfHwgZG9jLmRvY3VtZW50RWxlbWVudDsKICAgICAgICAgICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7CiAgICAgICAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQyLmNyZWF0ZVRleHROb2RlKGxlYWRpbmdXaGl0ZXNwYWNlKSwgYm9keS5jaGlsZE5vZGVzWzBdIHx8IG51bGwpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlUYWdOYW1lLmNhbGwoZG9jLCBXSE9MRV9ET0NVTUVOVCA/ICJodG1sIiA6ICJib2R5IilbMF07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIFdIT0xFX0RPQ1VNRU5UID8gZG9jLmRvY3VtZW50RWxlbWVudCA6IGJvZHk7CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIF9jcmVhdGVJdGVyYXRvciA9IGZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvcjIocm9vdCkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwoCiAgICAgICAgICAgICAgcm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsCiAgICAgICAgICAgICAgcm9vdCwKICAgICAgICAgICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQsCiAgICAgICAgICAgICAgbnVsbCwKICAgICAgICAgICAgICBmYWxzZQogICAgICAgICAgICApOwogICAgICAgICAgfTsKICAgICAgICAgIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQyKGVsbSkgewogICAgICAgICAgICByZXR1cm4gZWxtIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50ICYmICh0eXBlb2YgZWxtLm5vZGVOYW1lICE9PSAic3RyaW5nIiB8fCB0eXBlb2YgZWxtLnRleHRDb250ZW50ICE9PSAic3RyaW5nIiB8fCB0eXBlb2YgZWxtLnJlbW92ZUNoaWxkICE9PSAiZnVuY3Rpb24iIHx8ICEoZWxtLmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBOYW1lZE5vZGVNYXApIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQXR0cmlidXRlICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBlbG0uc2V0QXR0cmlidXRlICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBlbG0ubmFtZXNwYWNlVVJJICE9PSAic3RyaW5nIiB8fCB0eXBlb2YgZWxtLmluc2VydEJlZm9yZSAhPT0gImZ1bmN0aW9uIiB8fCB0eXBlb2YgZWxtLmhhc0NoaWxkTm9kZXMgIT09ICJmdW5jdGlvbiIpOwogICAgICAgICAgfTsKICAgICAgICAgIHZhciBfaXNOb2RlID0gZnVuY3Rpb24gX2lzTm9kZTIob2JqZWN0KSB7CiAgICAgICAgICAgIHJldHVybiBfdHlwZW9mKE5vZGUpID09PSAib2JqZWN0IiA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiBvYmplY3QgJiYgX3R5cGVvZihvYmplY3QpID09PSAib2JqZWN0IiAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAibnVtYmVyIiAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAic3RyaW5nIjsKICAgICAgICAgIH07CiAgICAgICAgICB2YXIgX2V4ZWN1dGVIb29rID0gZnVuY3Rpb24gX2V4ZWN1dGVIb29rMihlbnRyeVBvaW50LCBjdXJyZW50Tm9kZSwgZGF0YSkgewogICAgICAgICAgICBpZiAoIWhvb2tzW2VudHJ5UG9pbnRdKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGFycmF5Rm9yRWFjaChob29rc1tlbnRyeVBvaW50XSwgZnVuY3Rpb24oaG9vaykgewogICAgICAgICAgICAgIGhvb2suY2FsbChET01QdXJpZnkyLCBjdXJyZW50Tm9kZSwgZGF0YSwgQ09ORklHKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIF9zYW5pdGl6ZUVsZW1lbnRzID0gZnVuY3Rpb24gX3Nhbml0aXplRWxlbWVudHMyKGN1cnJlbnROb2RlKSB7CiAgICAgICAgICAgIHZhciBjb250ZW50OwogICAgICAgICAgICBfZXhlY3V0ZUhvb2soImJlZm9yZVNhbml0aXplRWxlbWVudHMiLCBjdXJyZW50Tm9kZSwgbnVsbCk7CiAgICAgICAgICAgIGlmIChfaXNDbG9iYmVyZWQoY3VycmVudE5vZGUpKSB7CiAgICAgICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocmVnRXhwVGVzdCgvW1x1MDA4MC1cdUZGRkZdLywgY3VycmVudE5vZGUubm9kZU5hbWUpKSB7CiAgICAgICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTsKICAgICAgICAgICAgX2V4ZWN1dGVIb29rKCJ1cG9uU2FuaXRpemVFbGVtZW50IiwgY3VycmVudE5vZGUsIHsKICAgICAgICAgICAgICB0YWdOYW1lLAogICAgICAgICAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1MKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5oYXNDaGlsZE5vZGVzKCkgJiYgIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXHddL2csIGN1cnJlbnROb2RlLmlubmVySFRNTCkgJiYgcmVnRXhwVGVzdCgvPFsvXHddL2csIGN1cnJlbnROb2RlLnRleHRDb250ZW50KSkgewogICAgICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICJzZWxlY3QiICYmIHJlZ0V4cFRlc3QoLzx0ZW1wbGF0ZS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7CiAgICAgICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkgewogICAgICAgICAgICAgIGlmICghRk9SQklEX1RBR1NbdGFnTmFtZV0gJiYgX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QodGFnTmFtZSkpIHsKICAgICAgICAgICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHRhZ05hbWUpKQogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICBpZiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKHRhZ05hbWUpKQogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkgewogICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5wYXJlbnROb2RlOwogICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBnZXRDaGlsZE5vZGVzKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5jaGlsZE5vZGVzOwogICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSkgewogICAgICAgICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGNoaWxkTm9kZXMubGVuZ3RoOwogICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmVOb2RlKGNoaWxkTm9kZXNbaV0sIHRydWUpLCBnZXROZXh0U2libGluZyhjdXJyZW50Tm9kZSkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7CiAgICAgICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoKHRhZ05hbWUgPT09ICJub3NjcmlwdCIgfHwgdGFnTmFtZSA9PT0gIm5vZW1iZWQiKSAmJiByZWdFeHBUZXN0KC88XC9ubyhzY3JpcHR8ZW1iZWQpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHsKICAgICAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpOwogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMpIHsKICAgICAgICAgICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7CiAgICAgICAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgTVVTVEFDSEVfRVhQUiQxLCAiICIpOwogICAgICAgICAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIEVSQl9FWFBSJDEsICIgIik7CiAgICAgICAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgVE1QTElUX0VYUFIkMSwgIiAiKTsKICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQgIT09IGNvbnRlbnQpIHsKICAgICAgICAgICAgICAgIGFycmF5UHVzaChET01QdXJpZnkyLnJlbW92ZWQsIHsKICAgICAgICAgICAgICAgICAgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgY3VycmVudE5vZGUudGV4dENvbnRlbnQgPSBjb250ZW50OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBfZXhlY3V0ZUhvb2soImFmdGVyU2FuaXRpemVFbGVtZW50cyIsIGN1cnJlbnROb2RlLCBudWxsKTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfTsKICAgICAgICAgIHZhciBfaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9pc1ZhbGlkQXR0cmlidXRlMihsY1RhZywgbGNOYW1lLCB2YWx1ZSkgewogICAgICAgICAgICBpZiAoU0FOSVRJWkVfRE9NICYmIChsY05hbWUgPT09ICJpZCIgfHwgbGNOYW1lID09PSAibmFtZSIpICYmICh2YWx1ZSBpbiBkb2N1bWVudDIgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgIUZPUkJJRF9BVFRSW2xjTmFtZV0gJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIkMSwgbGNOYW1lKSkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiQxLCBsY05hbWUpKQogICAgICAgICAgICAgIDsKICAgICAgICAgICAgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHsKICAgICAgICAgICAgICBpZiAoX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QobGNUYWcpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIGxjVGFnKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sobGNUYWcpKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrLCBsY05hbWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayhsY05hbWUpKSB8fCBsY05hbWUgPT09ICJpcyIgJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHZhbHVlKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodmFsdWUpKSkKICAgICAgICAgICAgICAgIDsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSBpZiAoVVJJX1NBRkVfQVRUUklCVVRFU1tsY05hbWVdKQogICAgICAgICAgICAgIDsKICAgICAgICAgICAgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkMSwgIiIpKSkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIGVsc2UgaWYgKChsY05hbWUgPT09ICJzcmMiIHx8IGxjTmFtZSA9PT0gInhsaW5rOmhyZWYiIHx8IGxjTmFtZSA9PT0gImhyZWYiKSAmJiBsY1RhZyAhPT0gInNjcmlwdCIgJiYgc3RyaW5nSW5kZXhPZih2YWx1ZSwgImRhdGE6IikgPT09IDAgJiYgREFUQV9VUklfVEFHU1tsY1RhZ10pCiAgICAgICAgICAgICAgOwogICAgICAgICAgICBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkMSwgIiIpKSkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIGVsc2UgaWYgKCF2YWx1ZSkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH07CiAgICAgICAgICB2YXIgX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QgPSBmdW5jdGlvbiBfYmFzaWNDdXN0b21FbGVtZW50VGVzdDIodGFnTmFtZSkgewogICAgICAgICAgICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCItIikgPiAwOwogICAgICAgICAgfTsKICAgICAgICAgIHZhciBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3Nhbml0aXplQXR0cmlidXRlczIoY3VycmVudE5vZGUpIHsKICAgICAgICAgICAgdmFyIGF0dHI7CiAgICAgICAgICAgIHZhciB2YWx1ZTsKICAgICAgICAgICAgdmFyIGxjTmFtZTsKICAgICAgICAgICAgdmFyIGw7CiAgICAgICAgICAgIF9leGVjdXRlSG9vaygiYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzIiwgY3VycmVudE5vZGUsIG51bGwpOwogICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGN1cnJlbnROb2RlLmF0dHJpYnV0ZXM7CiAgICAgICAgICAgIGlmICghYXR0cmlidXRlcykgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgaG9va0V2ZW50ID0gewogICAgICAgICAgICAgIGF0dHJOYW1lOiAiIiwKICAgICAgICAgICAgICBhdHRyVmFsdWU6ICIiLAogICAgICAgICAgICAgIGtlZXBBdHRyOiB0cnVlLAogICAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBBTExPV0VEX0FUVFIKICAgICAgICAgICAgfTsKICAgICAgICAgICAgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOwogICAgICAgICAgICB3aGlsZSAobC0tKSB7CiAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbbF07CiAgICAgICAgICAgICAgdmFyIF9hdHRyID0gYXR0ciwgbmFtZSA9IF9hdHRyLm5hbWUsIG5hbWVzcGFjZVVSSSA9IF9hdHRyLm5hbWVzcGFjZVVSSTsKICAgICAgICAgICAgICB2YWx1ZSA9IG5hbWUgPT09ICJ2YWx1ZSIgPyBhdHRyLnZhbHVlIDogc3RyaW5nVHJpbShhdHRyLnZhbHVlKTsKICAgICAgICAgICAgICBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhuYW1lKTsKICAgICAgICAgICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7CiAgICAgICAgICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlOwogICAgICAgICAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7CiAgICAgICAgICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB2b2lkIDA7CiAgICAgICAgICAgICAgX2V4ZWN1dGVIb29rKCJ1cG9uU2FuaXRpemVBdHRyaWJ1dGUiLCBjdXJyZW50Tm9kZSwgaG9va0V2ZW50KTsKICAgICAgICAgICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7CiAgICAgICAgICAgICAgaWYgKGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyKSB7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7CiAgICAgICAgICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocmVnRXhwVGVzdCgvXC8+L2ksIHZhbHVlKSkgewogICAgICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykgewogICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBNVVNUQUNIRV9FWFBSJDEsICIgIik7CiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJDEsICIgIik7CiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIFRNUExJVF9FWFBSJDEsICIgIik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTsKICAgICAgICAgICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChTQU5JVElaRV9OQU1FRF9QUk9QUyAmJiAobGNOYW1lID09PSAiaWQiIHx8IGxjTmFtZSA9PT0gIm5hbWUiKSkgewogICAgICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7CiAgICAgICAgICAgICAgICB2YWx1ZSA9IFNBTklUSVpFX05BTUVEX1BST1BTX1BSRUZJWCArIHZhbHVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICYmIF90eXBlb2YodHJ1c3RlZFR5cGVzKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIHRydXN0ZWRUeXBlcy5nZXRBdHRyaWJ1dGVUeXBlID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlVVJJKQogICAgICAgICAgICAgICAgICA7CiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoICh0cnVzdGVkVHlwZXMuZ2V0QXR0cmlidXRlVHlwZShsY1RhZywgbGNOYW1lKSkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgIlRydXN0ZWRIVE1MIjoKICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwodmFsdWUpOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiVHJ1c3RlZFNjcmlwdFVSTCI6CiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVTY3JpcHRVUkwodmFsdWUpOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHsKICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBuYW1lLCB2YWx1ZSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYXJyYXlQb3AoRE9NUHVyaWZ5Mi5yZW1vdmVkKTsKICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIF9leGVjdXRlSG9vaygiYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMiLCBjdXJyZW50Tm9kZSwgbnVsbCk7CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIF9zYW5pdGl6ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uIF9zYW5pdGl6ZVNoYWRvd0RPTTIoZnJhZ21lbnQpIHsKICAgICAgICAgICAgdmFyIHNoYWRvd05vZGU7CiAgICAgICAgICAgIHZhciBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihmcmFnbWVudCk7CiAgICAgICAgICAgIF9leGVjdXRlSG9vaygiYmVmb3JlU2FuaXRpemVTaGFkb3dET00iLCBmcmFnbWVudCwgbnVsbCk7CiAgICAgICAgICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkgewogICAgICAgICAgICAgIF9leGVjdXRlSG9vaygidXBvblNhbml0aXplU2hhZG93Tm9kZSIsIHNoYWRvd05vZGUsIG51bGwpOwogICAgICAgICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhzaGFkb3dOb2RlKSkgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzaGFkb3dOb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50MikgewogICAgICAgICAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NMihzaGFkb3dOb2RlLmNvbnRlbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKHNoYWRvd05vZGUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIF9leGVjdXRlSG9vaygiYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTSIsIGZyYWdtZW50LCBudWxsKTsKICAgICAgICAgIH07CiAgICAgICAgICBET01QdXJpZnkyLnNhbml0aXplID0gZnVuY3Rpb24oZGlydHkpIHsKICAgICAgICAgICAgdmFyIGNmZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307CiAgICAgICAgICAgIHZhciBib2R5OwogICAgICAgICAgICB2YXIgaW1wb3J0ZWROb2RlOwogICAgICAgICAgICB2YXIgY3VycmVudE5vZGU7CiAgICAgICAgICAgIHZhciBvbGROb2RlOwogICAgICAgICAgICB2YXIgcmV0dXJuTm9kZTsKICAgICAgICAgICAgSVNfRU1QVFlfSU5QVVQgPSAhZGlydHk7CiAgICAgICAgICAgIGlmIChJU19FTVBUWV9JTlBVVCkgewogICAgICAgICAgICAgIGRpcnR5ID0gIjwhLS0+IjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAic3RyaW5nIiAmJiAhX2lzTm9kZShkaXJ0eSkpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5LnRvU3RyaW5nICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoInRvU3RyaW5nIGlzIG5vdCBhIGZ1bmN0aW9uIik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGRpcnR5ID0gZGlydHkudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgiZGlydHkgaXMgbm90IGEgc3RyaW5nLCBhYm9ydGluZyIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIURPTVB1cmlmeTIuaXNTdXBwb3J0ZWQpIHsKICAgICAgICAgICAgICBpZiAoX3R5cGVvZih3aW5kb3cyLnRvU3RhdGljSFRNTCkgPT09ICJvYmplY3QiIHx8IHR5cGVvZiB3aW5kb3cyLnRvU3RhdGljSFRNTCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdzIudG9TdGF0aWNIVE1MKGRpcnR5KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChfaXNOb2RlKGRpcnR5KSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93Mi50b1N0YXRpY0hUTUwoZGlydHkub3V0ZXJIVE1MKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghU0VUX0NPTkZJRykgewogICAgICAgICAgICAgIF9wYXJzZUNvbmZpZyhjZmcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIERPTVB1cmlmeTIucmVtb3ZlZCA9IFtdOwogICAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgIElOX1BMQUNFID0gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKElOX1BMQUNFKSB7CiAgICAgICAgICAgICAgaWYgKGRpcnR5Lm5vZGVOYW1lKSB7CiAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGRpcnR5Lm5vZGVOYW1lKTsKICAgICAgICAgICAgICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7CiAgICAgICAgICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgicm9vdCBub2RlIGlzIGZvcmJpZGRlbiBhbmQgY2Fubm90IGJlIHNhbml0aXplZCBpbi1wbGFjZSIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJ0eSBpbnN0YW5jZW9mIE5vZGUpIHsKICAgICAgICAgICAgICBib2R5ID0gX2luaXREb2N1bWVudCgiPCEtLS0tPiIpOwogICAgICAgICAgICAgIGltcG9ydGVkTm9kZSA9IGJvZHkub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKGRpcnR5LCB0cnVlKTsKICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSAxICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gIkJPRFkiKSB7CiAgICAgICAgICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAiSFRNTCIpIHsKICAgICAgICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaW1wb3J0ZWROb2RlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmIGRpcnR5LmluZGV4T2YoIjwiKSA9PT0gLTEpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBib2R5ID0gX2luaXREb2N1bWVudChkaXJ0eSk7CiAgICAgICAgICAgICAgaWYgKCFib2R5KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gUkVUVVJOX0RPTSA/IG51bGwgOiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gZW1wdHlIVE1MIDogIiI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHsKICAgICAgICAgICAgICBfZm9yY2VSZW1vdmUoYm9keS5maXJzdENoaWxkKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTsKICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpIHsKICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMgJiYgY3VycmVudE5vZGUgPT09IG9sZE5vZGUpIHsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpKSB7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50MikgewogICAgICAgICAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKTsKICAgICAgICAgICAgICBvbGROb2RlID0gY3VycmVudE5vZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgb2xkTm9kZSA9IG51bGw7CiAgICAgICAgICAgIGlmIChJTl9QTEFDRSkgewogICAgICAgICAgICAgIHJldHVybiBkaXJ0eTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoUkVUVVJOX0RPTSkgewogICAgICAgICAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7CiAgICAgICAgICAgICAgICByZXR1cm5Ob2RlID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudC5jYWxsKGJvZHkub3duZXJEb2N1bWVudCk7CiAgICAgICAgICAgICAgICB3aGlsZSAoYm9keS5maXJzdENoaWxkKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChBTExPV0VEX0FUVFIuc2hhZG93cm9vdCkgewogICAgICAgICAgICAgICAgcmV0dXJuTm9kZSA9IGltcG9ydE5vZGUuY2FsbChvcmlnaW5hbERvY3VtZW50LCByZXR1cm5Ob2RlLCB0cnVlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybk5vZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MOwogICAgICAgICAgICBpZiAoV0hPTEVfRE9DVU1FTlQgJiYgQUxMT1dFRF9UQUdTWyIhZG9jdHlwZSJdICYmIGJvZHkub3duZXJEb2N1bWVudCAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZSAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lICYmIHJlZ0V4cFRlc3QoRE9DVFlQRV9OQU1FLCBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lKSkgewogICAgICAgICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gIjwhRE9DVFlQRSAiICsgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSArICI+XG4iICsgc2VyaWFsaXplZEhUTUw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykgewogICAgICAgICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgTVVTVEFDSEVfRVhQUiQxLCAiICIpOwogICAgICAgICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgRVJCX0VYUFIkMSwgIiAiKTsKICAgICAgICAgICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIFRNUExJVF9FWFBSJDEsICIgIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoc2VyaWFsaXplZEhUTUwpIDogc2VyaWFsaXplZEhUTUw7CiAgICAgICAgICB9OwogICAgICAgICAgRE9NUHVyaWZ5Mi5zZXRDb25maWcgPSBmdW5jdGlvbihjZmcpIHsKICAgICAgICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7CiAgICAgICAgICAgIFNFVF9DT05GSUcgPSB0cnVlOwogICAgICAgICAgfTsKICAgICAgICAgIERPTVB1cmlmeTIuY2xlYXJDb25maWcgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgQ09ORklHID0gbnVsbDsKICAgICAgICAgICAgU0VUX0NPTkZJRyA9IGZhbHNlOwogICAgICAgICAgfTsKICAgICAgICAgIERPTVB1cmlmeTIuaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHRhZywgYXR0ciwgdmFsdWUpIHsKICAgICAgICAgICAgaWYgKCFDT05GSUcpIHsKICAgICAgICAgICAgICBfcGFyc2VDb25maWcoe30pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7CiAgICAgICAgICAgIHZhciBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhhdHRyKTsKICAgICAgICAgICAgcmV0dXJuIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKTsKICAgICAgICAgIH07CiAgICAgICAgICBET01QdXJpZnkyLmFkZEhvb2sgPSBmdW5jdGlvbihlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBob29rc1tlbnRyeVBvaW50XSB8fCBbXTsKICAgICAgICAgICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pOwogICAgICAgICAgfTsKICAgICAgICAgIERPTVB1cmlmeTIucmVtb3ZlSG9vayA9IGZ1bmN0aW9uKGVudHJ5UG9pbnQpIHsKICAgICAgICAgICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5UG9wKGhvb2tzW2VudHJ5UG9pbnRdKTsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIERPTVB1cmlmeTIucmVtb3ZlSG9va3MgPSBmdW5jdGlvbihlbnRyeVBvaW50KSB7CiAgICAgICAgICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkgewogICAgICAgICAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBET01QdXJpZnkyLnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGhvb2tzID0ge307CiAgICAgICAgICB9OwogICAgICAgICAgcmV0dXJuIERPTVB1cmlmeTI7CiAgICAgICAgfQogICAgICAgIHZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTsKICAgICAgICByZXR1cm4gcHVyaWZ5OwogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2RlZmluZWQuanMKICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7CiAgICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbDsKICB9CiAgdmFyIGRlZmluZWRfZGVmYXVsdCA9IGRlZmluZWQ7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9EZXZlbG9wZXJFcnJvci5qcwogIGZ1bmN0aW9uIERldmVsb3BlckVycm9yKG1lc3NhZ2UpIHsKICAgIHRoaXMubmFtZSA9ICJEZXZlbG9wZXJFcnJvciI7CiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgbGV0IHN0YWNrOwogICAgdHJ5IHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIHN0YWNrID0gZS5zdGFjazsKICAgIH0KICAgIHRoaXMuc3RhY2sgPSBzdGFjazsKICB9CiAgaWYgKGRlZmluZWRfZGVmYXVsdChPYmplY3QuY3JlYXRlKSkgewogICAgRGV2ZWxvcGVyRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpOwogICAgRGV2ZWxvcGVyRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGV2ZWxvcGVyRXJyb3I7CiAgfQogIERldmVsb3BlckVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogICAgbGV0IHN0ciA9IGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfWA7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KHRoaXMuc3RhY2spKSB7CiAgICAgIHN0ciArPSBgCiR7dGhpcy5zdGFjay50b1N0cmluZygpfWA7CiAgICB9CiAgICByZXR1cm4gc3RyOwogIH07CiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHsKICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigKICAgICAgIlRoaXMgZnVuY3Rpb24gZGVmaW5lcyBhbiBpbnRlcmZhY2UgYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LiIKICAgICk7CiAgfTsKICB2YXIgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCA9IERldmVsb3BlckVycm9yOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ2hlY2suanMKICB2YXIgQ2hlY2sgPSB7fTsKICBDaGVjay50eXBlT2YgPSB7fTsKICBmdW5jdGlvbiBnZXRVbmRlZmluZWRFcnJvck1lc3NhZ2UobmFtZSkgewogICAgcmV0dXJuIGAke25hbWV9IGlzIHJlcXVpcmVkLCBhY3R1YWwgdmFsdWUgd2FzIHVuZGVmaW5lZGA7CiAgfQogIGZ1bmN0aW9uIGdldEZhaWxlZFR5cGVFcnJvck1lc3NhZ2UoYWN0dWFsLCBleHBlY3RlZCwgbmFtZSkgewogICAgcmV0dXJuIGBFeHBlY3RlZCAke25hbWV9IHRvIGJlIHR5cGVvZiAke2V4cGVjdGVkfSwgYWN0dWFsIHR5cGVvZiB3YXMgJHthY3R1YWx9YDsKICB9CiAgQ2hlY2suZGVmaW5lZCA9IGZ1bmN0aW9uKG5hbWUsIHRlc3QpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRlc3QpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KGdldFVuZGVmaW5lZEVycm9yTWVzc2FnZShuYW1lKSk7CiAgICB9CiAgfTsKICBDaGVjay50eXBlT2YuZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIHRlc3QpIHsKICAgIGlmICh0eXBlb2YgdGVzdCAhPT0gImZ1bmN0aW9uIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICBnZXRGYWlsZWRUeXBlRXJyb3JNZXNzYWdlKHR5cGVvZiB0ZXN0LCAiZnVuY3Rpb24iLCBuYW1lKQogICAgICApOwogICAgfQogIH07CiAgQ2hlY2sudHlwZU9mLnN0cmluZyA9IGZ1bmN0aW9uKG5hbWUsIHRlc3QpIHsKICAgIGlmICh0eXBlb2YgdGVzdCAhPT0gInN0cmluZyIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgZ2V0RmFpbGVkVHlwZUVycm9yTWVzc2FnZSh0eXBlb2YgdGVzdCwgInN0cmluZyIsIG5hbWUpCiAgICAgICk7CiAgICB9CiAgfTsKICBDaGVjay50eXBlT2YubnVtYmVyID0gZnVuY3Rpb24obmFtZSwgdGVzdCkgewogICAgaWYgKHR5cGVvZiB0ZXN0ICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICBnZXRGYWlsZWRUeXBlRXJyb3JNZXNzYWdlKHR5cGVvZiB0ZXN0LCAibnVtYmVyIiwgbmFtZSkKICAgICAgKTsKICAgIH0KICB9OwogIENoZWNrLnR5cGVPZi5udW1iZXIubGVzc1RoYW4gPSBmdW5jdGlvbihuYW1lLCB0ZXN0LCBsaW1pdCkgewogICAgQ2hlY2sudHlwZU9mLm51bWJlcihuYW1lLCB0ZXN0KTsKICAgIGlmICh0ZXN0ID49IGxpbWl0KSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgIGBFeHBlY3RlZCAke25hbWV9IHRvIGJlIGxlc3MgdGhhbiAke2xpbWl0fSwgYWN0dWFsIHZhbHVlIHdhcyAke3Rlc3R9YAogICAgICApOwogICAgfQogIH07CiAgQ2hlY2sudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzID0gZnVuY3Rpb24obmFtZSwgdGVzdCwgbGltaXQpIHsKICAgIENoZWNrLnR5cGVPZi5udW1iZXIobmFtZSwgdGVzdCk7CiAgICBpZiAodGVzdCA+IGxpbWl0KSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgIGBFeHBlY3RlZCAke25hbWV9IHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke2xpbWl0fSwgYWN0dWFsIHZhbHVlIHdhcyAke3Rlc3R9YAogICAgICApOwogICAgfQogIH07CiAgQ2hlY2sudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uKG5hbWUsIHRlc3QsIGxpbWl0KSB7CiAgICBDaGVjay50eXBlT2YubnVtYmVyKG5hbWUsIHRlc3QpOwogICAgaWYgKHRlc3QgPD0gbGltaXQpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgZ3JlYXRlciB0aGFuICR7bGltaXR9LCBhY3R1YWwgdmFsdWUgd2FzICR7dGVzdH1gCiAgICAgICk7CiAgICB9CiAgfTsKICBDaGVjay50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMgPSBmdW5jdGlvbihuYW1lLCB0ZXN0LCBsaW1pdCkgewogICAgQ2hlY2sudHlwZU9mLm51bWJlcihuYW1lLCB0ZXN0KTsKICAgIGlmICh0ZXN0IDwgbGltaXQpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7bGltaXR9LCBhY3R1YWwgdmFsdWUgd2FzICR7dGVzdH1gCiAgICAgICk7CiAgICB9CiAgfTsKICBDaGVjay50eXBlT2Yub2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgdGVzdCkgewogICAgaWYgKHR5cGVvZiB0ZXN0ICE9PSAib2JqZWN0IikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICBnZXRGYWlsZWRUeXBlRXJyb3JNZXNzYWdlKHR5cGVvZiB0ZXN0LCAib2JqZWN0IiwgbmFtZSkKICAgICAgKTsKICAgIH0KICB9OwogIENoZWNrLnR5cGVPZi5ib29sID0gZnVuY3Rpb24obmFtZSwgdGVzdCkgewogICAgaWYgKHR5cGVvZiB0ZXN0ICE9PSAiYm9vbGVhbiIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgZ2V0RmFpbGVkVHlwZUVycm9yTWVzc2FnZSh0eXBlb2YgdGVzdCwgImJvb2xlYW4iLCBuYW1lKQogICAgICApOwogICAgfQogIH07CiAgQ2hlY2sudHlwZU9mLmJpZ2ludCA9IGZ1bmN0aW9uKG5hbWUsIHRlc3QpIHsKICAgIGlmICh0eXBlb2YgdGVzdCAhPT0gImJpZ2ludCIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgZ2V0RmFpbGVkVHlwZUVycm9yTWVzc2FnZSh0eXBlb2YgdGVzdCwgImJpZ2ludCIsIG5hbWUpCiAgICAgICk7CiAgICB9CiAgfTsKICBDaGVjay50eXBlT2YubnVtYmVyLmVxdWFscyA9IGZ1bmN0aW9uKG5hbWUxLCBuYW1lMiwgdGVzdDEsIHRlc3QyKSB7CiAgICBDaGVjay50eXBlT2YubnVtYmVyKG5hbWUxLCB0ZXN0MSk7CiAgICBDaGVjay50eXBlT2YubnVtYmVyKG5hbWUyLCB0ZXN0Mik7CiAgICBpZiAodGVzdDEgIT09IHRlc3QyKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgIGAke25hbWUxfSBtdXN0IGJlIGVxdWFsIHRvICR7bmFtZTJ9LCB0aGUgYWN0dWFsIHZhbHVlcyBhcmUgJHt0ZXN0MX0gYW5kICR7dGVzdDJ9YAogICAgICApOwogICAgfQogIH07CiAgdmFyIENoZWNrX2RlZmF1bHQgPSBDaGVjazsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2RlZmF1bHRWYWx1ZS5qcwogIGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZShhMywgYikgewogICAgaWYgKGEzICE9PSB2b2lkIDAgJiYgYTMgIT09IG51bGwpIHsKICAgICAgcmV0dXJuIGEzOwogICAgfQogICAgcmV0dXJuIGI7CiAgfQogIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QgPSBPYmplY3QuZnJlZXplKHt9KTsKICB2YXIgZGVmYXVsdFZhbHVlX2RlZmF1bHQgPSBkZWZhdWx0VmFsdWU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9NYXRoLmpzCiAgdmFyIGltcG9ydF9tZXJzZW5uZV90d2lzdGVyID0gX190b0VTTShyZXF1aXJlX21lcnNlbm5lX3R3aXN0ZXIoKSwgMSk7CiAgdmFyIENlc2l1bU1hdGggPSB7fTsKICBDZXNpdW1NYXRoLkVQU0lMT04xID0gMC4xOwogIENlc2l1bU1hdGguRVBTSUxPTjIgPSAwLjAxOwogIENlc2l1bU1hdGguRVBTSUxPTjMgPSAxZS0zOwogIENlc2l1bU1hdGguRVBTSUxPTjQgPSAxZS00OwogIENlc2l1bU1hdGguRVBTSUxPTjUgPSAxZS01OwogIENlc2l1bU1hdGguRVBTSUxPTjYgPSAxZS02OwogIENlc2l1bU1hdGguRVBTSUxPTjcgPSAxZS03OwogIENlc2l1bU1hdGguRVBTSUxPTjggPSAxZS04OwogIENlc2l1bU1hdGguRVBTSUxPTjkgPSAxZS05OwogIENlc2l1bU1hdGguRVBTSUxPTjEwID0gMWUtMTA7CiAgQ2VzaXVtTWF0aC5FUFNJTE9OMTEgPSAxZS0xMTsKICBDZXNpdW1NYXRoLkVQU0lMT04xMiA9IDFlLTEyOwogIENlc2l1bU1hdGguRVBTSUxPTjEzID0gMWUtMTM7CiAgQ2VzaXVtTWF0aC5FUFNJTE9OMTQgPSAxZS0xNDsKICBDZXNpdW1NYXRoLkVQU0lMT04xNSA9IDFlLTE1OwogIENlc2l1bU1hdGguRVBTSUxPTjE2ID0gMWUtMTY7CiAgQ2VzaXVtTWF0aC5FUFNJTE9OMTcgPSAxZS0xNzsKICBDZXNpdW1NYXRoLkVQU0lMT04xOCA9IDFlLTE4OwogIENlc2l1bU1hdGguRVBTSUxPTjE5ID0gMWUtMTk7CiAgQ2VzaXVtTWF0aC5FUFNJTE9OMjAgPSAxZS0yMDsKICBDZXNpdW1NYXRoLkVQU0lMT04yMSA9IDFlLTIxOwogIENlc2l1bU1hdGguR1JBVklUQVRJT05BTFBBUkFNRVRFUiA9IDM5ODYwMDQ0MThlNTsKICBDZXNpdW1NYXRoLlNPTEFSX1JBRElVUyA9IDY5NTVlNTsKICBDZXNpdW1NYXRoLkxVTkFSX1JBRElVUyA9IDE3Mzc0MDA7CiAgQ2VzaXVtTWF0aC5TSVhUWV9GT1VSX0tJTE9CWVRFUyA9IDY0ICogMTAyNDsKICBDZXNpdW1NYXRoLkZPVVJfR0lHQUJZVEVTID0gNCAqIDEwMjQgKiAxMDI0ICogMTAyNDsKICBDZXNpdW1NYXRoLnNpZ24gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChNYXRoLnNpZ24sIGZ1bmN0aW9uIHNpZ24odmFsdWUpIHsKICAgIHZhbHVlID0gK3ZhbHVlOwogICAgaWYgKHZhbHVlID09PSAwIHx8IHZhbHVlICE9PSB2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWU7CiAgICB9CiAgICByZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xOwogIH0pOwogIENlc2l1bU1hdGguc2lnbk5vdFplcm8gPSBmdW5jdGlvbih2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlIDwgMCA/IC0xIDogMTsKICB9OwogIENlc2l1bU1hdGgudG9TTm9ybSA9IGZ1bmN0aW9uKHZhbHVlLCByYW5nZU1heGltdW0pIHsKICAgIHJhbmdlTWF4aW11bSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHJhbmdlTWF4aW11bSwgMjU1KTsKICAgIHJldHVybiBNYXRoLnJvdW5kKAogICAgICAoQ2VzaXVtTWF0aC5jbGFtcCh2YWx1ZSwgLTEsIDEpICogMC41ICsgMC41KSAqIHJhbmdlTWF4aW11bQogICAgKTsKICB9OwogIENlc2l1bU1hdGguZnJvbVNOb3JtID0gZnVuY3Rpb24odmFsdWUsIHJhbmdlTWF4aW11bSkgewogICAgcmFuZ2VNYXhpbXVtID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQocmFuZ2VNYXhpbXVtLCAyNTUpOwogICAgcmV0dXJuIENlc2l1bU1hdGguY2xhbXAodmFsdWUsIDAsIHJhbmdlTWF4aW11bSkgLyByYW5nZU1heGltdW0gKiAyIC0gMTsKICB9OwogIENlc2l1bU1hdGgubm9ybWFsaXplID0gZnVuY3Rpb24odmFsdWUsIHJhbmdlTWluaW11bSwgcmFuZ2VNYXhpbXVtKSB7CiAgICByYW5nZU1heGltdW0gPSBNYXRoLm1heChyYW5nZU1heGltdW0gLSByYW5nZU1pbmltdW0sIDApOwogICAgcmV0dXJuIHJhbmdlTWF4aW11bSA9PT0gMCA/IDAgOiBDZXNpdW1NYXRoLmNsYW1wKCh2YWx1ZSAtIHJhbmdlTWluaW11bSkgLyByYW5nZU1heGltdW0sIDAsIDEpOwogIH07CiAgQ2VzaXVtTWF0aC5zaW5oID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoTWF0aC5zaW5oLCBmdW5jdGlvbiBzaW5oKHZhbHVlKSB7CiAgICByZXR1cm4gKE1hdGguZXhwKHZhbHVlKSAtIE1hdGguZXhwKC12YWx1ZSkpIC8gMjsKICB9KTsKICBDZXNpdW1NYXRoLmNvc2ggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChNYXRoLmNvc2gsIGZ1bmN0aW9uIGNvc2godmFsdWUpIHsKICAgIHJldHVybiAoTWF0aC5leHAodmFsdWUpICsgTWF0aC5leHAoLXZhbHVlKSkgLyAyOwogIH0pOwogIENlc2l1bU1hdGgubGVycCA9IGZ1bmN0aW9uKHAsIHEsIHRpbWUpIHsKICAgIHJldHVybiAoMSAtIHRpbWUpICogcCArIHRpbWUgKiBxOwogIH07CiAgQ2VzaXVtTWF0aC5QSSA9IE1hdGguUEk7CiAgQ2VzaXVtTWF0aC5PTkVfT1ZFUl9QSSA9IDEgLyBNYXRoLlBJOwogIENlc2l1bU1hdGguUElfT1ZFUl9UV08gPSBNYXRoLlBJIC8gMjsKICBDZXNpdW1NYXRoLlBJX09WRVJfVEhSRUUgPSBNYXRoLlBJIC8gMzsKICBDZXNpdW1NYXRoLlBJX09WRVJfRk9VUiA9IE1hdGguUEkgLyA0OwogIENlc2l1bU1hdGguUElfT1ZFUl9TSVggPSBNYXRoLlBJIC8gNjsKICBDZXNpdW1NYXRoLlRIUkVFX1BJX09WRVJfVFdPID0gMyAqIE1hdGguUEkgLyAyOwogIENlc2l1bU1hdGguVFdPX1BJID0gMiAqIE1hdGguUEk7CiAgQ2VzaXVtTWF0aC5PTkVfT1ZFUl9UV09fUEkgPSAxIC8gKDIgKiBNYXRoLlBJKTsKICBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRSA9IE1hdGguUEkgLyAxODA7CiAgQ2VzaXVtTWF0aC5ERUdSRUVTX1BFUl9SQURJQU4gPSAxODAgLyBNYXRoLlBJOwogIENlc2l1bU1hdGguUkFESUFOU19QRVJfQVJDU0VDT05EID0gQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUUgLyAzNjAwOwogIENlc2l1bU1hdGgudG9SYWRpYW5zID0gZnVuY3Rpb24oZGVncmVlcykgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZGVncmVlcykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImRlZ3JlZXMgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICByZXR1cm4gZGVncmVlcyAqIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFOwogIH07CiAgQ2VzaXVtTWF0aC50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyYWRpYW5zKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicmFkaWFucyBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHJldHVybiByYWRpYW5zICogQ2VzaXVtTWF0aC5ERUdSRUVTX1BFUl9SQURJQU47CiAgfTsKICBDZXNpdW1NYXRoLmNvbnZlcnRMb25naXR1ZGVSYW5nZSA9IGZ1bmN0aW9uKGFuZ2xlKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChhbmdsZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImFuZ2xlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgdHdvUGkgPSBDZXNpdW1NYXRoLlRXT19QSTsKICAgIGNvbnN0IHNpbXBsaWZpZWQgPSBhbmdsZSAtIE1hdGguZmxvb3IoYW5nbGUgLyB0d29QaSkgKiB0d29QaTsKICAgIGlmIChzaW1wbGlmaWVkIDwgLU1hdGguUEkpIHsKICAgICAgcmV0dXJuIHNpbXBsaWZpZWQgKyB0d29QaTsKICAgIH0KICAgIGlmIChzaW1wbGlmaWVkID49IE1hdGguUEkpIHsKICAgICAgcmV0dXJuIHNpbXBsaWZpZWQgLSB0d29QaTsKICAgIH0KICAgIHJldHVybiBzaW1wbGlmaWVkOwogIH07CiAgQ2VzaXVtTWF0aC5jbGFtcFRvTGF0aXR1ZGVSYW5nZSA9IGZ1bmN0aW9uKGFuZ2xlKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChhbmdsZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImFuZ2xlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgcmV0dXJuIENlc2l1bU1hdGguY2xhbXAoCiAgICAgIGFuZ2xlLAogICAgICAtMSAqIENlc2l1bU1hdGguUElfT1ZFUl9UV08sCiAgICAgIENlc2l1bU1hdGguUElfT1ZFUl9UV08KICAgICk7CiAgfTsKICBDZXNpdW1NYXRoLm5lZ2F0aXZlUGlUb1BpID0gZnVuY3Rpb24oYW5nbGUpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGFuZ2xlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYW5nbGUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoYW5nbGUgPj0gLUNlc2l1bU1hdGguUEkgJiYgYW5nbGUgPD0gQ2VzaXVtTWF0aC5QSSkgewogICAgICByZXR1cm4gYW5nbGU7CiAgICB9CiAgICByZXR1cm4gQ2VzaXVtTWF0aC56ZXJvVG9Ud29QaShhbmdsZSArIENlc2l1bU1hdGguUEkpIC0gQ2VzaXVtTWF0aC5QSTsKICB9OwogIENlc2l1bU1hdGguemVyb1RvVHdvUGkgPSBmdW5jdGlvbihhbmdsZSkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYW5nbGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhbmdsZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmIChhbmdsZSA+PSAwICYmIGFuZ2xlIDw9IENlc2l1bU1hdGguVFdPX1BJKSB7CiAgICAgIHJldHVybiBhbmdsZTsKICAgIH0KICAgIGNvbnN0IG1vZCA9IENlc2l1bU1hdGgubW9kKGFuZ2xlLCBDZXNpdW1NYXRoLlRXT19QSSk7CiAgICBpZiAoTWF0aC5hYnMobW9kKSA8IENlc2l1bU1hdGguRVBTSUxPTjE0ICYmIE1hdGguYWJzKGFuZ2xlKSA+IENlc2l1bU1hdGguRVBTSUxPTjE0KSB7CiAgICAgIHJldHVybiBDZXNpdW1NYXRoLlRXT19QSTsKICAgIH0KICAgIHJldHVybiBtb2Q7CiAgfTsKICBDZXNpdW1NYXRoLm1vZCA9IGZ1bmN0aW9uKG0sIG4pIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG0pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJtIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQobikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm4gaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAobiA9PT0gMCkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZGl2aXNvciBjYW5ub3QgYmUgMC4iKTsKICAgIH0KICAgIGlmIChDZXNpdW1NYXRoLnNpZ24obSkgPT09IENlc2l1bU1hdGguc2lnbihuKSAmJiBNYXRoLmFicyhtKSA8IE1hdGguYWJzKG4pKSB7CiAgICAgIHJldHVybiBtOwogICAgfQogICAgcmV0dXJuIChtICUgbiArIG4pICUgbjsKICB9OwogIENlc2l1bU1hdGguZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZWxhdGl2ZUVwc2lsb24sIGFic29sdXRlRXBzaWxvbikgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQobGVmdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImxlZnQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJpZ2h0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgcmVsYXRpdmVFcHNpbG9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQocmVsYXRpdmVFcHNpbG9uLCAwKTsKICAgIGFic29sdXRlRXBzaWxvbiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGFic29sdXRlRXBzaWxvbiwgcmVsYXRpdmVFcHNpbG9uKTsKICAgIGNvbnN0IGFic0RpZmYgPSBNYXRoLmFicyhsZWZ0IC0gcmlnaHQpOwogICAgcmV0dXJuIGFic0RpZmYgPD0gYWJzb2x1dGVFcHNpbG9uIHx8IGFic0RpZmYgPD0gcmVsYXRpdmVFcHNpbG9uICogTWF0aC5tYXgoTWF0aC5hYnMobGVmdCksIE1hdGguYWJzKHJpZ2h0KSk7CiAgfTsKICBDZXNpdW1NYXRoLmxlc3NUaGFuID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGFic29sdXRlRXBzaWxvbikgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQobGVmdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImZpcnN0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmlnaHQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJzZWNvbmQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChhYnNvbHV0ZUVwc2lsb24pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhYnNvbHV0ZUVwc2lsb24gaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICByZXR1cm4gbGVmdCAtIHJpZ2h0IDwgLWFic29sdXRlRXBzaWxvbjsKICB9OwogIENlc2l1bU1hdGgubGVzc1RoYW5PckVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBhYnNvbHV0ZUVwc2lsb24pIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGxlZnQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJmaXJzdCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgic2Vjb25kIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYWJzb2x1dGVFcHNpbG9uKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYWJzb2x1dGVFcHNpbG9uIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgcmV0dXJuIGxlZnQgLSByaWdodCA8IGFic29sdXRlRXBzaWxvbjsKICB9OwogIENlc2l1bU1hdGguZ3JlYXRlclRoYW4gPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgYWJzb2x1dGVFcHNpbG9uKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsZWZ0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZmlyc3QgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInNlY29uZCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGFic29sdXRlRXBzaWxvbikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImFic29sdXRlRXBzaWxvbiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHJldHVybiBsZWZ0IC0gcmlnaHQgPiBhYnNvbHV0ZUVwc2lsb247CiAgfTsKICBDZXNpdW1NYXRoLmdyZWF0ZXJUaGFuT3JFcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgYWJzb2x1dGVFcHNpbG9uKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsZWZ0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZmlyc3QgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInNlY29uZCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGFic29sdXRlRXBzaWxvbikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImFic29sdXRlRXBzaWxvbiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHJldHVybiBsZWZ0IC0gcmlnaHQgPiAtYWJzb2x1dGVFcHNpbG9uOwogIH07CiAgdmFyIGZhY3RvcmlhbHMgPSBbMV07CiAgQ2VzaXVtTWF0aC5mYWN0b3JpYWwgPSBmdW5jdGlvbihuKSB7CiAgICBpZiAodHlwZW9mIG4gIT09ICJudW1iZXIiIHx8IG4gPCAwKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJBIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBpcyByZXF1aXJlZC4iCiAgICAgICk7CiAgICB9CiAgICBjb25zdCBsZW5ndGggPSBmYWN0b3JpYWxzLmxlbmd0aDsKICAgIGlmIChuID49IGxlbmd0aCkgewogICAgICBsZXQgc3VtID0gZmFjdG9yaWFsc1tsZW5ndGggLSAxXTsKICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aDsgaSA8PSBuOyBpKyspIHsKICAgICAgICBjb25zdCBuZXh0ID0gc3VtICogaTsKICAgICAgICBmYWN0b3JpYWxzLnB1c2gobmV4dCk7CiAgICAgICAgc3VtID0gbmV4dDsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGZhY3RvcmlhbHNbbl07CiAgfTsKICBDZXNpdW1NYXRoLmluY3JlbWVudFdyYXAgPSBmdW5jdGlvbihuLCBtYXhpbXVtVmFsdWUsIG1pbmltdW1WYWx1ZSkgewogICAgbWluaW11bVZhbHVlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQobWluaW11bVZhbHVlLCAwKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG4pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJuIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKG1heGltdW1WYWx1ZSA8PSBtaW5pbXVtVmFsdWUpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm1heGltdW1WYWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBtaW5pbXVtVmFsdWUuIik7CiAgICB9CiAgICArK247CiAgICBpZiAobiA+IG1heGltdW1WYWx1ZSkgewogICAgICBuID0gbWluaW11bVZhbHVlOwogICAgfQogICAgcmV0dXJuIG47CiAgfTsKICBDZXNpdW1NYXRoLmlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uKG4pIHsKICAgIGlmICh0eXBlb2YgbiAhPT0gIm51bWJlciIgfHwgbiA8IDAgfHwgbiA+IDQyOTQ5NjcyOTUpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIkEgbnVtYmVyIGJldHdlZW4gMCBhbmQgKDJeMzIpLTEgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICByZXR1cm4gbiAhPT0gMCAmJiAobiAmIG4gLSAxKSA9PT0gMDsKICB9OwogIENlc2l1bU1hdGgubmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbihuKSB7CiAgICBpZiAodHlwZW9mIG4gIT09ICJudW1iZXIiIHx8IG4gPCAwIHx8IG4gPiAyMTQ3NDgzNjQ4KSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDJeMzEgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICAtLW47CiAgICBuIHw9IG4gPj4gMTsKICAgIG4gfD0gbiA+PiAyOwogICAgbiB8PSBuID4+IDQ7CiAgICBuIHw9IG4gPj4gODsKICAgIG4gfD0gbiA+PiAxNjsKICAgICsrbjsKICAgIHJldHVybiBuOwogIH07CiAgQ2VzaXVtTWF0aC5wcmV2aW91c1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihuKSB7CiAgICBpZiAodHlwZW9mIG4gIT09ICJudW1iZXIiIHx8IG4gPCAwIHx8IG4gPiA0Mjk0OTY3Mjk1KSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJBIG51bWJlciBiZXR3ZWVuIDAgYW5kICgyXjMyKS0xIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgbiB8PSBuID4+IDE7CiAgICBuIHw9IG4gPj4gMjsKICAgIG4gfD0gbiA+PiA0OwogICAgbiB8PSBuID4+IDg7CiAgICBuIHw9IG4gPj4gMTY7CiAgICBuIHw9IG4gPj4gMzI7CiAgICBuID0gKG4gPj4+IDApIC0gKG4gPj4+IDEpOwogICAgcmV0dXJuIG47CiAgfTsKICBDZXNpdW1NYXRoLmNsYW1wID0gZnVuY3Rpb24odmFsdWUsIG1pbiwgbWF4KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInZhbHVlIiwgdmFsdWUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJtaW4iLCBtaW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJtYXgiLCBtYXgpOwogICAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTsKICB9OwogIHZhciByYW5kb21OdW1iZXJHZW5lcmF0b3IgPSBuZXcgaW1wb3J0X21lcnNlbm5lX3R3aXN0ZXIuZGVmYXVsdCgpOwogIENlc2l1bU1hdGguc2V0UmFuZG9tTnVtYmVyU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHNlZWQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJzZWVkIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgcmFuZG9tTnVtYmVyR2VuZXJhdG9yID0gbmV3IGltcG9ydF9tZXJzZW5uZV90d2lzdGVyLmRlZmF1bHQoc2VlZCk7CiAgfTsKICBDZXNpdW1NYXRoLm5leHRSYW5kb21OdW1iZXIgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiByYW5kb21OdW1iZXJHZW5lcmF0b3IucmFuZG9tKCk7CiAgfTsKICBDZXNpdW1NYXRoLnJhbmRvbUJldHdlZW4gPSBmdW5jdGlvbihtaW4sIG1heCkgewogICAgcmV0dXJuIENlc2l1bU1hdGgubmV4dFJhbmRvbU51bWJlcigpICogKG1heCAtIG1pbikgKyBtaW47CiAgfTsKICBDZXNpdW1NYXRoLmFjb3NDbGFtcGVkID0gZnVuY3Rpb24odmFsdWUpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHZhbHVlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidmFsdWUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICByZXR1cm4gTWF0aC5hY29zKENlc2l1bU1hdGguY2xhbXAodmFsdWUsIC0xLCAxKSk7CiAgfTsKICBDZXNpdW1NYXRoLmFzaW5DbGFtcGVkID0gZnVuY3Rpb24odmFsdWUpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHZhbHVlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidmFsdWUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICByZXR1cm4gTWF0aC5hc2luKENlc2l1bU1hdGguY2xhbXAodmFsdWUsIC0xLCAxKSk7CiAgfTsKICBDZXNpdW1NYXRoLmNob3JkTGVuZ3RoID0gZnVuY3Rpb24oYW5nbGUsIHJhZGl1cykgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYW5nbGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhbmdsZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJhZGl1cykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJhZGl1cyBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHJldHVybiAyICogcmFkaXVzICogTWF0aC5zaW4oYW5nbGUgKiAwLjUpOwogIH07CiAgQ2VzaXVtTWF0aC5sb2dCYXNlID0gZnVuY3Rpb24obnVtYmVyLCBiYXNlKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChudW1iZXIpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJudW1iZXIgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChiYXNlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYmFzZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHJldHVybiBNYXRoLmxvZyhudW1iZXIpIC8gTWF0aC5sb2coYmFzZSk7CiAgfTsKICBDZXNpdW1NYXRoLmNicnQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChNYXRoLmNicnQsIGZ1bmN0aW9uIGNicnQobnVtYmVyKSB7CiAgICBjb25zdCByZXN1bHQgPSBNYXRoLnBvdyhNYXRoLmFicyhudW1iZXIpLCAxIC8gMyk7CiAgICByZXR1cm4gbnVtYmVyIDwgMCA/IC1yZXN1bHQgOiByZXN1bHQ7CiAgfSk7CiAgQ2VzaXVtTWF0aC5sb2cyID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoTWF0aC5sb2cyLCBmdW5jdGlvbiBsb2cyKG51bWJlcikgewogICAgcmV0dXJuIE1hdGgubG9nKG51bWJlcikgKiBNYXRoLkxPRzJFOwogIH0pOwogIENlc2l1bU1hdGguZm9nID0gZnVuY3Rpb24oZGlzdGFuY2VUb0NhbWVyYSwgZGVuc2l0eSkgewogICAgY29uc3Qgc2NhbGFyID0gZGlzdGFuY2VUb0NhbWVyYSAqIGRlbnNpdHk7CiAgICByZXR1cm4gMSAtIE1hdGguZXhwKC0oc2NhbGFyICogc2NhbGFyKSk7CiAgfTsKICBDZXNpdW1NYXRoLmZhc3RBcHByb3hpbWF0ZUF0YW4gPSBmdW5jdGlvbih4KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoIngiLCB4KTsKICAgIHJldHVybiB4ICogKC0wLjE3ODQgKiBNYXRoLmFicyh4KSAtIDAuMDY2MyAqIHggKiB4ICsgMS4wMzAxKTsKICB9OwogIENlc2l1bU1hdGguZmFzdEFwcHJveGltYXRlQXRhbjIgPSBmdW5jdGlvbih4LCB5KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoIngiLCB4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieSIsIHkpOwogICAgbGV0IG9wcG9zaXRlOwogICAgbGV0IHQgPSBNYXRoLmFicyh4KTsKICAgIG9wcG9zaXRlID0gTWF0aC5hYnMoeSk7CiAgICBjb25zdCBhZGphY2VudCA9IE1hdGgubWF4KHQsIG9wcG9zaXRlKTsKICAgIG9wcG9zaXRlID0gTWF0aC5taW4odCwgb3Bwb3NpdGUpOwogICAgY29uc3Qgb3Bwb3NpdGVPdmVyQWRqYWNlbnQgPSBvcHBvc2l0ZSAvIGFkamFjZW50OwogICAgaWYgKGlzTmFOKG9wcG9zaXRlT3ZlckFkamFjZW50KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZWl0aGVyIHggb3IgeSBtdXN0IGJlIG5vbnplcm8iKTsKICAgIH0KICAgIHQgPSBDZXNpdW1NYXRoLmZhc3RBcHByb3hpbWF0ZUF0YW4ob3Bwb3NpdGVPdmVyQWRqYWNlbnQpOwogICAgdCA9IE1hdGguYWJzKHkpID4gTWF0aC5hYnMoeCkgPyBDZXNpdW1NYXRoLlBJX09WRVJfVFdPIC0gdCA6IHQ7CiAgICB0ID0geCA8IDAgPyBDZXNpdW1NYXRoLlBJIC0gdCA6IHQ7CiAgICB0ID0geSA8IDAgPyAtdCA6IHQ7CiAgICByZXR1cm4gdDsKICB9OwogIHZhciBNYXRoX2RlZmF1bHQgPSBDZXNpdW1NYXRoOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ2FydGVzaWFuMy5qcwogIGZ1bmN0aW9uIENhcnRlc2lhbjMoeCwgeSwgeikgewogICAgdGhpcy54ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoeCwgMCk7CiAgICB0aGlzLnkgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh5LCAwKTsKICAgIHRoaXMueiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHosIDApOwogIH0KICBDYXJ0ZXNpYW4zLmZyb21TcGhlcmljYWwgPSBmdW5jdGlvbihzcGhlcmljYWwsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzcGhlcmljYWwiLCBzcGhlcmljYWwpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpOwogICAgfQogICAgY29uc3QgY2xvY2sgPSBzcGhlcmljYWwuY2xvY2s7CiAgICBjb25zdCBjb25lID0gc3BoZXJpY2FsLmNvbmU7CiAgICBjb25zdCBtYWduaXR1ZGUgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzcGhlcmljYWwubWFnbml0dWRlLCAxKTsKICAgIGNvbnN0IHJhZGlhbCA9IG1hZ25pdHVkZSAqIE1hdGguc2luKGNvbmUpOwogICAgcmVzdWx0LnggPSByYWRpYWwgKiBNYXRoLmNvcyhjbG9jayk7CiAgICByZXN1bHQueSA9IHJhZGlhbCAqIE1hdGguc2luKGNsb2NrKTsKICAgIHJlc3VsdC56ID0gbWFnbml0dWRlICogTWF0aC5jb3MoY29uZSk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5mcm9tRWxlbWVudHMgPSBmdW5jdGlvbih4LCB5LCB6LCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW4zKHgsIHksIHopOwogICAgfQogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjMuY2xvbmUgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY2FydGVzaWFuKSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IENhcnRlc2lhbjMoY2FydGVzaWFuLngsIGNhcnRlc2lhbi55LCBjYXJ0ZXNpYW4ueik7CiAgICB9CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54OwogICAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueTsKICAgIHJlc3VsdC56ID0gY2FydGVzaWFuLno7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5mcm9tQ2FydGVzaWFuNCA9IENhcnRlc2lhbjMuY2xvbmU7CiAgQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGggPSAzOwogIENhcnRlc2lhbjMucGFjayA9IGZ1bmN0aW9uKHZhbHVlLCBhcnJheSwgc3RhcnRpbmdJbmRleCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ2YWx1ZSIsIHZhbHVlKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RhcnRpbmdJbmRleCwgMCk7CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUueDsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS55OwogICAgYXJyYXlbc3RhcnRpbmdJbmRleF0gPSB2YWx1ZS56OwogICAgcmV0dXJuIGFycmF5OwogIH07CiAgQ2FydGVzaWFuMy51bnBhY2sgPSBmdW5jdGlvbihhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpOwogICAgfQogICAgcmVzdWx0LnggPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0LnkgPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0LnogPSBhcnJheVtzdGFydGluZ0luZGV4XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW4zLnBhY2tBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICBjb25zdCByZXN1bHRMZW5ndGggPSBsZW5ndGggKiAzOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXJyYXkocmVzdWx0TGVuZ3RoKTsKICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoICE9PSByZXN1bHRMZW5ndGgpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgIklmIHJlc3VsdCBpcyBhIHR5cGVkIGFycmF5LCBpdCBtdXN0IGhhdmUgZXhhY3RseSBhcnJheS5sZW5ndGggKiAzIGVsZW1lbnRzIgogICAgICApOwogICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoICE9PSByZXN1bHRMZW5ndGgpIHsKICAgICAgcmVzdWx0Lmxlbmd0aCA9IHJlc3VsdExlbmd0aDsKICAgIH0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgQ2FydGVzaWFuMy5wYWNrKGFycmF5W2ldLCByZXN1bHQsIGkgKiAzKTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW4zLnVucGFja0FycmF5ID0gZnVuY3Rpb24oYXJyYXksIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJhcnJheS5sZW5ndGgiLCBhcnJheS5sZW5ndGgsIDMpOwogICAgaWYgKGFycmF5Lmxlbmd0aCAlIDMgIT09IDApIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImFycmF5IGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMy4iKTsKICAgIH0KICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCAvIDMpOwogICAgfSBlbHNlIHsKICAgICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aCAvIDM7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAzKSB7CiAgICAgIGNvbnN0IGluZGV4ID0gaSAvIDM7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBDYXJ0ZXNpYW4zLnVucGFjayhhcnJheSwgaSwgcmVzdWx0W2luZGV4XSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5mcm9tQXJyYXkgPSBDYXJ0ZXNpYW4zLnVucGFjazsKICBDYXJ0ZXNpYW4zLm1heGltdW1Db21wb25lbnQgPSBmdW5jdGlvbihjYXJ0ZXNpYW4pIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIHJldHVybiBNYXRoLm1heChjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnksIGNhcnRlc2lhbi56KTsKICB9OwogIENhcnRlc2lhbjMubWluaW11bUNvbXBvbmVudCA9IGZ1bmN0aW9uKGNhcnRlc2lhbikgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgcmV0dXJuIE1hdGgubWluKGNhcnRlc2lhbi54LCBjYXJ0ZXNpYW4ueSwgY2FydGVzaWFuLnopOwogIH07CiAgQ2FydGVzaWFuMy5taW5pbXVtQnlDb21wb25lbnQgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZmlyc3QiLCBmaXJzdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInNlY29uZCIsIHNlY29uZCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IE1hdGgubWluKGZpcnN0LngsIHNlY29uZC54KTsKICAgIHJlc3VsdC55ID0gTWF0aC5taW4oZmlyc3QueSwgc2Vjb25kLnkpOwogICAgcmVzdWx0LnogPSBNYXRoLm1pbihmaXJzdC56LCBzZWNvbmQueik7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5tYXhpbXVtQnlDb21wb25lbnQgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZmlyc3QiLCBmaXJzdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInNlY29uZCIsIHNlY29uZCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IE1hdGgubWF4KGZpcnN0LngsIHNlY29uZC54KTsKICAgIHJlc3VsdC55ID0gTWF0aC5tYXgoZmlyc3QueSwgc2Vjb25kLnkpOwogICAgcmVzdWx0LnogPSBNYXRoLm1heChmaXJzdC56LCBzZWNvbmQueik7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInZhbHVlIiwgdmFsdWUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtaW4iLCBtaW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXgiLCBtYXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgeCA9IE1hdGhfZGVmYXVsdC5jbGFtcCh2YWx1ZS54LCBtaW4ueCwgbWF4LngpOwogICAgY29uc3QgeSA9IE1hdGhfZGVmYXVsdC5jbGFtcCh2YWx1ZS55LCBtaW4ueSwgbWF4LnkpOwogICAgY29uc3QgeiA9IE1hdGhfZGVmYXVsdC5jbGFtcCh2YWx1ZS56LCBtaW4ueiwgbWF4LnopOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjMubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uKGNhcnRlc2lhbikgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgcmV0dXJuIGNhcnRlc2lhbi54ICogY2FydGVzaWFuLnggKyBjYXJ0ZXNpYW4ueSAqIGNhcnRlc2lhbi55ICsgY2FydGVzaWFuLnogKiBjYXJ0ZXNpYW4uejsKICB9OwogIENhcnRlc2lhbjMubWFnbml0dWRlID0gZnVuY3Rpb24oY2FydGVzaWFuKSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KENhcnRlc2lhbjMubWFnbml0dWRlU3F1YXJlZChjYXJ0ZXNpYW4pKTsKICB9OwogIHZhciBkaXN0YW5jZVNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpOwogIENhcnRlc2lhbjMuZGlzdGFuY2UgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2FydGVzaWFuMy5zdWJ0cmFjdChsZWZ0LCByaWdodCwgZGlzdGFuY2VTY3JhdGNoKTsKICAgIHJldHVybiBDYXJ0ZXNpYW4zLm1hZ25pdHVkZShkaXN0YW5jZVNjcmF0Y2gpOwogIH07CiAgQ2FydGVzaWFuMy5kaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2FydGVzaWFuMy5zdWJ0cmFjdChsZWZ0LCByaWdodCwgZGlzdGFuY2VTY3JhdGNoKTsKICAgIHJldHVybiBDYXJ0ZXNpYW4zLm1hZ25pdHVkZVNxdWFyZWQoZGlzdGFuY2VTY3JhdGNoKTsKICB9OwogIENhcnRlc2lhbjMubm9ybWFsaXplID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IG1hZ25pdHVkZSA9IENhcnRlc2lhbjMubWFnbml0dWRlKGNhcnRlc2lhbik7CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54IC8gbWFnbml0dWRlOwogICAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAvIG1hZ25pdHVkZTsKICAgIHJlc3VsdC56ID0gY2FydGVzaWFuLnogLyBtYWduaXR1ZGU7CiAgICBpZiAoaXNOYU4ocmVzdWx0LngpIHx8IGlzTmFOKHJlc3VsdC55KSB8fCBpc05hTihyZXN1bHQueikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm5vcm1hbGl6ZWQgcmVzdWx0IGlzIG5vdCBhIG51bWJlciIpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjMuZG90ID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIHJldHVybiBsZWZ0LnggKiByaWdodC54ICsgbGVmdC55ICogcmlnaHQueSArIGxlZnQueiAqIHJpZ2h0Lno7CiAgfTsKICBDYXJ0ZXNpYW4zLm11bHRpcGx5Q29tcG9uZW50cyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gbGVmdC54ICogcmlnaHQueDsKICAgIHJlc3VsdC55ID0gbGVmdC55ICogcmlnaHQueTsKICAgIHJlc3VsdC56ID0gbGVmdC56ICogcmlnaHQuejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW4zLmRpdmlkZUNvbXBvbmVudHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGxlZnQueCAvIHJpZ2h0Lng7CiAgICByZXN1bHQueSA9IGxlZnQueSAvIHJpZ2h0Lnk7CiAgICByZXN1bHQueiA9IGxlZnQueiAvIHJpZ2h0Lno7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5hZGQgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGxlZnQueCArIHJpZ2h0Lng7CiAgICByZXN1bHQueSA9IGxlZnQueSArIHJpZ2h0Lnk7CiAgICByZXN1bHQueiA9IGxlZnQueiArIHJpZ2h0Lno7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gbGVmdC54IC0gcmlnaHQueDsKICAgIHJlc3VsdC55ID0gbGVmdC55IC0gcmlnaHQueTsKICAgIHJlc3VsdC56ID0gbGVmdC56IC0gcmlnaHQuejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHNjYWxhciwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxhciIsIHNjYWxhcik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54ICogc2NhbGFyOwogICAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAqIHNjYWxhcjsKICAgIHJlc3VsdC56ID0gY2FydGVzaWFuLnogKiBzY2FsYXI7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5kaXZpZGVCeVNjYWxhciA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgc2NhbGFyLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigic2NhbGFyIiwgc2NhbGFyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gY2FydGVzaWFuLnggLyBzY2FsYXI7CiAgICByZXN1bHQueSA9IGNhcnRlc2lhbi55IC8gc2NhbGFyOwogICAgcmVzdWx0LnogPSBjYXJ0ZXNpYW4ueiAvIHNjYWxhcjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW4zLm5lZ2F0ZSA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IC1jYXJ0ZXNpYW4ueDsKICAgIHJlc3VsdC55ID0gLWNhcnRlc2lhbi55OwogICAgcmVzdWx0LnogPSAtY2FydGVzaWFuLno7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5hYnMgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0LnggPSBNYXRoLmFicyhjYXJ0ZXNpYW4ueCk7CiAgICByZXN1bHQueSA9IE1hdGguYWJzKGNhcnRlc2lhbi55KTsKICAgIHJlc3VsdC56ID0gTWF0aC5hYnMoY2FydGVzaWFuLnopOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBsZXJwU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7CiAgQ2FydGVzaWFuMy5sZXJwID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgdCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInN0YXJ0Iiwgc3RhcnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJlbmQiLCBlbmQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJ0IiwgdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoZW5kLCB0LCBsZXJwU2NyYXRjaCk7CiAgICByZXN1bHQgPSBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoc3RhcnQsIDEgLSB0LCByZXN1bHQpOwogICAgcmV0dXJuIENhcnRlc2lhbjMuYWRkKGxlcnBTY3JhdGNoLCByZXN1bHQsIHJlc3VsdCk7CiAgfTsKICB2YXIgYW5nbGVCZXR3ZWVuU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7CiAgdmFyIGFuZ2xlQmV0d2VlblNjcmF0Y2gyID0gbmV3IENhcnRlc2lhbjMoKTsKICBDYXJ0ZXNpYW4zLmFuZ2xlQmV0d2VlbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShsZWZ0LCBhbmdsZUJldHdlZW5TY3JhdGNoKTsKICAgIENhcnRlc2lhbjMubm9ybWFsaXplKHJpZ2h0LCBhbmdsZUJldHdlZW5TY3JhdGNoMik7CiAgICBjb25zdCBjb3NpbmUgPSBDYXJ0ZXNpYW4zLmRvdChhbmdsZUJldHdlZW5TY3JhdGNoLCBhbmdsZUJldHdlZW5TY3JhdGNoMik7CiAgICBjb25zdCBzaW5lID0gQ2FydGVzaWFuMy5tYWduaXR1ZGUoCiAgICAgIENhcnRlc2lhbjMuY3Jvc3MoCiAgICAgICAgYW5nbGVCZXR3ZWVuU2NyYXRjaCwKICAgICAgICBhbmdsZUJldHdlZW5TY3JhdGNoMiwKICAgICAgICBhbmdsZUJldHdlZW5TY3JhdGNoCiAgICAgICkKICAgICk7CiAgICByZXR1cm4gTWF0aC5hdGFuMihzaW5lLCBjb3NpbmUpOwogIH07CiAgdmFyIG1vc3RPcnRob2dvbmFsQXhpc1NjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpOwogIENhcnRlc2lhbjMubW9zdE9ydGhvZ29uYWxBeGlzID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGYgPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShjYXJ0ZXNpYW4sIG1vc3RPcnRob2dvbmFsQXhpc1NjcmF0Y2gpOwogICAgQ2FydGVzaWFuMy5hYnMoZiwgZik7CiAgICBpZiAoZi54IDw9IGYueSkgewogICAgICBpZiAoZi54IDw9IGYueikgewogICAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjMuY2xvbmUoQ2FydGVzaWFuMy5VTklUX1gsIHJlc3VsdCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0ID0gQ2FydGVzaWFuMy5jbG9uZShDYXJ0ZXNpYW4zLlVOSVRfWiwgcmVzdWx0KTsKICAgICAgfQogICAgfSBlbHNlIGlmIChmLnkgPD0gZi56KSB7CiAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjMuY2xvbmUoQ2FydGVzaWFuMy5VTklUX1ksIHJlc3VsdCk7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQgPSBDYXJ0ZXNpYW4zLmNsb25lKENhcnRlc2lhbjMuVU5JVF9aLCByZXN1bHQpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uKGEzLCBiLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYSIsIGEzKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYiIsIGIpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3Qgc2NhbGFyID0gQ2FydGVzaWFuMy5kb3QoYTMsIGIpIC8gQ2FydGVzaWFuMy5kb3QoYiwgYik7CiAgICByZXR1cm4gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKGIsIHNjYWxhciwgcmVzdWx0KTsKICB9OwogIENhcnRlc2lhbjMuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBsZWZ0LnggPT09IHJpZ2h0LnggJiYgbGVmdC55ID09PSByaWdodC55ICYmIGxlZnQueiA9PT0gcmlnaHQuejsKICB9OwogIENhcnRlc2lhbjMuZXF1YWxzQXJyYXkgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIGFycmF5LCBvZmZzZXQpIHsKICAgIHJldHVybiBjYXJ0ZXNpYW4ueCA9PT0gYXJyYXlbb2Zmc2V0XSAmJiBjYXJ0ZXNpYW4ueSA9PT0gYXJyYXlbb2Zmc2V0ICsgMV0gJiYgY2FydGVzaWFuLnogPT09IGFycmF5W29mZnNldCArIDJdOwogIH07CiAgQ2FydGVzaWFuMy5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlbGF0aXZlRXBzaWxvbiwgYWJzb2x1dGVFcHNpbG9uKSB7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIGxlZnQueCwKICAgICAgcmlnaHQueCwKICAgICAgcmVsYXRpdmVFcHNpbG9uLAogICAgICBhYnNvbHV0ZUVwc2lsb24KICAgICkgJiYgTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIGxlZnQueSwKICAgICAgcmlnaHQueSwKICAgICAgcmVsYXRpdmVFcHNpbG9uLAogICAgICBhYnNvbHV0ZUVwc2lsb24KICAgICkgJiYgTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIGxlZnQueiwKICAgICAgcmlnaHQueiwKICAgICAgcmVsYXRpdmVFcHNpbG9uLAogICAgICBhYnNvbHV0ZUVwc2lsb24KICAgICk7CiAgfTsKICBDYXJ0ZXNpYW4zLmNyb3NzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgbGVmdFggPSBsZWZ0Lng7CiAgICBjb25zdCBsZWZ0WSA9IGxlZnQueTsKICAgIGNvbnN0IGxlZnRaID0gbGVmdC56OwogICAgY29uc3QgcmlnaHRYID0gcmlnaHQueDsKICAgIGNvbnN0IHJpZ2h0WSA9IHJpZ2h0Lnk7CiAgICBjb25zdCByaWdodFogPSByaWdodC56OwogICAgY29uc3QgeCA9IGxlZnRZICogcmlnaHRaIC0gbGVmdFogKiByaWdodFk7CiAgICBjb25zdCB5ID0gbGVmdFogKiByaWdodFggLSBsZWZ0WCAqIHJpZ2h0WjsKICAgIGNvbnN0IHogPSBsZWZ0WCAqIHJpZ2h0WSAtIGxlZnRZICogcmlnaHRYOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjMubWlkcG9pbnQgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IChsZWZ0LnggKyByaWdodC54KSAqIDAuNTsKICAgIHJlc3VsdC55ID0gKGxlZnQueSArIHJpZ2h0LnkpICogMC41OwogICAgcmVzdWx0LnogPSAobGVmdC56ICsgcmlnaHQueikgKiAwLjU7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5mcm9tRGVncmVlcyA9IGZ1bmN0aW9uKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCwgZWxsaXBzb2lkLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigibG9uZ2l0dWRlIiwgbG9uZ2l0dWRlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigibGF0aXR1ZGUiLCBsYXRpdHVkZSk7CiAgICBsb25naXR1ZGUgPSBNYXRoX2RlZmF1bHQudG9SYWRpYW5zKGxvbmdpdHVkZSk7CiAgICBsYXRpdHVkZSA9IE1hdGhfZGVmYXVsdC50b1JhZGlhbnMobGF0aXR1ZGUpOwogICAgcmV0dXJuIENhcnRlc2lhbjMuZnJvbVJhZGlhbnMobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0LCBlbGxpcHNvaWQsIHJlc3VsdCk7CiAgfTsKICB2YXIgc2NyYXRjaE4gPSBuZXcgQ2FydGVzaWFuMygpOwogIHZhciBzY3JhdGNoSyA9IG5ldyBDYXJ0ZXNpYW4zKCk7CiAgdmFyIHdnczg0UmFkaWlTcXVhcmVkID0gbmV3IENhcnRlc2lhbjMoCiAgICA2Mzc4MTM3ICogNjM3ODEzNywKICAgIDYzNzgxMzcgKiA2Mzc4MTM3LAogICAgNjM1Njc1MjMxNDI0NTE3OWUtOSAqIDYzNTY3NTIzMTQyNDUxNzllLTkKICApOwogIENhcnRlc2lhbjMuZnJvbVJhZGlhbnMgPSBmdW5jdGlvbihsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQsIGVsbGlwc29pZCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImxvbmdpdHVkZSIsIGxvbmdpdHVkZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImxhdGl0dWRlIiwgbGF0aXR1ZGUpOwogICAgaGVpZ2h0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoaGVpZ2h0LCAwKTsKICAgIGNvbnN0IHJhZGlpU3F1YXJlZCA9IGRlZmluZWRfZGVmYXVsdChlbGxpcHNvaWQpID8gZWxsaXBzb2lkLnJhZGlpU3F1YXJlZCA6IHdnczg0UmFkaWlTcXVhcmVkOwogICAgY29uc3QgY29zTGF0aXR1ZGUgPSBNYXRoLmNvcyhsYXRpdHVkZSk7CiAgICBzY3JhdGNoTi54ID0gY29zTGF0aXR1ZGUgKiBNYXRoLmNvcyhsb25naXR1ZGUpOwogICAgc2NyYXRjaE4ueSA9IGNvc0xhdGl0dWRlICogTWF0aC5zaW4obG9uZ2l0dWRlKTsKICAgIHNjcmF0Y2hOLnogPSBNYXRoLnNpbihsYXRpdHVkZSk7CiAgICBzY3JhdGNoTiA9IENhcnRlc2lhbjMubm9ybWFsaXplKHNjcmF0Y2hOLCBzY3JhdGNoTik7CiAgICBDYXJ0ZXNpYW4zLm11bHRpcGx5Q29tcG9uZW50cyhyYWRpaVNxdWFyZWQsIHNjcmF0Y2hOLCBzY3JhdGNoSyk7CiAgICBjb25zdCBnYW1tYSA9IE1hdGguc3FydChDYXJ0ZXNpYW4zLmRvdChzY3JhdGNoTiwgc2NyYXRjaEspKTsKICAgIHNjcmF0Y2hLID0gQ2FydGVzaWFuMy5kaXZpZGVCeVNjYWxhcihzY3JhdGNoSywgZ2FtbWEsIHNjcmF0Y2hLKTsKICAgIHNjcmF0Y2hOID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHNjcmF0Y2hOLCBoZWlnaHQsIHNjcmF0Y2hOKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTsKICAgIH0KICAgIHJldHVybiBDYXJ0ZXNpYW4zLmFkZChzY3JhdGNoSywgc2NyYXRjaE4sIHJlc3VsdCk7CiAgfTsKICBDYXJ0ZXNpYW4zLmZyb21EZWdyZWVzQXJyYXkgPSBmdW5jdGlvbihjb29yZGluYXRlcywgZWxsaXBzb2lkLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiY29vcmRpbmF0ZXMiLCBjb29yZGluYXRlcyk7CiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMiB8fCBjb29yZGluYXRlcy5sZW5ndGggJSAyICE9PSAwKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJ0aGUgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAyIGFuZCBhdCBsZWFzdCAyIgogICAgICApOwogICAgfQogICAgY29uc3QgbGVuZ3RoID0gY29vcmRpbmF0ZXMubGVuZ3RoOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoIC8gMik7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoIC8gMjsKICAgIH0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHsKICAgICAgY29uc3QgbG9uZ2l0dWRlID0gY29vcmRpbmF0ZXNbaV07CiAgICAgIGNvbnN0IGxhdGl0dWRlID0gY29vcmRpbmF0ZXNbaSArIDFdOwogICAgICBjb25zdCBpbmRleCA9IGkgLyAyOwogICAgICByZXN1bHRbaW5kZXhdID0gQ2FydGVzaWFuMy5mcm9tRGVncmVlcygKICAgICAgICBsb25naXR1ZGUsCiAgICAgICAgbGF0aXR1ZGUsCiAgICAgICAgMCwKICAgICAgICBlbGxpcHNvaWQsCiAgICAgICAgcmVzdWx0W2luZGV4XQogICAgICApOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjMuZnJvbVJhZGlhbnNBcnJheSA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzLCBlbGxpcHNvaWQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjb29yZGluYXRlcyIsIGNvb3JkaW5hdGVzKTsKICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPCAyIHx8IGNvb3JkaW5hdGVzLmxlbmd0aCAlIDIgIT09IDApIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgInRoZSBudW1iZXIgb2YgY29vcmRpbmF0ZXMgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDIgYW5kIGF0IGxlYXN0IDIiCiAgICAgICk7CiAgICB9CiAgICBjb25zdCBsZW5ndGggPSBjb29yZGluYXRlcy5sZW5ndGg7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGggLyAyKTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyAyOwogICAgfQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikgewogICAgICBjb25zdCBsb25naXR1ZGUgPSBjb29yZGluYXRlc1tpXTsKICAgICAgY29uc3QgbGF0aXR1ZGUgPSBjb29yZGluYXRlc1tpICsgMV07CiAgICAgIGNvbnN0IGluZGV4ID0gaSAvIDI7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBDYXJ0ZXNpYW4zLmZyb21SYWRpYW5zKAogICAgICAgIGxvbmdpdHVkZSwKICAgICAgICBsYXRpdHVkZSwKICAgICAgICAwLAogICAgICAgIGVsbGlwc29pZCwKICAgICAgICByZXN1bHRbaW5kZXhdCiAgICAgICk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMy5mcm9tRGVncmVlc0FycmF5SGVpZ2h0cyA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzLCBlbGxpcHNvaWQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjb29yZGluYXRlcyIsIGNvb3JkaW5hdGVzKTsKICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPCAzIHx8IGNvb3JkaW5hdGVzLmxlbmd0aCAlIDMgIT09IDApIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgInRoZSBudW1iZXIgb2YgY29vcmRpbmF0ZXMgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMgYW5kIGF0IGxlYXN0IDMiCiAgICAgICk7CiAgICB9CiAgICBjb25zdCBsZW5ndGggPSBjb29yZGluYXRlcy5sZW5ndGg7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGggLyAzKTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyAzOwogICAgfQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykgewogICAgICBjb25zdCBsb25naXR1ZGUgPSBjb29yZGluYXRlc1tpXTsKICAgICAgY29uc3QgbGF0aXR1ZGUgPSBjb29yZGluYXRlc1tpICsgMV07CiAgICAgIGNvbnN0IGhlaWdodCA9IGNvb3JkaW5hdGVzW2kgKyAyXTsKICAgICAgY29uc3QgaW5kZXggPSBpIC8gMzsKICAgICAgcmVzdWx0W2luZGV4XSA9IENhcnRlc2lhbjMuZnJvbURlZ3JlZXMoCiAgICAgICAgbG9uZ2l0dWRlLAogICAgICAgIGxhdGl0dWRlLAogICAgICAgIGhlaWdodCwKICAgICAgICBlbGxpcHNvaWQsCiAgICAgICAgcmVzdWx0W2luZGV4XQogICAgICApOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjMuZnJvbVJhZGlhbnNBcnJheUhlaWdodHMgPSBmdW5jdGlvbihjb29yZGluYXRlcywgZWxsaXBzb2lkLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiY29vcmRpbmF0ZXMiLCBjb29yZGluYXRlcyk7CiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMyB8fCBjb29yZGluYXRlcy5sZW5ndGggJSAzICE9PSAwKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJ0aGUgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzIGFuZCBhdCBsZWFzdCAzIgogICAgICApOwogICAgfQogICAgY29uc3QgbGVuZ3RoID0gY29vcmRpbmF0ZXMubGVuZ3RoOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoIC8gMyk7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoIC8gMzsKICAgIH0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHsKICAgICAgY29uc3QgbG9uZ2l0dWRlID0gY29vcmRpbmF0ZXNbaV07CiAgICAgIGNvbnN0IGxhdGl0dWRlID0gY29vcmRpbmF0ZXNbaSArIDFdOwogICAgICBjb25zdCBoZWlnaHQgPSBjb29yZGluYXRlc1tpICsgMl07CiAgICAgIGNvbnN0IGluZGV4ID0gaSAvIDM7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBDYXJ0ZXNpYW4zLmZyb21SYWRpYW5zKAogICAgICAgIGxvbmdpdHVkZSwKICAgICAgICBsYXRpdHVkZSwKICAgICAgICBoZWlnaHQsCiAgICAgICAgZWxsaXBzb2lkLAogICAgICAgIHJlc3VsdFtpbmRleF0KICAgICAgKTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW4zLlpFUk8gPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW4zKDAsIDAsIDApKTsKICBDYXJ0ZXNpYW4zLk9ORSA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjMoMSwgMSwgMSkpOwogIENhcnRlc2lhbjMuVU5JVF9YID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMygxLCAwLCAwKSk7CiAgQ2FydGVzaWFuMy5VTklUX1kgPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW4zKDAsIDEsIDApKTsKICBDYXJ0ZXNpYW4zLlVOSVRfWiA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjMoMCwgMCwgMSkpOwogIENhcnRlc2lhbjMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gQ2FydGVzaWFuMy5jbG9uZSh0aGlzLCByZXN1bHQpOwogIH07CiAgQ2FydGVzaWFuMy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocmlnaHQpIHsKICAgIHJldHVybiBDYXJ0ZXNpYW4zLmVxdWFscyh0aGlzLCByaWdodCk7CiAgfTsKICBDYXJ0ZXNpYW4zLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24ocmlnaHQsIHJlbGF0aXZlRXBzaWxvbiwgYWJzb2x1dGVFcHNpbG9uKSB7CiAgICByZXR1cm4gQ2FydGVzaWFuMy5lcXVhbHNFcHNpbG9uKAogICAgICB0aGlzLAogICAgICByaWdodCwKICAgICAgcmVsYXRpdmVFcHNpbG9uLAogICAgICBhYnNvbHV0ZUVwc2lsb24KICAgICk7CiAgfTsKICBDYXJ0ZXNpYW4zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIGAoJHt0aGlzLnh9LCAke3RoaXMueX0sICR7dGhpcy56fSlgOwogIH07CiAgdmFyIENhcnRlc2lhbjNfZGVmYXVsdCA9IENhcnRlc2lhbjM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9DYXJ0ZXNpYW40LmpzCiAgZnVuY3Rpb24gQ2FydGVzaWFuNCh4LCB5LCB6LCB3KSB7CiAgICB0aGlzLnggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh4LCAwKTsKICAgIHRoaXMueSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHksIDApOwogICAgdGhpcy56ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoeiwgMCk7CiAgICB0aGlzLncgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh3LCAwKTsKICB9CiAgQ2FydGVzaWFuNC5mcm9tRWxlbWVudHMgPSBmdW5jdGlvbih4LCB5LCB6LCB3LCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW40KHgsIHksIHosIHcpOwogICAgfQogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmVzdWx0LncgPSB3OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjQuZnJvbUNvbG9yID0gZnVuY3Rpb24oY29sb3IsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjb2xvciIsIGNvbG9yKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW40KGNvbG9yLnJlZCwgY29sb3IuZ3JlZW4sIGNvbG9yLmJsdWUsIGNvbG9yLmFscGhhKTsKICAgIH0KICAgIHJlc3VsdC54ID0gY29sb3IucmVkOwogICAgcmVzdWx0LnkgPSBjb2xvci5ncmVlbjsKICAgIHJlc3VsdC56ID0gY29sb3IuYmx1ZTsKICAgIHJlc3VsdC53ID0gY29sb3IuYWxwaGE7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC5jbG9uZSA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChjYXJ0ZXNpYW4pKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuNChjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnksIGNhcnRlc2lhbi56LCBjYXJ0ZXNpYW4udyk7CiAgICB9CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54OwogICAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueTsKICAgIHJlc3VsdC56ID0gY2FydGVzaWFuLno7CiAgICByZXN1bHQudyA9IGNhcnRlc2lhbi53OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjQucGFja2VkTGVuZ3RoID0gNDsKICBDYXJ0ZXNpYW40LnBhY2sgPSBmdW5jdGlvbih2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgidmFsdWUiLCB2YWx1ZSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLng7CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUueTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS56OwogICAgYXJyYXlbc3RhcnRpbmdJbmRleF0gPSB2YWx1ZS53OwogICAgcmV0dXJuIGFycmF5OwogIH07CiAgQ2FydGVzaWFuNC51bnBhY2sgPSBmdW5jdGlvbihhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuNCgpOwogICAgfQogICAgcmVzdWx0LnggPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0LnkgPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0LnogPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0LncgPSBhcnJheVtzdGFydGluZ0luZGV4XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW40LnBhY2tBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICBjb25zdCByZXN1bHRMZW5ndGggPSBsZW5ndGggKiA0OwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXJyYXkocmVzdWx0TGVuZ3RoKTsKICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoICE9PSByZXN1bHRMZW5ndGgpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgIklmIHJlc3VsdCBpcyBhIHR5cGVkIGFycmF5LCBpdCBtdXN0IGhhdmUgZXhhY3RseSBhcnJheS5sZW5ndGggKiA0IGVsZW1lbnRzIgogICAgICApOwogICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoICE9PSByZXN1bHRMZW5ndGgpIHsKICAgICAgcmVzdWx0Lmxlbmd0aCA9IHJlc3VsdExlbmd0aDsKICAgIH0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgQ2FydGVzaWFuNC5wYWNrKGFycmF5W2ldLCByZXN1bHQsIGkgKiA0KTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW40LnVucGFja0FycmF5ID0gZnVuY3Rpb24oYXJyYXksIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJhcnJheS5sZW5ndGgiLCBhcnJheS5sZW5ndGgsIDQpOwogICAgaWYgKGFycmF5Lmxlbmd0aCAlIDQgIT09IDApIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImFycmF5IGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNC4iKTsKICAgIH0KICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCAvIDQpOwogICAgfSBlbHNlIHsKICAgICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aCAvIDQ7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7CiAgICAgIGNvbnN0IGluZGV4ID0gaSAvIDQ7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBDYXJ0ZXNpYW40LnVucGFjayhhcnJheSwgaSwgcmVzdWx0W2luZGV4XSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC5mcm9tQXJyYXkgPSBDYXJ0ZXNpYW40LnVucGFjazsKICBDYXJ0ZXNpYW40Lm1heGltdW1Db21wb25lbnQgPSBmdW5jdGlvbihjYXJ0ZXNpYW4pIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIHJldHVybiBNYXRoLm1heChjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnksIGNhcnRlc2lhbi56LCBjYXJ0ZXNpYW4udyk7CiAgfTsKICBDYXJ0ZXNpYW40Lm1pbmltdW1Db21wb25lbnQgPSBmdW5jdGlvbihjYXJ0ZXNpYW4pIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIHJldHVybiBNYXRoLm1pbihjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnksIGNhcnRlc2lhbi56LCBjYXJ0ZXNpYW4udyk7CiAgfTsKICBDYXJ0ZXNpYW40Lm1pbmltdW1CeUNvbXBvbmVudCA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJmaXJzdCIsIGZpcnN0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic2Vjb25kIiwgc2Vjb25kKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gTWF0aC5taW4oZmlyc3QueCwgc2Vjb25kLngpOwogICAgcmVzdWx0LnkgPSBNYXRoLm1pbihmaXJzdC55LCBzZWNvbmQueSk7CiAgICByZXN1bHQueiA9IE1hdGgubWluKGZpcnN0LnosIHNlY29uZC56KTsKICAgIHJlc3VsdC53ID0gTWF0aC5taW4oZmlyc3Qudywgc2Vjb25kLncpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjQubWF4aW11bUJ5Q29tcG9uZW50ID0gZnVuY3Rpb24oZmlyc3QsIHNlY29uZCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImZpcnN0IiwgZmlyc3QpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzZWNvbmQiLCBzZWNvbmQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0LnggPSBNYXRoLm1heChmaXJzdC54LCBzZWNvbmQueCk7CiAgICByZXN1bHQueSA9IE1hdGgubWF4KGZpcnN0LnksIHNlY29uZC55KTsKICAgIHJlc3VsdC56ID0gTWF0aC5tYXgoZmlyc3Queiwgc2Vjb25kLnopOwogICAgcmVzdWx0LncgPSBNYXRoLm1heChmaXJzdC53LCBzZWNvbmQudyk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInZhbHVlIiwgdmFsdWUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtaW4iLCBtaW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXgiLCBtYXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgeCA9IE1hdGhfZGVmYXVsdC5jbGFtcCh2YWx1ZS54LCBtaW4ueCwgbWF4LngpOwogICAgY29uc3QgeSA9IE1hdGhfZGVmYXVsdC5jbGFtcCh2YWx1ZS55LCBtaW4ueSwgbWF4LnkpOwogICAgY29uc3QgeiA9IE1hdGhfZGVmYXVsdC5jbGFtcCh2YWx1ZS56LCBtaW4ueiwgbWF4LnopOwogICAgY29uc3QgdyA9IE1hdGhfZGVmYXVsdC5jbGFtcCh2YWx1ZS53LCBtaW4udywgbWF4LncpOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmVzdWx0LncgPSB3OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjQubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uKGNhcnRlc2lhbikgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgcmV0dXJuIGNhcnRlc2lhbi54ICogY2FydGVzaWFuLnggKyBjYXJ0ZXNpYW4ueSAqIGNhcnRlc2lhbi55ICsgY2FydGVzaWFuLnogKiBjYXJ0ZXNpYW4ueiArIGNhcnRlc2lhbi53ICogY2FydGVzaWFuLnc7CiAgfTsKICBDYXJ0ZXNpYW40Lm1hZ25pdHVkZSA9IGZ1bmN0aW9uKGNhcnRlc2lhbikgewogICAgcmV0dXJuIE1hdGguc3FydChDYXJ0ZXNpYW40Lm1hZ25pdHVkZVNxdWFyZWQoY2FydGVzaWFuKSk7CiAgfTsKICB2YXIgZGlzdGFuY2VTY3JhdGNoMiA9IG5ldyBDYXJ0ZXNpYW40KCk7CiAgQ2FydGVzaWFuNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDYXJ0ZXNpYW40LnN1YnRyYWN0KGxlZnQsIHJpZ2h0LCBkaXN0YW5jZVNjcmF0Y2gyKTsKICAgIHJldHVybiBDYXJ0ZXNpYW40Lm1hZ25pdHVkZShkaXN0YW5jZVNjcmF0Y2gyKTsKICB9OwogIENhcnRlc2lhbjQuZGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENhcnRlc2lhbjQuc3VidHJhY3QobGVmdCwgcmlnaHQsIGRpc3RhbmNlU2NyYXRjaDIpOwogICAgcmV0dXJuIENhcnRlc2lhbjQubWFnbml0dWRlU3F1YXJlZChkaXN0YW5jZVNjcmF0Y2gyKTsKICB9OwogIENhcnRlc2lhbjQubm9ybWFsaXplID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IG1hZ25pdHVkZSA9IENhcnRlc2lhbjQubWFnbml0dWRlKGNhcnRlc2lhbik7CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54IC8gbWFnbml0dWRlOwogICAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAvIG1hZ25pdHVkZTsKICAgIHJlc3VsdC56ID0gY2FydGVzaWFuLnogLyBtYWduaXR1ZGU7CiAgICByZXN1bHQudyA9IGNhcnRlc2lhbi53IC8gbWFnbml0dWRlOwogICAgaWYgKGlzTmFOKHJlc3VsdC54KSB8fCBpc05hTihyZXN1bHQueSkgfHwgaXNOYU4ocmVzdWx0LnopIHx8IGlzTmFOKHJlc3VsdC53KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgibm9ybWFsaXplZCByZXN1bHQgaXMgbm90IGEgbnVtYmVyIik7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC5kb3QgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgcmV0dXJuIGxlZnQueCAqIHJpZ2h0LnggKyBsZWZ0LnkgKiByaWdodC55ICsgbGVmdC56ICogcmlnaHQueiArIGxlZnQudyAqIHJpZ2h0Lnc7CiAgfTsKICBDYXJ0ZXNpYW40Lm11bHRpcGx5Q29tcG9uZW50cyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gbGVmdC54ICogcmlnaHQueDsKICAgIHJlc3VsdC55ID0gbGVmdC55ICogcmlnaHQueTsKICAgIHJlc3VsdC56ID0gbGVmdC56ICogcmlnaHQuejsKICAgIHJlc3VsdC53ID0gbGVmdC53ICogcmlnaHQudzsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW40LmRpdmlkZUNvbXBvbmVudHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGxlZnQueCAvIHJpZ2h0Lng7CiAgICByZXN1bHQueSA9IGxlZnQueSAvIHJpZ2h0Lnk7CiAgICByZXN1bHQueiA9IGxlZnQueiAvIHJpZ2h0Lno7CiAgICByZXN1bHQudyA9IGxlZnQudyAvIHJpZ2h0Lnc7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC5hZGQgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGxlZnQueCArIHJpZ2h0Lng7CiAgICByZXN1bHQueSA9IGxlZnQueSArIHJpZ2h0Lnk7CiAgICByZXN1bHQueiA9IGxlZnQueiArIHJpZ2h0Lno7CiAgICByZXN1bHQudyA9IGxlZnQudyArIHJpZ2h0Lnc7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gbGVmdC54IC0gcmlnaHQueDsKICAgIHJlc3VsdC55ID0gbGVmdC55IC0gcmlnaHQueTsKICAgIHJlc3VsdC56ID0gbGVmdC56IC0gcmlnaHQuejsKICAgIHJlc3VsdC53ID0gbGVmdC53IC0gcmlnaHQudzsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW40Lm11bHRpcGx5QnlTY2FsYXIgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHNjYWxhciwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxhciIsIHNjYWxhcik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54ICogc2NhbGFyOwogICAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAqIHNjYWxhcjsKICAgIHJlc3VsdC56ID0gY2FydGVzaWFuLnogKiBzY2FsYXI7CiAgICByZXN1bHQudyA9IGNhcnRlc2lhbi53ICogc2NhbGFyOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjQuZGl2aWRlQnlTY2FsYXIgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHNjYWxhciwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxhciIsIHNjYWxhcik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54IC8gc2NhbGFyOwogICAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAvIHNjYWxhcjsKICAgIHJlc3VsdC56ID0gY2FydGVzaWFuLnogLyBzY2FsYXI7CiAgICByZXN1bHQudyA9IGNhcnRlc2lhbi53IC8gc2NhbGFyOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjQubmVnYXRlID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gLWNhcnRlc2lhbi54OwogICAgcmVzdWx0LnkgPSAtY2FydGVzaWFuLnk7CiAgICByZXN1bHQueiA9IC1jYXJ0ZXNpYW4uejsKICAgIHJlc3VsdC53ID0gLWNhcnRlc2lhbi53OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjQuYWJzID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gTWF0aC5hYnMoY2FydGVzaWFuLngpOwogICAgcmVzdWx0LnkgPSBNYXRoLmFicyhjYXJ0ZXNpYW4ueSk7CiAgICByZXN1bHQueiA9IE1hdGguYWJzKGNhcnRlc2lhbi56KTsKICAgIHJlc3VsdC53ID0gTWF0aC5hYnMoY2FydGVzaWFuLncpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBsZXJwU2NyYXRjaDIgPSBuZXcgQ2FydGVzaWFuNCgpOwogIENhcnRlc2lhbjQubGVycCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzdGFydCIsIHN0YXJ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZW5kIiwgZW5kKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigidCIsIHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgQ2FydGVzaWFuNC5tdWx0aXBseUJ5U2NhbGFyKGVuZCwgdCwgbGVycFNjcmF0Y2gyKTsKICAgIHJlc3VsdCA9IENhcnRlc2lhbjQubXVsdGlwbHlCeVNjYWxhcihzdGFydCwgMSAtIHQsIHJlc3VsdCk7CiAgICByZXR1cm4gQ2FydGVzaWFuNC5hZGQobGVycFNjcmF0Y2gyLCByZXN1bHQsIHJlc3VsdCk7CiAgfTsKICB2YXIgbW9zdE9ydGhvZ29uYWxBeGlzU2NyYXRjaDIgPSBuZXcgQ2FydGVzaWFuNCgpOwogIENhcnRlc2lhbjQubW9zdE9ydGhvZ29uYWxBeGlzID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGYgPSBDYXJ0ZXNpYW40Lm5vcm1hbGl6ZShjYXJ0ZXNpYW4sIG1vc3RPcnRob2dvbmFsQXhpc1NjcmF0Y2gyKTsKICAgIENhcnRlc2lhbjQuYWJzKGYsIGYpOwogICAgaWYgKGYueCA8PSBmLnkpIHsKICAgICAgaWYgKGYueCA8PSBmLnopIHsKICAgICAgICBpZiAoZi54IDw9IGYudykgewogICAgICAgICAgcmVzdWx0ID0gQ2FydGVzaWFuNC5jbG9uZShDYXJ0ZXNpYW40LlVOSVRfWCwgcmVzdWx0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmVzdWx0ID0gQ2FydGVzaWFuNC5jbG9uZShDYXJ0ZXNpYW40LlVOSVRfVywgcmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoZi56IDw9IGYudykgewogICAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjQuY2xvbmUoQ2FydGVzaWFuNC5VTklUX1osIHJlc3VsdCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0ID0gQ2FydGVzaWFuNC5jbG9uZShDYXJ0ZXNpYW40LlVOSVRfVywgcmVzdWx0KTsKICAgICAgfQogICAgfSBlbHNlIGlmIChmLnkgPD0gZi56KSB7CiAgICAgIGlmIChmLnkgPD0gZi53KSB7CiAgICAgICAgcmVzdWx0ID0gQ2FydGVzaWFuNC5jbG9uZShDYXJ0ZXNpYW40LlVOSVRfWSwgcmVzdWx0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQgPSBDYXJ0ZXNpYW40LmNsb25lKENhcnRlc2lhbjQuVU5JVF9XLCByZXN1bHQpOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGYueiA8PSBmLncpIHsKICAgICAgcmVzdWx0ID0gQ2FydGVzaWFuNC5jbG9uZShDYXJ0ZXNpYW40LlVOSVRfWiwgcmVzdWx0KTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjQuY2xvbmUoQ2FydGVzaWFuNC5VTklUX1csIHJlc3VsdCk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIGxlZnQueCA9PT0gcmlnaHQueCAmJiBsZWZ0LnkgPT09IHJpZ2h0LnkgJiYgbGVmdC56ID09PSByaWdodC56ICYmIGxlZnQudyA9PT0gcmlnaHQudzsKICB9OwogIENhcnRlc2lhbjQuZXF1YWxzQXJyYXkgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIGFycmF5LCBvZmZzZXQpIHsKICAgIHJldHVybiBjYXJ0ZXNpYW4ueCA9PT0gYXJyYXlbb2Zmc2V0XSAmJiBjYXJ0ZXNpYW4ueSA9PT0gYXJyYXlbb2Zmc2V0ICsgMV0gJiYgY2FydGVzaWFuLnogPT09IGFycmF5W29mZnNldCArIDJdICYmIGNhcnRlc2lhbi53ID09PSBhcnJheVtvZmZzZXQgKyAzXTsKICB9OwogIENhcnRlc2lhbjQuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZWxhdGl2ZUVwc2lsb24sIGFic29sdXRlRXBzaWxvbikgewogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LngsCiAgICAgIHJpZ2h0LngsCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LnksCiAgICAgIHJpZ2h0LnksCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LnosCiAgICAgIHJpZ2h0LnosCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LncsCiAgICAgIHJpZ2h0LncsCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApOwogIH07CiAgQ2FydGVzaWFuNC5aRVJPID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuNCgwLCAwLCAwLCAwKSk7CiAgQ2FydGVzaWFuNC5PTkUgPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW40KDEsIDEsIDEsIDEpKTsKICBDYXJ0ZXNpYW40LlVOSVRfWCA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjQoMSwgMCwgMCwgMCkpOwogIENhcnRlc2lhbjQuVU5JVF9ZID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuNCgwLCAxLCAwLCAwKSk7CiAgQ2FydGVzaWFuNC5VTklUX1ogPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW40KDAsIDAsIDEsIDApKTsKICBDYXJ0ZXNpYW40LlVOSVRfVyA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjQoMCwgMCwgMCwgMSkpOwogIENhcnRlc2lhbjQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gQ2FydGVzaWFuNC5jbG9uZSh0aGlzLCByZXN1bHQpOwogIH07CiAgQ2FydGVzaWFuNC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocmlnaHQpIHsKICAgIHJldHVybiBDYXJ0ZXNpYW40LmVxdWFscyh0aGlzLCByaWdodCk7CiAgfTsKICBDYXJ0ZXNpYW40LnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24ocmlnaHQsIHJlbGF0aXZlRXBzaWxvbiwgYWJzb2x1dGVFcHNpbG9uKSB7CiAgICByZXR1cm4gQ2FydGVzaWFuNC5lcXVhbHNFcHNpbG9uKAogICAgICB0aGlzLAogICAgICByaWdodCwKICAgICAgcmVsYXRpdmVFcHNpbG9uLAogICAgICBhYnNvbHV0ZUVwc2lsb24KICAgICk7CiAgfTsKICBDYXJ0ZXNpYW40LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIGAoJHt0aGlzLnh9LCAke3RoaXMueX0sICR7dGhpcy56fSwgJHt0aGlzLnd9KWA7CiAgfTsKICB2YXIgc2NyYXRjaEYzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxKTsKICB2YXIgc2NyYXRjaFU4QXJyYXkgPSBuZXcgVWludDhBcnJheShzY3JhdGNoRjMyQXJyYXkuYnVmZmVyKTsKICB2YXIgdGVzdFUzMiA9IG5ldyBVaW50MzJBcnJheShbMjg3NDU0MDIwXSk7CiAgdmFyIHRlc3RVOCA9IG5ldyBVaW50OEFycmF5KHRlc3RVMzIuYnVmZmVyKTsKICB2YXIgbGl0dGxlRW5kaWFuID0gdGVzdFU4WzBdID09PSA2ODsKICBDYXJ0ZXNpYW40LnBhY2tGbG9hdCA9IGZ1bmN0aW9uKHZhbHVlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigidmFsdWUiLCB2YWx1ZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW40KCk7CiAgICB9CiAgICBzY3JhdGNoRjMyQXJyYXlbMF0gPSB2YWx1ZTsKICAgIGlmIChsaXR0bGVFbmRpYW4pIHsKICAgICAgcmVzdWx0LnggPSBzY3JhdGNoVThBcnJheVswXTsKICAgICAgcmVzdWx0LnkgPSBzY3JhdGNoVThBcnJheVsxXTsKICAgICAgcmVzdWx0LnogPSBzY3JhdGNoVThBcnJheVsyXTsKICAgICAgcmVzdWx0LncgPSBzY3JhdGNoVThBcnJheVszXTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdC54ID0gc2NyYXRjaFU4QXJyYXlbM107CiAgICAgIHJlc3VsdC55ID0gc2NyYXRjaFU4QXJyYXlbMl07CiAgICAgIHJlc3VsdC56ID0gc2NyYXRjaFU4QXJyYXlbMV07CiAgICAgIHJlc3VsdC53ID0gc2NyYXRjaFU4QXJyYXlbMF07CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuNC51bnBhY2tGbG9hdCA9IGZ1bmN0aW9uKHBhY2tlZEZsb2F0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInBhY2tlZEZsb2F0IiwgcGFja2VkRmxvYXQpOwogICAgaWYgKGxpdHRsZUVuZGlhbikgewogICAgICBzY3JhdGNoVThBcnJheVswXSA9IHBhY2tlZEZsb2F0Lng7CiAgICAgIHNjcmF0Y2hVOEFycmF5WzFdID0gcGFja2VkRmxvYXQueTsKICAgICAgc2NyYXRjaFU4QXJyYXlbMl0gPSBwYWNrZWRGbG9hdC56OwogICAgICBzY3JhdGNoVThBcnJheVszXSA9IHBhY2tlZEZsb2F0Lnc7CiAgICB9IGVsc2UgewogICAgICBzY3JhdGNoVThBcnJheVswXSA9IHBhY2tlZEZsb2F0Lnc7CiAgICAgIHNjcmF0Y2hVOEFycmF5WzFdID0gcGFja2VkRmxvYXQuejsKICAgICAgc2NyYXRjaFU4QXJyYXlbMl0gPSBwYWNrZWRGbG9hdC55OwogICAgICBzY3JhdGNoVThBcnJheVszXSA9IHBhY2tlZEZsb2F0Lng7CiAgICB9CiAgICByZXR1cm4gc2NyYXRjaEYzMkFycmF5WzBdOwogIH07CiAgdmFyIENhcnRlc2lhbjRfZGVmYXVsdCA9IENhcnRlc2lhbjQ7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9NYXRyaXgzLmpzCiAgZnVuY3Rpb24gTWF0cml4Myhjb2x1bW4wUm93MCwgY29sdW1uMVJvdzAsIGNvbHVtbjJSb3cwLCBjb2x1bW4wUm93MSwgY29sdW1uMVJvdzEsIGNvbHVtbjJSb3cxLCBjb2x1bW4wUm93MiwgY29sdW1uMVJvdzIsIGNvbHVtbjJSb3cyKSB7CiAgICB0aGlzWzBdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMFJvdzAsIDApOwogICAgdGhpc1sxXSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjBSb3cxLCAwKTsKICAgIHRoaXNbMl0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4wUm93MiwgMCk7CiAgICB0aGlzWzNdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMVJvdzAsIDApOwogICAgdGhpc1s0XSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjFSb3cxLCAwKTsKICAgIHRoaXNbNV0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4xUm93MiwgMCk7CiAgICB0aGlzWzZdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMlJvdzAsIDApOwogICAgdGhpc1s3XSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjJSb3cxLCAwKTsKICAgIHRoaXNbOF0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4yUm93MiwgMCk7CiAgfQogIE1hdHJpeDMucGFja2VkTGVuZ3RoID0gOTsKICBNYXRyaXgzLnBhY2sgPSBmdW5jdGlvbih2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgidmFsdWUiLCB2YWx1ZSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzBdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzFdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzJdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzNdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzRdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzVdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzZdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzddOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzhdOwogICAgcmV0dXJuIGFycmF5OwogIH07CiAgTWF0cml4My51bnBhY2sgPSBmdW5jdGlvbihhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgTWF0cml4MygpOwogICAgfQogICAgcmVzdWx0WzBdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFsxXSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbMl0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzNdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFs0XSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbNV0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzZdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFs3XSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbOF0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMucGFja0FycmF5ID0gZnVuY3Rpb24oYXJyYXksIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKICAgIGNvbnN0IHJlc3VsdExlbmd0aCA9IGxlbmd0aCAqIDk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShyZXN1bHRMZW5ndGgpOwogICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggIT09IHJlc3VsdExlbmd0aCkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAiSWYgcmVzdWx0IGlzIGEgdHlwZWQgYXJyYXksIGl0IG11c3QgaGF2ZSBleGFjdGx5IGFycmF5Lmxlbmd0aCAqIDkgZWxlbWVudHMiCiAgICAgICk7CiAgICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggIT09IHJlc3VsdExlbmd0aCkgewogICAgICByZXN1bHQubGVuZ3RoID0gcmVzdWx0TGVuZ3RoOwogICAgfQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICBNYXRyaXgzLnBhY2soYXJyYXlbaV0sIHJlc3VsdCwgaSAqIDkpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMudW5wYWNrQXJyYXkgPSBmdW5jdGlvbihhcnJheSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoImFycmF5Lmxlbmd0aCIsIGFycmF5Lmxlbmd0aCwgOSk7CiAgICBpZiAoYXJyYXkubGVuZ3RoICUgOSAhPT0gMCkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYXJyYXkgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5LiIpOwogICAgfQogICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoIC8gOSk7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoIC8gOTsKICAgIH0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDkpIHsKICAgICAgY29uc3QgaW5kZXggPSBpIC8gOTsKICAgICAgcmVzdWx0W2luZGV4XSA9IE1hdHJpeDMudW5wYWNrKGFycmF5LCBpLCByZXN1bHRbaW5kZXhdKTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLmNsb25lID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG1hdHJpeCkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBNYXRyaXgzKAogICAgICAgIG1hdHJpeFswXSwKICAgICAgICBtYXRyaXhbM10sCiAgICAgICAgbWF0cml4WzZdLAogICAgICAgIG1hdHJpeFsxXSwKICAgICAgICBtYXRyaXhbNF0sCiAgICAgICAgbWF0cml4WzddLAogICAgICAgIG1hdHJpeFsyXSwKICAgICAgICBtYXRyaXhbNV0sCiAgICAgICAgbWF0cml4WzhdCiAgICAgICk7CiAgICB9CiAgICByZXN1bHRbMF0gPSBtYXRyaXhbMF07CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV07CiAgICByZXN1bHRbMl0gPSBtYXRyaXhbMl07CiAgICByZXN1bHRbM10gPSBtYXRyaXhbM107CiAgICByZXN1bHRbNF0gPSBtYXRyaXhbNF07CiAgICByZXN1bHRbNV0gPSBtYXRyaXhbNV07CiAgICByZXN1bHRbNl0gPSBtYXRyaXhbNl07CiAgICByZXN1bHRbN10gPSBtYXRyaXhbN107CiAgICByZXN1bHRbOF0gPSBtYXRyaXhbOF07CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4My5mcm9tQXJyYXkgPSBNYXRyaXgzLnVucGFjazsKICBNYXRyaXgzLmZyb21Db2x1bW5NYWpvckFycmF5ID0gZnVuY3Rpb24odmFsdWVzLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgidmFsdWVzIiwgdmFsdWVzKTsKICAgIHJldHVybiBNYXRyaXgzLmNsb25lKHZhbHVlcywgcmVzdWx0KTsKICB9OwogIE1hdHJpeDMuZnJvbVJvd01ham9yQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ2YWx1ZXMiLCB2YWx1ZXMpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IE1hdHJpeDMoCiAgICAgICAgdmFsdWVzWzBdLAogICAgICAgIHZhbHVlc1sxXSwKICAgICAgICB2YWx1ZXNbMl0sCiAgICAgICAgdmFsdWVzWzNdLAogICAgICAgIHZhbHVlc1s0XSwKICAgICAgICB2YWx1ZXNbNV0sCiAgICAgICAgdmFsdWVzWzZdLAogICAgICAgIHZhbHVlc1s3XSwKICAgICAgICB2YWx1ZXNbOF0KICAgICAgKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IHZhbHVlc1swXTsKICAgIHJlc3VsdFsxXSA9IHZhbHVlc1szXTsKICAgIHJlc3VsdFsyXSA9IHZhbHVlc1s2XTsKICAgIHJlc3VsdFszXSA9IHZhbHVlc1sxXTsKICAgIHJlc3VsdFs0XSA9IHZhbHVlc1s0XTsKICAgIHJlc3VsdFs1XSA9IHZhbHVlc1s3XTsKICAgIHJlc3VsdFs2XSA9IHZhbHVlc1syXTsKICAgIHJlc3VsdFs3XSA9IHZhbHVlc1s1XTsKICAgIHJlc3VsdFs4XSA9IHZhbHVlc1s4XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLmZyb21RdWF0ZXJuaW9uID0gZnVuY3Rpb24ocXVhdGVybmlvbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInF1YXRlcm5pb24iLCBxdWF0ZXJuaW9uKTsKICAgIGNvbnN0IHgyID0gcXVhdGVybmlvbi54ICogcXVhdGVybmlvbi54OwogICAgY29uc3QgeHkgPSBxdWF0ZXJuaW9uLnggKiBxdWF0ZXJuaW9uLnk7CiAgICBjb25zdCB4eiA9IHF1YXRlcm5pb24ueCAqIHF1YXRlcm5pb24uejsKICAgIGNvbnN0IHh3ID0gcXVhdGVybmlvbi54ICogcXVhdGVybmlvbi53OwogICAgY29uc3QgeTIgPSBxdWF0ZXJuaW9uLnkgKiBxdWF0ZXJuaW9uLnk7CiAgICBjb25zdCB5eiA9IHF1YXRlcm5pb24ueSAqIHF1YXRlcm5pb24uejsKICAgIGNvbnN0IHl3ID0gcXVhdGVybmlvbi55ICogcXVhdGVybmlvbi53OwogICAgY29uc3QgejIgPSBxdWF0ZXJuaW9uLnogKiBxdWF0ZXJuaW9uLno7CiAgICBjb25zdCB6dyA9IHF1YXRlcm5pb24ueiAqIHF1YXRlcm5pb24udzsKICAgIGNvbnN0IHcyID0gcXVhdGVybmlvbi53ICogcXVhdGVybmlvbi53OwogICAgY29uc3QgbTAwID0geDIgLSB5MiAtIHoyICsgdzI7CiAgICBjb25zdCBtMDEgPSAyICogKHh5IC0gencpOwogICAgY29uc3QgbTAyID0gMiAqICh4eiArIHl3KTsKICAgIGNvbnN0IG0xMCA9IDIgKiAoeHkgKyB6dyk7CiAgICBjb25zdCBtMTEgPSAteDIgKyB5MiAtIHoyICsgdzI7CiAgICBjb25zdCBtMTIgPSAyICogKHl6IC0geHcpOwogICAgY29uc3QgbTIwID0gMiAqICh4eiAtIHl3KTsKICAgIGNvbnN0IG0yMSA9IDIgKiAoeXogKyB4dyk7CiAgICBjb25zdCBtMjIgPSAteDIgLSB5MiArIHoyICsgdzI7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4MyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IG0wMDsKICAgIHJlc3VsdFsxXSA9IG0xMDsKICAgIHJlc3VsdFsyXSA9IG0yMDsKICAgIHJlc3VsdFszXSA9IG0wMTsKICAgIHJlc3VsdFs0XSA9IG0xMTsKICAgIHJlc3VsdFs1XSA9IG0yMTsKICAgIHJlc3VsdFs2XSA9IG0wMjsKICAgIHJlc3VsdFs3XSA9IG0xMjsKICAgIHJlc3VsdFs4XSA9IG0yMjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLmZyb21IZWFkaW5nUGl0Y2hSb2xsID0gZnVuY3Rpb24oaGVhZGluZ1BpdGNoUm9sbCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImhlYWRpbmdQaXRjaFJvbGwiLCBoZWFkaW5nUGl0Y2hSb2xsKTsKICAgIGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3MoLWhlYWRpbmdQaXRjaFJvbGwucGl0Y2gpOwogICAgY29uc3QgY29zUHNpID0gTWF0aC5jb3MoLWhlYWRpbmdQaXRjaFJvbGwuaGVhZGluZyk7CiAgICBjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyhoZWFkaW5nUGl0Y2hSb2xsLnJvbGwpOwogICAgY29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbigtaGVhZGluZ1BpdGNoUm9sbC5waXRjaCk7CiAgICBjb25zdCBzaW5Qc2kgPSBNYXRoLnNpbigtaGVhZGluZ1BpdGNoUm9sbC5oZWFkaW5nKTsKICAgIGNvbnN0IHNpblBoaSA9IE1hdGguc2luKGhlYWRpbmdQaXRjaFJvbGwucm9sbCk7CiAgICBjb25zdCBtMDAgPSBjb3NUaGV0YSAqIGNvc1BzaTsKICAgIGNvbnN0IG0wMSA9IC1jb3NQaGkgKiBzaW5Qc2kgKyBzaW5QaGkgKiBzaW5UaGV0YSAqIGNvc1BzaTsKICAgIGNvbnN0IG0wMiA9IHNpblBoaSAqIHNpblBzaSArIGNvc1BoaSAqIHNpblRoZXRhICogY29zUHNpOwogICAgY29uc3QgbTEwID0gY29zVGhldGEgKiBzaW5Qc2k7CiAgICBjb25zdCBtMTEgPSBjb3NQaGkgKiBjb3NQc2kgKyBzaW5QaGkgKiBzaW5UaGV0YSAqIHNpblBzaTsKICAgIGNvbnN0IG0xMiA9IC1zaW5QaGkgKiBjb3NQc2kgKyBjb3NQaGkgKiBzaW5UaGV0YSAqIHNpblBzaTsKICAgIGNvbnN0IG0yMCA9IC1zaW5UaGV0YTsKICAgIGNvbnN0IG0yMSA9IHNpblBoaSAqIGNvc1RoZXRhOwogICAgY29uc3QgbTIyID0gY29zUGhpICogY29zVGhldGE7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4MyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IG0wMDsKICAgIHJlc3VsdFsxXSA9IG0xMDsKICAgIHJlc3VsdFsyXSA9IG0yMDsKICAgIHJlc3VsdFszXSA9IG0wMTsKICAgIHJlc3VsdFs0XSA9IG0xMTsKICAgIHJlc3VsdFs1XSA9IG0yMTsKICAgIHJlc3VsdFs2XSA9IG0wMjsKICAgIHJlc3VsdFs3XSA9IG0xMjsKICAgIHJlc3VsdFs4XSA9IG0yMjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLmZyb21TY2FsZSA9IGZ1bmN0aW9uKHNjYWxlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic2NhbGUiLCBzY2FsZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4MyhzY2FsZS54LCAwLCAwLCAwLCBzY2FsZS55LCAwLCAwLCAwLCBzY2FsZS56KTsKICAgIH0KICAgIHJlc3VsdFswXSA9IHNjYWxlLng7CiAgICByZXN1bHRbMV0gPSAwOwogICAgcmVzdWx0WzJdID0gMDsKICAgIHJlc3VsdFszXSA9IDA7CiAgICByZXN1bHRbNF0gPSBzY2FsZS55OwogICAgcmVzdWx0WzVdID0gMDsKICAgIHJlc3VsdFs2XSA9IDA7CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gc2NhbGUuejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLmZyb21Vbmlmb3JtU2NhbGUgPSBmdW5jdGlvbihzY2FsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxlIiwgc2NhbGUpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IE1hdHJpeDMoc2NhbGUsIDAsIDAsIDAsIHNjYWxlLCAwLCAwLCAwLCBzY2FsZSk7CiAgICB9CiAgICByZXN1bHRbMF0gPSBzY2FsZTsKICAgIHJlc3VsdFsxXSA9IDA7CiAgICByZXN1bHRbMl0gPSAwOwogICAgcmVzdWx0WzNdID0gMDsKICAgIHJlc3VsdFs0XSA9IHNjYWxlOwogICAgcmVzdWx0WzVdID0gMDsKICAgIHJlc3VsdFs2XSA9IDA7CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gc2NhbGU7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4My5mcm9tQ3Jvc3NQcm9kdWN0ID0gZnVuY3Rpb24odmVjdG9yLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgidmVjdG9yIiwgdmVjdG9yKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBNYXRyaXgzKAogICAgICAgIDAsCiAgICAgICAgLXZlY3Rvci56LAogICAgICAgIHZlY3Rvci55LAogICAgICAgIHZlY3Rvci56LAogICAgICAgIDAsCiAgICAgICAgLXZlY3Rvci54LAogICAgICAgIC12ZWN0b3IueSwKICAgICAgICB2ZWN0b3IueCwKICAgICAgICAwCiAgICAgICk7CiAgICB9CiAgICByZXN1bHRbMF0gPSAwOwogICAgcmVzdWx0WzFdID0gdmVjdG9yLno7CiAgICByZXN1bHRbMl0gPSAtdmVjdG9yLnk7CiAgICByZXN1bHRbM10gPSAtdmVjdG9yLno7CiAgICByZXN1bHRbNF0gPSAwOwogICAgcmVzdWx0WzVdID0gdmVjdG9yLng7CiAgICByZXN1bHRbNl0gPSB2ZWN0b3IueTsKICAgIHJlc3VsdFs3XSA9IC12ZWN0b3IueDsKICAgIHJlc3VsdFs4XSA9IDA7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4My5mcm9tUm90YXRpb25YID0gZnVuY3Rpb24oYW5nbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJhbmdsZSIsIGFuZ2xlKTsKICAgIGNvbnN0IGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpOwogICAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4MygKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIGNvc0FuZ2xlLAogICAgICAgIC1zaW5BbmdsZSwKICAgICAgICAwLAogICAgICAgIHNpbkFuZ2xlLAogICAgICAgIGNvc0FuZ2xlCiAgICAgICk7CiAgICB9CiAgICByZXN1bHRbMF0gPSAxOwogICAgcmVzdWx0WzFdID0gMDsKICAgIHJlc3VsdFsyXSA9IDA7CiAgICByZXN1bHRbM10gPSAwOwogICAgcmVzdWx0WzRdID0gY29zQW5nbGU7CiAgICByZXN1bHRbNV0gPSBzaW5BbmdsZTsKICAgIHJlc3VsdFs2XSA9IDA7CiAgICByZXN1bHRbN10gPSAtc2luQW5nbGU7CiAgICByZXN1bHRbOF0gPSBjb3NBbmdsZTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLmZyb21Sb3RhdGlvblkgPSBmdW5jdGlvbihhbmdsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImFuZ2xlIiwgYW5nbGUpOwogICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7CiAgICBjb25zdCBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBNYXRyaXgzKAogICAgICAgIGNvc0FuZ2xlLAogICAgICAgIDAsCiAgICAgICAgc2luQW5nbGUsCiAgICAgICAgMCwKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgLXNpbkFuZ2xlLAogICAgICAgIDAsCiAgICAgICAgY29zQW5nbGUKICAgICAgKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IGNvc0FuZ2xlOwogICAgcmVzdWx0WzFdID0gMDsKICAgIHJlc3VsdFsyXSA9IC1zaW5BbmdsZTsKICAgIHJlc3VsdFszXSA9IDA7CiAgICByZXN1bHRbNF0gPSAxOwogICAgcmVzdWx0WzVdID0gMDsKICAgIHJlc3VsdFs2XSA9IHNpbkFuZ2xlOwogICAgcmVzdWx0WzddID0gMDsKICAgIHJlc3VsdFs4XSA9IGNvc0FuZ2xlOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMuZnJvbVJvdGF0aW9uWiA9IGZ1bmN0aW9uKGFuZ2xlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigiYW5nbGUiLCBhbmdsZSk7CiAgICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTsKICAgIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IE1hdHJpeDMoCiAgICAgICAgY29zQW5nbGUsCiAgICAgICAgLXNpbkFuZ2xlLAogICAgICAgIDAsCiAgICAgICAgc2luQW5nbGUsCiAgICAgICAgY29zQW5nbGUsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApOwogICAgfQogICAgcmVzdWx0WzBdID0gY29zQW5nbGU7CiAgICByZXN1bHRbMV0gPSBzaW5BbmdsZTsKICAgIHJlc3VsdFsyXSA9IDA7CiAgICByZXN1bHRbM10gPSAtc2luQW5nbGU7CiAgICByZXN1bHRbNF0gPSBjb3NBbmdsZTsKICAgIHJlc3VsdFs1XSA9IDA7CiAgICByZXN1bHRbNl0gPSAwOwogICAgcmVzdWx0WzddID0gMDsKICAgIHJlc3VsdFs4XSA9IDE7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4My50b0FycmF5ID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIFsKICAgICAgICBtYXRyaXhbMF0sCiAgICAgICAgbWF0cml4WzFdLAogICAgICAgIG1hdHJpeFsyXSwKICAgICAgICBtYXRyaXhbM10sCiAgICAgICAgbWF0cml4WzRdLAogICAgICAgIG1hdHJpeFs1XSwKICAgICAgICBtYXRyaXhbNl0sCiAgICAgICAgbWF0cml4WzddLAogICAgICAgIG1hdHJpeFs4XQogICAgICBdOwogICAgfQogICAgcmVzdWx0WzBdID0gbWF0cml4WzBdOwogICAgcmVzdWx0WzFdID0gbWF0cml4WzFdOwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdOwogICAgcmVzdWx0WzRdID0gbWF0cml4WzRdOwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdOwogICAgcmVzdWx0WzZdID0gbWF0cml4WzZdOwogICAgcmVzdWx0WzddID0gbWF0cml4WzddOwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMuZ2V0RWxlbWVudEluZGV4ID0gZnVuY3Rpb24oY29sdW1uLCByb3cpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJyb3ciLCByb3csIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoInJvdyIsIHJvdywgMik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiY29sdW1uIiwgY29sdW1uLCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJjb2x1bW4iLCBjb2x1bW4sIDIpOwogICAgcmV0dXJuIGNvbHVtbiAqIDMgKyByb3c7CiAgfTsKICBNYXRyaXgzLmdldENvbHVtbiA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoImluZGV4IiwgaW5kZXgsIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoImluZGV4IiwgaW5kZXgsIDIpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4ICogMzsKICAgIGNvbnN0IHggPSBtYXRyaXhbc3RhcnRJbmRleF07CiAgICBjb25zdCB5ID0gbWF0cml4W3N0YXJ0SW5kZXggKyAxXTsKICAgIGNvbnN0IHogPSBtYXRyaXhbc3RhcnRJbmRleCArIDJdOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMuc2V0Q29sdW1uID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCwgY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJpbmRleCIsIGluZGV4LCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJpbmRleCIsIGluZGV4LCAyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdCA9IE1hdHJpeDMuY2xvbmUobWF0cml4LCByZXN1bHQpOwogICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4ICogMzsKICAgIHJlc3VsdFtzdGFydEluZGV4XSA9IGNhcnRlc2lhbi54OwogICAgcmVzdWx0W3N0YXJ0SW5kZXggKyAxXSA9IGNhcnRlc2lhbi55OwogICAgcmVzdWx0W3N0YXJ0SW5kZXggKyAyXSA9IGNhcnRlc2lhbi56OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMuZ2V0Um93ID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCB4ID0gbWF0cml4W2luZGV4XTsKICAgIGNvbnN0IHkgPSBtYXRyaXhbaW5kZXggKyAzXTsKICAgIGNvbnN0IHogPSBtYXRyaXhbaW5kZXggKyA2XTsKICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJlc3VsdC56ID0gejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLnNldFJvdyA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgsIGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQgPSBNYXRyaXgzLmNsb25lKG1hdHJpeCwgcmVzdWx0KTsKICAgIHJlc3VsdFtpbmRleF0gPSBjYXJ0ZXNpYW4ueDsKICAgIHJlc3VsdFtpbmRleCArIDNdID0gY2FydGVzaWFuLnk7CiAgICByZXN1bHRbaW5kZXggKyA2XSA9IGNhcnRlc2lhbi56OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY2FsZVNjcmF0Y2gxID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIE1hdHJpeDMuc2V0U2NhbGUgPSBmdW5jdGlvbihtYXRyaXgsIHNjYWxlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic2NhbGUiLCBzY2FsZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBleGlzdGluZ1NjYWxlID0gTWF0cml4My5nZXRTY2FsZShtYXRyaXgsIHNjYWxlU2NyYXRjaDEpOwogICAgY29uc3Qgc2NhbGVSYXRpb1ggPSBzY2FsZS54IC8gZXhpc3RpbmdTY2FsZS54OwogICAgY29uc3Qgc2NhbGVSYXRpb1kgPSBzY2FsZS55IC8gZXhpc3RpbmdTY2FsZS55OwogICAgY29uc3Qgc2NhbGVSYXRpb1ogPSBzY2FsZS56IC8gZXhpc3RpbmdTY2FsZS56OwogICAgcmVzdWx0WzBdID0gbWF0cml4WzBdICogc2NhbGVSYXRpb1g7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZVJhdGlvWDsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXSAqIHNjYWxlUmF0aW9YOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdICogc2NhbGVSYXRpb1k7CiAgICByZXN1bHRbNF0gPSBtYXRyaXhbNF0gKiBzY2FsZVJhdGlvWTsKICAgIHJlc3VsdFs1XSA9IG1hdHJpeFs1XSAqIHNjYWxlUmF0aW9ZOwogICAgcmVzdWx0WzZdID0gbWF0cml4WzZdICogc2NhbGVSYXRpb1o7CiAgICByZXN1bHRbN10gPSBtYXRyaXhbN10gKiBzY2FsZVJhdGlvWjsKICAgIHJlc3VsdFs4XSA9IG1hdHJpeFs4XSAqIHNjYWxlUmF0aW9aOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY2FsZVNjcmF0Y2gyID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIE1hdHJpeDMuc2V0VW5pZm9ybVNjYWxlID0gZnVuY3Rpb24obWF0cml4LCBzY2FsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxlIiwgc2NhbGUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgZXhpc3RpbmdTY2FsZSA9IE1hdHJpeDMuZ2V0U2NhbGUobWF0cml4LCBzY2FsZVNjcmF0Y2gyKTsKICAgIGNvbnN0IHNjYWxlUmF0aW9YID0gc2NhbGUgLyBleGlzdGluZ1NjYWxlLng7CiAgICBjb25zdCBzY2FsZVJhdGlvWSA9IHNjYWxlIC8gZXhpc3RpbmdTY2FsZS55OwogICAgY29uc3Qgc2NhbGVSYXRpb1ogPSBzY2FsZSAvIGV4aXN0aW5nU2NhbGUuejsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAqIHNjYWxlUmF0aW9YOwogICAgcmVzdWx0WzFdID0gbWF0cml4WzFdICogc2NhbGVSYXRpb1g7CiAgICByZXN1bHRbMl0gPSBtYXRyaXhbMl0gKiBzY2FsZVJhdGlvWDsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAqIHNjYWxlUmF0aW9ZOwogICAgcmVzdWx0WzRdID0gbWF0cml4WzRdICogc2NhbGVSYXRpb1k7CiAgICByZXN1bHRbNV0gPSBtYXRyaXhbNV0gKiBzY2FsZVJhdGlvWTsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs2XSAqIHNjYWxlUmF0aW9aOwogICAgcmVzdWx0WzddID0gbWF0cml4WzddICogc2NhbGVSYXRpb1o7CiAgICByZXN1bHRbOF0gPSBtYXRyaXhbOF0gKiBzY2FsZVJhdGlvWjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NyYXRjaENvbHVtbiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBNYXRyaXgzLmdldFNjYWxlID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZSgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmZyb21FbGVtZW50cyhtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBzY3JhdGNoQ29sdW1uKQogICAgKTsKICAgIHJlc3VsdC55ID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZSgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmZyb21FbGVtZW50cyhtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBzY3JhdGNoQ29sdW1uKQogICAgKTsKICAgIHJlc3VsdC56ID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZSgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmZyb21FbGVtZW50cyhtYXRyaXhbNl0sIG1hdHJpeFs3XSwgbWF0cml4WzhdLCBzY3JhdGNoQ29sdW1uKQogICAgKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NhbGVTY3JhdGNoMyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBNYXRyaXgzLmdldE1heGltdW1TY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCkgewogICAgTWF0cml4My5nZXRTY2FsZShtYXRyaXgsIHNjYWxlU2NyYXRjaDMpOwogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5tYXhpbXVtQ29tcG9uZW50KHNjYWxlU2NyYXRjaDMpOwogIH07CiAgdmFyIHNjYWxlU2NyYXRjaDQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgTWF0cml4My5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKG1hdHJpeCwgcm90YXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3Qgc2NhbGUgPSBNYXRyaXgzLmdldFNjYWxlKG1hdHJpeCwgc2NhbGVTY3JhdGNoNCk7CiAgICByZXN1bHRbMF0gPSByb3RhdGlvblswXSAqIHNjYWxlLng7CiAgICByZXN1bHRbMV0gPSByb3RhdGlvblsxXSAqIHNjYWxlLng7CiAgICByZXN1bHRbMl0gPSByb3RhdGlvblsyXSAqIHNjYWxlLng7CiAgICByZXN1bHRbM10gPSByb3RhdGlvblszXSAqIHNjYWxlLnk7CiAgICByZXN1bHRbNF0gPSByb3RhdGlvbls0XSAqIHNjYWxlLnk7CiAgICByZXN1bHRbNV0gPSByb3RhdGlvbls1XSAqIHNjYWxlLnk7CiAgICByZXN1bHRbNl0gPSByb3RhdGlvbls2XSAqIHNjYWxlLno7CiAgICByZXN1bHRbN10gPSByb3RhdGlvbls3XSAqIHNjYWxlLno7CiAgICByZXN1bHRbOF0gPSByb3RhdGlvbls4XSAqIHNjYWxlLno7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjYWxlU2NyYXRjaDUgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgTWF0cml4My5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBzY2FsZSA9IE1hdHJpeDMuZ2V0U2NhbGUobWF0cml4LCBzY2FsZVNjcmF0Y2g1KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAvIHNjYWxlLng7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gLyBzY2FsZS54OwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdIC8gc2NhbGUueDsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAvIHNjYWxlLnk7CiAgICByZXN1bHRbNF0gPSBtYXRyaXhbNF0gLyBzY2FsZS55OwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdIC8gc2NhbGUueTsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs2XSAvIHNjYWxlLno7CiAgICByZXN1bHRbN10gPSBtYXRyaXhbN10gLyBzY2FsZS56OwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdIC8gc2NhbGUuejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLm11bHRpcGx5ID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgY29sdW1uMFJvdzAgPSBsZWZ0WzBdICogcmlnaHRbMF0gKyBsZWZ0WzNdICogcmlnaHRbMV0gKyBsZWZ0WzZdICogcmlnaHRbMl07CiAgICBjb25zdCBjb2x1bW4wUm93MSA9IGxlZnRbMV0gKiByaWdodFswXSArIGxlZnRbNF0gKiByaWdodFsxXSArIGxlZnRbN10gKiByaWdodFsyXTsKICAgIGNvbnN0IGNvbHVtbjBSb3cyID0gbGVmdFsyXSAqIHJpZ2h0WzBdICsgbGVmdFs1XSAqIHJpZ2h0WzFdICsgbGVmdFs4XSAqIHJpZ2h0WzJdOwogICAgY29uc3QgY29sdW1uMVJvdzAgPSBsZWZ0WzBdICogcmlnaHRbM10gKyBsZWZ0WzNdICogcmlnaHRbNF0gKyBsZWZ0WzZdICogcmlnaHRbNV07CiAgICBjb25zdCBjb2x1bW4xUm93MSA9IGxlZnRbMV0gKiByaWdodFszXSArIGxlZnRbNF0gKiByaWdodFs0XSArIGxlZnRbN10gKiByaWdodFs1XTsKICAgIGNvbnN0IGNvbHVtbjFSb3cyID0gbGVmdFsyXSAqIHJpZ2h0WzNdICsgbGVmdFs1XSAqIHJpZ2h0WzRdICsgbGVmdFs4XSAqIHJpZ2h0WzVdOwogICAgY29uc3QgY29sdW1uMlJvdzAgPSBsZWZ0WzBdICogcmlnaHRbNl0gKyBsZWZ0WzNdICogcmlnaHRbN10gKyBsZWZ0WzZdICogcmlnaHRbOF07CiAgICBjb25zdCBjb2x1bW4yUm93MSA9IGxlZnRbMV0gKiByaWdodFs2XSArIGxlZnRbNF0gKiByaWdodFs3XSArIGxlZnRbN10gKiByaWdodFs4XTsKICAgIGNvbnN0IGNvbHVtbjJSb3cyID0gbGVmdFsyXSAqIHJpZ2h0WzZdICsgbGVmdFs1XSAqIHJpZ2h0WzddICsgbGVmdFs4XSAqIHJpZ2h0WzhdOwogICAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7CiAgICByZXN1bHRbMV0gPSBjb2x1bW4wUm93MTsKICAgIHJlc3VsdFsyXSA9IGNvbHVtbjBSb3cyOwogICAgcmVzdWx0WzNdID0gY29sdW1uMVJvdzA7CiAgICByZXN1bHRbNF0gPSBjb2x1bW4xUm93MTsKICAgIHJlc3VsdFs1XSA9IGNvbHVtbjFSb3cyOwogICAgcmVzdWx0WzZdID0gY29sdW1uMlJvdzA7CiAgICByZXN1bHRbN10gPSBjb2x1bW4yUm93MTsKICAgIHJlc3VsdFs4XSA9IGNvbHVtbjJSb3cyOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMuYWRkID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gbGVmdFswXSArIHJpZ2h0WzBdOwogICAgcmVzdWx0WzFdID0gbGVmdFsxXSArIHJpZ2h0WzFdOwogICAgcmVzdWx0WzJdID0gbGVmdFsyXSArIHJpZ2h0WzJdOwogICAgcmVzdWx0WzNdID0gbGVmdFszXSArIHJpZ2h0WzNdOwogICAgcmVzdWx0WzRdID0gbGVmdFs0XSArIHJpZ2h0WzRdOwogICAgcmVzdWx0WzVdID0gbGVmdFs1XSArIHJpZ2h0WzVdOwogICAgcmVzdWx0WzZdID0gbGVmdFs2XSArIHJpZ2h0WzZdOwogICAgcmVzdWx0WzddID0gbGVmdFs3XSArIHJpZ2h0WzddOwogICAgcmVzdWx0WzhdID0gbGVmdFs4XSArIHJpZ2h0WzhdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMuc3VidHJhY3QgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHRbMF0gPSBsZWZ0WzBdIC0gcmlnaHRbMF07CiAgICByZXN1bHRbMV0gPSBsZWZ0WzFdIC0gcmlnaHRbMV07CiAgICByZXN1bHRbMl0gPSBsZWZ0WzJdIC0gcmlnaHRbMl07CiAgICByZXN1bHRbM10gPSBsZWZ0WzNdIC0gcmlnaHRbM107CiAgICByZXN1bHRbNF0gPSBsZWZ0WzRdIC0gcmlnaHRbNF07CiAgICByZXN1bHRbNV0gPSBsZWZ0WzVdIC0gcmlnaHRbNV07CiAgICByZXN1bHRbNl0gPSBsZWZ0WzZdIC0gcmlnaHRbNl07CiAgICByZXN1bHRbN10gPSBsZWZ0WzddIC0gcmlnaHRbN107CiAgICByZXN1bHRbOF0gPSBsZWZ0WzhdIC0gcmlnaHRbOF07CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4My5tdWx0aXBseUJ5VmVjdG9yID0gZnVuY3Rpb24obWF0cml4LCBjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgdlggPSBjYXJ0ZXNpYW4ueDsKICAgIGNvbnN0IHZZID0gY2FydGVzaWFuLnk7CiAgICBjb25zdCB2WiA9IGNhcnRlc2lhbi56OwogICAgY29uc3QgeCA9IG1hdHJpeFswXSAqIHZYICsgbWF0cml4WzNdICogdlkgKyBtYXRyaXhbNl0gKiB2WjsKICAgIGNvbnN0IHkgPSBtYXRyaXhbMV0gKiB2WCArIG1hdHJpeFs0XSAqIHZZICsgbWF0cml4WzddICogdlo7CiAgICBjb25zdCB6ID0gbWF0cml4WzJdICogdlggKyBtYXRyaXhbNV0gKiB2WSArIG1hdHJpeFs4XSAqIHZaOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMubXVsdGlwbHlCeVNjYWxhciA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGFyLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigic2NhbGFyIiwgc2NhbGFyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAqIHNjYWxhcjsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFsxXSAqIHNjYWxhcjsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXSAqIHNjYWxhcjsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAqIHNjYWxhcjsKICAgIHJlc3VsdFs0XSA9IG1hdHJpeFs0XSAqIHNjYWxhcjsKICAgIHJlc3VsdFs1XSA9IG1hdHJpeFs1XSAqIHNjYWxhcjsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs2XSAqIHNjYWxhcjsKICAgIHJlc3VsdFs3XSA9IG1hdHJpeFs3XSAqIHNjYWxhcjsKICAgIHJlc3VsdFs4XSA9IG1hdHJpeFs4XSAqIHNjYWxhcjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLm11bHRpcGx5QnlTY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzY2FsZSIsIHNjYWxlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAqIHNjYWxlLng7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZS54OwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdICogc2NhbGUueDsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAqIHNjYWxlLnk7CiAgICByZXN1bHRbNF0gPSBtYXRyaXhbNF0gKiBzY2FsZS55OwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdICogc2NhbGUueTsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs2XSAqIHNjYWxlLno7CiAgICByZXN1bHRbN10gPSBtYXRyaXhbN10gKiBzY2FsZS56OwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdICogc2NhbGUuejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgzLm11bHRpcGx5QnlVbmlmb3JtU2NhbGUgPSBmdW5jdGlvbihtYXRyaXgsIHNjYWxlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigic2NhbGUiLCBzY2FsZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHRbMF0gPSBtYXRyaXhbMF0gKiBzY2FsZTsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFsxXSAqIHNjYWxlOwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdICogc2NhbGU7CiAgICByZXN1bHRbM10gPSBtYXRyaXhbM10gKiBzY2FsZTsKICAgIHJlc3VsdFs0XSA9IG1hdHJpeFs0XSAqIHNjYWxlOwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdICogc2NhbGU7CiAgICByZXN1bHRbNl0gPSBtYXRyaXhbNl0gKiBzY2FsZTsKICAgIHJlc3VsdFs3XSA9IG1hdHJpeFs3XSAqIHNjYWxlOwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdICogc2NhbGU7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4My5uZWdhdGUgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gLW1hdHJpeFswXTsKICAgIHJlc3VsdFsxXSA9IC1tYXRyaXhbMV07CiAgICByZXN1bHRbMl0gPSAtbWF0cml4WzJdOwogICAgcmVzdWx0WzNdID0gLW1hdHJpeFszXTsKICAgIHJlc3VsdFs0XSA9IC1tYXRyaXhbNF07CiAgICByZXN1bHRbNV0gPSAtbWF0cml4WzVdOwogICAgcmVzdWx0WzZdID0gLW1hdHJpeFs2XTsKICAgIHJlc3VsdFs3XSA9IC1tYXRyaXhbN107CiAgICByZXN1bHRbOF0gPSAtbWF0cml4WzhdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMudHJhbnNwb3NlID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGNvbHVtbjBSb3cwID0gbWF0cml4WzBdOwogICAgY29uc3QgY29sdW1uMFJvdzEgPSBtYXRyaXhbM107CiAgICBjb25zdCBjb2x1bW4wUm93MiA9IG1hdHJpeFs2XTsKICAgIGNvbnN0IGNvbHVtbjFSb3cwID0gbWF0cml4WzFdOwogICAgY29uc3QgY29sdW1uMVJvdzEgPSBtYXRyaXhbNF07CiAgICBjb25zdCBjb2x1bW4xUm93MiA9IG1hdHJpeFs3XTsKICAgIGNvbnN0IGNvbHVtbjJSb3cwID0gbWF0cml4WzJdOwogICAgY29uc3QgY29sdW1uMlJvdzEgPSBtYXRyaXhbNV07CiAgICBjb25zdCBjb2x1bW4yUm93MiA9IG1hdHJpeFs4XTsKICAgIHJlc3VsdFswXSA9IGNvbHVtbjBSb3cwOwogICAgcmVzdWx0WzFdID0gY29sdW1uMFJvdzE7CiAgICByZXN1bHRbMl0gPSBjb2x1bW4wUm93MjsKICAgIHJlc3VsdFszXSA9IGNvbHVtbjFSb3cwOwogICAgcmVzdWx0WzRdID0gY29sdW1uMVJvdzE7CiAgICByZXN1bHRbNV0gPSBjb2x1bW4xUm93MjsKICAgIHJlc3VsdFs2XSA9IGNvbHVtbjJSb3cwOwogICAgcmVzdWx0WzddID0gY29sdW1uMlJvdzE7CiAgICByZXN1bHRbOF0gPSBjb2x1bW4yUm93MjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBmdW5jdGlvbiBjb21wdXRlRnJvYmVuaXVzTm9ybShtYXRyaXgpIHsKICAgIGxldCBub3JtID0gMDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgKytpKSB7CiAgICAgIGNvbnN0IHRlbXAgPSBtYXRyaXhbaV07CiAgICAgIG5vcm0gKz0gdGVtcCAqIHRlbXA7CiAgICB9CiAgICByZXR1cm4gTWF0aC5zcXJ0KG5vcm0pOwogIH0KICB2YXIgcm93VmFsID0gWzEsIDAsIDBdOwogIHZhciBjb2xWYWwgPSBbMiwgMiwgMV07CiAgZnVuY3Rpb24gb2ZmRGlhZ29uYWxGcm9iZW5pdXNOb3JtKG1hdHJpeCkgewogICAgbGV0IG5vcm0gPSAwOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyArK2kpIHsKICAgICAgY29uc3QgdGVtcCA9IG1hdHJpeFtNYXRyaXgzLmdldEVsZW1lbnRJbmRleChjb2xWYWxbaV0sIHJvd1ZhbFtpXSldOwogICAgICBub3JtICs9IDIgKiB0ZW1wICogdGVtcDsKICAgIH0KICAgIHJldHVybiBNYXRoLnNxcnQobm9ybSk7CiAgfQogIGZ1bmN0aW9uIHNodXJEZWNvbXBvc2l0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBjb25zdCB0b2xlcmFuY2UgPSBNYXRoX2RlZmF1bHQuRVBTSUxPTjE1OwogICAgbGV0IG1heERpYWdvbmFsID0gMDsKICAgIGxldCByb3RBeGlzID0gMTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgKytpKSB7CiAgICAgIGNvbnN0IHRlbXAgPSBNYXRoLmFicygKICAgICAgICBtYXRyaXhbTWF0cml4My5nZXRFbGVtZW50SW5kZXgoY29sVmFsW2ldLCByb3dWYWxbaV0pXQogICAgICApOwogICAgICBpZiAodGVtcCA+IG1heERpYWdvbmFsKSB7CiAgICAgICAgcm90QXhpcyA9IGk7CiAgICAgICAgbWF4RGlhZ29uYWwgPSB0ZW1wOwogICAgICB9CiAgICB9CiAgICBsZXQgYyA9IDE7CiAgICBsZXQgcyA9IDA7CiAgICBjb25zdCBwID0gcm93VmFsW3JvdEF4aXNdOwogICAgY29uc3QgcSA9IGNvbFZhbFtyb3RBeGlzXTsKICAgIGlmIChNYXRoLmFicyhtYXRyaXhbTWF0cml4My5nZXRFbGVtZW50SW5kZXgocSwgcCldKSA+IHRvbGVyYW5jZSkgewogICAgICBjb25zdCBxcSA9IG1hdHJpeFtNYXRyaXgzLmdldEVsZW1lbnRJbmRleChxLCBxKV07CiAgICAgIGNvbnN0IHBwID0gbWF0cml4W01hdHJpeDMuZ2V0RWxlbWVudEluZGV4KHAsIHApXTsKICAgICAgY29uc3QgcXAgPSBtYXRyaXhbTWF0cml4My5nZXRFbGVtZW50SW5kZXgocSwgcCldOwogICAgICBjb25zdCB0YXUgPSAocXEgLSBwcCkgLyAyIC8gcXA7CiAgICAgIGxldCB0OwogICAgICBpZiAodGF1IDwgMCkgewogICAgICAgIHQgPSAtMSAvICgtdGF1ICsgTWF0aC5zcXJ0KDEgKyB0YXUgKiB0YXUpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0ID0gMSAvICh0YXUgKyBNYXRoLnNxcnQoMSArIHRhdSAqIHRhdSkpOwogICAgICB9CiAgICAgIGMgPSAxIC8gTWF0aC5zcXJ0KDEgKyB0ICogdCk7CiAgICAgIHMgPSB0ICogYzsKICAgIH0KICAgIHJlc3VsdCA9IE1hdHJpeDMuY2xvbmUoTWF0cml4My5JREVOVElUWSwgcmVzdWx0KTsKICAgIHJlc3VsdFtNYXRyaXgzLmdldEVsZW1lbnRJbmRleChwLCBwKV0gPSByZXN1bHRbTWF0cml4My5nZXRFbGVtZW50SW5kZXgocSwgcSldID0gYzsKICAgIHJlc3VsdFtNYXRyaXgzLmdldEVsZW1lbnRJbmRleChxLCBwKV0gPSBzOwogICAgcmVzdWx0W01hdHJpeDMuZ2V0RWxlbWVudEluZGV4KHAsIHEpXSA9IC1zOwogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGpNYXRyaXggPSBuZXcgTWF0cml4MygpOwogIHZhciBqTWF0cml4VHJhbnNwb3NlID0gbmV3IE1hdHJpeDMoKTsKICBNYXRyaXgzLmNvbXB1dGVFaWdlbkRlY29tcG9zaXRpb24gPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgY29uc3QgdG9sZXJhbmNlID0gTWF0aF9kZWZhdWx0LkVQU0lMT04yMDsKICAgIGNvbnN0IG1heFN3ZWVwcyA9IDEwOwogICAgbGV0IGNvdW50ID0gMDsKICAgIGxldCBzd2VlcCA9IDA7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IHt9OwogICAgfQogICAgY29uc3QgdW5pdGFyeU1hdHJpeCA9IHJlc3VsdC51bml0YXJ5ID0gTWF0cml4My5jbG9uZSgKICAgICAgTWF0cml4My5JREVOVElUWSwKICAgICAgcmVzdWx0LnVuaXRhcnkKICAgICk7CiAgICBjb25zdCBkaWFnTWF0cml4ID0gcmVzdWx0LmRpYWdvbmFsID0gTWF0cml4My5jbG9uZShtYXRyaXgsIHJlc3VsdC5kaWFnb25hbCk7CiAgICBjb25zdCBlcHNpbG9uID0gdG9sZXJhbmNlICogY29tcHV0ZUZyb2Jlbml1c05vcm0oZGlhZ01hdHJpeCk7CiAgICB3aGlsZSAoc3dlZXAgPCBtYXhTd2VlcHMgJiYgb2ZmRGlhZ29uYWxGcm9iZW5pdXNOb3JtKGRpYWdNYXRyaXgpID4gZXBzaWxvbikgewogICAgICBzaHVyRGVjb21wb3NpdGlvbihkaWFnTWF0cml4LCBqTWF0cml4KTsKICAgICAgTWF0cml4My50cmFuc3Bvc2Uoak1hdHJpeCwgak1hdHJpeFRyYW5zcG9zZSk7CiAgICAgIE1hdHJpeDMubXVsdGlwbHkoZGlhZ01hdHJpeCwgak1hdHJpeCwgZGlhZ01hdHJpeCk7CiAgICAgIE1hdHJpeDMubXVsdGlwbHkoak1hdHJpeFRyYW5zcG9zZSwgZGlhZ01hdHJpeCwgZGlhZ01hdHJpeCk7CiAgICAgIE1hdHJpeDMubXVsdGlwbHkodW5pdGFyeU1hdHJpeCwgak1hdHJpeCwgdW5pdGFyeU1hdHJpeCk7CiAgICAgIGlmICgrK2NvdW50ID4gMikgewogICAgICAgICsrc3dlZXA7CiAgICAgICAgY291bnQgPSAwOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4My5hYnMgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gTWF0aC5hYnMobWF0cml4WzBdKTsKICAgIHJlc3VsdFsxXSA9IE1hdGguYWJzKG1hdHJpeFsxXSk7CiAgICByZXN1bHRbMl0gPSBNYXRoLmFicyhtYXRyaXhbMl0pOwogICAgcmVzdWx0WzNdID0gTWF0aC5hYnMobWF0cml4WzNdKTsKICAgIHJlc3VsdFs0XSA9IE1hdGguYWJzKG1hdHJpeFs0XSk7CiAgICByZXN1bHRbNV0gPSBNYXRoLmFicyhtYXRyaXhbNV0pOwogICAgcmVzdWx0WzZdID0gTWF0aC5hYnMobWF0cml4WzZdKTsKICAgIHJlc3VsdFs3XSA9IE1hdGguYWJzKG1hdHJpeFs3XSk7CiAgICByZXN1bHRbOF0gPSBNYXRoLmFicyhtYXRyaXhbOF0pOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbihtYXRyaXgpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIGNvbnN0IG0xMSA9IG1hdHJpeFswXTsKICAgIGNvbnN0IG0yMSA9IG1hdHJpeFszXTsKICAgIGNvbnN0IG0zMSA9IG1hdHJpeFs2XTsKICAgIGNvbnN0IG0xMiA9IG1hdHJpeFsxXTsKICAgIGNvbnN0IG0yMiA9IG1hdHJpeFs0XTsKICAgIGNvbnN0IG0zMiA9IG1hdHJpeFs3XTsKICAgIGNvbnN0IG0xMyA9IG1hdHJpeFsyXTsKICAgIGNvbnN0IG0yMyA9IG1hdHJpeFs1XTsKICAgIGNvbnN0IG0zMyA9IG1hdHJpeFs4XTsKICAgIHJldHVybiBtMTEgKiAobTIyICogbTMzIC0gbTIzICogbTMyKSArIG0xMiAqIChtMjMgKiBtMzEgLSBtMjEgKiBtMzMpICsgbTEzICogKG0yMSAqIG0zMiAtIG0yMiAqIG0zMSk7CiAgfTsKICBNYXRyaXgzLmludmVyc2UgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgbTExID0gbWF0cml4WzBdOwogICAgY29uc3QgbTIxID0gbWF0cml4WzFdOwogICAgY29uc3QgbTMxID0gbWF0cml4WzJdOwogICAgY29uc3QgbTEyID0gbWF0cml4WzNdOwogICAgY29uc3QgbTIyID0gbWF0cml4WzRdOwogICAgY29uc3QgbTMyID0gbWF0cml4WzVdOwogICAgY29uc3QgbTEzID0gbWF0cml4WzZdOwogICAgY29uc3QgbTIzID0gbWF0cml4WzddOwogICAgY29uc3QgbTMzID0gbWF0cml4WzhdOwogICAgY29uc3QgZGV0ZXJtaW5hbnQgPSBNYXRyaXgzLmRldGVybWluYW50KG1hdHJpeCk7CiAgICBpZiAoTWF0aC5hYnMoZGV0ZXJtaW5hbnQpIDw9IE1hdGhfZGVmYXVsdC5FUFNJTE9OMTUpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm1hdHJpeCBpcyBub3QgaW52ZXJ0aWJsZSIpOwogICAgfQogICAgcmVzdWx0WzBdID0gbTIyICogbTMzIC0gbTIzICogbTMyOwogICAgcmVzdWx0WzFdID0gbTIzICogbTMxIC0gbTIxICogbTMzOwogICAgcmVzdWx0WzJdID0gbTIxICogbTMyIC0gbTIyICogbTMxOwogICAgcmVzdWx0WzNdID0gbTEzICogbTMyIC0gbTEyICogbTMzOwogICAgcmVzdWx0WzRdID0gbTExICogbTMzIC0gbTEzICogbTMxOwogICAgcmVzdWx0WzVdID0gbTEyICogbTMxIC0gbTExICogbTMyOwogICAgcmVzdWx0WzZdID0gbTEyICogbTIzIC0gbTEzICogbTIyOwogICAgcmVzdWx0WzddID0gbTEzICogbTIxIC0gbTExICogbTIzOwogICAgcmVzdWx0WzhdID0gbTExICogbTIyIC0gbTEyICogbTIxOwogICAgY29uc3Qgc2NhbGUgPSAxIC8gZGV0ZXJtaW5hbnQ7CiAgICByZXR1cm4gTWF0cml4My5tdWx0aXBseUJ5U2NhbGFyKHJlc3VsdCwgc2NhbGUsIHJlc3VsdCk7CiAgfTsKICB2YXIgc2NyYXRjaFRyYW5zcG9zZU1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7CiAgTWF0cml4My5pbnZlcnNlVHJhbnNwb3NlID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJldHVybiBNYXRyaXgzLmludmVyc2UoCiAgICAgIE1hdHJpeDMudHJhbnNwb3NlKG1hdHJpeCwgc2NyYXRjaFRyYW5zcG9zZU1hdHJpeCksCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIE1hdHJpeDMuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBsZWZ0WzBdID09PSByaWdodFswXSAmJiBsZWZ0WzFdID09PSByaWdodFsxXSAmJiBsZWZ0WzJdID09PSByaWdodFsyXSAmJiBsZWZ0WzNdID09PSByaWdodFszXSAmJiBsZWZ0WzRdID09PSByaWdodFs0XSAmJiBsZWZ0WzVdID09PSByaWdodFs1XSAmJiBsZWZ0WzZdID09PSByaWdodFs2XSAmJiBsZWZ0WzddID09PSByaWdodFs3XSAmJiBsZWZ0WzhdID09PSByaWdodFs4XTsKICB9OwogIE1hdHJpeDMuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBlcHNpbG9uKSB7CiAgICBlcHNpbG9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZXBzaWxvbiwgMCk7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgTWF0aC5hYnMobGVmdFswXSAtIHJpZ2h0WzBdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMV0gLSByaWdodFsxXSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0WzJdIC0gcmlnaHRbMl0pIDw9IGVwc2lsb24gJiYgTWF0aC5hYnMobGVmdFszXSAtIHJpZ2h0WzNdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbNF0gLSByaWdodFs0XSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0WzVdIC0gcmlnaHRbNV0pIDw9IGVwc2lsb24gJiYgTWF0aC5hYnMobGVmdFs2XSAtIHJpZ2h0WzZdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbN10gLSByaWdodFs3XSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0WzhdIC0gcmlnaHRbOF0pIDw9IGVwc2lsb247CiAgfTsKICBNYXRyaXgzLklERU5USVRZID0gT2JqZWN0LmZyZWV6ZSgKICAgIG5ldyBNYXRyaXgzKDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEpCiAgKTsKICBNYXRyaXgzLlpFUk8gPSBPYmplY3QuZnJlZXplKAogICAgbmV3IE1hdHJpeDMoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCkKICApOwogIE1hdHJpeDMuQ09MVU1OMFJPVzAgPSAwOwogIE1hdHJpeDMuQ09MVU1OMFJPVzEgPSAxOwogIE1hdHJpeDMuQ09MVU1OMFJPVzIgPSAyOwogIE1hdHJpeDMuQ09MVU1OMVJPVzAgPSAzOwogIE1hdHJpeDMuQ09MVU1OMVJPVzEgPSA0OwogIE1hdHJpeDMuQ09MVU1OMVJPVzIgPSA1OwogIE1hdHJpeDMuQ09MVU1OMlJPVzAgPSA2OwogIE1hdHJpeDMuQ09MVU1OMlJPVzEgPSA3OwogIE1hdHJpeDMuQ09MVU1OMlJPVzIgPSA4OwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1hdHJpeDMucHJvdG90eXBlLCB7CiAgICBsZW5ndGg6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gTWF0cml4My5wYWNrZWRMZW5ndGg7CiAgICAgIH0KICAgIH0KICB9KTsKICBNYXRyaXgzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkgewogICAgcmV0dXJuIE1hdHJpeDMuY2xvbmUodGhpcywgcmVzdWx0KTsKICB9OwogIE1hdHJpeDMucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHJpZ2h0KSB7CiAgICByZXR1cm4gTWF0cml4My5lcXVhbHModGhpcywgcmlnaHQpOwogIH07CiAgTWF0cml4My5lcXVhbHNBcnJheSA9IGZ1bmN0aW9uKG1hdHJpeCwgYXJyYXksIG9mZnNldCkgewogICAgcmV0dXJuIG1hdHJpeFswXSA9PT0gYXJyYXlbb2Zmc2V0XSAmJiBtYXRyaXhbMV0gPT09IGFycmF5W29mZnNldCArIDFdICYmIG1hdHJpeFsyXSA9PT0gYXJyYXlbb2Zmc2V0ICsgMl0gJiYgbWF0cml4WzNdID09PSBhcnJheVtvZmZzZXQgKyAzXSAmJiBtYXRyaXhbNF0gPT09IGFycmF5W29mZnNldCArIDRdICYmIG1hdHJpeFs1XSA9PT0gYXJyYXlbb2Zmc2V0ICsgNV0gJiYgbWF0cml4WzZdID09PSBhcnJheVtvZmZzZXQgKyA2XSAmJiBtYXRyaXhbN10gPT09IGFycmF5W29mZnNldCArIDddICYmIG1hdHJpeFs4XSA9PT0gYXJyYXlbb2Zmc2V0ICsgOF07CiAgfTsKICBNYXRyaXgzLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24ocmlnaHQsIGVwc2lsb24pIHsKICAgIHJldHVybiBNYXRyaXgzLmVxdWFsc0Vwc2lsb24odGhpcywgcmlnaHQsIGVwc2lsb24pOwogIH07CiAgTWF0cml4My5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiBgKCR7dGhpc1swXX0sICR7dGhpc1szXX0sICR7dGhpc1s2XX0pCigke3RoaXNbMV19LCAke3RoaXNbNF19LCAke3RoaXNbN119KQooJHt0aGlzWzJdfSwgJHt0aGlzWzVdfSwgJHt0aGlzWzhdfSlgOwogIH07CiAgdmFyIE1hdHJpeDNfZGVmYXVsdCA9IE1hdHJpeDM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9SdW50aW1lRXJyb3IuanMKICBmdW5jdGlvbiBSdW50aW1lRXJyb3IobWVzc2FnZSkgewogICAgdGhpcy5uYW1lID0gIlJ1bnRpbWVFcnJvciI7CiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgbGV0IHN0YWNrOwogICAgdHJ5IHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIHN0YWNrID0gZS5zdGFjazsKICAgIH0KICAgIHRoaXMuc3RhY2sgPSBzdGFjazsKICB9CiAgaWYgKGRlZmluZWRfZGVmYXVsdChPYmplY3QuY3JlYXRlKSkgewogICAgUnVudGltZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTsKICAgIFJ1bnRpbWVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSdW50aW1lRXJyb3I7CiAgfQogIFJ1bnRpbWVFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsKICAgIGxldCBzdHIgPSBgJHt0aGlzLm5hbWV9OiAke3RoaXMubWVzc2FnZX1gOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdCh0aGlzLnN0YWNrKSkgewogICAgICBzdHIgKz0gYAoke3RoaXMuc3RhY2sudG9TdHJpbmcoKX1gOwogICAgfQogICAgcmV0dXJuIHN0cjsKICB9OwogIHZhciBSdW50aW1lRXJyb3JfZGVmYXVsdCA9IFJ1bnRpbWVFcnJvcjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL01hdHJpeDQuanMKICBmdW5jdGlvbiBNYXRyaXg0KGNvbHVtbjBSb3cwLCBjb2x1bW4xUm93MCwgY29sdW1uMlJvdzAsIGNvbHVtbjNSb3cwLCBjb2x1bW4wUm93MSwgY29sdW1uMVJvdzEsIGNvbHVtbjJSb3cxLCBjb2x1bW4zUm93MSwgY29sdW1uMFJvdzIsIGNvbHVtbjFSb3cyLCBjb2x1bW4yUm93MiwgY29sdW1uM1JvdzIsIGNvbHVtbjBSb3czLCBjb2x1bW4xUm93MywgY29sdW1uMlJvdzMsIGNvbHVtbjNSb3czKSB7CiAgICB0aGlzWzBdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMFJvdzAsIDApOwogICAgdGhpc1sxXSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjBSb3cxLCAwKTsKICAgIHRoaXNbMl0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4wUm93MiwgMCk7CiAgICB0aGlzWzNdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMFJvdzMsIDApOwogICAgdGhpc1s0XSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjFSb3cwLCAwKTsKICAgIHRoaXNbNV0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4xUm93MSwgMCk7CiAgICB0aGlzWzZdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMVJvdzIsIDApOwogICAgdGhpc1s3XSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjFSb3czLCAwKTsKICAgIHRoaXNbOF0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4yUm93MCwgMCk7CiAgICB0aGlzWzldID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMlJvdzEsIDApOwogICAgdGhpc1sxMF0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4yUm93MiwgMCk7CiAgICB0aGlzWzExXSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjJSb3czLCAwKTsKICAgIHRoaXNbMTJdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uM1JvdzAsIDApOwogICAgdGhpc1sxM10gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4zUm93MSwgMCk7CiAgICB0aGlzWzE0XSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjNSb3cyLCAwKTsKICAgIHRoaXNbMTVdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uM1JvdzMsIDApOwogIH0KICBNYXRyaXg0LnBhY2tlZExlbmd0aCA9IDE2OwogIE1hdHJpeDQucGFjayA9IGZ1bmN0aW9uKHZhbHVlLCBhcnJheSwgc3RhcnRpbmdJbmRleCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ2YWx1ZSIsIHZhbHVlKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RhcnRpbmdJbmRleCwgMCk7CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbMF07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbMV07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbMl07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbM107CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbNF07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbNV07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbNl07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbN107CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbOF07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbOV07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbMTBdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzExXTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZVsxMl07CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWVbMTNdOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlWzE0XTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXhdID0gdmFsdWVbMTVdOwogICAgcmV0dXJuIGFycmF5OwogIH07CiAgTWF0cml4NC51bnBhY2sgPSBmdW5jdGlvbihhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgTWF0cml4NCgpOwogICAgfQogICAgcmVzdWx0WzBdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFsxXSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbMl0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzNdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFs0XSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbNV0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzZdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFs3XSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbOF0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzldID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFsxMF0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzExXSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbMTJdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFsxM10gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzE0XSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbMTVdID0gYXJyYXlbc3RhcnRpbmdJbmRleF07CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5wYWNrQXJyYXkgPSBmdW5jdGlvbihhcnJheSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogICAgY29uc3QgcmVzdWx0TGVuZ3RoID0gbGVuZ3RoICogMTY7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShyZXN1bHRMZW5ndGgpOwogICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggIT09IHJlc3VsdExlbmd0aCkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAiSWYgcmVzdWx0IGlzIGEgdHlwZWQgYXJyYXksIGl0IG11c3QgaGF2ZSBleGFjdGx5IGFycmF5Lmxlbmd0aCAqIDE2IGVsZW1lbnRzIgogICAgICApOwogICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoICE9PSByZXN1bHRMZW5ndGgpIHsKICAgICAgcmVzdWx0Lmxlbmd0aCA9IHJlc3VsdExlbmd0aDsKICAgIH0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgTWF0cml4NC5wYWNrKGFycmF5W2ldLCByZXN1bHQsIGkgKiAxNik7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC51bnBhY2tBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiYXJyYXkubGVuZ3RoIiwgYXJyYXkubGVuZ3RoLCAxNik7CiAgICBpZiAoYXJyYXkubGVuZ3RoICUgMTYgIT09IDApIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImFycmF5IGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYuIik7CiAgICB9CiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGggLyAxNik7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoIC8gMTY7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxNikgewogICAgICBjb25zdCBpbmRleCA9IGkgLyAxNjsKICAgICAgcmVzdWx0W2luZGV4XSA9IE1hdHJpeDQudW5wYWNrKGFycmF5LCBpLCByZXN1bHRbaW5kZXhdKTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LmNsb25lID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG1hdHJpeCkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBNYXRyaXg0KAogICAgICAgIG1hdHJpeFswXSwKICAgICAgICBtYXRyaXhbNF0sCiAgICAgICAgbWF0cml4WzhdLAogICAgICAgIG1hdHJpeFsxMl0sCiAgICAgICAgbWF0cml4WzFdLAogICAgICAgIG1hdHJpeFs1XSwKICAgICAgICBtYXRyaXhbOV0sCiAgICAgICAgbWF0cml4WzEzXSwKICAgICAgICBtYXRyaXhbMl0sCiAgICAgICAgbWF0cml4WzZdLAogICAgICAgIG1hdHJpeFsxMF0sCiAgICAgICAgbWF0cml4WzE0XSwKICAgICAgICBtYXRyaXhbM10sCiAgICAgICAgbWF0cml4WzddLAogICAgICAgIG1hdHJpeFsxMV0sCiAgICAgICAgbWF0cml4WzE1XQogICAgICApOwogICAgfQogICAgcmVzdWx0WzBdID0gbWF0cml4WzBdOwogICAgcmVzdWx0WzFdID0gbWF0cml4WzFdOwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdOwogICAgcmVzdWx0WzRdID0gbWF0cml4WzRdOwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdOwogICAgcmVzdWx0WzZdID0gbWF0cml4WzZdOwogICAgcmVzdWx0WzddID0gbWF0cml4WzddOwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdOwogICAgcmVzdWx0WzldID0gbWF0cml4WzldOwogICAgcmVzdWx0WzEwXSA9IG1hdHJpeFsxMF07CiAgICByZXN1bHRbMTFdID0gbWF0cml4WzExXTsKICAgIHJlc3VsdFsxMl0gPSBtYXRyaXhbMTJdOwogICAgcmVzdWx0WzEzXSA9IG1hdHJpeFsxM107CiAgICByZXN1bHRbMTRdID0gbWF0cml4WzE0XTsKICAgIHJlc3VsdFsxNV0gPSBtYXRyaXhbMTVdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuZnJvbUFycmF5ID0gTWF0cml4NC51bnBhY2s7CiAgTWF0cml4NC5mcm9tQ29sdW1uTWFqb3JBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcywgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInZhbHVlcyIsIHZhbHVlcyk7CiAgICByZXR1cm4gTWF0cml4NC5jbG9uZSh2YWx1ZXMsIHJlc3VsdCk7CiAgfTsKICBNYXRyaXg0LmZyb21Sb3dNYWpvckFycmF5ID0gZnVuY3Rpb24odmFsdWVzLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgidmFsdWVzIiwgdmFsdWVzKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBNYXRyaXg0KAogICAgICAgIHZhbHVlc1swXSwKICAgICAgICB2YWx1ZXNbMV0sCiAgICAgICAgdmFsdWVzWzJdLAogICAgICAgIHZhbHVlc1szXSwKICAgICAgICB2YWx1ZXNbNF0sCiAgICAgICAgdmFsdWVzWzVdLAogICAgICAgIHZhbHVlc1s2XSwKICAgICAgICB2YWx1ZXNbN10sCiAgICAgICAgdmFsdWVzWzhdLAogICAgICAgIHZhbHVlc1s5XSwKICAgICAgICB2YWx1ZXNbMTBdLAogICAgICAgIHZhbHVlc1sxMV0sCiAgICAgICAgdmFsdWVzWzEyXSwKICAgICAgICB2YWx1ZXNbMTNdLAogICAgICAgIHZhbHVlc1sxNF0sCiAgICAgICAgdmFsdWVzWzE1XQogICAgICApOwogICAgfQogICAgcmVzdWx0WzBdID0gdmFsdWVzWzBdOwogICAgcmVzdWx0WzFdID0gdmFsdWVzWzRdOwogICAgcmVzdWx0WzJdID0gdmFsdWVzWzhdOwogICAgcmVzdWx0WzNdID0gdmFsdWVzWzEyXTsKICAgIHJlc3VsdFs0XSA9IHZhbHVlc1sxXTsKICAgIHJlc3VsdFs1XSA9IHZhbHVlc1s1XTsKICAgIHJlc3VsdFs2XSA9IHZhbHVlc1s5XTsKICAgIHJlc3VsdFs3XSA9IHZhbHVlc1sxM107CiAgICByZXN1bHRbOF0gPSB2YWx1ZXNbMl07CiAgICByZXN1bHRbOV0gPSB2YWx1ZXNbNl07CiAgICByZXN1bHRbMTBdID0gdmFsdWVzWzEwXTsKICAgIHJlc3VsdFsxMV0gPSB2YWx1ZXNbMTRdOwogICAgcmVzdWx0WzEyXSA9IHZhbHVlc1szXTsKICAgIHJlc3VsdFsxM10gPSB2YWx1ZXNbN107CiAgICByZXN1bHRbMTRdID0gdmFsdWVzWzExXTsKICAgIHJlc3VsdFsxNV0gPSB2YWx1ZXNbMTVdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbihyb3RhdGlvbiwgdHJhbnNsYXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyb3RhdGlvbiIsIHJvdGF0aW9uKTsKICAgIHRyYW5zbGF0aW9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQodHJhbnNsYXRpb24sIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBNYXRyaXg0KAogICAgICAgIHJvdGF0aW9uWzBdLAogICAgICAgIHJvdGF0aW9uWzNdLAogICAgICAgIHJvdGF0aW9uWzZdLAogICAgICAgIHRyYW5zbGF0aW9uLngsCiAgICAgICAgcm90YXRpb25bMV0sCiAgICAgICAgcm90YXRpb25bNF0sCiAgICAgICAgcm90YXRpb25bN10sCiAgICAgICAgdHJhbnNsYXRpb24ueSwKICAgICAgICByb3RhdGlvblsyXSwKICAgICAgICByb3RhdGlvbls1XSwKICAgICAgICByb3RhdGlvbls4XSwKICAgICAgICB0cmFuc2xhdGlvbi56LAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEKICAgICAgKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IHJvdGF0aW9uWzBdOwogICAgcmVzdWx0WzFdID0gcm90YXRpb25bMV07CiAgICByZXN1bHRbMl0gPSByb3RhdGlvblsyXTsKICAgIHJlc3VsdFszXSA9IDA7CiAgICByZXN1bHRbNF0gPSByb3RhdGlvblszXTsKICAgIHJlc3VsdFs1XSA9IHJvdGF0aW9uWzRdOwogICAgcmVzdWx0WzZdID0gcm90YXRpb25bNV07CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gcm90YXRpb25bNl07CiAgICByZXN1bHRbOV0gPSByb3RhdGlvbls3XTsKICAgIHJlc3VsdFsxMF0gPSByb3RhdGlvbls4XTsKICAgIHJlc3VsdFsxMV0gPSAwOwogICAgcmVzdWx0WzEyXSA9IHRyYW5zbGF0aW9uLng7CiAgICByZXN1bHRbMTNdID0gdHJhbnNsYXRpb24ueTsKICAgIHJlc3VsdFsxNF0gPSB0cmFuc2xhdGlvbi56OwogICAgcmVzdWx0WzE1XSA9IDE7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5mcm9tVHJhbnNsYXRpb25RdWF0ZXJuaW9uUm90YXRpb25TY2FsZSA9IGZ1bmN0aW9uKHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2xhdGlvbiIsIHRyYW5zbGF0aW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicm90YXRpb24iLCByb3RhdGlvbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInNjYWxlIiwgc2NhbGUpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgTWF0cml4NCgpOwogICAgfQogICAgY29uc3Qgc2NhbGVYID0gc2NhbGUueDsKICAgIGNvbnN0IHNjYWxlWSA9IHNjYWxlLnk7CiAgICBjb25zdCBzY2FsZVogPSBzY2FsZS56OwogICAgY29uc3QgeDIgPSByb3RhdGlvbi54ICogcm90YXRpb24ueDsKICAgIGNvbnN0IHh5ID0gcm90YXRpb24ueCAqIHJvdGF0aW9uLnk7CiAgICBjb25zdCB4eiA9IHJvdGF0aW9uLnggKiByb3RhdGlvbi56OwogICAgY29uc3QgeHcgPSByb3RhdGlvbi54ICogcm90YXRpb24udzsKICAgIGNvbnN0IHkyID0gcm90YXRpb24ueSAqIHJvdGF0aW9uLnk7CiAgICBjb25zdCB5eiA9IHJvdGF0aW9uLnkgKiByb3RhdGlvbi56OwogICAgY29uc3QgeXcgPSByb3RhdGlvbi55ICogcm90YXRpb24udzsKICAgIGNvbnN0IHoyID0gcm90YXRpb24ueiAqIHJvdGF0aW9uLno7CiAgICBjb25zdCB6dyA9IHJvdGF0aW9uLnogKiByb3RhdGlvbi53OwogICAgY29uc3QgdzIgPSByb3RhdGlvbi53ICogcm90YXRpb24udzsKICAgIGNvbnN0IG0wMCA9IHgyIC0geTIgLSB6MiArIHcyOwogICAgY29uc3QgbTAxID0gMiAqICh4eSAtIHp3KTsKICAgIGNvbnN0IG0wMiA9IDIgKiAoeHogKyB5dyk7CiAgICBjb25zdCBtMTAgPSAyICogKHh5ICsgencpOwogICAgY29uc3QgbTExID0gLXgyICsgeTIgLSB6MiArIHcyOwogICAgY29uc3QgbTEyID0gMiAqICh5eiAtIHh3KTsKICAgIGNvbnN0IG0yMCA9IDIgKiAoeHogLSB5dyk7CiAgICBjb25zdCBtMjEgPSAyICogKHl6ICsgeHcpOwogICAgY29uc3QgbTIyID0gLXgyIC0geTIgKyB6MiArIHcyOwogICAgcmVzdWx0WzBdID0gbTAwICogc2NhbGVYOwogICAgcmVzdWx0WzFdID0gbTEwICogc2NhbGVYOwogICAgcmVzdWx0WzJdID0gbTIwICogc2NhbGVYOwogICAgcmVzdWx0WzNdID0gMDsKICAgIHJlc3VsdFs0XSA9IG0wMSAqIHNjYWxlWTsKICAgIHJlc3VsdFs1XSA9IG0xMSAqIHNjYWxlWTsKICAgIHJlc3VsdFs2XSA9IG0yMSAqIHNjYWxlWTsKICAgIHJlc3VsdFs3XSA9IDA7CiAgICByZXN1bHRbOF0gPSBtMDIgKiBzY2FsZVo7CiAgICByZXN1bHRbOV0gPSBtMTIgKiBzY2FsZVo7CiAgICByZXN1bHRbMTBdID0gbTIyICogc2NhbGVaOwogICAgcmVzdWx0WzExXSA9IDA7CiAgICByZXN1bHRbMTJdID0gdHJhbnNsYXRpb24ueDsKICAgIHJlc3VsdFsxM10gPSB0cmFuc2xhdGlvbi55OwogICAgcmVzdWx0WzE0XSA9IHRyYW5zbGF0aW9uLno7CiAgICByZXN1bHRbMTVdID0gMTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LmZyb21UcmFuc2xhdGlvblJvdGF0aW9uU2NhbGUgPSBmdW5jdGlvbih0cmFuc2xhdGlvblJvdGF0aW9uU2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2xhdGlvblJvdGF0aW9uU2NhbGUiLCB0cmFuc2xhdGlvblJvdGF0aW9uU2NhbGUpOwogICAgcmV0dXJuIE1hdHJpeDQuZnJvbVRyYW5zbGF0aW9uUXVhdGVybmlvblJvdGF0aW9uU2NhbGUoCiAgICAgIHRyYW5zbGF0aW9uUm90YXRpb25TY2FsZS50cmFuc2xhdGlvbiwKICAgICAgdHJhbnNsYXRpb25Sb3RhdGlvblNjYWxlLnJvdGF0aW9uLAogICAgICB0cmFuc2xhdGlvblJvdGF0aW9uU2NhbGUuc2NhbGUsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIE1hdHJpeDQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24odHJhbnNsYXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2xhdGlvbiIsIHRyYW5zbGF0aW9uKTsKICAgIHJldHVybiBNYXRyaXg0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKE1hdHJpeDNfZGVmYXVsdC5JREVOVElUWSwgdHJhbnNsYXRpb24sIHJlc3VsdCk7CiAgfTsKICBNYXRyaXg0LmZyb21TY2FsZSA9IGZ1bmN0aW9uKHNjYWxlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic2NhbGUiLCBzY2FsZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4NCgKICAgICAgICBzY2FsZS54LAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgc2NhbGUueSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIHNjYWxlLnosCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICk7CiAgICB9CiAgICByZXN1bHRbMF0gPSBzY2FsZS54OwogICAgcmVzdWx0WzFdID0gMDsKICAgIHJlc3VsdFsyXSA9IDA7CiAgICByZXN1bHRbM10gPSAwOwogICAgcmVzdWx0WzRdID0gMDsKICAgIHJlc3VsdFs1XSA9IHNjYWxlLnk7CiAgICByZXN1bHRbNl0gPSAwOwogICAgcmVzdWx0WzddID0gMDsKICAgIHJlc3VsdFs4XSA9IDA7CiAgICByZXN1bHRbOV0gPSAwOwogICAgcmVzdWx0WzEwXSA9IHNjYWxlLno7CiAgICByZXN1bHRbMTFdID0gMDsKICAgIHJlc3VsdFsxMl0gPSAwOwogICAgcmVzdWx0WzEzXSA9IDA7CiAgICByZXN1bHRbMTRdID0gMDsKICAgIHJlc3VsdFsxNV0gPSAxOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuZnJvbVVuaWZvcm1TY2FsZSA9IGZ1bmN0aW9uKHNjYWxlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigic2NhbGUiLCBzY2FsZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4NCgKICAgICAgICBzY2FsZSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIHNjYWxlLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgc2NhbGUsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICk7CiAgICB9CiAgICByZXN1bHRbMF0gPSBzY2FsZTsKICAgIHJlc3VsdFsxXSA9IDA7CiAgICByZXN1bHRbMl0gPSAwOwogICAgcmVzdWx0WzNdID0gMDsKICAgIHJlc3VsdFs0XSA9IDA7CiAgICByZXN1bHRbNV0gPSBzY2FsZTsKICAgIHJlc3VsdFs2XSA9IDA7CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gMDsKICAgIHJlc3VsdFs5XSA9IDA7CiAgICByZXN1bHRbMTBdID0gc2NhbGU7CiAgICByZXN1bHRbMTFdID0gMDsKICAgIHJlc3VsdFsxMl0gPSAwOwogICAgcmVzdWx0WzEzXSA9IDA7CiAgICByZXN1bHRbMTRdID0gMDsKICAgIHJlc3VsdFsxNV0gPSAxOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ocm90YXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyb3RhdGlvbiIsIHJvdGF0aW9uKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IE1hdHJpeDQoKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IHJvdGF0aW9uWzBdOwogICAgcmVzdWx0WzFdID0gcm90YXRpb25bMV07CiAgICByZXN1bHRbMl0gPSByb3RhdGlvblsyXTsKICAgIHJlc3VsdFszXSA9IDA7CiAgICByZXN1bHRbNF0gPSByb3RhdGlvblszXTsKICAgIHJlc3VsdFs1XSA9IHJvdGF0aW9uWzRdOwogICAgcmVzdWx0WzZdID0gcm90YXRpb25bNV07CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gcm90YXRpb25bNl07CiAgICByZXN1bHRbOV0gPSByb3RhdGlvbls3XTsKICAgIHJlc3VsdFsxMF0gPSByb3RhdGlvbls4XTsKICAgIHJlc3VsdFsxMV0gPSAwOwogICAgcmVzdWx0WzEyXSA9IDA7CiAgICByZXN1bHRbMTNdID0gMDsKICAgIHJlc3VsdFsxNF0gPSAwOwogICAgcmVzdWx0WzE1XSA9IDE7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIGZyb21DYW1lcmFGID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBmcm9tQ2FtZXJhUiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZnJvbUNhbWVyYVUgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgTWF0cml4NC5mcm9tQ2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FtZXJhIiwgY2FtZXJhKTsKICAgIGNvbnN0IHBvc2l0aW9uID0gY2FtZXJhLnBvc2l0aW9uOwogICAgY29uc3QgZGlyZWN0aW9uID0gY2FtZXJhLmRpcmVjdGlvbjsKICAgIGNvbnN0IHVwID0gY2FtZXJhLnVwOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYW1lcmEucG9zaXRpb24iLCBwb3NpdGlvbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhbWVyYS5kaXJlY3Rpb24iLCBkaXJlY3Rpb24pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYW1lcmEudXAiLCB1cCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKGRpcmVjdGlvbiwgZnJvbUNhbWVyYUYpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0Lm5vcm1hbGl6ZSgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNyb3NzKGZyb21DYW1lcmFGLCB1cCwgZnJvbUNhbWVyYVIpLAogICAgICBmcm9tQ2FtZXJhUgogICAgKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyhmcm9tQ2FtZXJhUiwgZnJvbUNhbWVyYUYsIGZyb21DYW1lcmFVKSwKICAgICAgZnJvbUNhbWVyYVUKICAgICk7CiAgICBjb25zdCBzWCA9IGZyb21DYW1lcmFSLng7CiAgICBjb25zdCBzWSA9IGZyb21DYW1lcmFSLnk7CiAgICBjb25zdCBzWiA9IGZyb21DYW1lcmFSLno7CiAgICBjb25zdCBmWCA9IGZyb21DYW1lcmFGLng7CiAgICBjb25zdCBmWSA9IGZyb21DYW1lcmFGLnk7CiAgICBjb25zdCBmWiA9IGZyb21DYW1lcmFGLno7CiAgICBjb25zdCB1WCA9IGZyb21DYW1lcmFVLng7CiAgICBjb25zdCB1WSA9IGZyb21DYW1lcmFVLnk7CiAgICBjb25zdCB1WiA9IGZyb21DYW1lcmFVLno7CiAgICBjb25zdCBwb3NpdGlvblggPSBwb3NpdGlvbi54OwogICAgY29uc3QgcG9zaXRpb25ZID0gcG9zaXRpb24ueTsKICAgIGNvbnN0IHBvc2l0aW9uWiA9IHBvc2l0aW9uLno7CiAgICBjb25zdCB0MCA9IHNYICogLXBvc2l0aW9uWCArIHNZICogLXBvc2l0aW9uWSArIHNaICogLXBvc2l0aW9uWjsKICAgIGNvbnN0IHQxID0gdVggKiAtcG9zaXRpb25YICsgdVkgKiAtcG9zaXRpb25ZICsgdVogKiAtcG9zaXRpb25aOwogICAgY29uc3QgdDIgPSBmWCAqIHBvc2l0aW9uWCArIGZZICogcG9zaXRpb25ZICsgZlogKiBwb3NpdGlvblo7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4NCgKICAgICAgICBzWCwKICAgICAgICBzWSwKICAgICAgICBzWiwKICAgICAgICB0MCwKICAgICAgICB1WCwKICAgICAgICB1WSwKICAgICAgICB1WiwKICAgICAgICB0MSwKICAgICAgICAtZlgsCiAgICAgICAgLWZZLAogICAgICAgIC1mWiwKICAgICAgICB0MiwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICk7CiAgICB9CiAgICByZXN1bHRbMF0gPSBzWDsKICAgIHJlc3VsdFsxXSA9IHVYOwogICAgcmVzdWx0WzJdID0gLWZYOwogICAgcmVzdWx0WzNdID0gMDsKICAgIHJlc3VsdFs0XSA9IHNZOwogICAgcmVzdWx0WzVdID0gdVk7CiAgICByZXN1bHRbNl0gPSAtZlk7CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gc1o7CiAgICByZXN1bHRbOV0gPSB1WjsKICAgIHJlc3VsdFsxMF0gPSAtZlo7CiAgICByZXN1bHRbMTFdID0gMDsKICAgIHJlc3VsdFsxMl0gPSB0MDsKICAgIHJlc3VsdFsxM10gPSB0MTsKICAgIHJlc3VsdFsxNF0gPSB0MjsKICAgIHJlc3VsdFsxNV0gPSAxOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuY29tcHV0ZVBlcnNwZWN0aXZlRmllbGRPZlZpZXcgPSBmdW5jdGlvbihmb3ZZLCBhc3BlY3RSYXRpbywgbmVhciwgZmFyLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbigiZm92WSIsIGZvdlksIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuKCJmb3ZZIiwgZm92WSwgTWF0aC5QSSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW4oIm5lYXIiLCBuZWFyLCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbigiZmFyIiwgZmFyLCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgudGFuKGZvdlkgKiAwLjUpOwogICAgY29uc3QgY29sdW1uMVJvdzEgPSAxIC8gYm90dG9tOwogICAgY29uc3QgY29sdW1uMFJvdzAgPSBjb2x1bW4xUm93MSAvIGFzcGVjdFJhdGlvOwogICAgY29uc3QgY29sdW1uMlJvdzIgPSAoZmFyICsgbmVhcikgLyAobmVhciAtIGZhcik7CiAgICBjb25zdCBjb2x1bW4zUm93MiA9IDIgKiBmYXIgKiBuZWFyIC8gKG5lYXIgLSBmYXIpOwogICAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7CiAgICByZXN1bHRbMV0gPSAwOwogICAgcmVzdWx0WzJdID0gMDsKICAgIHJlc3VsdFszXSA9IDA7CiAgICByZXN1bHRbNF0gPSAwOwogICAgcmVzdWx0WzVdID0gY29sdW1uMVJvdzE7CiAgICByZXN1bHRbNl0gPSAwOwogICAgcmVzdWx0WzddID0gMDsKICAgIHJlc3VsdFs4XSA9IDA7CiAgICByZXN1bHRbOV0gPSAwOwogICAgcmVzdWx0WzEwXSA9IGNvbHVtbjJSb3cyOwogICAgcmVzdWx0WzExXSA9IC0xOwogICAgcmVzdWx0WzEyXSA9IDA7CiAgICByZXN1bHRbMTNdID0gMDsKICAgIHJlc3VsdFsxNF0gPSBjb2x1bW4zUm93MjsKICAgIHJlc3VsdFsxNV0gPSAwOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuY29tcHV0ZU9ydGhvZ3JhcGhpY09mZkNlbnRlciA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigiYm90dG9tIiwgYm90dG9tKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigidG9wIiwgdG9wKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigibmVhciIsIG5lYXIpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJmYXIiLCBmYXIpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgbGV0IGEzID0gMSAvIChyaWdodCAtIGxlZnQpOwogICAgbGV0IGIgPSAxIC8gKHRvcCAtIGJvdHRvbSk7CiAgICBsZXQgYyA9IDEgLyAoZmFyIC0gbmVhcik7CiAgICBjb25zdCB0eCA9IC0ocmlnaHQgKyBsZWZ0KSAqIGEzOwogICAgY29uc3QgdHkgPSAtKHRvcCArIGJvdHRvbSkgKiBiOwogICAgY29uc3QgdHogPSAtKGZhciArIG5lYXIpICogYzsKICAgIGEzICo9IDI7CiAgICBiICo9IDI7CiAgICBjICo9IC0yOwogICAgcmVzdWx0WzBdID0gYTM7CiAgICByZXN1bHRbMV0gPSAwOwogICAgcmVzdWx0WzJdID0gMDsKICAgIHJlc3VsdFszXSA9IDA7CiAgICByZXN1bHRbNF0gPSAwOwogICAgcmVzdWx0WzVdID0gYjsKICAgIHJlc3VsdFs2XSA9IDA7CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gMDsKICAgIHJlc3VsdFs5XSA9IDA7CiAgICByZXN1bHRbMTBdID0gYzsKICAgIHJlc3VsdFsxMV0gPSAwOwogICAgcmVzdWx0WzEyXSA9IHR4OwogICAgcmVzdWx0WzEzXSA9IHR5OwogICAgcmVzdWx0WzE0XSA9IHR6OwogICAgcmVzdWx0WzE1XSA9IDE7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5jb21wdXRlUGVyc3BlY3RpdmVPZmZDZW50ZXIgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImJvdHRvbSIsIGJvdHRvbSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInRvcCIsIHRvcCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoIm5lYXIiLCBuZWFyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigiZmFyIiwgZmFyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGNvbHVtbjBSb3cwID0gMiAqIG5lYXIgLyAocmlnaHQgLSBsZWZ0KTsKICAgIGNvbnN0IGNvbHVtbjFSb3cxID0gMiAqIG5lYXIgLyAodG9wIC0gYm90dG9tKTsKICAgIGNvbnN0IGNvbHVtbjJSb3cwID0gKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTsKICAgIGNvbnN0IGNvbHVtbjJSb3cxID0gKHRvcCArIGJvdHRvbSkgLyAodG9wIC0gYm90dG9tKTsKICAgIGNvbnN0IGNvbHVtbjJSb3cyID0gLShmYXIgKyBuZWFyKSAvIChmYXIgLSBuZWFyKTsKICAgIGNvbnN0IGNvbHVtbjJSb3czID0gLTE7CiAgICBjb25zdCBjb2x1bW4zUm93MiA9IC0yICogZmFyICogbmVhciAvIChmYXIgLSBuZWFyKTsKICAgIHJlc3VsdFswXSA9IGNvbHVtbjBSb3cwOwogICAgcmVzdWx0WzFdID0gMDsKICAgIHJlc3VsdFsyXSA9IDA7CiAgICByZXN1bHRbM10gPSAwOwogICAgcmVzdWx0WzRdID0gMDsKICAgIHJlc3VsdFs1XSA9IGNvbHVtbjFSb3cxOwogICAgcmVzdWx0WzZdID0gMDsKICAgIHJlc3VsdFs3XSA9IDA7CiAgICByZXN1bHRbOF0gPSBjb2x1bW4yUm93MDsKICAgIHJlc3VsdFs5XSA9IGNvbHVtbjJSb3cxOwogICAgcmVzdWx0WzEwXSA9IGNvbHVtbjJSb3cyOwogICAgcmVzdWx0WzExXSA9IGNvbHVtbjJSb3czOwogICAgcmVzdWx0WzEyXSA9IDA7CiAgICByZXN1bHRbMTNdID0gMDsKICAgIHJlc3VsdFsxNF0gPSBjb2x1bW4zUm93MjsKICAgIHJlc3VsdFsxNV0gPSAwOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuY29tcHV0ZUluZmluaXRlUGVyc3BlY3RpdmVPZmZDZW50ZXIgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJib3R0b20iLCBib3R0b20pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJ0b3AiLCB0b3ApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJuZWFyIiwgbmVhcik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBjb2x1bW4wUm93MCA9IDIgKiBuZWFyIC8gKHJpZ2h0IC0gbGVmdCk7CiAgICBjb25zdCBjb2x1bW4xUm93MSA9IDIgKiBuZWFyIC8gKHRvcCAtIGJvdHRvbSk7CiAgICBjb25zdCBjb2x1bW4yUm93MCA9IChyaWdodCArIGxlZnQpIC8gKHJpZ2h0IC0gbGVmdCk7CiAgICBjb25zdCBjb2x1bW4yUm93MSA9ICh0b3AgKyBib3R0b20pIC8gKHRvcCAtIGJvdHRvbSk7CiAgICBjb25zdCBjb2x1bW4yUm93MiA9IC0xOwogICAgY29uc3QgY29sdW1uMlJvdzMgPSAtMTsKICAgIGNvbnN0IGNvbHVtbjNSb3cyID0gLTIgKiBuZWFyOwogICAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7CiAgICByZXN1bHRbMV0gPSAwOwogICAgcmVzdWx0WzJdID0gMDsKICAgIHJlc3VsdFszXSA9IDA7CiAgICByZXN1bHRbNF0gPSAwOwogICAgcmVzdWx0WzVdID0gY29sdW1uMVJvdzE7CiAgICByZXN1bHRbNl0gPSAwOwogICAgcmVzdWx0WzddID0gMDsKICAgIHJlc3VsdFs4XSA9IGNvbHVtbjJSb3cwOwogICAgcmVzdWx0WzldID0gY29sdW1uMlJvdzE7CiAgICByZXN1bHRbMTBdID0gY29sdW1uMlJvdzI7CiAgICByZXN1bHRbMTFdID0gY29sdW1uMlJvdzM7CiAgICByZXN1bHRbMTJdID0gMDsKICAgIHJlc3VsdFsxM10gPSAwOwogICAgcmVzdWx0WzE0XSA9IGNvbHVtbjNSb3cyOwogICAgcmVzdWx0WzE1XSA9IDA7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5jb21wdXRlVmlld3BvcnRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKHZpZXdwb3J0LCBuZWFyRGVwdGhSYW5nZSwgZmFyRGVwdGhSYW5nZSwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBNYXRyaXg0KCk7CiAgICB9CiAgICB2aWV3cG9ydCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHZpZXdwb3J0LCBkZWZhdWx0VmFsdWVfZGVmYXVsdC5FTVBUWV9PQkpFQ1QpOwogICAgY29uc3QgeCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHZpZXdwb3J0LngsIDApOwogICAgY29uc3QgeSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHZpZXdwb3J0LnksIDApOwogICAgY29uc3Qgd2lkdGggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh2aWV3cG9ydC53aWR0aCwgMCk7CiAgICBjb25zdCBoZWlnaHQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh2aWV3cG9ydC5oZWlnaHQsIDApOwogICAgbmVhckRlcHRoUmFuZ2UgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChuZWFyRGVwdGhSYW5nZSwgMCk7CiAgICBmYXJEZXB0aFJhbmdlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZmFyRGVwdGhSYW5nZSwgMSk7CiAgICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAqIDAuNTsKICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgKiAwLjU7CiAgICBjb25zdCBoYWxmRGVwdGggPSAoZmFyRGVwdGhSYW5nZSAtIG5lYXJEZXB0aFJhbmdlKSAqIDAuNTsKICAgIGNvbnN0IGNvbHVtbjBSb3cwID0gaGFsZldpZHRoOwogICAgY29uc3QgY29sdW1uMVJvdzEgPSBoYWxmSGVpZ2h0OwogICAgY29uc3QgY29sdW1uMlJvdzIgPSBoYWxmRGVwdGg7CiAgICBjb25zdCBjb2x1bW4zUm93MCA9IHggKyBoYWxmV2lkdGg7CiAgICBjb25zdCBjb2x1bW4zUm93MSA9IHkgKyBoYWxmSGVpZ2h0OwogICAgY29uc3QgY29sdW1uM1JvdzIgPSBuZWFyRGVwdGhSYW5nZSArIGhhbGZEZXB0aDsKICAgIGNvbnN0IGNvbHVtbjNSb3czID0gMTsKICAgIHJlc3VsdFswXSA9IGNvbHVtbjBSb3cwOwogICAgcmVzdWx0WzFdID0gMDsKICAgIHJlc3VsdFsyXSA9IDA7CiAgICByZXN1bHRbM10gPSAwOwogICAgcmVzdWx0WzRdID0gMDsKICAgIHJlc3VsdFs1XSA9IGNvbHVtbjFSb3cxOwogICAgcmVzdWx0WzZdID0gMDsKICAgIHJlc3VsdFs3XSA9IDA7CiAgICByZXN1bHRbOF0gPSAwOwogICAgcmVzdWx0WzldID0gMDsKICAgIHJlc3VsdFsxMF0gPSBjb2x1bW4yUm93MjsKICAgIHJlc3VsdFsxMV0gPSAwOwogICAgcmVzdWx0WzEyXSA9IGNvbHVtbjNSb3cwOwogICAgcmVzdWx0WzEzXSA9IGNvbHVtbjNSb3cxOwogICAgcmVzdWx0WzE0XSA9IGNvbHVtbjNSb3cyOwogICAgcmVzdWx0WzE1XSA9IGNvbHVtbjNSb3czOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuY29tcHV0ZVZpZXcgPSBmdW5jdGlvbihwb3NpdGlvbiwgZGlyZWN0aW9uLCB1cCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJwb3NpdGlvbiIsIHBvc2l0aW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZGlyZWN0aW9uIiwgZGlyZWN0aW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgidXAiLCB1cCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gcmlnaHQueDsKICAgIHJlc3VsdFsxXSA9IHVwLng7CiAgICByZXN1bHRbMl0gPSAtZGlyZWN0aW9uLng7CiAgICByZXN1bHRbM10gPSAwOwogICAgcmVzdWx0WzRdID0gcmlnaHQueTsKICAgIHJlc3VsdFs1XSA9IHVwLnk7CiAgICByZXN1bHRbNl0gPSAtZGlyZWN0aW9uLnk7CiAgICByZXN1bHRbN10gPSAwOwogICAgcmVzdWx0WzhdID0gcmlnaHQuejsKICAgIHJlc3VsdFs5XSA9IHVwLno7CiAgICByZXN1bHRbMTBdID0gLWRpcmVjdGlvbi56OwogICAgcmVzdWx0WzExXSA9IDA7CiAgICByZXN1bHRbMTJdID0gLUNhcnRlc2lhbjNfZGVmYXVsdC5kb3QocmlnaHQsIHBvc2l0aW9uKTsKICAgIHJlc3VsdFsxM10gPSAtQ2FydGVzaWFuM19kZWZhdWx0LmRvdCh1cCwgcG9zaXRpb24pOwogICAgcmVzdWx0WzE0XSA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZGlyZWN0aW9uLCBwb3NpdGlvbik7CiAgICByZXN1bHRbMTVdID0gMTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LnRvQXJyYXkgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gWwogICAgICAgIG1hdHJpeFswXSwKICAgICAgICBtYXRyaXhbMV0sCiAgICAgICAgbWF0cml4WzJdLAogICAgICAgIG1hdHJpeFszXSwKICAgICAgICBtYXRyaXhbNF0sCiAgICAgICAgbWF0cml4WzVdLAogICAgICAgIG1hdHJpeFs2XSwKICAgICAgICBtYXRyaXhbN10sCiAgICAgICAgbWF0cml4WzhdLAogICAgICAgIG1hdHJpeFs5XSwKICAgICAgICBtYXRyaXhbMTBdLAogICAgICAgIG1hdHJpeFsxMV0sCiAgICAgICAgbWF0cml4WzEyXSwKICAgICAgICBtYXRyaXhbMTNdLAogICAgICAgIG1hdHJpeFsxNF0sCiAgICAgICAgbWF0cml4WzE1XQogICAgICBdOwogICAgfQogICAgcmVzdWx0WzBdID0gbWF0cml4WzBdOwogICAgcmVzdWx0WzFdID0gbWF0cml4WzFdOwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdOwogICAgcmVzdWx0WzRdID0gbWF0cml4WzRdOwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdOwogICAgcmVzdWx0WzZdID0gbWF0cml4WzZdOwogICAgcmVzdWx0WzddID0gbWF0cml4WzddOwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdOwogICAgcmVzdWx0WzldID0gbWF0cml4WzldOwogICAgcmVzdWx0WzEwXSA9IG1hdHJpeFsxMF07CiAgICByZXN1bHRbMTFdID0gbWF0cml4WzExXTsKICAgIHJlc3VsdFsxMl0gPSBtYXRyaXhbMTJdOwogICAgcmVzdWx0WzEzXSA9IG1hdHJpeFsxM107CiAgICByZXN1bHRbMTRdID0gbWF0cml4WzE0XTsKICAgIHJlc3VsdFsxNV0gPSBtYXRyaXhbMTVdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuZ2V0RWxlbWVudEluZGV4ID0gZnVuY3Rpb24oY29sdW1uLCByb3cpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJyb3ciLCByb3csIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoInJvdyIsIHJvdywgMyk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiY29sdW1uIiwgY29sdW1uLCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJjb2x1bW4iLCBjb2x1bW4sIDMpOwogICAgcmV0dXJuIGNvbHVtbiAqIDQgKyByb3c7CiAgfTsKICBNYXRyaXg0LmdldENvbHVtbiA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoImluZGV4IiwgaW5kZXgsIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoImluZGV4IiwgaW5kZXgsIDMpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4ICogNDsKICAgIGNvbnN0IHggPSBtYXRyaXhbc3RhcnRJbmRleF07CiAgICBjb25zdCB5ID0gbWF0cml4W3N0YXJ0SW5kZXggKyAxXTsKICAgIGNvbnN0IHogPSBtYXRyaXhbc3RhcnRJbmRleCArIDJdOwogICAgY29uc3QgdyA9IG1hdHJpeFtzdGFydEluZGV4ICsgM107CiAgICByZXN1bHQueCA9IHg7CiAgICByZXN1bHQueSA9IHk7CiAgICByZXN1bHQueiA9IHo7CiAgICByZXN1bHQudyA9IHc7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5zZXRDb2x1bW4gPSBmdW5jdGlvbihtYXRyaXgsIGluZGV4LCBjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoImluZGV4IiwgaW5kZXgsIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoImluZGV4IiwgaW5kZXgsIDMpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0ID0gTWF0cml4NC5jbG9uZShtYXRyaXgsIHJlc3VsdCk7CiAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXggKiA0OwogICAgcmVzdWx0W3N0YXJ0SW5kZXhdID0gY2FydGVzaWFuLng7CiAgICByZXN1bHRbc3RhcnRJbmRleCArIDFdID0gY2FydGVzaWFuLnk7CiAgICByZXN1bHRbc3RhcnRJbmRleCArIDJdID0gY2FydGVzaWFuLno7CiAgICByZXN1bHRbc3RhcnRJbmRleCArIDNdID0gY2FydGVzaWFuLnc7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5nZXRSb3cgPSBmdW5jdGlvbihtYXRyaXgsIGluZGV4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJpbmRleCIsIGluZGV4LCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJpbmRleCIsIGluZGV4LCAzKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IHggPSBtYXRyaXhbaW5kZXhdOwogICAgY29uc3QgeSA9IG1hdHJpeFtpbmRleCArIDRdOwogICAgY29uc3QgeiA9IG1hdHJpeFtpbmRleCArIDhdOwogICAgY29uc3QgdyA9IG1hdHJpeFtpbmRleCArIDEyXTsKICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJlc3VsdC56ID0gejsKICAgIHJlc3VsdC53ID0gdzsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LnNldFJvdyA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgsIGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMyk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQgPSBNYXRyaXg0LmNsb25lKG1hdHJpeCwgcmVzdWx0KTsKICAgIHJlc3VsdFtpbmRleF0gPSBjYXJ0ZXNpYW4ueDsKICAgIHJlc3VsdFtpbmRleCArIDRdID0gY2FydGVzaWFuLnk7CiAgICByZXN1bHRbaW5kZXggKyA4XSA9IGNhcnRlc2lhbi56OwogICAgcmVzdWx0W2luZGV4ICsgMTJdID0gY2FydGVzaWFuLnc7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5zZXRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG1hdHJpeCwgdHJhbnNsYXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2xhdGlvbiIsIHRyYW5zbGF0aW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXTsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFsxXTsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXTsKICAgIHJlc3VsdFs0XSA9IG1hdHJpeFs0XTsKICAgIHJlc3VsdFs1XSA9IG1hdHJpeFs1XTsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs2XTsKICAgIHJlc3VsdFs3XSA9IG1hdHJpeFs3XTsKICAgIHJlc3VsdFs4XSA9IG1hdHJpeFs4XTsKICAgIHJlc3VsdFs5XSA9IG1hdHJpeFs5XTsKICAgIHJlc3VsdFsxMF0gPSBtYXRyaXhbMTBdOwogICAgcmVzdWx0WzExXSA9IG1hdHJpeFsxMV07CiAgICByZXN1bHRbMTJdID0gdHJhbnNsYXRpb24ueDsKICAgIHJlc3VsdFsxM10gPSB0cmFuc2xhdGlvbi55OwogICAgcmVzdWx0WzE0XSA9IHRyYW5zbGF0aW9uLno7CiAgICByZXN1bHRbMTVdID0gbWF0cml4WzE1XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NhbGVTY3JhdGNoMTIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgTWF0cml4NC5zZXRTY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzY2FsZSIsIHNjYWxlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGV4aXN0aW5nU2NhbGUgPSBNYXRyaXg0LmdldFNjYWxlKG1hdHJpeCwgc2NhbGVTY3JhdGNoMTIpOwogICAgY29uc3Qgc2NhbGVSYXRpb1ggPSBzY2FsZS54IC8gZXhpc3RpbmdTY2FsZS54OwogICAgY29uc3Qgc2NhbGVSYXRpb1kgPSBzY2FsZS55IC8gZXhpc3RpbmdTY2FsZS55OwogICAgY29uc3Qgc2NhbGVSYXRpb1ogPSBzY2FsZS56IC8gZXhpc3RpbmdTY2FsZS56OwogICAgcmVzdWx0WzBdID0gbWF0cml4WzBdICogc2NhbGVSYXRpb1g7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZVJhdGlvWDsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXSAqIHNjYWxlUmF0aW9YOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdOwogICAgcmVzdWx0WzRdID0gbWF0cml4WzRdICogc2NhbGVSYXRpb1k7CiAgICByZXN1bHRbNV0gPSBtYXRyaXhbNV0gKiBzY2FsZVJhdGlvWTsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs2XSAqIHNjYWxlUmF0aW9ZOwogICAgcmVzdWx0WzddID0gbWF0cml4WzddOwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdICogc2NhbGVSYXRpb1o7CiAgICByZXN1bHRbOV0gPSBtYXRyaXhbOV0gKiBzY2FsZVJhdGlvWjsKICAgIHJlc3VsdFsxMF0gPSBtYXRyaXhbMTBdICogc2NhbGVSYXRpb1o7CiAgICByZXN1bHRbMTFdID0gbWF0cml4WzExXTsKICAgIHJlc3VsdFsxMl0gPSBtYXRyaXhbMTJdOwogICAgcmVzdWx0WzEzXSA9IG1hdHJpeFsxM107CiAgICByZXN1bHRbMTRdID0gbWF0cml4WzE0XTsKICAgIHJlc3VsdFsxNV0gPSBtYXRyaXhbMTVdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY2FsZVNjcmF0Y2gyMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBNYXRyaXg0LnNldFVuaWZvcm1TY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJzY2FsZSIsIHNjYWxlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGV4aXN0aW5nU2NhbGUgPSBNYXRyaXg0LmdldFNjYWxlKG1hdHJpeCwgc2NhbGVTY3JhdGNoMjIpOwogICAgY29uc3Qgc2NhbGVSYXRpb1ggPSBzY2FsZSAvIGV4aXN0aW5nU2NhbGUueDsKICAgIGNvbnN0IHNjYWxlUmF0aW9ZID0gc2NhbGUgLyBleGlzdGluZ1NjYWxlLnk7CiAgICBjb25zdCBzY2FsZVJhdGlvWiA9IHNjYWxlIC8gZXhpc3RpbmdTY2FsZS56OwogICAgcmVzdWx0WzBdID0gbWF0cml4WzBdICogc2NhbGVSYXRpb1g7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZVJhdGlvWDsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXSAqIHNjYWxlUmF0aW9YOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdOwogICAgcmVzdWx0WzRdID0gbWF0cml4WzRdICogc2NhbGVSYXRpb1k7CiAgICByZXN1bHRbNV0gPSBtYXRyaXhbNV0gKiBzY2FsZVJhdGlvWTsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs2XSAqIHNjYWxlUmF0aW9ZOwogICAgcmVzdWx0WzddID0gbWF0cml4WzddOwogICAgcmVzdWx0WzhdID0gbWF0cml4WzhdICogc2NhbGVSYXRpb1o7CiAgICByZXN1bHRbOV0gPSBtYXRyaXhbOV0gKiBzY2FsZVJhdGlvWjsKICAgIHJlc3VsdFsxMF0gPSBtYXRyaXhbMTBdICogc2NhbGVSYXRpb1o7CiAgICByZXN1bHRbMTFdID0gbWF0cml4WzExXTsKICAgIHJlc3VsdFsxMl0gPSBtYXRyaXhbMTJdOwogICAgcmVzdWx0WzEzXSA9IG1hdHJpeFsxM107CiAgICByZXN1bHRbMTRdID0gbWF0cml4WzE0XTsKICAgIHJlc3VsdFsxNV0gPSBtYXRyaXhbMTVdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY3JhdGNoQ29sdW1uMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBNYXRyaXg0LmdldFNjYWxlID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZSgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmZyb21FbGVtZW50cyhtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBzY3JhdGNoQ29sdW1uMikKICAgICk7CiAgICByZXN1bHQueSA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5mcm9tRWxlbWVudHMobWF0cml4WzRdLCBtYXRyaXhbNV0sIG1hdHJpeFs2XSwgc2NyYXRjaENvbHVtbjIpCiAgICApOwogICAgcmVzdWx0LnogPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbUVsZW1lbnRzKG1hdHJpeFs4XSwgbWF0cml4WzldLCBtYXRyaXhbMTBdLCBzY3JhdGNoQ29sdW1uMikKICAgICk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjYWxlU2NyYXRjaDMyID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIE1hdHJpeDQuZ2V0TWF4aW11bVNjYWxlID0gZnVuY3Rpb24obWF0cml4KSB7CiAgICBNYXRyaXg0LmdldFNjYWxlKG1hdHJpeCwgc2NhbGVTY3JhdGNoMzIpOwogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5tYXhpbXVtQ29tcG9uZW50KHNjYWxlU2NyYXRjaDMyKTsKICB9OwogIHZhciBzY2FsZVNjcmF0Y2g0MiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBNYXRyaXg0LnNldFJvdGF0aW9uID0gZnVuY3Rpb24obWF0cml4LCByb3RhdGlvbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBzY2FsZSA9IE1hdHJpeDQuZ2V0U2NhbGUobWF0cml4LCBzY2FsZVNjcmF0Y2g0Mik7CiAgICByZXN1bHRbMF0gPSByb3RhdGlvblswXSAqIHNjYWxlLng7CiAgICByZXN1bHRbMV0gPSByb3RhdGlvblsxXSAqIHNjYWxlLng7CiAgICByZXN1bHRbMl0gPSByb3RhdGlvblsyXSAqIHNjYWxlLng7CiAgICByZXN1bHRbM10gPSBtYXRyaXhbM107CiAgICByZXN1bHRbNF0gPSByb3RhdGlvblszXSAqIHNjYWxlLnk7CiAgICByZXN1bHRbNV0gPSByb3RhdGlvbls0XSAqIHNjYWxlLnk7CiAgICByZXN1bHRbNl0gPSByb3RhdGlvbls1XSAqIHNjYWxlLnk7CiAgICByZXN1bHRbN10gPSBtYXRyaXhbN107CiAgICByZXN1bHRbOF0gPSByb3RhdGlvbls2XSAqIHNjYWxlLno7CiAgICByZXN1bHRbOV0gPSByb3RhdGlvbls3XSAqIHNjYWxlLno7CiAgICByZXN1bHRbMTBdID0gcm90YXRpb25bOF0gKiBzY2FsZS56OwogICAgcmVzdWx0WzExXSA9IG1hdHJpeFsxMV07CiAgICByZXN1bHRbMTJdID0gbWF0cml4WzEyXTsKICAgIHJlc3VsdFsxM10gPSBtYXRyaXhbMTNdOwogICAgcmVzdWx0WzE0XSA9IG1hdHJpeFsxNF07CiAgICByZXN1bHRbMTVdID0gbWF0cml4WzE1XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NhbGVTY3JhdGNoNTIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgTWF0cml4NC5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBzY2FsZSA9IE1hdHJpeDQuZ2V0U2NhbGUobWF0cml4LCBzY2FsZVNjcmF0Y2g1Mik7CiAgICByZXN1bHRbMF0gPSBtYXRyaXhbMF0gLyBzY2FsZS54OwogICAgcmVzdWx0WzFdID0gbWF0cml4WzFdIC8gc2NhbGUueDsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXSAvIHNjYWxlLng7CiAgICByZXN1bHRbM10gPSBtYXRyaXhbNF0gLyBzY2FsZS55OwogICAgcmVzdWx0WzRdID0gbWF0cml4WzVdIC8gc2NhbGUueTsKICAgIHJlc3VsdFs1XSA9IG1hdHJpeFs2XSAvIHNjYWxlLnk7CiAgICByZXN1bHRbNl0gPSBtYXRyaXhbOF0gLyBzY2FsZS56OwogICAgcmVzdWx0WzddID0gbWF0cml4WzldIC8gc2NhbGUuejsKICAgIHJlc3VsdFs4XSA9IG1hdHJpeFsxMF0gLyBzY2FsZS56OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQubXVsdGlwbHkgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBsZWZ0MCA9IGxlZnRbMF07CiAgICBjb25zdCBsZWZ0MSA9IGxlZnRbMV07CiAgICBjb25zdCBsZWZ0MiA9IGxlZnRbMl07CiAgICBjb25zdCBsZWZ0MyA9IGxlZnRbM107CiAgICBjb25zdCBsZWZ0NCA9IGxlZnRbNF07CiAgICBjb25zdCBsZWZ0NSA9IGxlZnRbNV07CiAgICBjb25zdCBsZWZ0NiA9IGxlZnRbNl07CiAgICBjb25zdCBsZWZ0NyA9IGxlZnRbN107CiAgICBjb25zdCBsZWZ0OCA9IGxlZnRbOF07CiAgICBjb25zdCBsZWZ0OSA9IGxlZnRbOV07CiAgICBjb25zdCBsZWZ0MTAgPSBsZWZ0WzEwXTsKICAgIGNvbnN0IGxlZnQxMSA9IGxlZnRbMTFdOwogICAgY29uc3QgbGVmdDEyID0gbGVmdFsxMl07CiAgICBjb25zdCBsZWZ0MTMgPSBsZWZ0WzEzXTsKICAgIGNvbnN0IGxlZnQxNCA9IGxlZnRbMTRdOwogICAgY29uc3QgbGVmdDE1ID0gbGVmdFsxNV07CiAgICBjb25zdCByaWdodDAgPSByaWdodFswXTsKICAgIGNvbnN0IHJpZ2h0MSA9IHJpZ2h0WzFdOwogICAgY29uc3QgcmlnaHQyID0gcmlnaHRbMl07CiAgICBjb25zdCByaWdodDMgPSByaWdodFszXTsKICAgIGNvbnN0IHJpZ2h0NCA9IHJpZ2h0WzRdOwogICAgY29uc3QgcmlnaHQ1ID0gcmlnaHRbNV07CiAgICBjb25zdCByaWdodDYgPSByaWdodFs2XTsKICAgIGNvbnN0IHJpZ2h0NyA9IHJpZ2h0WzddOwogICAgY29uc3QgcmlnaHQ4ID0gcmlnaHRbOF07CiAgICBjb25zdCByaWdodDkgPSByaWdodFs5XTsKICAgIGNvbnN0IHJpZ2h0MTAgPSByaWdodFsxMF07CiAgICBjb25zdCByaWdodDExID0gcmlnaHRbMTFdOwogICAgY29uc3QgcmlnaHQxMiA9IHJpZ2h0WzEyXTsKICAgIGNvbnN0IHJpZ2h0MTMgPSByaWdodFsxM107CiAgICBjb25zdCByaWdodDE0ID0gcmlnaHRbMTRdOwogICAgY29uc3QgcmlnaHQxNSA9IHJpZ2h0WzE1XTsKICAgIGNvbnN0IGNvbHVtbjBSb3cwID0gbGVmdDAgKiByaWdodDAgKyBsZWZ0NCAqIHJpZ2h0MSArIGxlZnQ4ICogcmlnaHQyICsgbGVmdDEyICogcmlnaHQzOwogICAgY29uc3QgY29sdW1uMFJvdzEgPSBsZWZ0MSAqIHJpZ2h0MCArIGxlZnQ1ICogcmlnaHQxICsgbGVmdDkgKiByaWdodDIgKyBsZWZ0MTMgKiByaWdodDM7CiAgICBjb25zdCBjb2x1bW4wUm93MiA9IGxlZnQyICogcmlnaHQwICsgbGVmdDYgKiByaWdodDEgKyBsZWZ0MTAgKiByaWdodDIgKyBsZWZ0MTQgKiByaWdodDM7CiAgICBjb25zdCBjb2x1bW4wUm93MyA9IGxlZnQzICogcmlnaHQwICsgbGVmdDcgKiByaWdodDEgKyBsZWZ0MTEgKiByaWdodDIgKyBsZWZ0MTUgKiByaWdodDM7CiAgICBjb25zdCBjb2x1bW4xUm93MCA9IGxlZnQwICogcmlnaHQ0ICsgbGVmdDQgKiByaWdodDUgKyBsZWZ0OCAqIHJpZ2h0NiArIGxlZnQxMiAqIHJpZ2h0NzsKICAgIGNvbnN0IGNvbHVtbjFSb3cxID0gbGVmdDEgKiByaWdodDQgKyBsZWZ0NSAqIHJpZ2h0NSArIGxlZnQ5ICogcmlnaHQ2ICsgbGVmdDEzICogcmlnaHQ3OwogICAgY29uc3QgY29sdW1uMVJvdzIgPSBsZWZ0MiAqIHJpZ2h0NCArIGxlZnQ2ICogcmlnaHQ1ICsgbGVmdDEwICogcmlnaHQ2ICsgbGVmdDE0ICogcmlnaHQ3OwogICAgY29uc3QgY29sdW1uMVJvdzMgPSBsZWZ0MyAqIHJpZ2h0NCArIGxlZnQ3ICogcmlnaHQ1ICsgbGVmdDExICogcmlnaHQ2ICsgbGVmdDE1ICogcmlnaHQ3OwogICAgY29uc3QgY29sdW1uMlJvdzAgPSBsZWZ0MCAqIHJpZ2h0OCArIGxlZnQ0ICogcmlnaHQ5ICsgbGVmdDggKiByaWdodDEwICsgbGVmdDEyICogcmlnaHQxMTsKICAgIGNvbnN0IGNvbHVtbjJSb3cxID0gbGVmdDEgKiByaWdodDggKyBsZWZ0NSAqIHJpZ2h0OSArIGxlZnQ5ICogcmlnaHQxMCArIGxlZnQxMyAqIHJpZ2h0MTE7CiAgICBjb25zdCBjb2x1bW4yUm93MiA9IGxlZnQyICogcmlnaHQ4ICsgbGVmdDYgKiByaWdodDkgKyBsZWZ0MTAgKiByaWdodDEwICsgbGVmdDE0ICogcmlnaHQxMTsKICAgIGNvbnN0IGNvbHVtbjJSb3czID0gbGVmdDMgKiByaWdodDggKyBsZWZ0NyAqIHJpZ2h0OSArIGxlZnQxMSAqIHJpZ2h0MTAgKyBsZWZ0MTUgKiByaWdodDExOwogICAgY29uc3QgY29sdW1uM1JvdzAgPSBsZWZ0MCAqIHJpZ2h0MTIgKyBsZWZ0NCAqIHJpZ2h0MTMgKyBsZWZ0OCAqIHJpZ2h0MTQgKyBsZWZ0MTIgKiByaWdodDE1OwogICAgY29uc3QgY29sdW1uM1JvdzEgPSBsZWZ0MSAqIHJpZ2h0MTIgKyBsZWZ0NSAqIHJpZ2h0MTMgKyBsZWZ0OSAqIHJpZ2h0MTQgKyBsZWZ0MTMgKiByaWdodDE1OwogICAgY29uc3QgY29sdW1uM1JvdzIgPSBsZWZ0MiAqIHJpZ2h0MTIgKyBsZWZ0NiAqIHJpZ2h0MTMgKyBsZWZ0MTAgKiByaWdodDE0ICsgbGVmdDE0ICogcmlnaHQxNTsKICAgIGNvbnN0IGNvbHVtbjNSb3czID0gbGVmdDMgKiByaWdodDEyICsgbGVmdDcgKiByaWdodDEzICsgbGVmdDExICogcmlnaHQxNCArIGxlZnQxNSAqIHJpZ2h0MTU7CiAgICByZXN1bHRbMF0gPSBjb2x1bW4wUm93MDsKICAgIHJlc3VsdFsxXSA9IGNvbHVtbjBSb3cxOwogICAgcmVzdWx0WzJdID0gY29sdW1uMFJvdzI7CiAgICByZXN1bHRbM10gPSBjb2x1bW4wUm93MzsKICAgIHJlc3VsdFs0XSA9IGNvbHVtbjFSb3cwOwogICAgcmVzdWx0WzVdID0gY29sdW1uMVJvdzE7CiAgICByZXN1bHRbNl0gPSBjb2x1bW4xUm93MjsKICAgIHJlc3VsdFs3XSA9IGNvbHVtbjFSb3czOwogICAgcmVzdWx0WzhdID0gY29sdW1uMlJvdzA7CiAgICByZXN1bHRbOV0gPSBjb2x1bW4yUm93MTsKICAgIHJlc3VsdFsxMF0gPSBjb2x1bW4yUm93MjsKICAgIHJlc3VsdFsxMV0gPSBjb2x1bW4yUm93MzsKICAgIHJlc3VsdFsxMl0gPSBjb2x1bW4zUm93MDsKICAgIHJlc3VsdFsxM10gPSBjb2x1bW4zUm93MTsKICAgIHJlc3VsdFsxNF0gPSBjb2x1bW4zUm93MjsKICAgIHJlc3VsdFsxNV0gPSBjb2x1bW4zUm93MzsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LmFkZCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IGxlZnRbMF0gKyByaWdodFswXTsKICAgIHJlc3VsdFsxXSA9IGxlZnRbMV0gKyByaWdodFsxXTsKICAgIHJlc3VsdFsyXSA9IGxlZnRbMl0gKyByaWdodFsyXTsKICAgIHJlc3VsdFszXSA9IGxlZnRbM10gKyByaWdodFszXTsKICAgIHJlc3VsdFs0XSA9IGxlZnRbNF0gKyByaWdodFs0XTsKICAgIHJlc3VsdFs1XSA9IGxlZnRbNV0gKyByaWdodFs1XTsKICAgIHJlc3VsdFs2XSA9IGxlZnRbNl0gKyByaWdodFs2XTsKICAgIHJlc3VsdFs3XSA9IGxlZnRbN10gKyByaWdodFs3XTsKICAgIHJlc3VsdFs4XSA9IGxlZnRbOF0gKyByaWdodFs4XTsKICAgIHJlc3VsdFs5XSA9IGxlZnRbOV0gKyByaWdodFs5XTsKICAgIHJlc3VsdFsxMF0gPSBsZWZ0WzEwXSArIHJpZ2h0WzEwXTsKICAgIHJlc3VsdFsxMV0gPSBsZWZ0WzExXSArIHJpZ2h0WzExXTsKICAgIHJlc3VsdFsxMl0gPSBsZWZ0WzEyXSArIHJpZ2h0WzEyXTsKICAgIHJlc3VsdFsxM10gPSBsZWZ0WzEzXSArIHJpZ2h0WzEzXTsKICAgIHJlc3VsdFsxNF0gPSBsZWZ0WzE0XSArIHJpZ2h0WzE0XTsKICAgIHJlc3VsdFsxNV0gPSBsZWZ0WzE1XSArIHJpZ2h0WzE1XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LnN1YnRyYWN0ID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gbGVmdFswXSAtIHJpZ2h0WzBdOwogICAgcmVzdWx0WzFdID0gbGVmdFsxXSAtIHJpZ2h0WzFdOwogICAgcmVzdWx0WzJdID0gbGVmdFsyXSAtIHJpZ2h0WzJdOwogICAgcmVzdWx0WzNdID0gbGVmdFszXSAtIHJpZ2h0WzNdOwogICAgcmVzdWx0WzRdID0gbGVmdFs0XSAtIHJpZ2h0WzRdOwogICAgcmVzdWx0WzVdID0gbGVmdFs1XSAtIHJpZ2h0WzVdOwogICAgcmVzdWx0WzZdID0gbGVmdFs2XSAtIHJpZ2h0WzZdOwogICAgcmVzdWx0WzddID0gbGVmdFs3XSAtIHJpZ2h0WzddOwogICAgcmVzdWx0WzhdID0gbGVmdFs4XSAtIHJpZ2h0WzhdOwogICAgcmVzdWx0WzldID0gbGVmdFs5XSAtIHJpZ2h0WzldOwogICAgcmVzdWx0WzEwXSA9IGxlZnRbMTBdIC0gcmlnaHRbMTBdOwogICAgcmVzdWx0WzExXSA9IGxlZnRbMTFdIC0gcmlnaHRbMTFdOwogICAgcmVzdWx0WzEyXSA9IGxlZnRbMTJdIC0gcmlnaHRbMTJdOwogICAgcmVzdWx0WzEzXSA9IGxlZnRbMTNdIC0gcmlnaHRbMTNdOwogICAgcmVzdWx0WzE0XSA9IGxlZnRbMTRdIC0gcmlnaHRbMTRdOwogICAgcmVzdWx0WzE1XSA9IGxlZnRbMTVdIC0gcmlnaHRbMTVdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQubXVsdGlwbHlUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGxlZnQwID0gbGVmdFswXTsKICAgIGNvbnN0IGxlZnQxID0gbGVmdFsxXTsKICAgIGNvbnN0IGxlZnQyID0gbGVmdFsyXTsKICAgIGNvbnN0IGxlZnQ0ID0gbGVmdFs0XTsKICAgIGNvbnN0IGxlZnQ1ID0gbGVmdFs1XTsKICAgIGNvbnN0IGxlZnQ2ID0gbGVmdFs2XTsKICAgIGNvbnN0IGxlZnQ4ID0gbGVmdFs4XTsKICAgIGNvbnN0IGxlZnQ5ID0gbGVmdFs5XTsKICAgIGNvbnN0IGxlZnQxMCA9IGxlZnRbMTBdOwogICAgY29uc3QgbGVmdDEyID0gbGVmdFsxMl07CiAgICBjb25zdCBsZWZ0MTMgPSBsZWZ0WzEzXTsKICAgIGNvbnN0IGxlZnQxNCA9IGxlZnRbMTRdOwogICAgY29uc3QgcmlnaHQwID0gcmlnaHRbMF07CiAgICBjb25zdCByaWdodDEgPSByaWdodFsxXTsKICAgIGNvbnN0IHJpZ2h0MiA9IHJpZ2h0WzJdOwogICAgY29uc3QgcmlnaHQ0ID0gcmlnaHRbNF07CiAgICBjb25zdCByaWdodDUgPSByaWdodFs1XTsKICAgIGNvbnN0IHJpZ2h0NiA9IHJpZ2h0WzZdOwogICAgY29uc3QgcmlnaHQ4ID0gcmlnaHRbOF07CiAgICBjb25zdCByaWdodDkgPSByaWdodFs5XTsKICAgIGNvbnN0IHJpZ2h0MTAgPSByaWdodFsxMF07CiAgICBjb25zdCByaWdodDEyID0gcmlnaHRbMTJdOwogICAgY29uc3QgcmlnaHQxMyA9IHJpZ2h0WzEzXTsKICAgIGNvbnN0IHJpZ2h0MTQgPSByaWdodFsxNF07CiAgICBjb25zdCBjb2x1bW4wUm93MCA9IGxlZnQwICogcmlnaHQwICsgbGVmdDQgKiByaWdodDEgKyBsZWZ0OCAqIHJpZ2h0MjsKICAgIGNvbnN0IGNvbHVtbjBSb3cxID0gbGVmdDEgKiByaWdodDAgKyBsZWZ0NSAqIHJpZ2h0MSArIGxlZnQ5ICogcmlnaHQyOwogICAgY29uc3QgY29sdW1uMFJvdzIgPSBsZWZ0MiAqIHJpZ2h0MCArIGxlZnQ2ICogcmlnaHQxICsgbGVmdDEwICogcmlnaHQyOwogICAgY29uc3QgY29sdW1uMVJvdzAgPSBsZWZ0MCAqIHJpZ2h0NCArIGxlZnQ0ICogcmlnaHQ1ICsgbGVmdDggKiByaWdodDY7CiAgICBjb25zdCBjb2x1bW4xUm93MSA9IGxlZnQxICogcmlnaHQ0ICsgbGVmdDUgKiByaWdodDUgKyBsZWZ0OSAqIHJpZ2h0NjsKICAgIGNvbnN0IGNvbHVtbjFSb3cyID0gbGVmdDIgKiByaWdodDQgKyBsZWZ0NiAqIHJpZ2h0NSArIGxlZnQxMCAqIHJpZ2h0NjsKICAgIGNvbnN0IGNvbHVtbjJSb3cwID0gbGVmdDAgKiByaWdodDggKyBsZWZ0NCAqIHJpZ2h0OSArIGxlZnQ4ICogcmlnaHQxMDsKICAgIGNvbnN0IGNvbHVtbjJSb3cxID0gbGVmdDEgKiByaWdodDggKyBsZWZ0NSAqIHJpZ2h0OSArIGxlZnQ5ICogcmlnaHQxMDsKICAgIGNvbnN0IGNvbHVtbjJSb3cyID0gbGVmdDIgKiByaWdodDggKyBsZWZ0NiAqIHJpZ2h0OSArIGxlZnQxMCAqIHJpZ2h0MTA7CiAgICBjb25zdCBjb2x1bW4zUm93MCA9IGxlZnQwICogcmlnaHQxMiArIGxlZnQ0ICogcmlnaHQxMyArIGxlZnQ4ICogcmlnaHQxNCArIGxlZnQxMjsKICAgIGNvbnN0IGNvbHVtbjNSb3cxID0gbGVmdDEgKiByaWdodDEyICsgbGVmdDUgKiByaWdodDEzICsgbGVmdDkgKiByaWdodDE0ICsgbGVmdDEzOwogICAgY29uc3QgY29sdW1uM1JvdzIgPSBsZWZ0MiAqIHJpZ2h0MTIgKyBsZWZ0NiAqIHJpZ2h0MTMgKyBsZWZ0MTAgKiByaWdodDE0ICsgbGVmdDE0OwogICAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7CiAgICByZXN1bHRbMV0gPSBjb2x1bW4wUm93MTsKICAgIHJlc3VsdFsyXSA9IGNvbHVtbjBSb3cyOwogICAgcmVzdWx0WzNdID0gMDsKICAgIHJlc3VsdFs0XSA9IGNvbHVtbjFSb3cwOwogICAgcmVzdWx0WzVdID0gY29sdW1uMVJvdzE7CiAgICByZXN1bHRbNl0gPSBjb2x1bW4xUm93MjsKICAgIHJlc3VsdFs3XSA9IDA7CiAgICByZXN1bHRbOF0gPSBjb2x1bW4yUm93MDsKICAgIHJlc3VsdFs5XSA9IGNvbHVtbjJSb3cxOwogICAgcmVzdWx0WzEwXSA9IGNvbHVtbjJSb3cyOwogICAgcmVzdWx0WzExXSA9IDA7CiAgICByZXN1bHRbMTJdID0gY29sdW1uM1JvdzA7CiAgICByZXN1bHRbMTNdID0gY29sdW1uM1JvdzE7CiAgICByZXN1bHRbMTRdID0gY29sdW1uM1JvdzI7CiAgICByZXN1bHRbMTVdID0gMTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0Lm11bHRpcGx5QnlNYXRyaXgzID0gZnVuY3Rpb24obWF0cml4LCByb3RhdGlvbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJvdGF0aW9uIiwgcm90YXRpb24pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgbGVmdDAgPSBtYXRyaXhbMF07CiAgICBjb25zdCBsZWZ0MSA9IG1hdHJpeFsxXTsKICAgIGNvbnN0IGxlZnQyID0gbWF0cml4WzJdOwogICAgY29uc3QgbGVmdDQgPSBtYXRyaXhbNF07CiAgICBjb25zdCBsZWZ0NSA9IG1hdHJpeFs1XTsKICAgIGNvbnN0IGxlZnQ2ID0gbWF0cml4WzZdOwogICAgY29uc3QgbGVmdDggPSBtYXRyaXhbOF07CiAgICBjb25zdCBsZWZ0OSA9IG1hdHJpeFs5XTsKICAgIGNvbnN0IGxlZnQxMCA9IG1hdHJpeFsxMF07CiAgICBjb25zdCByaWdodDAgPSByb3RhdGlvblswXTsKICAgIGNvbnN0IHJpZ2h0MSA9IHJvdGF0aW9uWzFdOwogICAgY29uc3QgcmlnaHQyID0gcm90YXRpb25bMl07CiAgICBjb25zdCByaWdodDQgPSByb3RhdGlvblszXTsKICAgIGNvbnN0IHJpZ2h0NSA9IHJvdGF0aW9uWzRdOwogICAgY29uc3QgcmlnaHQ2ID0gcm90YXRpb25bNV07CiAgICBjb25zdCByaWdodDggPSByb3RhdGlvbls2XTsKICAgIGNvbnN0IHJpZ2h0OSA9IHJvdGF0aW9uWzddOwogICAgY29uc3QgcmlnaHQxMCA9IHJvdGF0aW9uWzhdOwogICAgY29uc3QgY29sdW1uMFJvdzAgPSBsZWZ0MCAqIHJpZ2h0MCArIGxlZnQ0ICogcmlnaHQxICsgbGVmdDggKiByaWdodDI7CiAgICBjb25zdCBjb2x1bW4wUm93MSA9IGxlZnQxICogcmlnaHQwICsgbGVmdDUgKiByaWdodDEgKyBsZWZ0OSAqIHJpZ2h0MjsKICAgIGNvbnN0IGNvbHVtbjBSb3cyID0gbGVmdDIgKiByaWdodDAgKyBsZWZ0NiAqIHJpZ2h0MSArIGxlZnQxMCAqIHJpZ2h0MjsKICAgIGNvbnN0IGNvbHVtbjFSb3cwID0gbGVmdDAgKiByaWdodDQgKyBsZWZ0NCAqIHJpZ2h0NSArIGxlZnQ4ICogcmlnaHQ2OwogICAgY29uc3QgY29sdW1uMVJvdzEgPSBsZWZ0MSAqIHJpZ2h0NCArIGxlZnQ1ICogcmlnaHQ1ICsgbGVmdDkgKiByaWdodDY7CiAgICBjb25zdCBjb2x1bW4xUm93MiA9IGxlZnQyICogcmlnaHQ0ICsgbGVmdDYgKiByaWdodDUgKyBsZWZ0MTAgKiByaWdodDY7CiAgICBjb25zdCBjb2x1bW4yUm93MCA9IGxlZnQwICogcmlnaHQ4ICsgbGVmdDQgKiByaWdodDkgKyBsZWZ0OCAqIHJpZ2h0MTA7CiAgICBjb25zdCBjb2x1bW4yUm93MSA9IGxlZnQxICogcmlnaHQ4ICsgbGVmdDUgKiByaWdodDkgKyBsZWZ0OSAqIHJpZ2h0MTA7CiAgICBjb25zdCBjb2x1bW4yUm93MiA9IGxlZnQyICogcmlnaHQ4ICsgbGVmdDYgKiByaWdodDkgKyBsZWZ0MTAgKiByaWdodDEwOwogICAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7CiAgICByZXN1bHRbMV0gPSBjb2x1bW4wUm93MTsKICAgIHJlc3VsdFsyXSA9IGNvbHVtbjBSb3cyOwogICAgcmVzdWx0WzNdID0gMDsKICAgIHJlc3VsdFs0XSA9IGNvbHVtbjFSb3cwOwogICAgcmVzdWx0WzVdID0gY29sdW1uMVJvdzE7CiAgICByZXN1bHRbNl0gPSBjb2x1bW4xUm93MjsKICAgIHJlc3VsdFs3XSA9IDA7CiAgICByZXN1bHRbOF0gPSBjb2x1bW4yUm93MDsKICAgIHJlc3VsdFs5XSA9IGNvbHVtbjJSb3cxOwogICAgcmVzdWx0WzEwXSA9IGNvbHVtbjJSb3cyOwogICAgcmVzdWx0WzExXSA9IDA7CiAgICByZXN1bHRbMTJdID0gbWF0cml4WzEyXTsKICAgIHJlc3VsdFsxM10gPSBtYXRyaXhbMTNdOwogICAgcmVzdWx0WzE0XSA9IG1hdHJpeFsxNF07CiAgICByZXN1bHRbMTVdID0gbWF0cml4WzE1XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0Lm11bHRpcGx5QnlUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG1hdHJpeCwgdHJhbnNsYXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2xhdGlvbiIsIHRyYW5zbGF0aW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IHggPSB0cmFuc2xhdGlvbi54OwogICAgY29uc3QgeSA9IHRyYW5zbGF0aW9uLnk7CiAgICBjb25zdCB6ID0gdHJhbnNsYXRpb24uejsKICAgIGNvbnN0IHR4ID0geCAqIG1hdHJpeFswXSArIHkgKiBtYXRyaXhbNF0gKyB6ICogbWF0cml4WzhdICsgbWF0cml4WzEyXTsKICAgIGNvbnN0IHR5ID0geCAqIG1hdHJpeFsxXSArIHkgKiBtYXRyaXhbNV0gKyB6ICogbWF0cml4WzldICsgbWF0cml4WzEzXTsKICAgIGNvbnN0IHR6ID0geCAqIG1hdHJpeFsyXSArIHkgKiBtYXRyaXhbNl0gKyB6ICogbWF0cml4WzEwXSArIG1hdHJpeFsxNF07CiAgICByZXN1bHRbMF0gPSBtYXRyaXhbMF07CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV07CiAgICByZXN1bHRbMl0gPSBtYXRyaXhbMl07CiAgICByZXN1bHRbM10gPSBtYXRyaXhbM107CiAgICByZXN1bHRbNF0gPSBtYXRyaXhbNF07CiAgICByZXN1bHRbNV0gPSBtYXRyaXhbNV07CiAgICByZXN1bHRbNl0gPSBtYXRyaXhbNl07CiAgICByZXN1bHRbN10gPSBtYXRyaXhbN107CiAgICByZXN1bHRbOF0gPSBtYXRyaXhbOF07CiAgICByZXN1bHRbOV0gPSBtYXRyaXhbOV07CiAgICByZXN1bHRbMTBdID0gbWF0cml4WzEwXTsKICAgIHJlc3VsdFsxMV0gPSBtYXRyaXhbMTFdOwogICAgcmVzdWx0WzEyXSA9IHR4OwogICAgcmVzdWx0WzEzXSA9IHR5OwogICAgcmVzdWx0WzE0XSA9IHR6OwogICAgcmVzdWx0WzE1XSA9IG1hdHJpeFsxNV07CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5tdWx0aXBseUJ5U2NhbGUgPSBmdW5jdGlvbihtYXRyaXgsIHNjYWxlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic2NhbGUiLCBzY2FsZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBzY2FsZVggPSBzY2FsZS54OwogICAgY29uc3Qgc2NhbGVZID0gc2NhbGUueTsKICAgIGNvbnN0IHNjYWxlWiA9IHNjYWxlLno7CiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSAmJiBzY2FsZVogPT09IDEpIHsKICAgICAgcmV0dXJuIE1hdHJpeDQuY2xvbmUobWF0cml4LCByZXN1bHQpOwogICAgfQogICAgcmVzdWx0WzBdID0gc2NhbGVYICogbWF0cml4WzBdOwogICAgcmVzdWx0WzFdID0gc2NhbGVYICogbWF0cml4WzFdOwogICAgcmVzdWx0WzJdID0gc2NhbGVYICogbWF0cml4WzJdOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdOwogICAgcmVzdWx0WzRdID0gc2NhbGVZICogbWF0cml4WzRdOwogICAgcmVzdWx0WzVdID0gc2NhbGVZICogbWF0cml4WzVdOwogICAgcmVzdWx0WzZdID0gc2NhbGVZICogbWF0cml4WzZdOwogICAgcmVzdWx0WzddID0gbWF0cml4WzddOwogICAgcmVzdWx0WzhdID0gc2NhbGVaICogbWF0cml4WzhdOwogICAgcmVzdWx0WzldID0gc2NhbGVaICogbWF0cml4WzldOwogICAgcmVzdWx0WzEwXSA9IHNjYWxlWiAqIG1hdHJpeFsxMF07CiAgICByZXN1bHRbMTFdID0gbWF0cml4WzExXTsKICAgIHJlc3VsdFsxMl0gPSBtYXRyaXhbMTJdOwogICAgcmVzdWx0WzEzXSA9IG1hdHJpeFsxM107CiAgICByZXN1bHRbMTRdID0gbWF0cml4WzE0XTsKICAgIHJlc3VsdFsxNV0gPSBtYXRyaXhbMTVdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQubXVsdGlwbHlCeVVuaWZvcm1TY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJzY2FsZSIsIHNjYWxlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAqIHNjYWxlOwogICAgcmVzdWx0WzFdID0gbWF0cml4WzFdICogc2NhbGU7CiAgICByZXN1bHRbMl0gPSBtYXRyaXhbMl0gKiBzY2FsZTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXTsKICAgIHJlc3VsdFs0XSA9IG1hdHJpeFs0XSAqIHNjYWxlOwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdICogc2NhbGU7CiAgICByZXN1bHRbNl0gPSBtYXRyaXhbNl0gKiBzY2FsZTsKICAgIHJlc3VsdFs3XSA9IG1hdHJpeFs3XTsKICAgIHJlc3VsdFs4XSA9IG1hdHJpeFs4XSAqIHNjYWxlOwogICAgcmVzdWx0WzldID0gbWF0cml4WzldICogc2NhbGU7CiAgICByZXN1bHRbMTBdID0gbWF0cml4WzEwXSAqIHNjYWxlOwogICAgcmVzdWx0WzExXSA9IG1hdHJpeFsxMV07CiAgICByZXN1bHRbMTJdID0gbWF0cml4WzEyXTsKICAgIHJlc3VsdFsxM10gPSBtYXRyaXhbMTNdOwogICAgcmVzdWx0WzE0XSA9IG1hdHJpeFsxNF07CiAgICByZXN1bHRbMTVdID0gbWF0cml4WzE1XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0Lm11bHRpcGx5QnlWZWN0b3IgPSBmdW5jdGlvbihtYXRyaXgsIGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCB2WCA9IGNhcnRlc2lhbi54OwogICAgY29uc3QgdlkgPSBjYXJ0ZXNpYW4ueTsKICAgIGNvbnN0IHZaID0gY2FydGVzaWFuLno7CiAgICBjb25zdCB2VyA9IGNhcnRlc2lhbi53OwogICAgY29uc3QgeCA9IG1hdHJpeFswXSAqIHZYICsgbWF0cml4WzRdICogdlkgKyBtYXRyaXhbOF0gKiB2WiArIG1hdHJpeFsxMl0gKiB2VzsKICAgIGNvbnN0IHkgPSBtYXRyaXhbMV0gKiB2WCArIG1hdHJpeFs1XSAqIHZZICsgbWF0cml4WzldICogdlogKyBtYXRyaXhbMTNdICogdlc7CiAgICBjb25zdCB6ID0gbWF0cml4WzJdICogdlggKyBtYXRyaXhbNl0gKiB2WSArIG1hdHJpeFsxMF0gKiB2WiArIG1hdHJpeFsxNF0gKiB2VzsKICAgIGNvbnN0IHcgPSBtYXRyaXhbM10gKiB2WCArIG1hdHJpeFs3XSAqIHZZICsgbWF0cml4WzExXSAqIHZaICsgbWF0cml4WzE1XSAqIHZXOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmVzdWx0LncgPSB3OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQubXVsdGlwbHlCeVBvaW50QXNWZWN0b3IgPSBmdW5jdGlvbihtYXRyaXgsIGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCB2WCA9IGNhcnRlc2lhbi54OwogICAgY29uc3QgdlkgPSBjYXJ0ZXNpYW4ueTsKICAgIGNvbnN0IHZaID0gY2FydGVzaWFuLno7CiAgICBjb25zdCB4ID0gbWF0cml4WzBdICogdlggKyBtYXRyaXhbNF0gKiB2WSArIG1hdHJpeFs4XSAqIHZaOwogICAgY29uc3QgeSA9IG1hdHJpeFsxXSAqIHZYICsgbWF0cml4WzVdICogdlkgKyBtYXRyaXhbOV0gKiB2WjsKICAgIGNvbnN0IHogPSBtYXRyaXhbMl0gKiB2WCArIG1hdHJpeFs2XSAqIHZZICsgbWF0cml4WzEwXSAqIHZaOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQubXVsdGlwbHlCeVBvaW50ID0gZnVuY3Rpb24obWF0cml4LCBjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgdlggPSBjYXJ0ZXNpYW4ueDsKICAgIGNvbnN0IHZZID0gY2FydGVzaWFuLnk7CiAgICBjb25zdCB2WiA9IGNhcnRlc2lhbi56OwogICAgY29uc3QgeCA9IG1hdHJpeFswXSAqIHZYICsgbWF0cml4WzRdICogdlkgKyBtYXRyaXhbOF0gKiB2WiArIG1hdHJpeFsxMl07CiAgICBjb25zdCB5ID0gbWF0cml4WzFdICogdlggKyBtYXRyaXhbNV0gKiB2WSArIG1hdHJpeFs5XSAqIHZaICsgbWF0cml4WzEzXTsKICAgIGNvbnN0IHogPSBtYXRyaXhbMl0gKiB2WCArIG1hdHJpeFs2XSAqIHZZICsgbWF0cml4WzEwXSAqIHZaICsgbWF0cml4WzE0XTsKICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJlc3VsdC56ID0gejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0Lm11bHRpcGx5QnlTY2FsYXIgPSBmdW5jdGlvbihtYXRyaXgsIHNjYWxhciwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxhciIsIHNjYWxhcik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHRbMF0gPSBtYXRyaXhbMF0gKiBzY2FsYXI7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gKiBzY2FsYXI7CiAgICByZXN1bHRbMl0gPSBtYXRyaXhbMl0gKiBzY2FsYXI7CiAgICByZXN1bHRbM10gPSBtYXRyaXhbM10gKiBzY2FsYXI7CiAgICByZXN1bHRbNF0gPSBtYXRyaXhbNF0gKiBzY2FsYXI7CiAgICByZXN1bHRbNV0gPSBtYXRyaXhbNV0gKiBzY2FsYXI7CiAgICByZXN1bHRbNl0gPSBtYXRyaXhbNl0gKiBzY2FsYXI7CiAgICByZXN1bHRbN10gPSBtYXRyaXhbN10gKiBzY2FsYXI7CiAgICByZXN1bHRbOF0gPSBtYXRyaXhbOF0gKiBzY2FsYXI7CiAgICByZXN1bHRbOV0gPSBtYXRyaXhbOV0gKiBzY2FsYXI7CiAgICByZXN1bHRbMTBdID0gbWF0cml4WzEwXSAqIHNjYWxhcjsKICAgIHJlc3VsdFsxMV0gPSBtYXRyaXhbMTFdICogc2NhbGFyOwogICAgcmVzdWx0WzEyXSA9IG1hdHJpeFsxMl0gKiBzY2FsYXI7CiAgICByZXN1bHRbMTNdID0gbWF0cml4WzEzXSAqIHNjYWxhcjsKICAgIHJlc3VsdFsxNF0gPSBtYXRyaXhbMTRdICogc2NhbGFyOwogICAgcmVzdWx0WzE1XSA9IG1hdHJpeFsxNV0gKiBzY2FsYXI7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5uZWdhdGUgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gLW1hdHJpeFswXTsKICAgIHJlc3VsdFsxXSA9IC1tYXRyaXhbMV07CiAgICByZXN1bHRbMl0gPSAtbWF0cml4WzJdOwogICAgcmVzdWx0WzNdID0gLW1hdHJpeFszXTsKICAgIHJlc3VsdFs0XSA9IC1tYXRyaXhbNF07CiAgICByZXN1bHRbNV0gPSAtbWF0cml4WzVdOwogICAgcmVzdWx0WzZdID0gLW1hdHJpeFs2XTsKICAgIHJlc3VsdFs3XSA9IC1tYXRyaXhbN107CiAgICByZXN1bHRbOF0gPSAtbWF0cml4WzhdOwogICAgcmVzdWx0WzldID0gLW1hdHJpeFs5XTsKICAgIHJlc3VsdFsxMF0gPSAtbWF0cml4WzEwXTsKICAgIHJlc3VsdFsxMV0gPSAtbWF0cml4WzExXTsKICAgIHJlc3VsdFsxMl0gPSAtbWF0cml4WzEyXTsKICAgIHJlc3VsdFsxM10gPSAtbWF0cml4WzEzXTsKICAgIHJlc3VsdFsxNF0gPSAtbWF0cml4WzE0XTsKICAgIHJlc3VsdFsxNV0gPSAtbWF0cml4WzE1XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBtYXRyaXgxID0gbWF0cml4WzFdOwogICAgY29uc3QgbWF0cml4MiA9IG1hdHJpeFsyXTsKICAgIGNvbnN0IG1hdHJpeDMgPSBtYXRyaXhbM107CiAgICBjb25zdCBtYXRyaXg2ID0gbWF0cml4WzZdOwogICAgY29uc3QgbWF0cml4NyA9IG1hdHJpeFs3XTsKICAgIGNvbnN0IG1hdHJpeDExID0gbWF0cml4WzExXTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXTsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFs0XTsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFs4XTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFsxMl07CiAgICByZXN1bHRbNF0gPSBtYXRyaXgxOwogICAgcmVzdWx0WzVdID0gbWF0cml4WzVdOwogICAgcmVzdWx0WzZdID0gbWF0cml4WzldOwogICAgcmVzdWx0WzddID0gbWF0cml4WzEzXTsKICAgIHJlc3VsdFs4XSA9IG1hdHJpeDI7CiAgICByZXN1bHRbOV0gPSBtYXRyaXg2OwogICAgcmVzdWx0WzEwXSA9IG1hdHJpeFsxMF07CiAgICByZXN1bHRbMTFdID0gbWF0cml4WzE0XTsKICAgIHJlc3VsdFsxMl0gPSBtYXRyaXgzOwogICAgcmVzdWx0WzEzXSA9IG1hdHJpeDc7CiAgICByZXN1bHRbMTRdID0gbWF0cml4MTE7CiAgICByZXN1bHRbMTVdID0gbWF0cml4WzE1XTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXg0LmFicyA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHRbMF0gPSBNYXRoLmFicyhtYXRyaXhbMF0pOwogICAgcmVzdWx0WzFdID0gTWF0aC5hYnMobWF0cml4WzFdKTsKICAgIHJlc3VsdFsyXSA9IE1hdGguYWJzKG1hdHJpeFsyXSk7CiAgICByZXN1bHRbM10gPSBNYXRoLmFicyhtYXRyaXhbM10pOwogICAgcmVzdWx0WzRdID0gTWF0aC5hYnMobWF0cml4WzRdKTsKICAgIHJlc3VsdFs1XSA9IE1hdGguYWJzKG1hdHJpeFs1XSk7CiAgICByZXN1bHRbNl0gPSBNYXRoLmFicyhtYXRyaXhbNl0pOwogICAgcmVzdWx0WzddID0gTWF0aC5hYnMobWF0cml4WzddKTsKICAgIHJlc3VsdFs4XSA9IE1hdGguYWJzKG1hdHJpeFs4XSk7CiAgICByZXN1bHRbOV0gPSBNYXRoLmFicyhtYXRyaXhbOV0pOwogICAgcmVzdWx0WzEwXSA9IE1hdGguYWJzKG1hdHJpeFsxMF0pOwogICAgcmVzdWx0WzExXSA9IE1hdGguYWJzKG1hdHJpeFsxMV0pOwogICAgcmVzdWx0WzEyXSA9IE1hdGguYWJzKG1hdHJpeFsxMl0pOwogICAgcmVzdWx0WzEzXSA9IE1hdGguYWJzKG1hdHJpeFsxM10pOwogICAgcmVzdWx0WzE0XSA9IE1hdGguYWJzKG1hdHJpeFsxNF0pOwogICAgcmVzdWx0WzE1XSA9IE1hdGguYWJzKG1hdHJpeFsxNV0pOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDQuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBsZWZ0WzEyXSA9PT0gcmlnaHRbMTJdICYmIGxlZnRbMTNdID09PSByaWdodFsxM10gJiYgbGVmdFsxNF0gPT09IHJpZ2h0WzE0XSAmJiBsZWZ0WzBdID09PSByaWdodFswXSAmJiBsZWZ0WzFdID09PSByaWdodFsxXSAmJiBsZWZ0WzJdID09PSByaWdodFsyXSAmJiBsZWZ0WzRdID09PSByaWdodFs0XSAmJiBsZWZ0WzVdID09PSByaWdodFs1XSAmJiBsZWZ0WzZdID09PSByaWdodFs2XSAmJiBsZWZ0WzhdID09PSByaWdodFs4XSAmJiBsZWZ0WzldID09PSByaWdodFs5XSAmJiBsZWZ0WzEwXSA9PT0gcmlnaHRbMTBdICYmIGxlZnRbM10gPT09IHJpZ2h0WzNdICYmIGxlZnRbN10gPT09IHJpZ2h0WzddICYmIGxlZnRbMTFdID09PSByaWdodFsxMV0gJiYgbGVmdFsxNV0gPT09IHJpZ2h0WzE1XTsKICB9OwogIE1hdHJpeDQuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBlcHNpbG9uKSB7CiAgICBlcHNpbG9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZXBzaWxvbiwgMCk7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgTWF0aC5hYnMobGVmdFswXSAtIHJpZ2h0WzBdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMV0gLSByaWdodFsxXSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0WzJdIC0gcmlnaHRbMl0pIDw9IGVwc2lsb24gJiYgTWF0aC5hYnMobGVmdFszXSAtIHJpZ2h0WzNdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbNF0gLSByaWdodFs0XSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0WzVdIC0gcmlnaHRbNV0pIDw9IGVwc2lsb24gJiYgTWF0aC5hYnMobGVmdFs2XSAtIHJpZ2h0WzZdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbN10gLSByaWdodFs3XSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0WzhdIC0gcmlnaHRbOF0pIDw9IGVwc2lsb24gJiYgTWF0aC5hYnMobGVmdFs5XSAtIHJpZ2h0WzldKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMTBdIC0gcmlnaHRbMTBdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMTFdIC0gcmlnaHRbMTFdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMTJdIC0gcmlnaHRbMTJdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMTNdIC0gcmlnaHRbMTNdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMTRdIC0gcmlnaHRbMTRdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMTVdIC0gcmlnaHRbMTVdKSA8PSBlcHNpbG9uOwogIH07CiAgTWF0cml4NC5nZXRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IG1hdHJpeFsxMl07CiAgICByZXN1bHQueSA9IG1hdHJpeFsxM107CiAgICByZXN1bHQueiA9IG1hdHJpeFsxNF07CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5nZXRNYXRyaXgzID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXTsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFsxXTsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFs0XTsKICAgIHJlc3VsdFs0XSA9IG1hdHJpeFs1XTsKICAgIHJlc3VsdFs1XSA9IG1hdHJpeFs2XTsKICAgIHJlc3VsdFs2XSA9IG1hdHJpeFs4XTsKICAgIHJlc3VsdFs3XSA9IG1hdHJpeFs5XTsKICAgIHJlc3VsdFs4XSA9IG1hdHJpeFsxMF07CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjcmF0Y2hJbnZlcnNlUm90YXRpb24gPSBuZXcgTWF0cml4M19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hNYXRyaXgzWmVybyA9IG5ldyBNYXRyaXgzX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaEJvdHRvbVJvdyA9IG5ldyBDYXJ0ZXNpYW40X2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaEV4cGVjdGVkQm90dG9tUm93ID0gbmV3IENhcnRlc2lhbjRfZGVmYXVsdCgwLCAwLCAwLCAxKTsKICBNYXRyaXg0LmludmVyc2UgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3Qgc3JjMCA9IG1hdHJpeFswXTsKICAgIGNvbnN0IHNyYzEgPSBtYXRyaXhbNF07CiAgICBjb25zdCBzcmMyID0gbWF0cml4WzhdOwogICAgY29uc3Qgc3JjMyA9IG1hdHJpeFsxMl07CiAgICBjb25zdCBzcmM0ID0gbWF0cml4WzFdOwogICAgY29uc3Qgc3JjNSA9IG1hdHJpeFs1XTsKICAgIGNvbnN0IHNyYzYgPSBtYXRyaXhbOV07CiAgICBjb25zdCBzcmM3ID0gbWF0cml4WzEzXTsKICAgIGNvbnN0IHNyYzggPSBtYXRyaXhbMl07CiAgICBjb25zdCBzcmM5ID0gbWF0cml4WzZdOwogICAgY29uc3Qgc3JjMTAgPSBtYXRyaXhbMTBdOwogICAgY29uc3Qgc3JjMTEgPSBtYXRyaXhbMTRdOwogICAgY29uc3Qgc3JjMTIgPSBtYXRyaXhbM107CiAgICBjb25zdCBzcmMxMyA9IG1hdHJpeFs3XTsKICAgIGNvbnN0IHNyYzE0ID0gbWF0cml4WzExXTsKICAgIGNvbnN0IHNyYzE1ID0gbWF0cml4WzE1XTsKICAgIGxldCB0bXAwID0gc3JjMTAgKiBzcmMxNTsKICAgIGxldCB0bXAxID0gc3JjMTEgKiBzcmMxNDsKICAgIGxldCB0bXAyID0gc3JjOSAqIHNyYzE1OwogICAgbGV0IHRtcDMgPSBzcmMxMSAqIHNyYzEzOwogICAgbGV0IHRtcDQgPSBzcmM5ICogc3JjMTQ7CiAgICBsZXQgdG1wNSA9IHNyYzEwICogc3JjMTM7CiAgICBsZXQgdG1wNiA9IHNyYzggKiBzcmMxNTsKICAgIGxldCB0bXA3ID0gc3JjMTEgKiBzcmMxMjsKICAgIGxldCB0bXA4ID0gc3JjOCAqIHNyYzE0OwogICAgbGV0IHRtcDkgPSBzcmMxMCAqIHNyYzEyOwogICAgbGV0IHRtcDEwID0gc3JjOCAqIHNyYzEzOwogICAgbGV0IHRtcDExID0gc3JjOSAqIHNyYzEyOwogICAgY29uc3QgZHN0MCA9IHRtcDAgKiBzcmM1ICsgdG1wMyAqIHNyYzYgKyB0bXA0ICogc3JjNyAtICh0bXAxICogc3JjNSArIHRtcDIgKiBzcmM2ICsgdG1wNSAqIHNyYzcpOwogICAgY29uc3QgZHN0MSA9IHRtcDEgKiBzcmM0ICsgdG1wNiAqIHNyYzYgKyB0bXA5ICogc3JjNyAtICh0bXAwICogc3JjNCArIHRtcDcgKiBzcmM2ICsgdG1wOCAqIHNyYzcpOwogICAgY29uc3QgZHN0MiA9IHRtcDIgKiBzcmM0ICsgdG1wNyAqIHNyYzUgKyB0bXAxMCAqIHNyYzcgLSAodG1wMyAqIHNyYzQgKyB0bXA2ICogc3JjNSArIHRtcDExICogc3JjNyk7CiAgICBjb25zdCBkc3QzID0gdG1wNSAqIHNyYzQgKyB0bXA4ICogc3JjNSArIHRtcDExICogc3JjNiAtICh0bXA0ICogc3JjNCArIHRtcDkgKiBzcmM1ICsgdG1wMTAgKiBzcmM2KTsKICAgIGNvbnN0IGRzdDQgPSB0bXAxICogc3JjMSArIHRtcDIgKiBzcmMyICsgdG1wNSAqIHNyYzMgLSAodG1wMCAqIHNyYzEgKyB0bXAzICogc3JjMiArIHRtcDQgKiBzcmMzKTsKICAgIGNvbnN0IGRzdDUgPSB0bXAwICogc3JjMCArIHRtcDcgKiBzcmMyICsgdG1wOCAqIHNyYzMgLSAodG1wMSAqIHNyYzAgKyB0bXA2ICogc3JjMiArIHRtcDkgKiBzcmMzKTsKICAgIGNvbnN0IGRzdDYgPSB0bXAzICogc3JjMCArIHRtcDYgKiBzcmMxICsgdG1wMTEgKiBzcmMzIC0gKHRtcDIgKiBzcmMwICsgdG1wNyAqIHNyYzEgKyB0bXAxMCAqIHNyYzMpOwogICAgY29uc3QgZHN0NyA9IHRtcDQgKiBzcmMwICsgdG1wOSAqIHNyYzEgKyB0bXAxMCAqIHNyYzIgLSAodG1wNSAqIHNyYzAgKyB0bXA4ICogc3JjMSArIHRtcDExICogc3JjMik7CiAgICB0bXAwID0gc3JjMiAqIHNyYzc7CiAgICB0bXAxID0gc3JjMyAqIHNyYzY7CiAgICB0bXAyID0gc3JjMSAqIHNyYzc7CiAgICB0bXAzID0gc3JjMyAqIHNyYzU7CiAgICB0bXA0ID0gc3JjMSAqIHNyYzY7CiAgICB0bXA1ID0gc3JjMiAqIHNyYzU7CiAgICB0bXA2ID0gc3JjMCAqIHNyYzc7CiAgICB0bXA3ID0gc3JjMyAqIHNyYzQ7CiAgICB0bXA4ID0gc3JjMCAqIHNyYzY7CiAgICB0bXA5ID0gc3JjMiAqIHNyYzQ7CiAgICB0bXAxMCA9IHNyYzAgKiBzcmM1OwogICAgdG1wMTEgPSBzcmMxICogc3JjNDsKICAgIGNvbnN0IGRzdDggPSB0bXAwICogc3JjMTMgKyB0bXAzICogc3JjMTQgKyB0bXA0ICogc3JjMTUgLSAodG1wMSAqIHNyYzEzICsgdG1wMiAqIHNyYzE0ICsgdG1wNSAqIHNyYzE1KTsKICAgIGNvbnN0IGRzdDkgPSB0bXAxICogc3JjMTIgKyB0bXA2ICogc3JjMTQgKyB0bXA5ICogc3JjMTUgLSAodG1wMCAqIHNyYzEyICsgdG1wNyAqIHNyYzE0ICsgdG1wOCAqIHNyYzE1KTsKICAgIGNvbnN0IGRzdDEwID0gdG1wMiAqIHNyYzEyICsgdG1wNyAqIHNyYzEzICsgdG1wMTAgKiBzcmMxNSAtICh0bXAzICogc3JjMTIgKyB0bXA2ICogc3JjMTMgKyB0bXAxMSAqIHNyYzE1KTsKICAgIGNvbnN0IGRzdDExID0gdG1wNSAqIHNyYzEyICsgdG1wOCAqIHNyYzEzICsgdG1wMTEgKiBzcmMxNCAtICh0bXA0ICogc3JjMTIgKyB0bXA5ICogc3JjMTMgKyB0bXAxMCAqIHNyYzE0KTsKICAgIGNvbnN0IGRzdDEyID0gdG1wMiAqIHNyYzEwICsgdG1wNSAqIHNyYzExICsgdG1wMSAqIHNyYzkgLSAodG1wNCAqIHNyYzExICsgdG1wMCAqIHNyYzkgKyB0bXAzICogc3JjMTApOwogICAgY29uc3QgZHN0MTMgPSB0bXA4ICogc3JjMTEgKyB0bXAwICogc3JjOCArIHRtcDcgKiBzcmMxMCAtICh0bXA2ICogc3JjMTAgKyB0bXA5ICogc3JjMTEgKyB0bXAxICogc3JjOCk7CiAgICBjb25zdCBkc3QxNCA9IHRtcDYgKiBzcmM5ICsgdG1wMTEgKiBzcmMxMSArIHRtcDMgKiBzcmM4IC0gKHRtcDEwICogc3JjMTEgKyB0bXAyICogc3JjOCArIHRtcDcgKiBzcmM5KTsKICAgIGNvbnN0IGRzdDE1ID0gdG1wMTAgKiBzcmMxMCArIHRtcDQgKiBzcmM4ICsgdG1wOSAqIHNyYzkgLSAodG1wOCAqIHNyYzkgKyB0bXAxMSAqIHNyYzEwICsgdG1wNSAqIHNyYzgpOwogICAgbGV0IGRldCA9IHNyYzAgKiBkc3QwICsgc3JjMSAqIGRzdDEgKyBzcmMyICogZHN0MiArIHNyYzMgKiBkc3QzOwogICAgaWYgKE1hdGguYWJzKGRldCkgPCBNYXRoX2RlZmF1bHQuRVBTSUxPTjIxKSB7CiAgICAgIGlmIChNYXRyaXgzX2RlZmF1bHQuZXF1YWxzRXBzaWxvbigKICAgICAgICBNYXRyaXg0LmdldE1hdHJpeDMobWF0cml4LCBzY3JhdGNoSW52ZXJzZVJvdGF0aW9uKSwKICAgICAgICBzY3JhdGNoTWF0cml4M1plcm8sCiAgICAgICAgTWF0aF9kZWZhdWx0LkVQU0lMT043CiAgICAgICkgJiYgQ2FydGVzaWFuNF9kZWZhdWx0LmVxdWFscygKICAgICAgICBNYXRyaXg0LmdldFJvdyhtYXRyaXgsIDMsIHNjcmF0Y2hCb3R0b21Sb3cpLAogICAgICAgIHNjcmF0Y2hFeHBlY3RlZEJvdHRvbVJvdwogICAgICApKSB7CiAgICAgICAgcmVzdWx0WzBdID0gMDsKICAgICAgICByZXN1bHRbMV0gPSAwOwogICAgICAgIHJlc3VsdFsyXSA9IDA7CiAgICAgICAgcmVzdWx0WzNdID0gMDsKICAgICAgICByZXN1bHRbNF0gPSAwOwogICAgICAgIHJlc3VsdFs1XSA9IDA7CiAgICAgICAgcmVzdWx0WzZdID0gMDsKICAgICAgICByZXN1bHRbN10gPSAwOwogICAgICAgIHJlc3VsdFs4XSA9IDA7CiAgICAgICAgcmVzdWx0WzldID0gMDsKICAgICAgICByZXN1bHRbMTBdID0gMDsKICAgICAgICByZXN1bHRbMTFdID0gMDsKICAgICAgICByZXN1bHRbMTJdID0gLW1hdHJpeFsxMl07CiAgICAgICAgcmVzdWx0WzEzXSA9IC1tYXRyaXhbMTNdOwogICAgICAgIHJlc3VsdFsxNF0gPSAtbWF0cml4WzE0XTsKICAgICAgICByZXN1bHRbMTVdID0gMTsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3JfZGVmYXVsdCgKICAgICAgICAibWF0cml4IGlzIG5vdCBpbnZlcnRpYmxlIGJlY2F1c2UgaXRzIGRldGVybWluYXRlIGlzIHplcm8uIgogICAgICApOwogICAgfQogICAgZGV0ID0gMSAvIGRldDsKICAgIHJlc3VsdFswXSA9IGRzdDAgKiBkZXQ7CiAgICByZXN1bHRbMV0gPSBkc3QxICogZGV0OwogICAgcmVzdWx0WzJdID0gZHN0MiAqIGRldDsKICAgIHJlc3VsdFszXSA9IGRzdDMgKiBkZXQ7CiAgICByZXN1bHRbNF0gPSBkc3Q0ICogZGV0OwogICAgcmVzdWx0WzVdID0gZHN0NSAqIGRldDsKICAgIHJlc3VsdFs2XSA9IGRzdDYgKiBkZXQ7CiAgICByZXN1bHRbN10gPSBkc3Q3ICogZGV0OwogICAgcmVzdWx0WzhdID0gZHN0OCAqIGRldDsKICAgIHJlc3VsdFs5XSA9IGRzdDkgKiBkZXQ7CiAgICByZXN1bHRbMTBdID0gZHN0MTAgKiBkZXQ7CiAgICByZXN1bHRbMTFdID0gZHN0MTEgKiBkZXQ7CiAgICByZXN1bHRbMTJdID0gZHN0MTIgKiBkZXQ7CiAgICByZXN1bHRbMTNdID0gZHN0MTMgKiBkZXQ7CiAgICByZXN1bHRbMTRdID0gZHN0MTQgKiBkZXQ7CiAgICByZXN1bHRbMTVdID0gZHN0MTUgKiBkZXQ7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4NC5pbnZlcnNlVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgbWF0cml4MCA9IG1hdHJpeFswXTsKICAgIGNvbnN0IG1hdHJpeDEgPSBtYXRyaXhbMV07CiAgICBjb25zdCBtYXRyaXgyID0gbWF0cml4WzJdOwogICAgY29uc3QgbWF0cml4NCA9IG1hdHJpeFs0XTsKICAgIGNvbnN0IG1hdHJpeDUgPSBtYXRyaXhbNV07CiAgICBjb25zdCBtYXRyaXg2ID0gbWF0cml4WzZdOwogICAgY29uc3QgbWF0cml4OCA9IG1hdHJpeFs4XTsKICAgIGNvbnN0IG1hdHJpeDkgPSBtYXRyaXhbOV07CiAgICBjb25zdCBtYXRyaXgxMCA9IG1hdHJpeFsxMF07CiAgICBjb25zdCB2WCA9IG1hdHJpeFsxMl07CiAgICBjb25zdCB2WSA9IG1hdHJpeFsxM107CiAgICBjb25zdCB2WiA9IG1hdHJpeFsxNF07CiAgICBjb25zdCB4ID0gLW1hdHJpeDAgKiB2WCAtIG1hdHJpeDEgKiB2WSAtIG1hdHJpeDIgKiB2WjsKICAgIGNvbnN0IHkgPSAtbWF0cml4NCAqIHZYIC0gbWF0cml4NSAqIHZZIC0gbWF0cml4NiAqIHZaOwogICAgY29uc3QgeiA9IC1tYXRyaXg4ICogdlggLSBtYXRyaXg5ICogdlkgLSBtYXRyaXgxMCAqIHZaOwogICAgcmVzdWx0WzBdID0gbWF0cml4MDsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeDQ7CiAgICByZXN1bHRbMl0gPSBtYXRyaXg4OwogICAgcmVzdWx0WzNdID0gMDsKICAgIHJlc3VsdFs0XSA9IG1hdHJpeDE7CiAgICByZXN1bHRbNV0gPSBtYXRyaXg1OwogICAgcmVzdWx0WzZdID0gbWF0cml4OTsKICAgIHJlc3VsdFs3XSA9IDA7CiAgICByZXN1bHRbOF0gPSBtYXRyaXgyOwogICAgcmVzdWx0WzldID0gbWF0cml4NjsKICAgIHJlc3VsdFsxMF0gPSBtYXRyaXgxMDsKICAgIHJlc3VsdFsxMV0gPSAwOwogICAgcmVzdWx0WzEyXSA9IHg7CiAgICByZXN1bHRbMTNdID0geTsKICAgIHJlc3VsdFsxNF0gPSB6OwogICAgcmVzdWx0WzE1XSA9IDE7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjcmF0Y2hUcmFuc3Bvc2VNYXRyaXgyID0gbmV3IE1hdHJpeDQoKTsKICBNYXRyaXg0LmludmVyc2VUcmFuc3Bvc2UgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmV0dXJuIE1hdHJpeDQuaW52ZXJzZSgKICAgICAgTWF0cml4NC50cmFuc3Bvc2UobWF0cml4LCBzY3JhdGNoVHJhbnNwb3NlTWF0cml4MiksCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIE1hdHJpeDQuSURFTlRJVFkgPSBPYmplY3QuZnJlZXplKAogICAgbmV3IE1hdHJpeDQoCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICkKICApOwogIE1hdHJpeDQuWkVSTyA9IE9iamVjdC5mcmVlemUoCiAgICBuZXcgTWF0cml4NCgKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMAogICAgKQogICk7CiAgTWF0cml4NC5DT0xVTU4wUk9XMCA9IDA7CiAgTWF0cml4NC5DT0xVTU4wUk9XMSA9IDE7CiAgTWF0cml4NC5DT0xVTU4wUk9XMiA9IDI7CiAgTWF0cml4NC5DT0xVTU4wUk9XMyA9IDM7CiAgTWF0cml4NC5DT0xVTU4xUk9XMCA9IDQ7CiAgTWF0cml4NC5DT0xVTU4xUk9XMSA9IDU7CiAgTWF0cml4NC5DT0xVTU4xUk9XMiA9IDY7CiAgTWF0cml4NC5DT0xVTU4xUk9XMyA9IDc7CiAgTWF0cml4NC5DT0xVTU4yUk9XMCA9IDg7CiAgTWF0cml4NC5DT0xVTU4yUk9XMSA9IDk7CiAgTWF0cml4NC5DT0xVTU4yUk9XMiA9IDEwOwogIE1hdHJpeDQuQ09MVU1OMlJPVzMgPSAxMTsKICBNYXRyaXg0LkNPTFVNTjNST1cwID0gMTI7CiAgTWF0cml4NC5DT0xVTU4zUk9XMSA9IDEzOwogIE1hdHJpeDQuQ09MVU1OM1JPVzIgPSAxNDsKICBNYXRyaXg0LkNPTFVNTjNST1czID0gMTU7CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWF0cml4NC5wcm90b3R5cGUsIHsKICAgIGxlbmd0aDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBNYXRyaXg0LnBhY2tlZExlbmd0aDsKICAgICAgfQogICAgfQogIH0pOwogIE1hdHJpeDQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gTWF0cml4NC5jbG9uZSh0aGlzLCByZXN1bHQpOwogIH07CiAgTWF0cml4NC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocmlnaHQpIHsKICAgIHJldHVybiBNYXRyaXg0LmVxdWFscyh0aGlzLCByaWdodCk7CiAgfTsKICBNYXRyaXg0LmVxdWFsc0FycmF5ID0gZnVuY3Rpb24obWF0cml4LCBhcnJheSwgb2Zmc2V0KSB7CiAgICByZXR1cm4gbWF0cml4WzBdID09PSBhcnJheVtvZmZzZXRdICYmIG1hdHJpeFsxXSA9PT0gYXJyYXlbb2Zmc2V0ICsgMV0gJiYgbWF0cml4WzJdID09PSBhcnJheVtvZmZzZXQgKyAyXSAmJiBtYXRyaXhbM10gPT09IGFycmF5W29mZnNldCArIDNdICYmIG1hdHJpeFs0XSA9PT0gYXJyYXlbb2Zmc2V0ICsgNF0gJiYgbWF0cml4WzVdID09PSBhcnJheVtvZmZzZXQgKyA1XSAmJiBtYXRyaXhbNl0gPT09IGFycmF5W29mZnNldCArIDZdICYmIG1hdHJpeFs3XSA9PT0gYXJyYXlbb2Zmc2V0ICsgN10gJiYgbWF0cml4WzhdID09PSBhcnJheVtvZmZzZXQgKyA4XSAmJiBtYXRyaXhbOV0gPT09IGFycmF5W29mZnNldCArIDldICYmIG1hdHJpeFsxMF0gPT09IGFycmF5W29mZnNldCArIDEwXSAmJiBtYXRyaXhbMTFdID09PSBhcnJheVtvZmZzZXQgKyAxMV0gJiYgbWF0cml4WzEyXSA9PT0gYXJyYXlbb2Zmc2V0ICsgMTJdICYmIG1hdHJpeFsxM10gPT09IGFycmF5W29mZnNldCArIDEzXSAmJiBtYXRyaXhbMTRdID09PSBhcnJheVtvZmZzZXQgKyAxNF0gJiYgbWF0cml4WzE1XSA9PT0gYXJyYXlbb2Zmc2V0ICsgMTVdOwogIH07CiAgTWF0cml4NC5wcm90b3R5cGUuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKHJpZ2h0LCBlcHNpbG9uKSB7CiAgICByZXR1cm4gTWF0cml4NC5lcXVhbHNFcHNpbG9uKHRoaXMsIHJpZ2h0LCBlcHNpbG9uKTsKICB9OwogIE1hdHJpeDQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gYCgke3RoaXNbMF19LCAke3RoaXNbNF19LCAke3RoaXNbOF19LCAke3RoaXNbMTJdfSkKKCR7dGhpc1sxXX0sICR7dGhpc1s1XX0sICR7dGhpc1s5XX0sICR7dGhpc1sxM119KQooJHt0aGlzWzJdfSwgJHt0aGlzWzZdfSwgJHt0aGlzWzEwXX0sICR7dGhpc1sxNF19KQooJHt0aGlzWzNdfSwgJHt0aGlzWzddfSwgJHt0aGlzWzExXX0sICR7dGhpc1sxNV19KWA7CiAgfTsKICB2YXIgTWF0cml4NF9kZWZhdWx0ID0gTWF0cml4NDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1dlYkdMQ29uc3RhbnRzLmpzCiAgdmFyIFdlYkdMQ29uc3RhbnRzID0gewogICAgREVQVEhfQlVGRkVSX0JJVDogMjU2LAogICAgU1RFTkNJTF9CVUZGRVJfQklUOiAxMDI0LAogICAgQ09MT1JfQlVGRkVSX0JJVDogMTYzODQsCiAgICBQT0lOVFM6IDAsCiAgICBMSU5FUzogMSwKICAgIExJTkVfTE9PUDogMiwKICAgIExJTkVfU1RSSVA6IDMsCiAgICBUUklBTkdMRVM6IDQsCiAgICBUUklBTkdMRV9TVFJJUDogNSwKICAgIFRSSUFOR0xFX0ZBTjogNiwKICAgIFpFUk86IDAsCiAgICBPTkU6IDEsCiAgICBTUkNfQ09MT1I6IDc2OCwKICAgIE9ORV9NSU5VU19TUkNfQ09MT1I6IDc2OSwKICAgIFNSQ19BTFBIQTogNzcwLAogICAgT05FX01JTlVTX1NSQ19BTFBIQTogNzcxLAogICAgRFNUX0FMUEhBOiA3NzIsCiAgICBPTkVfTUlOVVNfRFNUX0FMUEhBOiA3NzMsCiAgICBEU1RfQ09MT1I6IDc3NCwKICAgIE9ORV9NSU5VU19EU1RfQ09MT1I6IDc3NSwKICAgIFNSQ19BTFBIQV9TQVRVUkFURTogNzc2LAogICAgRlVOQ19BREQ6IDMyNzc0LAogICAgQkxFTkRfRVFVQVRJT046IDMyNzc3LAogICAgQkxFTkRfRVFVQVRJT05fUkdCOiAzMjc3NywKICAgIEJMRU5EX0VRVUFUSU9OX0FMUEhBOiAzNDg3NywKICAgIEZVTkNfU1VCVFJBQ1Q6IDMyNzc4LAogICAgRlVOQ19SRVZFUlNFX1NVQlRSQUNUOiAzMjc3OSwKICAgIEJMRU5EX0RTVF9SR0I6IDMyOTY4LAogICAgQkxFTkRfU1JDX1JHQjogMzI5NjksCiAgICBCTEVORF9EU1RfQUxQSEE6IDMyOTcwLAogICAgQkxFTkRfU1JDX0FMUEhBOiAzMjk3MSwKICAgIENPTlNUQU5UX0NPTE9SOiAzMjc2OSwKICAgIE9ORV9NSU5VU19DT05TVEFOVF9DT0xPUjogMzI3NzAsCiAgICBDT05TVEFOVF9BTFBIQTogMzI3NzEsCiAgICBPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEE6IDMyNzcyLAogICAgQkxFTkRfQ09MT1I6IDMyNzczLAogICAgQVJSQVlfQlVGRkVSOiAzNDk2MiwKICAgIEVMRU1FTlRfQVJSQVlfQlVGRkVSOiAzNDk2MywKICAgIEFSUkFZX0JVRkZFUl9CSU5ESU5HOiAzNDk2NCwKICAgIEVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTY1LAogICAgU1RSRUFNX0RSQVc6IDM1MDQwLAogICAgU1RBVElDX0RSQVc6IDM1MDQ0LAogICAgRFlOQU1JQ19EUkFXOiAzNTA0OCwKICAgIEJVRkZFUl9TSVpFOiAzNDY2MCwKICAgIEJVRkZFUl9VU0FHRTogMzQ2NjEsCiAgICBDVVJSRU5UX1ZFUlRFWF9BVFRSSUI6IDM0MzQyLAogICAgRlJPTlQ6IDEwMjgsCiAgICBCQUNLOiAxMDI5LAogICAgRlJPTlRfQU5EX0JBQ0s6IDEwMzIsCiAgICBDVUxMX0ZBQ0U6IDI4ODQsCiAgICBCTEVORDogMzA0MiwKICAgIERJVEhFUjogMzAyNCwKICAgIFNURU5DSUxfVEVTVDogMjk2MCwKICAgIERFUFRIX1RFU1Q6IDI5MjksCiAgICBTQ0lTU09SX1RFU1Q6IDMwODksCiAgICBQT0xZR09OX09GRlNFVF9GSUxMOiAzMjgyMywKICAgIFNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRTogMzI5MjYsCiAgICBTQU1QTEVfQ09WRVJBR0U6IDMyOTI4LAogICAgTk9fRVJST1I6IDAsCiAgICBJTlZBTElEX0VOVU06IDEyODAsCiAgICBJTlZBTElEX1ZBTFVFOiAxMjgxLAogICAgSU5WQUxJRF9PUEVSQVRJT046IDEyODIsCiAgICBPVVRfT0ZfTUVNT1JZOiAxMjg1LAogICAgQ1c6IDIzMDQsCiAgICBDQ1c6IDIzMDUsCiAgICBMSU5FX1dJRFRIOiAyODQ5LAogICAgQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFOiAzMzkwMSwKICAgIEFMSUFTRURfTElORV9XSURUSF9SQU5HRTogMzM5MDIsCiAgICBDVUxMX0ZBQ0VfTU9ERTogMjg4NSwKICAgIEZST05UX0ZBQ0U6IDI4ODYsCiAgICBERVBUSF9SQU5HRTogMjkyOCwKICAgIERFUFRIX1dSSVRFTUFTSzogMjkzMCwKICAgIERFUFRIX0NMRUFSX1ZBTFVFOiAyOTMxLAogICAgREVQVEhfRlVOQzogMjkzMiwKICAgIFNURU5DSUxfQ0xFQVJfVkFMVUU6IDI5NjEsCiAgICBTVEVOQ0lMX0ZVTkM6IDI5NjIsCiAgICBTVEVOQ0lMX0ZBSUw6IDI5NjQsCiAgICBTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTDogMjk2NSwKICAgIFNURU5DSUxfUEFTU19ERVBUSF9QQVNTOiAyOTY2LAogICAgU1RFTkNJTF9SRUY6IDI5NjcsCiAgICBTVEVOQ0lMX1ZBTFVFX01BU0s6IDI5NjMsCiAgICBTVEVOQ0lMX1dSSVRFTUFTSzogMjk2OCwKICAgIFNURU5DSUxfQkFDS19GVU5DOiAzNDgxNiwKICAgIFNURU5DSUxfQkFDS19GQUlMOiAzNDgxNywKICAgIFNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUw6IDM0ODE4LAogICAgU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfUEFTUzogMzQ4MTksCiAgICBTVEVOQ0lMX0JBQ0tfUkVGOiAzNjAwMywKICAgIFNURU5DSUxfQkFDS19WQUxVRV9NQVNLOiAzNjAwNCwKICAgIFNURU5DSUxfQkFDS19XUklURU1BU0s6IDM2MDA1LAogICAgVklFV1BPUlQ6IDI5NzgsCiAgICBTQ0lTU09SX0JPWDogMzA4OCwKICAgIENPTE9SX0NMRUFSX1ZBTFVFOiAzMTA2LAogICAgQ09MT1JfV1JJVEVNQVNLOiAzMTA3LAogICAgVU5QQUNLX0FMSUdOTUVOVDogMzMxNywKICAgIFBBQ0tfQUxJR05NRU5UOiAzMzMzLAogICAgTUFYX1RFWFRVUkVfU0laRTogMzM3OSwKICAgIE1BWF9WSUVXUE9SVF9ESU1TOiAzMzg2LAogICAgU1VCUElYRUxfQklUUzogMzQwOCwKICAgIFJFRF9CSVRTOiAzNDEwLAogICAgR1JFRU5fQklUUzogMzQxMSwKICAgIEJMVUVfQklUUzogMzQxMiwKICAgIEFMUEhBX0JJVFM6IDM0MTMsCiAgICBERVBUSF9CSVRTOiAzNDE0LAogICAgU1RFTkNJTF9CSVRTOiAzNDE1LAogICAgUE9MWUdPTl9PRkZTRVRfVU5JVFM6IDEwNzUyLAogICAgUE9MWUdPTl9PRkZTRVRfRkFDVE9SOiAzMjgyNCwKICAgIFRFWFRVUkVfQklORElOR18yRDogMzI4NzMsCiAgICBTQU1QTEVfQlVGRkVSUzogMzI5MzYsCiAgICBTQU1QTEVTOiAzMjkzNywKICAgIFNBTVBMRV9DT1ZFUkFHRV9WQUxVRTogMzI5MzgsCiAgICBTQU1QTEVfQ09WRVJBR0VfSU5WRVJUOiAzMjkzOSwKICAgIENPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTOiAzNDQ2NywKICAgIERPTlRfQ0FSRTogNDM1MiwKICAgIEZBU1RFU1Q6IDQzNTMsCiAgICBOSUNFU1Q6IDQzNTQsCiAgICBHRU5FUkFURV9NSVBNQVBfSElOVDogMzMxNzAsCiAgICBCWVRFOiA1MTIwLAogICAgVU5TSUdORURfQllURTogNTEyMSwKICAgIFNIT1JUOiA1MTIyLAogICAgVU5TSUdORURfU0hPUlQ6IDUxMjMsCiAgICBJTlQ6IDUxMjQsCiAgICBVTlNJR05FRF9JTlQ6IDUxMjUsCiAgICBGTE9BVDogNTEyNiwKICAgIERFUFRIX0NPTVBPTkVOVDogNjQwMiwKICAgIEFMUEhBOiA2NDA2LAogICAgUkdCOiA2NDA3LAogICAgUkdCQTogNjQwOCwKICAgIExVTUlOQU5DRTogNjQwOSwKICAgIExVTUlOQU5DRV9BTFBIQTogNjQxMCwKICAgIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6IDMyODE5LAogICAgVU5TSUdORURfU0hPUlRfNV81XzVfMTogMzI4MjAsCiAgICBVTlNJR05FRF9TSE9SVF81XzZfNTogMzM2MzUsCiAgICBGUkFHTUVOVF9TSEFERVI6IDM1NjMyLAogICAgVkVSVEVYX1NIQURFUjogMzU2MzMsCiAgICBNQVhfVkVSVEVYX0FUVFJJQlM6IDM0OTIxLAogICAgTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlM6IDM2MzQ3LAogICAgTUFYX1ZBUllJTkdfVkVDVE9SUzogMzYzNDgsCiAgICBNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUzogMzU2NjEsCiAgICBNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDM1NjYwLAogICAgTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDM0OTMwLAogICAgTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUzogMzYzNDksCiAgICBTSEFERVJfVFlQRTogMzU2NjMsCiAgICBERUxFVEVfU1RBVFVTOiAzNTcxMiwKICAgIExJTktfU1RBVFVTOiAzNTcxNCwKICAgIFZBTElEQVRFX1NUQVRVUzogMzU3MTUsCiAgICBBVFRBQ0hFRF9TSEFERVJTOiAzNTcxNywKICAgIEFDVElWRV9VTklGT1JNUzogMzU3MTgsCiAgICBBQ1RJVkVfQVRUUklCVVRFUzogMzU3MjEsCiAgICBTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT046IDM1NzI0LAogICAgQ1VSUkVOVF9QUk9HUkFNOiAzNTcyNSwKICAgIE5FVkVSOiA1MTIsCiAgICBMRVNTOiA1MTMsCiAgICBFUVVBTDogNTE0LAogICAgTEVRVUFMOiA1MTUsCiAgICBHUkVBVEVSOiA1MTYsCiAgICBOT1RFUVVBTDogNTE3LAogICAgR0VRVUFMOiA1MTgsCiAgICBBTFdBWVM6IDUxOSwKICAgIEtFRVA6IDc2ODAsCiAgICBSRVBMQUNFOiA3NjgxLAogICAgSU5DUjogNzY4MiwKICAgIERFQ1I6IDc2ODMsCiAgICBJTlZFUlQ6IDUzODYsCiAgICBJTkNSX1dSQVA6IDM0MDU1LAogICAgREVDUl9XUkFQOiAzNDA1NiwKICAgIFZFTkRPUjogNzkzNiwKICAgIFJFTkRFUkVSOiA3OTM3LAogICAgVkVSU0lPTjogNzkzOCwKICAgIE5FQVJFU1Q6IDk3MjgsCiAgICBMSU5FQVI6IDk3MjksCiAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiA5OTg0LAogICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiA5OTg1LAogICAgTkVBUkVTVF9NSVBNQVBfTElORUFSOiA5OTg2LAogICAgTElORUFSX01JUE1BUF9MSU5FQVI6IDk5ODcsCiAgICBURVhUVVJFX01BR19GSUxURVI6IDEwMjQwLAogICAgVEVYVFVSRV9NSU5fRklMVEVSOiAxMDI0MSwKICAgIFRFWFRVUkVfV1JBUF9TOiAxMDI0MiwKICAgIFRFWFRVUkVfV1JBUF9UOiAxMDI0MywKICAgIFRFWFRVUkVfMkQ6IDM1NTMsCiAgICBURVhUVVJFOiA1ODkwLAogICAgVEVYVFVSRV9DVUJFX01BUDogMzQwNjcsCiAgICBURVhUVVJFX0JJTkRJTkdfQ1VCRV9NQVA6IDM0MDY4LAogICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YOiAzNDA2OSwKICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWDogMzQwNzAsCiAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6IDM0MDcxLAogICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZOiAzNDA3MiwKICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWjogMzQwNzMsCiAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o6IDM0MDc0LAogICAgTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRTogMzQwNzYsCiAgICBURVhUVVJFMDogMzM5ODQsCiAgICBURVhUVVJFMTogMzM5ODUsCiAgICBURVhUVVJFMjogMzM5ODYsCiAgICBURVhUVVJFMzogMzM5ODcsCiAgICBURVhUVVJFNDogMzM5ODgsCiAgICBURVhUVVJFNTogMzM5ODksCiAgICBURVhUVVJFNjogMzM5OTAsCiAgICBURVhUVVJFNzogMzM5OTEsCiAgICBURVhUVVJFODogMzM5OTIsCiAgICBURVhUVVJFOTogMzM5OTMsCiAgICBURVhUVVJFMTA6IDMzOTk0LAogICAgVEVYVFVSRTExOiAzMzk5NSwKICAgIFRFWFRVUkUxMjogMzM5OTYsCiAgICBURVhUVVJFMTM6IDMzOTk3LAogICAgVEVYVFVSRTE0OiAzMzk5OCwKICAgIFRFWFRVUkUxNTogMzM5OTksCiAgICBURVhUVVJFMTY6IDM0ZTMsCiAgICBURVhUVVJFMTc6IDM0MDAxLAogICAgVEVYVFVSRTE4OiAzNDAwMiwKICAgIFRFWFRVUkUxOTogMzQwMDMsCiAgICBURVhUVVJFMjA6IDM0MDA0LAogICAgVEVYVFVSRTIxOiAzNDAwNSwKICAgIFRFWFRVUkUyMjogMzQwMDYsCiAgICBURVhUVVJFMjM6IDM0MDA3LAogICAgVEVYVFVSRTI0OiAzNDAwOCwKICAgIFRFWFRVUkUyNTogMzQwMDksCiAgICBURVhUVVJFMjY6IDM0MDEwLAogICAgVEVYVFVSRTI3OiAzNDAxMSwKICAgIFRFWFRVUkUyODogMzQwMTIsCiAgICBURVhUVVJFMjk6IDM0MDEzLAogICAgVEVYVFVSRTMwOiAzNDAxNCwKICAgIFRFWFRVUkUzMTogMzQwMTUsCiAgICBBQ1RJVkVfVEVYVFVSRTogMzQwMTYsCiAgICBSRVBFQVQ6IDEwNDk3LAogICAgQ0xBTVBfVE9fRURHRTogMzMwNzEsCiAgICBNSVJST1JFRF9SRVBFQVQ6IDMzNjQ4LAogICAgRkxPQVRfVkVDMjogMzU2NjQsCiAgICBGTE9BVF9WRUMzOiAzNTY2NSwKICAgIEZMT0FUX1ZFQzQ6IDM1NjY2LAogICAgSU5UX1ZFQzI6IDM1NjY3LAogICAgSU5UX1ZFQzM6IDM1NjY4LAogICAgSU5UX1ZFQzQ6IDM1NjY5LAogICAgQk9PTDogMzU2NzAsCiAgICBCT09MX1ZFQzI6IDM1NjcxLAogICAgQk9PTF9WRUMzOiAzNTY3MiwKICAgIEJPT0xfVkVDNDogMzU2NzMsCiAgICBGTE9BVF9NQVQyOiAzNTY3NCwKICAgIEZMT0FUX01BVDM6IDM1Njc1LAogICAgRkxPQVRfTUFUNDogMzU2NzYsCiAgICBTQU1QTEVSXzJEOiAzNTY3OCwKICAgIFNBTVBMRVJfQ1VCRTogMzU2ODAsCiAgICBWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQ6IDM0MzM4LAogICAgVkVSVEVYX0FUVFJJQl9BUlJBWV9TSVpFOiAzNDMzOSwKICAgIFZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFOiAzNDM0MCwKICAgIFZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRTogMzQzNDEsCiAgICBWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQ6IDM0OTIyLAogICAgVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSOiAzNDM3MywKICAgIFZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTc1LAogICAgSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFOiAzNTczOCwKICAgIElNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUOiAzNTczOSwKICAgIENPTVBJTEVfU1RBVFVTOiAzNTcxMywKICAgIExPV19GTE9BVDogMzYzMzYsCiAgICBNRURJVU1fRkxPQVQ6IDM2MzM3LAogICAgSElHSF9GTE9BVDogMzYzMzgsCiAgICBMT1dfSU5UOiAzNjMzOSwKICAgIE1FRElVTV9JTlQ6IDM2MzQwLAogICAgSElHSF9JTlQ6IDM2MzQxLAogICAgRlJBTUVCVUZGRVI6IDM2MTYwLAogICAgUkVOREVSQlVGRkVSOiAzNjE2MSwKICAgIFJHQkE0OiAzMjg1NCwKICAgIFJHQjVfQTE6IDMyODU1LAogICAgUkdCNTY1OiAzNjE5NCwKICAgIERFUFRIX0NPTVBPTkVOVDE2OiAzMzE4OSwKICAgIFNURU5DSUxfSU5ERVg6IDY0MDEsCiAgICBTVEVOQ0lMX0lOREVYODogMzYxNjgsCiAgICBERVBUSF9TVEVOQ0lMOiAzNDA0MSwKICAgIFJFTkRFUkJVRkZFUl9XSURUSDogMzYxNjIsCiAgICBSRU5ERVJCVUZGRVJfSEVJR0hUOiAzNjE2MywKICAgIFJFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQ6IDM2MTY0LAogICAgUkVOREVSQlVGRkVSX1JFRF9TSVpFOiAzNjE3NiwKICAgIFJFTkRFUkJVRkZFUl9HUkVFTl9TSVpFOiAzNjE3NywKICAgIFJFTkRFUkJVRkZFUl9CTFVFX1NJWkU6IDM2MTc4LAogICAgUkVOREVSQlVGRkVSX0FMUEhBX1NJWkU6IDM2MTc5LAogICAgUkVOREVSQlVGRkVSX0RFUFRIX1NJWkU6IDM2MTgwLAogICAgUkVOREVSQlVGRkVSX1NURU5DSUxfU0laRTogMzYxODEsCiAgICBGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFOiAzNjA0OCwKICAgIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUU6IDM2MDQ5LAogICAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMOiAzNjA1MCwKICAgIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFOiAzNjA1MSwKICAgIENPTE9SX0FUVEFDSE1FTlQwOiAzNjA2NCwKICAgIERFUFRIX0FUVEFDSE1FTlQ6IDM2MDk2LAogICAgU1RFTkNJTF9BVFRBQ0hNRU5UOiAzNjEyOCwKICAgIERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDogMzMzMDYsCiAgICBOT05FOiAwLAogICAgRlJBTUVCVUZGRVJfQ09NUExFVEU6IDM2MDUzLAogICAgRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOiAzNjA1NCwKICAgIEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOiAzNjA1NSwKICAgIEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzogMzYwNTcsCiAgICBGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDogMzYwNjEsCiAgICBGUkFNRUJVRkZFUl9CSU5ESU5HOiAzNjAwNiwKICAgIFJFTkRFUkJVRkZFUl9CSU5ESU5HOiAzNjAwNywKICAgIE1BWF9SRU5ERVJCVUZGRVJfU0laRTogMzQwMjQsCiAgICBJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjogMTI4NiwKICAgIFVOUEFDS19GTElQX1lfV0VCR0w6IDM3NDQwLAogICAgVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMOiAzNzQ0MSwKICAgIENPTlRFWFRfTE9TVF9XRUJHTDogMzc0NDIsCiAgICBVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMOiAzNzQ0MywKICAgIEJST1dTRVJfREVGQVVMVF9XRUJHTDogMzc0NDQsCiAgICBDT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUOiAzMzc3NiwKICAgIENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUOiAzMzc3NywKICAgIENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUOiAzMzc3OCwKICAgIENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUOiAzMzc3OSwKICAgIENPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc6IDM1ODQwLAogICAgQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRzogMzU4NDEsCiAgICBDT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRzogMzU4NDIsCiAgICBDT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRzogMzU4NDMsCiAgICBDT01QUkVTU0VEX1JHQkFfQVNUQ180eDRfV0VCR0w6IDM3ODA4LAogICAgQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTDogMzYxOTYsCiAgICBDT01QUkVTU0VEX1JHQkFfQlBUQ19VTk9STTogMzY0OTIsCiAgICBIQUxGX0ZMT0FUX09FUzogMzYxOTMsCiAgICBET1VCTEU6IDUxMzAsCiAgICBSRUFEX0JVRkZFUjogMzA3NCwKICAgIFVOUEFDS19ST1dfTEVOR1RIOiAzMzE0LAogICAgVU5QQUNLX1NLSVBfUk9XUzogMzMxNSwKICAgIFVOUEFDS19TS0lQX1BJWEVMUzogMzMxNiwKICAgIFBBQ0tfUk9XX0xFTkdUSDogMzMzMCwKICAgIFBBQ0tfU0tJUF9ST1dTOiAzMzMxLAogICAgUEFDS19TS0lQX1BJWEVMUzogMzMzMiwKICAgIENPTE9SOiA2MTQ0LAogICAgREVQVEg6IDYxNDUsCiAgICBTVEVOQ0lMOiA2MTQ2LAogICAgUkVEOiA2NDAzLAogICAgUkdCODogMzI4NDksCiAgICBSR0JBODogMzI4NTYsCiAgICBSR0IxMF9BMjogMzI4NTcsCiAgICBURVhUVVJFX0JJTkRJTkdfM0Q6IDMyODc0LAogICAgVU5QQUNLX1NLSVBfSU1BR0VTOiAzMjg3NywKICAgIFVOUEFDS19JTUFHRV9IRUlHSFQ6IDMyODc4LAogICAgVEVYVFVSRV8zRDogMzI4NzksCiAgICBURVhUVVJFX1dSQVBfUjogMzI4ODIsCiAgICBNQVhfM0RfVEVYVFVSRV9TSVpFOiAzMjg4MywKICAgIFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVjogMzM2NDAsCiAgICBNQVhfRUxFTUVOVFNfVkVSVElDRVM6IDMzZTMsCiAgICBNQVhfRUxFTUVOVFNfSU5ESUNFUzogMzMwMDEsCiAgICBURVhUVVJFX01JTl9MT0Q6IDMzMDgyLAogICAgVEVYVFVSRV9NQVhfTE9EOiAzMzA4MywKICAgIFRFWFRVUkVfQkFTRV9MRVZFTDogMzMwODQsCiAgICBURVhUVVJFX01BWF9MRVZFTDogMzMwODUsCiAgICBNSU46IDMyNzc1LAogICAgTUFYOiAzMjc3NiwKICAgIERFUFRIX0NPTVBPTkVOVDI0OiAzMzE5MCwKICAgIE1BWF9URVhUVVJFX0xPRF9CSUFTOiAzNDA0NSwKICAgIFRFWFRVUkVfQ09NUEFSRV9NT0RFOiAzNDg5MiwKICAgIFRFWFRVUkVfQ09NUEFSRV9GVU5DOiAzNDg5MywKICAgIENVUlJFTlRfUVVFUlk6IDM0OTE3LAogICAgUVVFUllfUkVTVUxUOiAzNDkxOCwKICAgIFFVRVJZX1JFU1VMVF9BVkFJTEFCTEU6IDM0OTE5LAogICAgU1RSRUFNX1JFQUQ6IDM1MDQxLAogICAgU1RSRUFNX0NPUFk6IDM1MDQyLAogICAgU1RBVElDX1JFQUQ6IDM1MDQ1LAogICAgU1RBVElDX0NPUFk6IDM1MDQ2LAogICAgRFlOQU1JQ19SRUFEOiAzNTA0OSwKICAgIERZTkFNSUNfQ09QWTogMzUwNTAsCiAgICBNQVhfRFJBV19CVUZGRVJTOiAzNDg1MiwKICAgIERSQVdfQlVGRkVSMDogMzQ4NTMsCiAgICBEUkFXX0JVRkZFUjE6IDM0ODU0LAogICAgRFJBV19CVUZGRVIyOiAzNDg1NSwKICAgIERSQVdfQlVGRkVSMzogMzQ4NTYsCiAgICBEUkFXX0JVRkZFUjQ6IDM0ODU3LAogICAgRFJBV19CVUZGRVI1OiAzNDg1OCwKICAgIERSQVdfQlVGRkVSNjogMzQ4NTksCiAgICBEUkFXX0JVRkZFUjc6IDM0ODYwLAogICAgRFJBV19CVUZGRVI4OiAzNDg2MSwKICAgIERSQVdfQlVGRkVSOTogMzQ4NjIsCiAgICBEUkFXX0JVRkZFUjEwOiAzNDg2MywKICAgIERSQVdfQlVGRkVSMTE6IDM0ODY0LAogICAgRFJBV19CVUZGRVIxMjogMzQ4NjUsCiAgICBEUkFXX0JVRkZFUjEzOiAzNDg2NiwKICAgIERSQVdfQlVGRkVSMTQ6IDM0ODY3LAogICAgRFJBV19CVUZGRVIxNTogMzQ4NjgsCiAgICBNQVhfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTOiAzNTY1NywKICAgIE1BWF9WRVJURVhfVU5JRk9STV9DT01QT05FTlRTOiAzNTY1OCwKICAgIFNBTVBMRVJfM0Q6IDM1Njc5LAogICAgU0FNUExFUl8yRF9TSEFET1c6IDM1NjgyLAogICAgRlJBR01FTlRfU0hBREVSX0RFUklWQVRJVkVfSElOVDogMzU3MjMsCiAgICBQSVhFTF9QQUNLX0JVRkZFUjogMzUwNTEsCiAgICBQSVhFTF9VTlBBQ0tfQlVGRkVSOiAzNTA1MiwKICAgIFBJWEVMX1BBQ0tfQlVGRkVSX0JJTkRJTkc6IDM1MDUzLAogICAgUElYRUxfVU5QQUNLX0JVRkZFUl9CSU5ESU5HOiAzNTA1NSwKICAgIEZMT0FUX01BVDJ4MzogMzU2ODUsCiAgICBGTE9BVF9NQVQyeDQ6IDM1Njg2LAogICAgRkxPQVRfTUFUM3gyOiAzNTY4NywKICAgIEZMT0FUX01BVDN4NDogMzU2ODgsCiAgICBGTE9BVF9NQVQ0eDI6IDM1Njg5LAogICAgRkxPQVRfTUFUNHgzOiAzNTY5MCwKICAgIFNSR0I6IDM1OTA0LAogICAgU1JHQjg6IDM1OTA1LAogICAgU1JHQjhfQUxQSEE4OiAzNTkwNywKICAgIENPTVBBUkVfUkVGX1RPX1RFWFRVUkU6IDM0ODk0LAogICAgUkdCQTMyRjogMzQ4MzYsCiAgICBSR0IzMkY6IDM0ODM3LAogICAgUkdCQTE2RjogMzQ4NDIsCiAgICBSR0IxNkY6IDM0ODQzLAogICAgVkVSVEVYX0FUVFJJQl9BUlJBWV9JTlRFR0VSOiAzNTA2OSwKICAgIE1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUzogMzUwNzEsCiAgICBNSU5fUFJPR1JBTV9URVhFTF9PRkZTRVQ6IDM1MDc2LAogICAgTUFYX1BST0dSQU1fVEVYRUxfT0ZGU0VUOiAzNTA3NywKICAgIE1BWF9WQVJZSU5HX0NPTVBPTkVOVFM6IDM1NjU5LAogICAgVEVYVFVSRV8yRF9BUlJBWTogMzU4NjYsCiAgICBURVhUVVJFX0JJTkRJTkdfMkRfQVJSQVk6IDM1ODY5LAogICAgUjExRl9HMTFGX0IxMEY6IDM1ODk4LAogICAgVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVjogMzU4OTksCiAgICBSR0I5X0U1OiAzNTkwMSwKICAgIFVOU0lHTkVEX0lOVF81XzlfOV85X1JFVjogMzU5MDIsCiAgICBUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX01PREU6IDM1OTY3LAogICAgTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9DT01QT05FTlRTOiAzNTk2OCwKICAgIFRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUzogMzU5NzEsCiAgICBUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX1NUQVJUOiAzNTk3MiwKICAgIFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU0laRTogMzU5NzMsCiAgICBUUkFOU0ZPUk1fRkVFREJBQ0tfUFJJTUlUSVZFU19XUklUVEVOOiAzNTk3NiwKICAgIFJBU1RFUklaRVJfRElTQ0FSRDogMzU5NzcsCiAgICBNQVhfVFJBTlNGT1JNX0ZFRURCQUNLX0lOVEVSTEVBVkVEX0NPTVBPTkVOVFM6IDM1OTc4LAogICAgTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9BVFRSSUJTOiAzNTk3OSwKICAgIElOVEVSTEVBVkVEX0FUVFJJQlM6IDM1OTgwLAogICAgU0VQQVJBVEVfQVRUUklCUzogMzU5ODEsCiAgICBUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSOiAzNTk4MiwKICAgIFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfQklORElORzogMzU5ODMsCiAgICBSR0JBMzJVSTogMzYyMDgsCiAgICBSR0IzMlVJOiAzNjIwOSwKICAgIFJHQkExNlVJOiAzNjIxNCwKICAgIFJHQjE2VUk6IDM2MjE1LAogICAgUkdCQThVSTogMzYyMjAsCiAgICBSR0I4VUk6IDM2MjIxLAogICAgUkdCQTMySTogMzYyMjYsCiAgICBSR0IzMkk6IDM2MjI3LAogICAgUkdCQTE2STogMzYyMzIsCiAgICBSR0IxNkk6IDM2MjMzLAogICAgUkdCQThJOiAzNjIzOCwKICAgIFJHQjhJOiAzNjIzOSwKICAgIFJFRF9JTlRFR0VSOiAzNjI0NCwKICAgIFJHQl9JTlRFR0VSOiAzNjI0OCwKICAgIFJHQkFfSU5URUdFUjogMzYyNDksCiAgICBTQU1QTEVSXzJEX0FSUkFZOiAzNjI4OSwKICAgIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XOiAzNjI5MiwKICAgIFNBTVBMRVJfQ1VCRV9TSEFET1c6IDM2MjkzLAogICAgVU5TSUdORURfSU5UX1ZFQzI6IDM2Mjk0LAogICAgVU5TSUdORURfSU5UX1ZFQzM6IDM2Mjk1LAogICAgVU5TSUdORURfSU5UX1ZFQzQ6IDM2Mjk2LAogICAgSU5UX1NBTVBMRVJfMkQ6IDM2Mjk4LAogICAgSU5UX1NBTVBMRVJfM0Q6IDM2Mjk5LAogICAgSU5UX1NBTVBMRVJfQ1VCRTogMzYzMDAsCiAgICBJTlRfU0FNUExFUl8yRF9BUlJBWTogMzYzMDMsCiAgICBVTlNJR05FRF9JTlRfU0FNUExFUl8yRDogMzYzMDYsCiAgICBVTlNJR05FRF9JTlRfU0FNUExFUl8zRDogMzYzMDcsCiAgICBVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFOiAzNjMwOCwKICAgIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZOiAzNjMxMSwKICAgIERFUFRIX0NPTVBPTkVOVDMyRjogMzYwMTIsCiAgICBERVBUSDMyRl9TVEVOQ0lMODogMzYwMTMsCiAgICBGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVY6IDM2MjY5LAogICAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9DT0xPUl9FTkNPRElORzogMzMyOTYsCiAgICBGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFOiAzMzI5NywKICAgIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfUkVEX1NJWkU6IDMzMjk4LAogICAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9HUkVFTl9TSVpFOiAzMzI5OSwKICAgIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFOiAzMzMwMCwKICAgIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQUxQSEFfU0laRTogMzMzMDEsCiAgICBGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0RFUFRIX1NJWkU6IDMzMzAyLAogICAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkU6IDMzMzAzLAogICAgRlJBTUVCVUZGRVJfREVGQVVMVDogMzMzMDQsCiAgICBVTlNJR05FRF9JTlRfMjRfODogMzQwNDIsCiAgICBERVBUSDI0X1NURU5DSUw4OiAzNTA1NiwKICAgIFVOU0lHTkVEX05PUk1BTElaRUQ6IDM1ODYzLAogICAgRFJBV19GUkFNRUJVRkZFUl9CSU5ESU5HOiAzNjAwNiwKICAgIFJFQURfRlJBTUVCVUZGRVI6IDM2MDA4LAogICAgRFJBV19GUkFNRUJVRkZFUjogMzYwMDksCiAgICBSRUFEX0ZSQU1FQlVGRkVSX0JJTkRJTkc6IDM2MDEwLAogICAgUkVOREVSQlVGRkVSX1NBTVBMRVM6IDM2MDExLAogICAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xBWUVSOiAzNjA1MiwKICAgIE1BWF9DT0xPUl9BVFRBQ0hNRU5UUzogMzYwNjMsCiAgICBDT0xPUl9BVFRBQ0hNRU5UMTogMzYwNjUsCiAgICBDT0xPUl9BVFRBQ0hNRU5UMjogMzYwNjYsCiAgICBDT0xPUl9BVFRBQ0hNRU5UMzogMzYwNjcsCiAgICBDT0xPUl9BVFRBQ0hNRU5UNDogMzYwNjgsCiAgICBDT0xPUl9BVFRBQ0hNRU5UNTogMzYwNjksCiAgICBDT0xPUl9BVFRBQ0hNRU5UNjogMzYwNzAsCiAgICBDT0xPUl9BVFRBQ0hNRU5UNzogMzYwNzEsCiAgICBDT0xPUl9BVFRBQ0hNRU5UODogMzYwNzIsCiAgICBDT0xPUl9BVFRBQ0hNRU5UOTogMzYwNzMsCiAgICBDT0xPUl9BVFRBQ0hNRU5UMTA6IDM2MDc0LAogICAgQ09MT1JfQVRUQUNITUVOVDExOiAzNjA3NSwKICAgIENPTE9SX0FUVEFDSE1FTlQxMjogMzYwNzYsCiAgICBDT0xPUl9BVFRBQ0hNRU5UMTM6IDM2MDc3LAogICAgQ09MT1JfQVRUQUNITUVOVDE0OiAzNjA3OCwKICAgIENPTE9SX0FUVEFDSE1FTlQxNTogMzYwNzksCiAgICBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01VTFRJU0FNUExFOiAzNjE4MiwKICAgIE1BWF9TQU1QTEVTOiAzNjE4MywKICAgIEhBTEZfRkxPQVQ6IDUxMzEsCiAgICBSRzogMzMzMTksCiAgICBSR19JTlRFR0VSOiAzMzMyMCwKICAgIFI4OiAzMzMyMSwKICAgIFJHODogMzMzMjMsCiAgICBSMTZGOiAzMzMyNSwKICAgIFIzMkY6IDMzMzI2LAogICAgUkcxNkY6IDMzMzI3LAogICAgUkczMkY6IDMzMzI4LAogICAgUjhJOiAzMzMyOSwKICAgIFI4VUk6IDMzMzMwLAogICAgUjE2STogMzMzMzEsCiAgICBSMTZVSTogMzMzMzIsCiAgICBSMzJJOiAzMzMzMywKICAgIFIzMlVJOiAzMzMzNCwKICAgIFJHOEk6IDMzMzM1LAogICAgUkc4VUk6IDMzMzM2LAogICAgUkcxNkk6IDMzMzM3LAogICAgUkcxNlVJOiAzMzMzOCwKICAgIFJHMzJJOiAzMzMzOSwKICAgIFJHMzJVSTogMzMzNDAsCiAgICBWRVJURVhfQVJSQVlfQklORElORzogMzQyMjksCiAgICBSOF9TTk9STTogMzY3NTYsCiAgICBSRzhfU05PUk06IDM2NzU3LAogICAgUkdCOF9TTk9STTogMzY3NTgsCiAgICBSR0JBOF9TTk9STTogMzY3NTksCiAgICBTSUdORURfTk9STUFMSVpFRDogMzY3NjQsCiAgICBDT1BZX1JFQURfQlVGRkVSOiAzNjY2MiwKICAgIENPUFlfV1JJVEVfQlVGRkVSOiAzNjY2MywKICAgIENPUFlfUkVBRF9CVUZGRVJfQklORElORzogMzY2NjIsCiAgICBDT1BZX1dSSVRFX0JVRkZFUl9CSU5ESU5HOiAzNjY2MywKICAgIFVOSUZPUk1fQlVGRkVSOiAzNTM0NSwKICAgIFVOSUZPUk1fQlVGRkVSX0JJTkRJTkc6IDM1MzY4LAogICAgVU5JRk9STV9CVUZGRVJfU1RBUlQ6IDM1MzY5LAogICAgVU5JRk9STV9CVUZGRVJfU0laRTogMzUzNzAsCiAgICBNQVhfVkVSVEVYX1VOSUZPUk1fQkxPQ0tTOiAzNTM3MSwKICAgIE1BWF9GUkFHTUVOVF9VTklGT1JNX0JMT0NLUzogMzUzNzMsCiAgICBNQVhfQ09NQklORURfVU5JRk9STV9CTE9DS1M6IDM1Mzc0LAogICAgTUFYX1VOSUZPUk1fQlVGRkVSX0JJTkRJTkdTOiAzNTM3NSwKICAgIE1BWF9VTklGT1JNX0JMT0NLX1NJWkU6IDM1Mzc2LAogICAgTUFYX0NPTUJJTkVEX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFM6IDM1Mzc3LAogICAgTUFYX0NPTUJJTkVEX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UUzogMzUzNzksCiAgICBVTklGT1JNX0JVRkZFUl9PRkZTRVRfQUxJR05NRU5UOiAzNTM4MCwKICAgIEFDVElWRV9VTklGT1JNX0JMT0NLUzogMzUzODIsCiAgICBVTklGT1JNX1RZUEU6IDM1MzgzLAogICAgVU5JRk9STV9TSVpFOiAzNTM4NCwKICAgIFVOSUZPUk1fQkxPQ0tfSU5ERVg6IDM1Mzg2LAogICAgVU5JRk9STV9PRkZTRVQ6IDM1Mzg3LAogICAgVU5JRk9STV9BUlJBWV9TVFJJREU6IDM1Mzg4LAogICAgVU5JRk9STV9NQVRSSVhfU1RSSURFOiAzNTM4OSwKICAgIFVOSUZPUk1fSVNfUk9XX01BSk9SOiAzNTM5MCwKICAgIFVOSUZPUk1fQkxPQ0tfQklORElORzogMzUzOTEsCiAgICBVTklGT1JNX0JMT0NLX0RBVEFfU0laRTogMzUzOTIsCiAgICBVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNUzogMzUzOTQsCiAgICBVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNX0lORElDRVM6IDM1Mzk1LAogICAgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVI6IDM1Mzk2LAogICAgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX0ZSQUdNRU5UX1NIQURFUjogMzUzOTgsCiAgICBJTlZBTElEX0lOREVYOiA0Mjk0OTY3Mjk1LAogICAgTUFYX1ZFUlRFWF9PVVRQVVRfQ09NUE9ORU5UUzogMzcxNTQsCiAgICBNQVhfRlJBR01FTlRfSU5QVVRfQ09NUE9ORU5UUzogMzcxNTcsCiAgICBNQVhfU0VSVkVSX1dBSVRfVElNRU9VVDogMzcxMzcsCiAgICBPQkpFQ1RfVFlQRTogMzcxMzgsCiAgICBTWU5DX0NPTkRJVElPTjogMzcxMzksCiAgICBTWU5DX1NUQVRVUzogMzcxNDAsCiAgICBTWU5DX0ZMQUdTOiAzNzE0MSwKICAgIFNZTkNfRkVOQ0U6IDM3MTQyLAogICAgU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEU6IDM3MTQzLAogICAgVU5TSUdOQUxFRDogMzcxNDQsCiAgICBTSUdOQUxFRDogMzcxNDUsCiAgICBBTFJFQURZX1NJR05BTEVEOiAzNzE0NiwKICAgIFRJTUVPVVRfRVhQSVJFRDogMzcxNDcsCiAgICBDT05ESVRJT05fU0FUSVNGSUVEOiAzNzE0OCwKICAgIFdBSVRfRkFJTEVEOiAzNzE0OSwKICAgIFNZTkNfRkxVU0hfQ09NTUFORFNfQklUOiAxLAogICAgVkVSVEVYX0FUVFJJQl9BUlJBWV9ESVZJU09SOiAzNTA3MCwKICAgIEFOWV9TQU1QTEVTX1BBU1NFRDogMzU4ODcsCiAgICBBTllfU0FNUExFU19QQVNTRURfQ09OU0VSVkFUSVZFOiAzNjIwMiwKICAgIFNBTVBMRVJfQklORElORzogMzUwOTcsCiAgICBSR0IxMF9BMlVJOiAzNjk3NSwKICAgIElOVF8yXzEwXzEwXzEwX1JFVjogMzYyNTUsCiAgICBUUkFOU0ZPUk1fRkVFREJBQ0s6IDM2Mzg2LAogICAgVFJBTlNGT1JNX0ZFRURCQUNLX1BBVVNFRDogMzYzODcsCiAgICBUUkFOU0ZPUk1fRkVFREJBQ0tfQUNUSVZFOiAzNjM4OCwKICAgIFRSQU5TRk9STV9GRUVEQkFDS19CSU5ESU5HOiAzNjM4OSwKICAgIENPTVBSRVNTRURfUjExX0VBQzogMzc0ODgsCiAgICBDT01QUkVTU0VEX1NJR05FRF9SMTFfRUFDOiAzNzQ4OSwKICAgIENPTVBSRVNTRURfUkcxMV9FQUM6IDM3NDkwLAogICAgQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUM6IDM3NDkxLAogICAgQ09NUFJFU1NFRF9SR0I4X0VUQzI6IDM3NDkyLAogICAgQ09NUFJFU1NFRF9TUkdCOF9FVEMyOiAzNzQ5MywKICAgIENPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzI6IDM3NDk0LAogICAgQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzI6IDM3NDk1LAogICAgQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQzogMzc0OTYsCiAgICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQzogMzc0OTcsCiAgICBURVhUVVJFX0lNTVVUQUJMRV9GT1JNQVQ6IDM3MTY3LAogICAgTUFYX0VMRU1FTlRfSU5ERVg6IDM2MjAzLAogICAgVEVYVFVSRV9JTU1VVEFCTEVfTEVWRUxTOiAzMzUwMywKICAgIE1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVDogMzQwNDcKICB9OwogIHZhciBXZWJHTENvbnN0YW50c19kZWZhdWx0ID0gT2JqZWN0LmZyZWV6ZShXZWJHTENvbnN0YW50cyk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9kZXN0cm95T2JqZWN0LmpzCiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsKICAgIHJldHVybiB0cnVlOwogIH0KICBmdW5jdGlvbiBkZXN0cm95T2JqZWN0KG9iamVjdCwgbWVzc2FnZSkgewogICAgbWVzc2FnZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBtZXNzYWdlLAogICAgICAiVGhpcyBvYmplY3Qgd2FzIGRlc3Ryb3llZCwgaS5lLiwgZGVzdHJveSgpIHdhcyBjYWxsZWQuIgogICAgKTsKICAgIGZ1bmN0aW9uIHRocm93T25EZXN0cm95ZWQoKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KG1lc3NhZ2UpOwogICAgfQogICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7CiAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBvYmplY3Rba2V5XSA9IHRocm93T25EZXN0cm95ZWQ7CiAgICAgIH0KICAgIH0KICAgIG9iamVjdC5pc0Rlc3Ryb3llZCA9IHJldHVyblRydWU7CiAgICByZXR1cm4gdm9pZCAwOwogIH0KICB2YXIgZGVzdHJveU9iamVjdF9kZWZhdWx0ID0gZGVzdHJveU9iamVjdDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0luZGV4RGF0YXR5cGUuanMKICB2YXIgSW5kZXhEYXRhdHlwZSA9IHsKICAgIFVOU0lHTkVEX0JZVEU6IFdlYkdMQ29uc3RhbnRzX2RlZmF1bHQuVU5TSUdORURfQllURSwKICAgIFVOU0lHTkVEX1NIT1JUOiBXZWJHTENvbnN0YW50c19kZWZhdWx0LlVOU0lHTkVEX1NIT1JULAogICAgVU5TSUdORURfSU5UOiBXZWJHTENvbnN0YW50c19kZWZhdWx0LlVOU0lHTkVEX0lOVAogIH07CiAgSW5kZXhEYXRhdHlwZS5nZXRTaXplSW5CeXRlcyA9IGZ1bmN0aW9uKGluZGV4RGF0YXR5cGUpIHsKICAgIHN3aXRjaCAoaW5kZXhEYXRhdHlwZSkgewogICAgICBjYXNlIEluZGV4RGF0YXR5cGUuVU5TSUdORURfQllURToKICAgICAgICByZXR1cm4gVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgY2FzZSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX1NIT1JUOgogICAgICAgIHJldHVybiBVaW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgY2FzZSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0lOVDoKICAgICAgICByZXR1cm4gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICB9CiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgImluZGV4RGF0YXR5cGUgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSB2YWxpZCBJbmRleERhdGF0eXBlIGNvbnN0YW50LiIKICAgICk7CiAgfTsKICBJbmRleERhdGF0eXBlLmZyb21TaXplSW5CeXRlcyA9IGZ1bmN0aW9uKHNpemVJbkJ5dGVzKSB7CiAgICBzd2l0Y2ggKHNpemVJbkJ5dGVzKSB7CiAgICAgIGNhc2UgMjoKICAgICAgICByZXR1cm4gSW5kZXhEYXRhdHlwZS5VTlNJR05FRF9TSE9SVDsKICAgICAgY2FzZSA0OgogICAgICAgIHJldHVybiBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0lOVDsKICAgICAgY2FzZSAxOgogICAgICAgIHJldHVybiBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0JZVEU7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgICAiU2l6ZSBpbiBieXRlcyBjYW5ub3QgYmUgbWFwcGVkIHRvIGFuIEluZGV4RGF0YXR5cGUiCiAgICAgICAgKTsKICAgIH0KICB9OwogIEluZGV4RGF0YXR5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihpbmRleERhdGF0eXBlKSB7CiAgICByZXR1cm4gZGVmaW5lZF9kZWZhdWx0KGluZGV4RGF0YXR5cGUpICYmIChpbmRleERhdGF0eXBlID09PSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0JZVEUgfHwgaW5kZXhEYXRhdHlwZSA9PT0gSW5kZXhEYXRhdHlwZS5VTlNJR05FRF9TSE9SVCB8fCBpbmRleERhdGF0eXBlID09PSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0lOVCk7CiAgfTsKICBJbmRleERhdGF0eXBlLmNyZWF0ZVR5cGVkQXJyYXkgPSBmdW5jdGlvbihudW1iZXJPZlZlcnRpY2VzLCBpbmRpY2VzTGVuZ3RoT3JBcnJheSkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQobnVtYmVyT2ZWZXJ0aWNlcykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm51bWJlck9mVmVydGljZXMgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAobnVtYmVyT2ZWZXJ0aWNlcyA+PSBNYXRoX2RlZmF1bHQuU0lYVFlfRk9VUl9LSUxPQllURVMpIHsKICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShpbmRpY2VzTGVuZ3RoT3JBcnJheSk7CiAgICB9CiAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGluZGljZXNMZW5ndGhPckFycmF5KTsKICB9OwogIEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKG51bWJlck9mVmVydGljZXMsIHNvdXJjZUFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG51bWJlck9mVmVydGljZXMpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJudW1iZXJPZlZlcnRpY2VzIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoc291cmNlQXJyYXkpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJzb3VyY2VBcnJheSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJ5dGVPZmZzZXQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJieXRlT2Zmc2V0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKG51bWJlck9mVmVydGljZXMgPj0gTWF0aF9kZWZhdWx0LlNJWFRZX0ZPVVJfS0lMT0JZVEVTKSB7CiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoc291cmNlQXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CiAgICB9CiAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KHNvdXJjZUFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpOwogIH07CiAgSW5kZXhEYXRhdHlwZS5mcm9tVHlwZWRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7CiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7CiAgICAgIHJldHVybiBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0JZVEU7CiAgICB9CiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkgewogICAgICByZXR1cm4gSW5kZXhEYXRhdHlwZS5VTlNJR05FRF9TSE9SVDsKICAgIH0KICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7CiAgICAgIHJldHVybiBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0lOVDsKICAgIH0KICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAiYXJyYXkgbXVzdCBiZSBhIFVpbnQ4QXJyYXksIFVpbnQxNkFycmF5LCBvciBVaW50MzJBcnJheS4iCiAgICApOwogIH07CiAgdmFyIEluZGV4RGF0YXR5cGVfZGVmYXVsdCA9IE9iamVjdC5mcmVlemUoSW5kZXhEYXRhdHlwZSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9GdWxsc2NyZWVuLmpzCiAgdmFyIF9zdXBwb3J0c0Z1bGxzY3JlZW47CiAgdmFyIF9uYW1lcyA9IHsKICAgIHJlcXVlc3RGdWxsc2NyZWVuOiB2b2lkIDAsCiAgICBleGl0RnVsbHNjcmVlbjogdm9pZCAwLAogICAgZnVsbHNjcmVlbkVuYWJsZWQ6IHZvaWQgMCwKICAgIGZ1bGxzY3JlZW5FbGVtZW50OiB2b2lkIDAsCiAgICBmdWxsc2NyZWVuY2hhbmdlOiB2b2lkIDAsCiAgICBmdWxsc2NyZWVuZXJyb3I6IHZvaWQgMAogIH07CiAgdmFyIEZ1bGxzY3JlZW4gPSB7fTsKICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGdWxsc2NyZWVuLCB7CiAgICBlbGVtZW50OiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKCFGdWxsc2NyZWVuLnN1cHBvcnRzRnVsbHNjcmVlbigpKSB7CiAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZG9jdW1lbnRbX25hbWVzLmZ1bGxzY3JlZW5FbGVtZW50XTsKICAgICAgfQogICAgfSwKICAgIGNoYW5nZUV2ZW50TmFtZTogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghRnVsbHNjcmVlbi5zdXBwb3J0c0Z1bGxzY3JlZW4oKSkgewogICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9uYW1lcy5mdWxsc2NyZWVuY2hhbmdlOwogICAgICB9CiAgICB9LAogICAgZXJyb3JFdmVudE5hbWU6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICBpZiAoIUZ1bGxzY3JlZW4uc3VwcG9ydHNGdWxsc2NyZWVuKCkpIHsKICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBfbmFtZXMuZnVsbHNjcmVlbmVycm9yOwogICAgICB9CiAgICB9LAogICAgZW5hYmxlZDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghRnVsbHNjcmVlbi5zdXBwb3J0c0Z1bGxzY3JlZW4oKSkgewogICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRvY3VtZW50W19uYW1lcy5mdWxsc2NyZWVuRW5hYmxlZF07CiAgICAgIH0KICAgIH0sCiAgICBmdWxsc2NyZWVuOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKCFGdWxsc2NyZWVuLnN1cHBvcnRzRnVsbHNjcmVlbigpKSB7CiAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gRnVsbHNjcmVlbi5lbGVtZW50ICE9PSBudWxsOwogICAgICB9CiAgICB9CiAgfSk7CiAgRnVsbHNjcmVlbi5zdXBwb3J0c0Z1bGxzY3JlZW4gPSBmdW5jdGlvbigpIHsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoX3N1cHBvcnRzRnVsbHNjcmVlbikpIHsKICAgICAgcmV0dXJuIF9zdXBwb3J0c0Z1bGxzY3JlZW47CiAgICB9CiAgICBfc3VwcG9ydHNGdWxsc2NyZWVuID0gZmFsc2U7CiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTsKICAgIGlmICh0eXBlb2YgYm9keS5yZXF1ZXN0RnVsbHNjcmVlbiA9PT0gImZ1bmN0aW9uIikgewogICAgICBfbmFtZXMucmVxdWVzdEZ1bGxzY3JlZW4gPSAicmVxdWVzdEZ1bGxzY3JlZW4iOwogICAgICBfbmFtZXMuZXhpdEZ1bGxzY3JlZW4gPSAiZXhpdEZ1bGxzY3JlZW4iOwogICAgICBfbmFtZXMuZnVsbHNjcmVlbkVuYWJsZWQgPSAiZnVsbHNjcmVlbkVuYWJsZWQiOwogICAgICBfbmFtZXMuZnVsbHNjcmVlbkVsZW1lbnQgPSAiZnVsbHNjcmVlbkVsZW1lbnQiOwogICAgICBfbmFtZXMuZnVsbHNjcmVlbmNoYW5nZSA9ICJmdWxsc2NyZWVuY2hhbmdlIjsKICAgICAgX25hbWVzLmZ1bGxzY3JlZW5lcnJvciA9ICJmdWxsc2NyZWVuZXJyb3IiOwogICAgICBfc3VwcG9ydHNGdWxsc2NyZWVuID0gdHJ1ZTsKICAgICAgcmV0dXJuIF9zdXBwb3J0c0Z1bGxzY3JlZW47CiAgICB9CiAgICBjb25zdCBwcmVmaXhlcyA9IFsid2Via2l0IiwgIm1veiIsICJvIiwgIm1zIiwgImtodG1sIl07CiAgICBsZXQgbmFtZTsKICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwcmVmaXhlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkgewogICAgICBjb25zdCBwcmVmaXggPSBwcmVmaXhlc1tpXTsKICAgICAgbmFtZSA9IGAke3ByZWZpeH1SZXF1ZXN0RnVsbHNjcmVlbmA7CiAgICAgIGlmICh0eXBlb2YgYm9keVtuYW1lXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIF9uYW1lcy5yZXF1ZXN0RnVsbHNjcmVlbiA9IG5hbWU7CiAgICAgICAgX3N1cHBvcnRzRnVsbHNjcmVlbiA9IHRydWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbmFtZSA9IGAke3ByZWZpeH1SZXF1ZXN0RnVsbFNjcmVlbmA7CiAgICAgICAgaWYgKHR5cGVvZiBib2R5W25hbWVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBfbmFtZXMucmVxdWVzdEZ1bGxzY3JlZW4gPSBuYW1lOwogICAgICAgICAgX3N1cHBvcnRzRnVsbHNjcmVlbiA9IHRydWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIG5hbWUgPSBgJHtwcmVmaXh9RXhpdEZ1bGxzY3JlZW5gOwogICAgICBpZiAodHlwZW9mIGRvY3VtZW50W25hbWVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgX25hbWVzLmV4aXRGdWxsc2NyZWVuID0gbmFtZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBuYW1lID0gYCR7cHJlZml4fUNhbmNlbEZ1bGxTY3JlZW5gOwogICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRbbmFtZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIF9uYW1lcy5leGl0RnVsbHNjcmVlbiA9IG5hbWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIG5hbWUgPSBgJHtwcmVmaXh9RnVsbHNjcmVlbkVuYWJsZWRgOwogICAgICBpZiAoZG9jdW1lbnRbbmFtZV0gIT09IHZvaWQgMCkgewogICAgICAgIF9uYW1lcy5mdWxsc2NyZWVuRW5hYmxlZCA9IG5hbWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbmFtZSA9IGAke3ByZWZpeH1GdWxsU2NyZWVuRW5hYmxlZGA7CiAgICAgICAgaWYgKGRvY3VtZW50W25hbWVdICE9PSB2b2lkIDApIHsKICAgICAgICAgIF9uYW1lcy5mdWxsc2NyZWVuRW5hYmxlZCA9IG5hbWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIG5hbWUgPSBgJHtwcmVmaXh9RnVsbHNjcmVlbkVsZW1lbnRgOwogICAgICBpZiAoZG9jdW1lbnRbbmFtZV0gIT09IHZvaWQgMCkgewogICAgICAgIF9uYW1lcy5mdWxsc2NyZWVuRWxlbWVudCA9IG5hbWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbmFtZSA9IGAke3ByZWZpeH1GdWxsU2NyZWVuRWxlbWVudGA7CiAgICAgICAgaWYgKGRvY3VtZW50W25hbWVdICE9PSB2b2lkIDApIHsKICAgICAgICAgIF9uYW1lcy5mdWxsc2NyZWVuRWxlbWVudCA9IG5hbWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIG5hbWUgPSBgJHtwcmVmaXh9ZnVsbHNjcmVlbmNoYW5nZWA7CiAgICAgIGlmIChkb2N1bWVudFtgb24ke25hbWV9YF0gIT09IHZvaWQgMCkgewogICAgICAgIGlmIChwcmVmaXggPT09ICJtcyIpIHsKICAgICAgICAgIG5hbWUgPSAiTVNGdWxsc2NyZWVuQ2hhbmdlIjsKICAgICAgICB9CiAgICAgICAgX25hbWVzLmZ1bGxzY3JlZW5jaGFuZ2UgPSBuYW1lOwogICAgICB9CiAgICAgIG5hbWUgPSBgJHtwcmVmaXh9ZnVsbHNjcmVlbmVycm9yYDsKICAgICAgaWYgKGRvY3VtZW50W2BvbiR7bmFtZX1gXSAhPT0gdm9pZCAwKSB7CiAgICAgICAgaWYgKHByZWZpeCA9PT0gIm1zIikgewogICAgICAgICAgbmFtZSA9ICJNU0Z1bGxzY3JlZW5FcnJvciI7CiAgICAgICAgfQogICAgICAgIF9uYW1lcy5mdWxsc2NyZWVuZXJyb3IgPSBuYW1lOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gX3N1cHBvcnRzRnVsbHNjcmVlbjsKICB9OwogIEZ1bGxzY3JlZW4ucmVxdWVzdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbihlbGVtZW50LCB2ckRldmljZSkgewogICAgaWYgKCFGdWxsc2NyZWVuLnN1cHBvcnRzRnVsbHNjcmVlbigpKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGVsZW1lbnRbX25hbWVzLnJlcXVlc3RGdWxsc2NyZWVuXSh7IHZyRGlzcGxheTogdnJEZXZpY2UgfSk7CiAgfTsKICBGdWxsc2NyZWVuLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7CiAgICBpZiAoIUZ1bGxzY3JlZW4uc3VwcG9ydHNGdWxsc2NyZWVuKCkpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgZG9jdW1lbnRbX25hbWVzLmV4aXRGdWxsc2NyZWVuXSgpOwogIH07CiAgRnVsbHNjcmVlbi5fbmFtZXMgPSBfbmFtZXM7CiAgdmFyIEZ1bGxzY3JlZW5fZGVmYXVsdCA9IEZ1bGxzY3JlZW47CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9GZWF0dXJlRGV0ZWN0aW9uLmpzCiAgdmFyIHRoZU5hdmlnYXRvcjsKICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gInVuZGVmaW5lZCIpIHsKICAgIHRoZU5hdmlnYXRvciA9IG5hdmlnYXRvcjsKICB9IGVsc2UgewogICAgdGhlTmF2aWdhdG9yID0ge307CiAgfQogIGZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKHZlcnNpb25TdHJpbmcpIHsKICAgIGNvbnN0IHBhcnRzID0gdmVyc2lvblN0cmluZy5zcGxpdCgiLiIpOwogICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgIHBhcnRzW2ldID0gcGFyc2VJbnQocGFydHNbaV0sIDEwKTsKICAgIH0KICAgIHJldHVybiBwYXJ0czsKICB9CiAgdmFyIGlzQ2hyb21lUmVzdWx0OwogIHZhciBjaHJvbWVWZXJzaW9uUmVzdWx0OwogIGZ1bmN0aW9uIGlzQ2hyb21lKCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaXNDaHJvbWVSZXN1bHQpKSB7CiAgICAgIGlzQ2hyb21lUmVzdWx0ID0gZmFsc2U7CiAgICAgIGlmICghaXNFZGdlKCkpIHsKICAgICAgICBjb25zdCBmaWVsZHMgPSAvIENocm9tZVwvKFtcLjAtOV0rKS8uZXhlYyh0aGVOYXZpZ2F0b3IudXNlckFnZW50KTsKICAgICAgICBpZiAoZmllbGRzICE9PSBudWxsKSB7CiAgICAgICAgICBpc0Nocm9tZVJlc3VsdCA9IHRydWU7CiAgICAgICAgICBjaHJvbWVWZXJzaW9uUmVzdWx0ID0gZXh0cmFjdFZlcnNpb24oZmllbGRzWzFdKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBpc0Nocm9tZVJlc3VsdDsKICB9CiAgZnVuY3Rpb24gY2hyb21lVmVyc2lvbigpIHsKICAgIHJldHVybiBpc0Nocm9tZSgpICYmIGNocm9tZVZlcnNpb25SZXN1bHQ7CiAgfQogIHZhciBpc1NhZmFyaVJlc3VsdDsKICB2YXIgc2FmYXJpVmVyc2lvblJlc3VsdDsKICBmdW5jdGlvbiBpc1NhZmFyaSgpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGlzU2FmYXJpUmVzdWx0KSkgewogICAgICBpc1NhZmFyaVJlc3VsdCA9IGZhbHNlOwogICAgICBpZiAoIWlzQ2hyb21lKCkgJiYgIWlzRWRnZSgpICYmIC8gU2FmYXJpXC9bXC4wLTldKy8udGVzdCh0aGVOYXZpZ2F0b3IudXNlckFnZW50KSkgewogICAgICAgIGNvbnN0IGZpZWxkcyA9IC8gVmVyc2lvblwvKFtcLjAtOV0rKS8uZXhlYyh0aGVOYXZpZ2F0b3IudXNlckFnZW50KTsKICAgICAgICBpZiAoZmllbGRzICE9PSBudWxsKSB7CiAgICAgICAgICBpc1NhZmFyaVJlc3VsdCA9IHRydWU7CiAgICAgICAgICBzYWZhcmlWZXJzaW9uUmVzdWx0ID0gZXh0cmFjdFZlcnNpb24oZmllbGRzWzFdKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBpc1NhZmFyaVJlc3VsdDsKICB9CiAgZnVuY3Rpb24gc2FmYXJpVmVyc2lvbigpIHsKICAgIHJldHVybiBpc1NhZmFyaSgpICYmIHNhZmFyaVZlcnNpb25SZXN1bHQ7CiAgfQogIHZhciBpc1dlYmtpdFJlc3VsdDsKICB2YXIgd2Via2l0VmVyc2lvblJlc3VsdDsKICBmdW5jdGlvbiBpc1dlYmtpdCgpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGlzV2Via2l0UmVzdWx0KSkgewogICAgICBpc1dlYmtpdFJlc3VsdCA9IGZhbHNlOwogICAgICBjb25zdCBmaWVsZHMgPSAvIEFwcGxlV2ViS2l0XC8oW1wuMC05XSspKFwrPykvLmV4ZWModGhlTmF2aWdhdG9yLnVzZXJBZ2VudCk7CiAgICAgIGlmIChmaWVsZHMgIT09IG51bGwpIHsKICAgICAgICBpc1dlYmtpdFJlc3VsdCA9IHRydWU7CiAgICAgICAgd2Via2l0VmVyc2lvblJlc3VsdCA9IGV4dHJhY3RWZXJzaW9uKGZpZWxkc1sxXSk7CiAgICAgICAgd2Via2l0VmVyc2lvblJlc3VsdC5pc05pZ2h0bHkgPSAhIWZpZWxkc1syXTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGlzV2Via2l0UmVzdWx0OwogIH0KICBmdW5jdGlvbiB3ZWJraXRWZXJzaW9uKCkgewogICAgcmV0dXJuIGlzV2Via2l0KCkgJiYgd2Via2l0VmVyc2lvblJlc3VsdDsKICB9CiAgdmFyIGlzSW50ZXJuZXRFeHBsb3JlclJlc3VsdDsKICB2YXIgaW50ZXJuZXRFeHBsb3JlclZlcnNpb25SZXN1bHQ7CiAgZnVuY3Rpb24gaXNJbnRlcm5ldEV4cGxvcmVyKCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaXNJbnRlcm5ldEV4cGxvcmVyUmVzdWx0KSkgewogICAgICBpc0ludGVybmV0RXhwbG9yZXJSZXN1bHQgPSBmYWxzZTsKICAgICAgbGV0IGZpZWxkczsKICAgICAgaWYgKHRoZU5hdmlnYXRvci5hcHBOYW1lID09PSAiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyIikgewogICAgICAgIGZpZWxkcyA9IC9NU0lFIChbMC05XXsxLH1bXC4wLTldezAsfSkvLmV4ZWModGhlTmF2aWdhdG9yLnVzZXJBZ2VudCk7CiAgICAgICAgaWYgKGZpZWxkcyAhPT0gbnVsbCkgewogICAgICAgICAgaXNJbnRlcm5ldEV4cGxvcmVyUmVzdWx0ID0gdHJ1ZTsKICAgICAgICAgIGludGVybmV0RXhwbG9yZXJWZXJzaW9uUmVzdWx0ID0gZXh0cmFjdFZlcnNpb24oZmllbGRzWzFdKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodGhlTmF2aWdhdG9yLmFwcE5hbWUgPT09ICJOZXRzY2FwZSIpIHsKICAgICAgICBmaWVsZHMgPSAvVHJpZGVudFwvLipydjooWzAtOV17MSx9W1wuMC05XXswLH0pLy5leGVjKAogICAgICAgICAgdGhlTmF2aWdhdG9yLnVzZXJBZ2VudAogICAgICAgICk7CiAgICAgICAgaWYgKGZpZWxkcyAhPT0gbnVsbCkgewogICAgICAgICAgaXNJbnRlcm5ldEV4cGxvcmVyUmVzdWx0ID0gdHJ1ZTsKICAgICAgICAgIGludGVybmV0RXhwbG9yZXJWZXJzaW9uUmVzdWx0ID0gZXh0cmFjdFZlcnNpb24oZmllbGRzWzFdKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBpc0ludGVybmV0RXhwbG9yZXJSZXN1bHQ7CiAgfQogIGZ1bmN0aW9uIGludGVybmV0RXhwbG9yZXJWZXJzaW9uKCkgewogICAgcmV0dXJuIGlzSW50ZXJuZXRFeHBsb3JlcigpICYmIGludGVybmV0RXhwbG9yZXJWZXJzaW9uUmVzdWx0OwogIH0KICB2YXIgaXNFZGdlUmVzdWx0OwogIHZhciBlZGdlVmVyc2lvblJlc3VsdDsKICBmdW5jdGlvbiBpc0VkZ2UoKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpc0VkZ2VSZXN1bHQpKSB7CiAgICAgIGlzRWRnZVJlc3VsdCA9IGZhbHNlOwogICAgICBjb25zdCBmaWVsZHMgPSAvIEVkZ1wvKFtcLjAtOV0rKS8uZXhlYyh0aGVOYXZpZ2F0b3IudXNlckFnZW50KTsKICAgICAgaWYgKGZpZWxkcyAhPT0gbnVsbCkgewogICAgICAgIGlzRWRnZVJlc3VsdCA9IHRydWU7CiAgICAgICAgZWRnZVZlcnNpb25SZXN1bHQgPSBleHRyYWN0VmVyc2lvbihmaWVsZHNbMV0pOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gaXNFZGdlUmVzdWx0OwogIH0KICBmdW5jdGlvbiBlZGdlVmVyc2lvbigpIHsKICAgIHJldHVybiBpc0VkZ2UoKSAmJiBlZGdlVmVyc2lvblJlc3VsdDsKICB9CiAgdmFyIGlzRmlyZWZveFJlc3VsdDsKICB2YXIgZmlyZWZveFZlcnNpb25SZXN1bHQ7CiAgZnVuY3Rpb24gaXNGaXJlZm94KCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaXNGaXJlZm94UmVzdWx0KSkgewogICAgICBpc0ZpcmVmb3hSZXN1bHQgPSBmYWxzZTsKICAgICAgY29uc3QgZmllbGRzID0gL0ZpcmVmb3hcLyhbXC4wLTldKykvLmV4ZWModGhlTmF2aWdhdG9yLnVzZXJBZ2VudCk7CiAgICAgIGlmIChmaWVsZHMgIT09IG51bGwpIHsKICAgICAgICBpc0ZpcmVmb3hSZXN1bHQgPSB0cnVlOwogICAgICAgIGZpcmVmb3hWZXJzaW9uUmVzdWx0ID0gZXh0cmFjdFZlcnNpb24oZmllbGRzWzFdKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGlzRmlyZWZveFJlc3VsdDsKICB9CiAgdmFyIGlzV2luZG93c1Jlc3VsdDsKICBmdW5jdGlvbiBpc1dpbmRvd3MoKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpc1dpbmRvd3NSZXN1bHQpKSB7CiAgICAgIGlzV2luZG93c1Jlc3VsdCA9IC9XaW5kb3dzL2kudGVzdCh0aGVOYXZpZ2F0b3IuYXBwVmVyc2lvbik7CiAgICB9CiAgICByZXR1cm4gaXNXaW5kb3dzUmVzdWx0OwogIH0KICB2YXIgaXNJUGFkT3JJT1NSZXN1bHQ7CiAgZnVuY3Rpb24gaXNJUGFkT3JJT1MoKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpc0lQYWRPcklPU1Jlc3VsdCkpIHsKICAgICAgaXNJUGFkT3JJT1NSZXN1bHQgPSBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICJpUGhvbmUiIHx8IG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gImlQb2QiIHx8IG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gImlQYWQiOwogICAgfQogICAgcmV0dXJuIGlzSVBhZE9ySU9TUmVzdWx0OwogIH0KICBmdW5jdGlvbiBmaXJlZm94VmVyc2lvbigpIHsKICAgIHJldHVybiBpc0ZpcmVmb3goKSAmJiBmaXJlZm94VmVyc2lvblJlc3VsdDsKICB9CiAgdmFyIGhhc1BvaW50ZXJFdmVudHM7CiAgZnVuY3Rpb24gc3VwcG9ydHNQb2ludGVyRXZlbnRzKCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaGFzUG9pbnRlckV2ZW50cykpIHsKICAgICAgaGFzUG9pbnRlckV2ZW50cyA9ICFpc0ZpcmVmb3goKSAmJiB0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSAidW5kZWZpbmVkIiAmJiAoIWRlZmluZWRfZGVmYXVsdCh0aGVOYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQpIHx8IHRoZU5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCk7CiAgICB9CiAgICByZXR1cm4gaGFzUG9pbnRlckV2ZW50czsKICB9CiAgdmFyIGltYWdlUmVuZGVyaW5nVmFsdWVSZXN1bHQ7CiAgdmFyIHN1cHBvcnRzSW1hZ2VSZW5kZXJpbmdQaXhlbGF0ZWRSZXN1bHQ7CiAgZnVuY3Rpb24gc3VwcG9ydHNJbWFnZVJlbmRlcmluZ1BpeGVsYXRlZCgpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHN1cHBvcnRzSW1hZ2VSZW5kZXJpbmdQaXhlbGF0ZWRSZXN1bHQpKSB7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpOwogICAgICBjYW52YXMuc2V0QXR0cmlidXRlKAogICAgICAgICJzdHlsZSIsCiAgICAgICAgImltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlcztpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsiCiAgICAgICk7CiAgICAgIGNvbnN0IHRtcDIgPSBjYW52YXMuc3R5bGUuaW1hZ2VSZW5kZXJpbmc7CiAgICAgIHN1cHBvcnRzSW1hZ2VSZW5kZXJpbmdQaXhlbGF0ZWRSZXN1bHQgPSBkZWZpbmVkX2RlZmF1bHQodG1wMikgJiYgdG1wMiAhPT0gIiI7CiAgICAgIGlmIChzdXBwb3J0c0ltYWdlUmVuZGVyaW5nUGl4ZWxhdGVkUmVzdWx0KSB7CiAgICAgICAgaW1hZ2VSZW5kZXJpbmdWYWx1ZVJlc3VsdCA9IHRtcDI7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBzdXBwb3J0c0ltYWdlUmVuZGVyaW5nUGl4ZWxhdGVkUmVzdWx0OwogIH0KICBmdW5jdGlvbiBpbWFnZVJlbmRlcmluZ1ZhbHVlKCkgewogICAgcmV0dXJuIHN1cHBvcnRzSW1hZ2VSZW5kZXJpbmdQaXhlbGF0ZWQoKSA/IGltYWdlUmVuZGVyaW5nVmFsdWVSZXN1bHQgOiB2b2lkIDA7CiAgfQogIGZ1bmN0aW9uIHN1cHBvcnRzV2ViUCgpIHsKICAgIGlmICghc3VwcG9ydHNXZWJQLmluaXRpYWxpemVkKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJZb3UgbXVzdCBjYWxsIEZlYXR1cmVEZXRlY3Rpb24uc3VwcG9ydHNXZWJQLmluaXRpYWxpemUgYW5kIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGNhbGxpbmcgRmVhdHVyZURldGVjdGlvbi5zdXBwb3J0c1dlYlAiCiAgICAgICk7CiAgICB9CiAgICByZXR1cm4gc3VwcG9ydHNXZWJQLl9yZXN1bHQ7CiAgfQogIHN1cHBvcnRzV2ViUC5fcHJvbWlzZSA9IHZvaWQgMDsKICBzdXBwb3J0c1dlYlAuX3Jlc3VsdCA9IHZvaWQgMDsKICBzdXBwb3J0c1dlYlAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkgewogICAgaWYgKGRlZmluZWRfZGVmYXVsdChzdXBwb3J0c1dlYlAuX3Byb21pc2UpKSB7CiAgICAgIHJldHVybiBzdXBwb3J0c1dlYlAuX3Byb21pc2U7CiAgICB9CiAgICBzdXBwb3J0c1dlYlAuX3Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gewogICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpOwogICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHsKICAgICAgICBzdXBwb3J0c1dlYlAuX3Jlc3VsdCA9IGltYWdlLndpZHRoID4gMCAmJiBpbWFnZS5oZWlnaHQgPiAwOwogICAgICAgIHJlc29sdmUoc3VwcG9ydHNXZWJQLl9yZXN1bHQpOwogICAgICB9OwogICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7CiAgICAgICAgc3VwcG9ydHNXZWJQLl9yZXN1bHQgPSBmYWxzZTsKICAgICAgICByZXNvbHZlKHN1cHBvcnRzV2ViUC5fcmVzdWx0KTsKICAgICAgfTsKICAgICAgaW1hZ2Uuc3JjID0gImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUEiOwogICAgfSk7CiAgICByZXR1cm4gc3VwcG9ydHNXZWJQLl9wcm9taXNlOwogIH07CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3VwcG9ydHNXZWJQLCB7CiAgICBpbml0aWFsaXplZDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBkZWZpbmVkX2RlZmF1bHQoc3VwcG9ydHNXZWJQLl9yZXN1bHQpOwogICAgICB9CiAgICB9CiAgfSk7CiAgdmFyIHR5cGVkQXJyYXlUeXBlcyA9IFtdOwogIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICJ1bmRlZmluZWQiKSB7CiAgICB0eXBlZEFycmF5VHlwZXMucHVzaCgKICAgICAgSW50OEFycmF5LAogICAgICBVaW50OEFycmF5LAogICAgICBJbnQxNkFycmF5LAogICAgICBVaW50MTZBcnJheSwKICAgICAgSW50MzJBcnJheSwKICAgICAgVWludDMyQXJyYXksCiAgICAgIEZsb2F0MzJBcnJheSwKICAgICAgRmxvYXQ2NEFycmF5CiAgICApOwogICAgaWYgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgdHlwZWRBcnJheVR5cGVzLnB1c2goVWludDhDbGFtcGVkQXJyYXkpOwogICAgfQogICAgaWYgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgdHlwZWRBcnJheVR5cGVzLnB1c2goVWludDhDbGFtcGVkQXJyYXkpOwogICAgfQogICAgaWYgKHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAidW5kZWZpbmVkIikgewogICAgICB0eXBlZEFycmF5VHlwZXMucHVzaChCaWdJbnQ2NEFycmF5KTsKICAgIH0KICAgIGlmICh0eXBlb2YgQmlnVWludDY0QXJyYXkgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgIHR5cGVkQXJyYXlUeXBlcy5wdXNoKEJpZ1VpbnQ2NEFycmF5KTsKICAgIH0KICB9CiAgdmFyIEZlYXR1cmVEZXRlY3Rpb24gPSB7CiAgICBpc0Nocm9tZSwKICAgIGNocm9tZVZlcnNpb24sCiAgICBpc1NhZmFyaSwKICAgIHNhZmFyaVZlcnNpb24sCiAgICBpc1dlYmtpdCwKICAgIHdlYmtpdFZlcnNpb24sCiAgICBpc0ludGVybmV0RXhwbG9yZXIsCiAgICBpbnRlcm5ldEV4cGxvcmVyVmVyc2lvbiwKICAgIGlzRWRnZSwKICAgIGVkZ2VWZXJzaW9uLAogICAgaXNGaXJlZm94LAogICAgZmlyZWZveFZlcnNpb24sCiAgICBpc1dpbmRvd3MsCiAgICBpc0lQYWRPcklPUywKICAgIGhhcmR3YXJlQ29uY3VycmVuY3k6IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHRoZU5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5LCAzKSwKICAgIHN1cHBvcnRzUG9pbnRlckV2ZW50cywKICAgIHN1cHBvcnRzSW1hZ2VSZW5kZXJpbmdQaXhlbGF0ZWQsCiAgICBzdXBwb3J0c1dlYlAsCiAgICBpbWFnZVJlbmRlcmluZ1ZhbHVlLAogICAgdHlwZWRBcnJheVR5cGVzCiAgfTsKICBGZWF0dXJlRGV0ZWN0aW9uLnN1cHBvcnRzQmFzaXMgPSBmdW5jdGlvbihzY2VuZSkgewogICAgcmV0dXJuIEZlYXR1cmVEZXRlY3Rpb24uc3VwcG9ydHNXZWJBc3NlbWJseSgpICYmIHNjZW5lLmNvbnRleHQuc3VwcG9ydHNCYXNpczsKICB9OwogIEZlYXR1cmVEZXRlY3Rpb24uc3VwcG9ydHNGdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gRnVsbHNjcmVlbl9kZWZhdWx0LnN1cHBvcnRzRnVsbHNjcmVlbigpOwogIH07CiAgRmVhdHVyZURldGVjdGlvbi5zdXBwb3J0c1R5cGVkQXJyYXlzID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAidW5kZWZpbmVkIjsKICB9OwogIEZlYXR1cmVEZXRlY3Rpb24uc3VwcG9ydHNCaWdJbnQ2NEFycmF5ID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdHlwZW9mIEJpZ0ludDY0QXJyYXkgIT09ICJ1bmRlZmluZWQiOwogIH07CiAgRmVhdHVyZURldGVjdGlvbi5zdXBwb3J0c0JpZ1VpbnQ2NEFycmF5ID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSAidW5kZWZpbmVkIjsKICB9OwogIEZlYXR1cmVEZXRlY3Rpb24uc3VwcG9ydHNCaWdJbnQgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiB0eXBlb2YgQmlnSW50ICE9PSAidW5kZWZpbmVkIjsKICB9OwogIEZlYXR1cmVEZXRlY3Rpb24uc3VwcG9ydHNXZWJXb3JrZXJzID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdHlwZW9mIFdvcmtlciAhPT0gInVuZGVmaW5lZCI7CiAgfTsKICBGZWF0dXJlRGV0ZWN0aW9uLnN1cHBvcnRzV2ViQXNzZW1ibHkgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICJ1bmRlZmluZWQiOwogIH07CiAgdmFyIEZlYXR1cmVEZXRlY3Rpb25fZGVmYXVsdCA9IEZlYXR1cmVEZXRlY3Rpb247CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9DYXJ0ZXNpYW4yLmpzCiAgZnVuY3Rpb24gQ2FydGVzaWFuMih4LCB5KSB7CiAgICB0aGlzLnggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh4LCAwKTsKICAgIHRoaXMueSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHksIDApOwogIH0KICBDYXJ0ZXNpYW4yLmZyb21FbGVtZW50cyA9IGZ1bmN0aW9uKHgsIHksIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IENhcnRlc2lhbjIoeCwgeSk7CiAgICB9CiAgICByZXN1bHQueCA9IHg7CiAgICByZXN1bHQueSA9IHk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5jbG9uZSA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChjYXJ0ZXNpYW4pKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuMihjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnkpOwogICAgfQogICAgcmVzdWx0LnggPSBjYXJ0ZXNpYW4ueDsKICAgIHJlc3VsdC55ID0gY2FydGVzaWFuLnk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5mcm9tQ2FydGVzaWFuMyA9IENhcnRlc2lhbjIuY2xvbmU7CiAgQ2FydGVzaWFuMi5mcm9tQ2FydGVzaWFuNCA9IENhcnRlc2lhbjIuY2xvbmU7CiAgQ2FydGVzaWFuMi5wYWNrZWRMZW5ndGggPSAyOwogIENhcnRlc2lhbjIucGFjayA9IGZ1bmN0aW9uKHZhbHVlLCBhcnJheSwgc3RhcnRpbmdJbmRleCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ2YWx1ZSIsIHZhbHVlKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RhcnRpbmdJbmRleCwgMCk7CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUueDsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXhdID0gdmFsdWUueTsKICAgIHJldHVybiBhcnJheTsKICB9OwogIENhcnRlc2lhbjIudW5wYWNrID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjIoKTsKICAgIH0KICAgIHJlc3VsdC54ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdC55ID0gYXJyYXlbc3RhcnRpbmdJbmRleF07CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5wYWNrQXJyYXkgPSBmdW5jdGlvbihhcnJheSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogICAgY29uc3QgcmVzdWx0TGVuZ3RoID0gbGVuZ3RoICogMjsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHJlc3VsdExlbmd0aCk7CiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCAhPT0gcmVzdWx0TGVuZ3RoKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJJZiByZXN1bHQgaXMgYSB0eXBlZCBhcnJheSwgaXQgbXVzdCBoYXZlIGV4YWN0bHkgYXJyYXkubGVuZ3RoICogMiBlbGVtZW50cyIKICAgICAgKTsKICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gcmVzdWx0TGVuZ3RoKSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSByZXN1bHRMZW5ndGg7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgIENhcnRlc2lhbjIucGFjayhhcnJheVtpXSwgcmVzdWx0LCBpICogMik7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi51bnBhY2tBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiYXJyYXkubGVuZ3RoIiwgYXJyYXkubGVuZ3RoLCAyKTsKICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhcnJheSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDIuIik7CiAgICB9CiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGggLyAyKTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyAyOwogICAgfQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikgewogICAgICBjb25zdCBpbmRleCA9IGkgLyAyOwogICAgICByZXN1bHRbaW5kZXhdID0gQ2FydGVzaWFuMi51bnBhY2soYXJyYXksIGksIHJlc3VsdFtpbmRleF0pOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjIuZnJvbUFycmF5ID0gQ2FydGVzaWFuMi51bnBhY2s7CiAgQ2FydGVzaWFuMi5tYXhpbXVtQ29tcG9uZW50ID0gZnVuY3Rpb24oY2FydGVzaWFuKSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICByZXR1cm4gTWF0aC5tYXgoY2FydGVzaWFuLngsIGNhcnRlc2lhbi55KTsKICB9OwogIENhcnRlc2lhbjIubWluaW11bUNvbXBvbmVudCA9IGZ1bmN0aW9uKGNhcnRlc2lhbikgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgcmV0dXJuIE1hdGgubWluKGNhcnRlc2lhbi54LCBjYXJ0ZXNpYW4ueSk7CiAgfTsKICBDYXJ0ZXNpYW4yLm1pbmltdW1CeUNvbXBvbmVudCA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJmaXJzdCIsIGZpcnN0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic2Vjb25kIiwgc2Vjb25kKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gTWF0aC5taW4oZmlyc3QueCwgc2Vjb25kLngpOwogICAgcmVzdWx0LnkgPSBNYXRoLm1pbihmaXJzdC55LCBzZWNvbmQueSk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5tYXhpbXVtQnlDb21wb25lbnQgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZmlyc3QiLCBmaXJzdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInNlY29uZCIsIHNlY29uZCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IE1hdGgubWF4KGZpcnN0LngsIHNlY29uZC54KTsKICAgIHJlc3VsdC55ID0gTWF0aC5tYXgoZmlyc3QueSwgc2Vjb25kLnkpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjIuY2xhbXAgPSBmdW5jdGlvbih2YWx1ZSwgbWluLCBtYXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ2YWx1ZSIsIHZhbHVlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWluIiwgbWluKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF4IiwgbWF4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IHggPSBNYXRoX2RlZmF1bHQuY2xhbXAodmFsdWUueCwgbWluLngsIG1heC54KTsKICAgIGNvbnN0IHkgPSBNYXRoX2RlZmF1bHQuY2xhbXAodmFsdWUueSwgbWluLnksIG1heC55KTsKICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBDYXJ0ZXNpYW4yLm1hZ25pdHVkZVNxdWFyZWQgPSBmdW5jdGlvbihjYXJ0ZXNpYW4pIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIHJldHVybiBjYXJ0ZXNpYW4ueCAqIGNhcnRlc2lhbi54ICsgY2FydGVzaWFuLnkgKiBjYXJ0ZXNpYW4ueTsKICB9OwogIENhcnRlc2lhbjIubWFnbml0dWRlID0gZnVuY3Rpb24oY2FydGVzaWFuKSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KENhcnRlc2lhbjIubWFnbml0dWRlU3F1YXJlZChjYXJ0ZXNpYW4pKTsKICB9OwogIHZhciBkaXN0YW5jZVNjcmF0Y2gzID0gbmV3IENhcnRlc2lhbjIoKTsKICBDYXJ0ZXNpYW4yLmRpc3RhbmNlID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENhcnRlc2lhbjIuc3VidHJhY3QobGVmdCwgcmlnaHQsIGRpc3RhbmNlU2NyYXRjaDMpOwogICAgcmV0dXJuIENhcnRlc2lhbjIubWFnbml0dWRlKGRpc3RhbmNlU2NyYXRjaDMpOwogIH07CiAgQ2FydGVzaWFuMi5kaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2FydGVzaWFuMi5zdWJ0cmFjdChsZWZ0LCByaWdodCwgZGlzdGFuY2VTY3JhdGNoMyk7CiAgICByZXR1cm4gQ2FydGVzaWFuMi5tYWduaXR1ZGVTcXVhcmVkKGRpc3RhbmNlU2NyYXRjaDMpOwogIH07CiAgQ2FydGVzaWFuMi5ub3JtYWxpemUgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgbWFnbml0dWRlID0gQ2FydGVzaWFuMi5tYWduaXR1ZGUoY2FydGVzaWFuKTsKICAgIHJlc3VsdC54ID0gY2FydGVzaWFuLnggLyBtYWduaXR1ZGU7CiAgICByZXN1bHQueSA9IGNhcnRlc2lhbi55IC8gbWFnbml0dWRlOwogICAgaWYgKGlzTmFOKHJlc3VsdC54KSB8fCBpc05hTihyZXN1bHQueSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm5vcm1hbGl6ZWQgcmVzdWx0IGlzIG5vdCBhIG51bWJlciIpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjIuZG90ID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIHJldHVybiBsZWZ0LnggKiByaWdodC54ICsgbGVmdC55ICogcmlnaHQueTsKICB9OwogIENhcnRlc2lhbjIuY3Jvc3MgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgcmV0dXJuIGxlZnQueCAqIHJpZ2h0LnkgLSBsZWZ0LnkgKiByaWdodC54OwogIH07CiAgQ2FydGVzaWFuMi5tdWx0aXBseUNvbXBvbmVudHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGxlZnQueCAqIHJpZ2h0Lng7CiAgICByZXN1bHQueSA9IGxlZnQueSAqIHJpZ2h0Lnk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5kaXZpZGVDb21wb25lbnRzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0LnggPSBsZWZ0LnggLyByaWdodC54OwogICAgcmVzdWx0LnkgPSBsZWZ0LnkgLyByaWdodC55OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjIuYWRkID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0LnggPSBsZWZ0LnggKyByaWdodC54OwogICAgcmVzdWx0LnkgPSBsZWZ0LnkgKyByaWdodC55OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjIuc3VidHJhY3QgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGxlZnQueCAtIHJpZ2h0Lng7CiAgICByZXN1bHQueSA9IGxlZnQueSAtIHJpZ2h0Lnk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5tdWx0aXBseUJ5U2NhbGFyID0gZnVuY3Rpb24oY2FydGVzaWFuLCBzY2FsYXIsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJzY2FsYXIiLCBzY2FsYXIpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0LnggPSBjYXJ0ZXNpYW4ueCAqIHNjYWxhcjsKICAgIHJlc3VsdC55ID0gY2FydGVzaWFuLnkgKiBzY2FsYXI7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5kaXZpZGVCeVNjYWxhciA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgc2NhbGFyLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigic2NhbGFyIiwgc2NhbGFyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gY2FydGVzaWFuLnggLyBzY2FsYXI7CiAgICByZXN1bHQueSA9IGNhcnRlc2lhbi55IC8gc2NhbGFyOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjIubmVnYXRlID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gLWNhcnRlc2lhbi54OwogICAgcmVzdWx0LnkgPSAtY2FydGVzaWFuLnk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydGVzaWFuMi5hYnMgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0LnggPSBNYXRoLmFicyhjYXJ0ZXNpYW4ueCk7CiAgICByZXN1bHQueSA9IE1hdGguYWJzKGNhcnRlc2lhbi55KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgbGVycFNjcmF0Y2gzID0gbmV3IENhcnRlc2lhbjIoKTsKICBDYXJ0ZXNpYW4yLmxlcnAgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic3RhcnQiLCBzdGFydCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImVuZCIsIGVuZCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInQiLCB0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIENhcnRlc2lhbjIubXVsdGlwbHlCeVNjYWxhcihlbmQsIHQsIGxlcnBTY3JhdGNoMyk7CiAgICByZXN1bHQgPSBDYXJ0ZXNpYW4yLm11bHRpcGx5QnlTY2FsYXIoc3RhcnQsIDEgLSB0LCByZXN1bHQpOwogICAgcmV0dXJuIENhcnRlc2lhbjIuYWRkKGxlcnBTY3JhdGNoMywgcmVzdWx0LCByZXN1bHQpOwogIH07CiAgdmFyIGFuZ2xlQmV0d2VlblNjcmF0Y2gzID0gbmV3IENhcnRlc2lhbjIoKTsKICB2YXIgYW5nbGVCZXR3ZWVuU2NyYXRjaDIyID0gbmV3IENhcnRlc2lhbjIoKTsKICBDYXJ0ZXNpYW4yLmFuZ2xlQmV0d2VlbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDYXJ0ZXNpYW4yLm5vcm1hbGl6ZShsZWZ0LCBhbmdsZUJldHdlZW5TY3JhdGNoMyk7CiAgICBDYXJ0ZXNpYW4yLm5vcm1hbGl6ZShyaWdodCwgYW5nbGVCZXR3ZWVuU2NyYXRjaDIyKTsKICAgIHJldHVybiBNYXRoX2RlZmF1bHQuYWNvc0NsYW1wZWQoCiAgICAgIENhcnRlc2lhbjIuZG90KGFuZ2xlQmV0d2VlblNjcmF0Y2gzLCBhbmdsZUJldHdlZW5TY3JhdGNoMjIpCiAgICApOwogIH07CiAgdmFyIG1vc3RPcnRob2dvbmFsQXhpc1NjcmF0Y2gzID0gbmV3IENhcnRlc2lhbjIoKTsKICBDYXJ0ZXNpYW4yLm1vc3RPcnRob2dvbmFsQXhpcyA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBmID0gQ2FydGVzaWFuMi5ub3JtYWxpemUoY2FydGVzaWFuLCBtb3N0T3J0aG9nb25hbEF4aXNTY3JhdGNoMyk7CiAgICBDYXJ0ZXNpYW4yLmFicyhmLCBmKTsKICAgIGlmIChmLnggPD0gZi55KSB7CiAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjIuY2xvbmUoQ2FydGVzaWFuMi5VTklUX1gsIHJlc3VsdCk7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQgPSBDYXJ0ZXNpYW4yLmNsb25lKENhcnRlc2lhbjIuVU5JVF9ZLCByZXN1bHQpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRlc2lhbjIuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBsZWZ0LnggPT09IHJpZ2h0LnggJiYgbGVmdC55ID09PSByaWdodC55OwogIH07CiAgQ2FydGVzaWFuMi5lcXVhbHNBcnJheSA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgYXJyYXksIG9mZnNldCkgewogICAgcmV0dXJuIGNhcnRlc2lhbi54ID09PSBhcnJheVtvZmZzZXRdICYmIGNhcnRlc2lhbi55ID09PSBhcnJheVtvZmZzZXQgKyAxXTsKICB9OwogIENhcnRlc2lhbjIuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZWxhdGl2ZUVwc2lsb24sIGFic29sdXRlRXBzaWxvbikgewogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LngsCiAgICAgIHJpZ2h0LngsCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LnksCiAgICAgIHJpZ2h0LnksCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApOwogIH07CiAgQ2FydGVzaWFuMi5aRVJPID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMigwLCAwKSk7CiAgQ2FydGVzaWFuMi5PTkUgPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW4yKDEsIDEpKTsKICBDYXJ0ZXNpYW4yLlVOSVRfWCA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjIoMSwgMCkpOwogIENhcnRlc2lhbjIuVU5JVF9ZID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMigwLCAxKSk7CiAgQ2FydGVzaWFuMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHsKICAgIHJldHVybiBDYXJ0ZXNpYW4yLmNsb25lKHRoaXMsIHJlc3VsdCk7CiAgfTsKICBDYXJ0ZXNpYW4yLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihyaWdodCkgewogICAgcmV0dXJuIENhcnRlc2lhbjIuZXF1YWxzKHRoaXMsIHJpZ2h0KTsKICB9OwogIENhcnRlc2lhbjIucHJvdG90eXBlLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbihyaWdodCwgcmVsYXRpdmVFcHNpbG9uLCBhYnNvbHV0ZUVwc2lsb24pIHsKICAgIHJldHVybiBDYXJ0ZXNpYW4yLmVxdWFsc0Vwc2lsb24oCiAgICAgIHRoaXMsCiAgICAgIHJpZ2h0LAogICAgICByZWxhdGl2ZUVwc2lsb24sCiAgICAgIGFic29sdXRlRXBzaWxvbgogICAgKTsKICB9OwogIENhcnRlc2lhbjIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gYCgke3RoaXMueH0sICR7dGhpcy55fSlgOwogIH07CiAgdmFyIENhcnRlc2lhbjJfZGVmYXVsdCA9IENhcnRlc2lhbjI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9zY2FsZVRvR2VvZGV0aWNTdXJmYWNlLmpzCiAgdmFyIHNjYWxlVG9HZW9kZXRpY1N1cmZhY2VJbnRlcnNlY3Rpb24gPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjYWxlVG9HZW9kZXRpY1N1cmZhY2VHcmFkaWVudCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBmdW5jdGlvbiBzY2FsZVRvR2VvZGV0aWNTdXJmYWNlKGNhcnRlc2lhbiwgb25lT3ZlclJhZGlpLCBvbmVPdmVyUmFkaWlTcXVhcmVkLCBjZW50ZXJUb2xlcmFuY2VTcXVhcmVkLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNhcnRlc2lhbikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImNhcnRlc2lhbiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9uZU92ZXJSYWRpaSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9uZU92ZXJSYWRpaSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9uZU92ZXJSYWRpaVNxdWFyZWQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvbmVPdmVyUmFkaWlTcXVhcmVkIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY2VudGVyVG9sZXJhbmNlU3F1YXJlZCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImNlbnRlclRvbGVyYW5jZVNxdWFyZWQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBwb3NpdGlvblggPSBjYXJ0ZXNpYW4ueDsKICAgIGNvbnN0IHBvc2l0aW9uWSA9IGNhcnRlc2lhbi55OwogICAgY29uc3QgcG9zaXRpb25aID0gY2FydGVzaWFuLno7CiAgICBjb25zdCBvbmVPdmVyUmFkaWlYID0gb25lT3ZlclJhZGlpLng7CiAgICBjb25zdCBvbmVPdmVyUmFkaWlZID0gb25lT3ZlclJhZGlpLnk7CiAgICBjb25zdCBvbmVPdmVyUmFkaWlaID0gb25lT3ZlclJhZGlpLno7CiAgICBjb25zdCB4MiA9IHBvc2l0aW9uWCAqIHBvc2l0aW9uWCAqIG9uZU92ZXJSYWRpaVggKiBvbmVPdmVyUmFkaWlYOwogICAgY29uc3QgeTIgPSBwb3NpdGlvblkgKiBwb3NpdGlvblkgKiBvbmVPdmVyUmFkaWlZICogb25lT3ZlclJhZGlpWTsKICAgIGNvbnN0IHoyID0gcG9zaXRpb25aICogcG9zaXRpb25aICogb25lT3ZlclJhZGlpWiAqIG9uZU92ZXJSYWRpaVo7CiAgICBjb25zdCBzcXVhcmVkTm9ybSA9IHgyICsgeTIgKyB6MjsKICAgIGNvbnN0IHJhdGlvID0gTWF0aC5zcXJ0KDEgLyBzcXVhcmVkTm9ybSk7CiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgY2FydGVzaWFuLAogICAgICByYXRpbywKICAgICAgc2NhbGVUb0dlb2RldGljU3VyZmFjZUludGVyc2VjdGlvbgogICAgKTsKICAgIGlmIChzcXVhcmVkTm9ybSA8IGNlbnRlclRvbGVyYW5jZVNxdWFyZWQpIHsKICAgICAgcmV0dXJuICFpc0Zpbml0ZShyYXRpbykgPyB2b2lkIDAgOiBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoaW50ZXJzZWN0aW9uLCByZXN1bHQpOwogICAgfQogICAgY29uc3Qgb25lT3ZlclJhZGlpU3F1YXJlZFggPSBvbmVPdmVyUmFkaWlTcXVhcmVkLng7CiAgICBjb25zdCBvbmVPdmVyUmFkaWlTcXVhcmVkWSA9IG9uZU92ZXJSYWRpaVNxdWFyZWQueTsKICAgIGNvbnN0IG9uZU92ZXJSYWRpaVNxdWFyZWRaID0gb25lT3ZlclJhZGlpU3F1YXJlZC56OwogICAgY29uc3QgZ3JhZGllbnQgPSBzY2FsZVRvR2VvZGV0aWNTdXJmYWNlR3JhZGllbnQ7CiAgICBncmFkaWVudC54ID0gaW50ZXJzZWN0aW9uLnggKiBvbmVPdmVyUmFkaWlTcXVhcmVkWCAqIDI7CiAgICBncmFkaWVudC55ID0gaW50ZXJzZWN0aW9uLnkgKiBvbmVPdmVyUmFkaWlTcXVhcmVkWSAqIDI7CiAgICBncmFkaWVudC56ID0gaW50ZXJzZWN0aW9uLnogKiBvbmVPdmVyUmFkaWlTcXVhcmVkWiAqIDI7CiAgICBsZXQgbGFtYmRhID0gKDEgLSByYXRpbykgKiBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKGNhcnRlc2lhbikgLyAoMC41ICogQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZShncmFkaWVudCkpOwogICAgbGV0IGNvcnJlY3Rpb24gPSAwOwogICAgbGV0IGZ1bmM7CiAgICBsZXQgZGVub21pbmF0b3I7CiAgICBsZXQgeE11bHRpcGxpZXI7CiAgICBsZXQgeU11bHRpcGxpZXI7CiAgICBsZXQgek11bHRpcGxpZXI7CiAgICBsZXQgeE11bHRpcGxpZXIyOwogICAgbGV0IHlNdWx0aXBsaWVyMjsKICAgIGxldCB6TXVsdGlwbGllcjI7CiAgICBsZXQgeE11bHRpcGxpZXIzOwogICAgbGV0IHlNdWx0aXBsaWVyMzsKICAgIGxldCB6TXVsdGlwbGllcjM7CiAgICBkbyB7CiAgICAgIGxhbWJkYSAtPSBjb3JyZWN0aW9uOwogICAgICB4TXVsdGlwbGllciA9IDEgLyAoMSArIGxhbWJkYSAqIG9uZU92ZXJSYWRpaVNxdWFyZWRYKTsKICAgICAgeU11bHRpcGxpZXIgPSAxIC8gKDEgKyBsYW1iZGEgKiBvbmVPdmVyUmFkaWlTcXVhcmVkWSk7CiAgICAgIHpNdWx0aXBsaWVyID0gMSAvICgxICsgbGFtYmRhICogb25lT3ZlclJhZGlpU3F1YXJlZFopOwogICAgICB4TXVsdGlwbGllcjIgPSB4TXVsdGlwbGllciAqIHhNdWx0aXBsaWVyOwogICAgICB5TXVsdGlwbGllcjIgPSB5TXVsdGlwbGllciAqIHlNdWx0aXBsaWVyOwogICAgICB6TXVsdGlwbGllcjIgPSB6TXVsdGlwbGllciAqIHpNdWx0aXBsaWVyOwogICAgICB4TXVsdGlwbGllcjMgPSB4TXVsdGlwbGllcjIgKiB4TXVsdGlwbGllcjsKICAgICAgeU11bHRpcGxpZXIzID0geU11bHRpcGxpZXIyICogeU11bHRpcGxpZXI7CiAgICAgIHpNdWx0aXBsaWVyMyA9IHpNdWx0aXBsaWVyMiAqIHpNdWx0aXBsaWVyOwogICAgICBmdW5jID0geDIgKiB4TXVsdGlwbGllcjIgKyB5MiAqIHlNdWx0aXBsaWVyMiArIHoyICogek11bHRpcGxpZXIyIC0gMTsKICAgICAgZGVub21pbmF0b3IgPSB4MiAqIHhNdWx0aXBsaWVyMyAqIG9uZU92ZXJSYWRpaVNxdWFyZWRYICsgeTIgKiB5TXVsdGlwbGllcjMgKiBvbmVPdmVyUmFkaWlTcXVhcmVkWSArIHoyICogek11bHRpcGxpZXIzICogb25lT3ZlclJhZGlpU3F1YXJlZFo7CiAgICAgIGNvbnN0IGRlcml2YXRpdmUgPSAtMiAqIGRlbm9taW5hdG9yOwogICAgICBjb3JyZWN0aW9uID0gZnVuYyAvIGRlcml2YXRpdmU7CiAgICB9IHdoaWxlIChNYXRoLmFicyhmdW5jKSA+IE1hdGhfZGVmYXVsdC5FUFNJTE9OMTIpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgKICAgICAgICBwb3NpdGlvblggKiB4TXVsdGlwbGllciwKICAgICAgICBwb3NpdGlvblkgKiB5TXVsdGlwbGllciwKICAgICAgICBwb3NpdGlvblogKiB6TXVsdGlwbGllcgogICAgICApOwogICAgfQogICAgcmVzdWx0LnggPSBwb3NpdGlvblggKiB4TXVsdGlwbGllcjsKICAgIHJlc3VsdC55ID0gcG9zaXRpb25ZICogeU11bHRpcGxpZXI7CiAgICByZXN1bHQueiA9IHBvc2l0aW9uWiAqIHpNdWx0aXBsaWVyOwogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIHNjYWxlVG9HZW9kZXRpY1N1cmZhY2VfZGVmYXVsdCA9IHNjYWxlVG9HZW9kZXRpY1N1cmZhY2U7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9DYXJ0b2dyYXBoaWMuanMKICBmdW5jdGlvbiBDYXJ0b2dyYXBoaWMobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0KSB7CiAgICB0aGlzLmxvbmdpdHVkZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGxvbmdpdHVkZSwgMCk7CiAgICB0aGlzLmxhdGl0dWRlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQobGF0aXR1ZGUsIDApOwogICAgdGhpcy5oZWlnaHQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChoZWlnaHQsIDApOwogIH0KICBDYXJ0b2dyYXBoaWMuZnJvbVJhZGlhbnMgPSBmdW5jdGlvbihsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJsb25naXR1ZGUiLCBsb25naXR1ZGUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJsYXRpdHVkZSIsIGxhdGl0dWRlKTsKICAgIGhlaWdodCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGhlaWdodCwgMCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydG9ncmFwaGljKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCk7CiAgICB9CiAgICByZXN1bHQubG9uZ2l0dWRlID0gbG9uZ2l0dWRlOwogICAgcmVzdWx0LmxhdGl0dWRlID0gbGF0aXR1ZGU7CiAgICByZXN1bHQuaGVpZ2h0ID0gaGVpZ2h0OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIENhcnRvZ3JhcGhpYy5mcm9tRGVncmVlcyA9IGZ1bmN0aW9uKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImxvbmdpdHVkZSIsIGxvbmdpdHVkZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImxhdGl0dWRlIiwgbGF0aXR1ZGUpOwogICAgbG9uZ2l0dWRlID0gTWF0aF9kZWZhdWx0LnRvUmFkaWFucyhsb25naXR1ZGUpOwogICAgbGF0aXR1ZGUgPSBNYXRoX2RlZmF1bHQudG9SYWRpYW5zKGxhdGl0dWRlKTsKICAgIHJldHVybiBDYXJ0b2dyYXBoaWMuZnJvbVJhZGlhbnMobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0LCByZXN1bHQpOwogIH07CiAgdmFyIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljTiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNQID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBjYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY0ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHdnczg0T25lT3ZlclJhZGlpID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgKICAgIDEgLyA2Mzc4MTM3LAogICAgMSAvIDYzNzgxMzcsCiAgICAxIC8gNjM1Njc1MjMxNDI0NTE3OWUtOQogICk7CiAgdmFyIHdnczg0T25lT3ZlclJhZGlpU3F1YXJlZCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoCiAgICAxIC8gKDYzNzgxMzcgKiA2Mzc4MTM3KSwKICAgIDEgLyAoNjM3ODEzNyAqIDYzNzgxMzcpLAogICAgMSAvICg2MzU2NzUyMzE0MjQ1MTc5ZS05ICogNjM1Njc1MjMxNDI0NTE3OWUtOSkKICApOwogIHZhciB3Z3M4NENlbnRlclRvbGVyYW5jZVNxdWFyZWQgPSBNYXRoX2RlZmF1bHQuRVBTSUxPTjE7CiAgQ2FydG9ncmFwaGljLmZyb21DYXJ0ZXNpYW4gPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIGVsbGlwc29pZCwgcmVzdWx0KSB7CiAgICBjb25zdCBvbmVPdmVyUmFkaWkgPSBkZWZpbmVkX2RlZmF1bHQoZWxsaXBzb2lkKSA/IGVsbGlwc29pZC5vbmVPdmVyUmFkaWkgOiB3Z3M4NE9uZU92ZXJSYWRpaTsKICAgIGNvbnN0IG9uZU92ZXJSYWRpaVNxdWFyZWQgPSBkZWZpbmVkX2RlZmF1bHQoZWxsaXBzb2lkKSA/IGVsbGlwc29pZC5vbmVPdmVyUmFkaWlTcXVhcmVkIDogd2dzODRPbmVPdmVyUmFkaWlTcXVhcmVkOwogICAgY29uc3QgY2VudGVyVG9sZXJhbmNlU3F1YXJlZCA9IGRlZmluZWRfZGVmYXVsdChlbGxpcHNvaWQpID8gZWxsaXBzb2lkLl9jZW50ZXJUb2xlcmFuY2VTcXVhcmVkIDogd2dzODRDZW50ZXJUb2xlcmFuY2VTcXVhcmVkOwogICAgY29uc3QgcCA9IHNjYWxlVG9HZW9kZXRpY1N1cmZhY2VfZGVmYXVsdCgKICAgICAgY2FydGVzaWFuLAogICAgICBvbmVPdmVyUmFkaWksCiAgICAgIG9uZU92ZXJSYWRpaVNxdWFyZWQsCiAgICAgIGNlbnRlclRvbGVyYW5jZVNxdWFyZWQsCiAgICAgIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljUAogICAgKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHApKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBsZXQgbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUNvbXBvbmVudHMoCiAgICAgIHAsCiAgICAgIG9uZU92ZXJSYWRpaVNxdWFyZWQsCiAgICAgIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljTgogICAgKTsKICAgIG4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKG4sIG4pOwogICAgY29uc3QgaCA9IENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjYXJ0ZXNpYW4sIHAsIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljSCk7CiAgICBjb25zdCBsb25naXR1ZGUgPSBNYXRoLmF0YW4yKG4ueSwgbi54KTsKICAgIGNvbnN0IGxhdGl0dWRlID0gTWF0aC5hc2luKG4ueik7CiAgICBjb25zdCBoZWlnaHQgPSBNYXRoX2RlZmF1bHQuc2lnbihDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KGgsIGNhcnRlc2lhbikpICogQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZShoKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0b2dyYXBoaWMobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0KTsKICAgIH0KICAgIHJlc3VsdC5sb25naXR1ZGUgPSBsb25naXR1ZGU7CiAgICByZXN1bHQubGF0aXR1ZGUgPSBsYXRpdHVkZTsKICAgIHJlc3VsdC5oZWlnaHQgPSBoZWlnaHQ7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydG9ncmFwaGljLnRvQ2FydGVzaWFuID0gZnVuY3Rpb24oY2FydG9ncmFwaGljLCBlbGxpcHNvaWQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjYXJ0b2dyYXBoaWMiLCBjYXJ0b2dyYXBoaWMpOwogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5mcm9tUmFkaWFucygKICAgICAgY2FydG9ncmFwaGljLmxvbmdpdHVkZSwKICAgICAgY2FydG9ncmFwaGljLmxhdGl0dWRlLAogICAgICBjYXJ0b2dyYXBoaWMuaGVpZ2h0LAogICAgICBlbGxpcHNvaWQsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIENhcnRvZ3JhcGhpYy5jbG9uZSA9IGZ1bmN0aW9uKGNhcnRvZ3JhcGhpYywgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChjYXJ0b2dyYXBoaWMpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydG9ncmFwaGljKAogICAgICAgIGNhcnRvZ3JhcGhpYy5sb25naXR1ZGUsCiAgICAgICAgY2FydG9ncmFwaGljLmxhdGl0dWRlLAogICAgICAgIGNhcnRvZ3JhcGhpYy5oZWlnaHQKICAgICAgKTsKICAgIH0KICAgIHJlc3VsdC5sb25naXR1ZGUgPSBjYXJ0b2dyYXBoaWMubG9uZ2l0dWRlOwogICAgcmVzdWx0LmxhdGl0dWRlID0gY2FydG9ncmFwaGljLmxhdGl0dWRlOwogICAgcmVzdWx0LmhlaWdodCA9IGNhcnRvZ3JhcGhpYy5oZWlnaHQ7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQ2FydG9ncmFwaGljLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgbGVmdC5sb25naXR1ZGUgPT09IHJpZ2h0LmxvbmdpdHVkZSAmJiBsZWZ0LmxhdGl0dWRlID09PSByaWdodC5sYXRpdHVkZSAmJiBsZWZ0LmhlaWdodCA9PT0gcmlnaHQuaGVpZ2h0OwogIH07CiAgQ2FydG9ncmFwaGljLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgZXBzaWxvbikgewogICAgZXBzaWxvbiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGVwc2lsb24sIDApOwogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIE1hdGguYWJzKGxlZnQubG9uZ2l0dWRlIC0gcmlnaHQubG9uZ2l0dWRlKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnQubGF0aXR1ZGUgLSByaWdodC5sYXRpdHVkZSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0LmhlaWdodCAtIHJpZ2h0LmhlaWdodCkgPD0gZXBzaWxvbjsKICB9OwogIENhcnRvZ3JhcGhpYy5aRVJPID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydG9ncmFwaGljKDAsIDAsIDApKTsKICBDYXJ0b2dyYXBoaWMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gQ2FydG9ncmFwaGljLmNsb25lKHRoaXMsIHJlc3VsdCk7CiAgfTsKICBDYXJ0b2dyYXBoaWMucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHJpZ2h0KSB7CiAgICByZXR1cm4gQ2FydG9ncmFwaGljLmVxdWFscyh0aGlzLCByaWdodCk7CiAgfTsKICBDYXJ0b2dyYXBoaWMucHJvdG90eXBlLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbihyaWdodCwgZXBzaWxvbikgewogICAgcmV0dXJuIENhcnRvZ3JhcGhpYy5lcXVhbHNFcHNpbG9uKHRoaXMsIHJpZ2h0LCBlcHNpbG9uKTsKICB9OwogIENhcnRvZ3JhcGhpYy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiBgKCR7dGhpcy5sb25naXR1ZGV9LCAke3RoaXMubGF0aXR1ZGV9LCAke3RoaXMuaGVpZ2h0fSlgOwogIH07CiAgdmFyIENhcnRvZ3JhcGhpY19kZWZhdWx0ID0gQ2FydG9ncmFwaGljOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvRWxsaXBzb2lkLmpzCiAgZnVuY3Rpb24gaW5pdGlhbGl6ZShlbGxpcHNvaWQsIHgsIHksIHopIHsKICAgIHggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh4LCAwKTsKICAgIHkgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh5LCAwKTsKICAgIHogPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh6LCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJ4IiwgeCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygieSIsIHksIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoInoiLCB6LCAwKTsKICAgIGVsbGlwc29pZC5fcmFkaWkgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KHgsIHksIHopOwogICAgZWxsaXBzb2lkLl9yYWRpaVNxdWFyZWQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KHggKiB4LCB5ICogeSwgeiAqIHopOwogICAgZWxsaXBzb2lkLl9yYWRpaVRvVGhlRm91cnRoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgKICAgICAgeCAqIHggKiB4ICogeCwKICAgICAgeSAqIHkgKiB5ICogeSwKICAgICAgeiAqIHogKiB6ICogegogICAgKTsKICAgIGVsbGlwc29pZC5fb25lT3ZlclJhZGlpID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgKICAgICAgeCA9PT0gMCA/IDAgOiAxIC8geCwKICAgICAgeSA9PT0gMCA/IDAgOiAxIC8geSwKICAgICAgeiA9PT0gMCA/IDAgOiAxIC8gegogICAgKTsKICAgIGVsbGlwc29pZC5fb25lT3ZlclJhZGlpU3F1YXJlZCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoCiAgICAgIHggPT09IDAgPyAwIDogMSAvICh4ICogeCksCiAgICAgIHkgPT09IDAgPyAwIDogMSAvICh5ICogeSksCiAgICAgIHogPT09IDAgPyAwIDogMSAvICh6ICogeikKICAgICk7CiAgICBlbGxpcHNvaWQuX21pbmltdW1SYWRpdXMgPSBNYXRoLm1pbih4LCB5LCB6KTsKICAgIGVsbGlwc29pZC5fbWF4aW11bVJhZGl1cyA9IE1hdGgubWF4KHgsIHksIHopOwogICAgZWxsaXBzb2lkLl9jZW50ZXJUb2xlcmFuY2VTcXVhcmVkID0gTWF0aF9kZWZhdWx0LkVQU0lMT04xOwogICAgaWYgKGVsbGlwc29pZC5fcmFkaWlTcXVhcmVkLnogIT09IDApIHsKICAgICAgZWxsaXBzb2lkLl9zcXVhcmVkWE92ZXJTcXVhcmVkWiA9IGVsbGlwc29pZC5fcmFkaWlTcXVhcmVkLnggLyBlbGxpcHNvaWQuX3JhZGlpU3F1YXJlZC56OwogICAgfQogIH0KICBmdW5jdGlvbiBFbGxpcHNvaWQoeCwgeSwgeikgewogICAgdGhpcy5fcmFkaWkgPSB2b2lkIDA7CiAgICB0aGlzLl9yYWRpaVNxdWFyZWQgPSB2b2lkIDA7CiAgICB0aGlzLl9yYWRpaVRvVGhlRm91cnRoID0gdm9pZCAwOwogICAgdGhpcy5fb25lT3ZlclJhZGlpID0gdm9pZCAwOwogICAgdGhpcy5fb25lT3ZlclJhZGlpU3F1YXJlZCA9IHZvaWQgMDsKICAgIHRoaXMuX21pbmltdW1SYWRpdXMgPSB2b2lkIDA7CiAgICB0aGlzLl9tYXhpbXVtUmFkaXVzID0gdm9pZCAwOwogICAgdGhpcy5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZCA9IHZvaWQgMDsKICAgIHRoaXMuX3NxdWFyZWRYT3ZlclNxdWFyZWRaID0gdm9pZCAwOwogICAgaW5pdGlhbGl6ZSh0aGlzLCB4LCB5LCB6KTsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxsaXBzb2lkLnByb3RvdHlwZSwgewogICAgcmFkaWk6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcmFkaWk7CiAgICAgIH0KICAgIH0sCiAgICByYWRpaVNxdWFyZWQ6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcmFkaWlTcXVhcmVkOwogICAgICB9CiAgICB9LAogICAgcmFkaWlUb1RoZUZvdXJ0aDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9yYWRpaVRvVGhlRm91cnRoOwogICAgICB9CiAgICB9LAogICAgb25lT3ZlclJhZGlpOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX29uZU92ZXJSYWRpaTsKICAgICAgfQogICAgfSwKICAgIG9uZU92ZXJSYWRpaVNxdWFyZWQ6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fb25lT3ZlclJhZGlpU3F1YXJlZDsKICAgICAgfQogICAgfSwKICAgIG1pbmltdW1SYWRpdXM6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fbWluaW11bVJhZGl1czsKICAgICAgfQogICAgfSwKICAgIG1heGltdW1SYWRpdXM6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fbWF4aW11bVJhZGl1czsKICAgICAgfQogICAgfQogIH0pOwogIEVsbGlwc29pZC5jbG9uZSA9IGZ1bmN0aW9uKGVsbGlwc29pZCwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChlbGxpcHNvaWQpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCByYWRpaSA9IGVsbGlwc29pZC5fcmFkaWk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgRWxsaXBzb2lkKHJhZGlpLngsIHJhZGlpLnksIHJhZGlpLnopOwogICAgfQogICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKHJhZGlpLCByZXN1bHQuX3JhZGlpKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShlbGxpcHNvaWQuX3JhZGlpU3F1YXJlZCwgcmVzdWx0Ll9yYWRpaVNxdWFyZWQpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGVsbGlwc29pZC5fcmFkaWlUb1RoZUZvdXJ0aCwgcmVzdWx0Ll9yYWRpaVRvVGhlRm91cnRoKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShlbGxpcHNvaWQuX29uZU92ZXJSYWRpaSwgcmVzdWx0Ll9vbmVPdmVyUmFkaWkpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGVsbGlwc29pZC5fb25lT3ZlclJhZGlpU3F1YXJlZCwgcmVzdWx0Ll9vbmVPdmVyUmFkaWlTcXVhcmVkKTsKICAgIHJlc3VsdC5fbWluaW11bVJhZGl1cyA9IGVsbGlwc29pZC5fbWluaW11bVJhZGl1czsKICAgIHJlc3VsdC5fbWF4aW11bVJhZGl1cyA9IGVsbGlwc29pZC5fbWF4aW11bVJhZGl1czsKICAgIHJlc3VsdC5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZCA9IGVsbGlwc29pZC5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBFbGxpcHNvaWQuZnJvbUNhcnRlc2lhbjMgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgRWxsaXBzb2lkKCk7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChjYXJ0ZXNpYW4pKSB7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBpbml0aWFsaXplKHJlc3VsdCwgY2FydGVzaWFuLngsIGNhcnRlc2lhbi55LCBjYXJ0ZXNpYW4ueik7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgRWxsaXBzb2lkLldHUzg0ID0gT2JqZWN0LmZyZWV6ZSgKICAgIG5ldyBFbGxpcHNvaWQoNjM3ODEzNywgNjM3ODEzNywgNjM1Njc1MjMxNDI0NTE3OWUtOSkKICApOwogIEVsbGlwc29pZC5VTklUX1NQSEVSRSA9IE9iamVjdC5mcmVlemUobmV3IEVsbGlwc29pZCgxLCAxLCAxKSk7CiAgRWxsaXBzb2lkLk1PT04gPSBPYmplY3QuZnJlZXplKAogICAgbmV3IEVsbGlwc29pZCgKICAgICAgTWF0aF9kZWZhdWx0LkxVTkFSX1JBRElVUywKICAgICAgTWF0aF9kZWZhdWx0LkxVTkFSX1JBRElVUywKICAgICAgTWF0aF9kZWZhdWx0LkxVTkFSX1JBRElVUwogICAgKQogICk7CiAgRWxsaXBzb2lkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkgewogICAgcmV0dXJuIEVsbGlwc29pZC5jbG9uZSh0aGlzLCByZXN1bHQpOwogIH07CiAgRWxsaXBzb2lkLnBhY2tlZExlbmd0aCA9IENhcnRlc2lhbjNfZGVmYXVsdC5wYWNrZWRMZW5ndGg7CiAgRWxsaXBzb2lkLnBhY2sgPSBmdW5jdGlvbih2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgidmFsdWUiLCB2YWx1ZSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnBhY2sodmFsdWUuX3JhZGlpLCBhcnJheSwgc3RhcnRpbmdJbmRleCk7CiAgICByZXR1cm4gYXJyYXk7CiAgfTsKICBFbGxpcHNvaWQudW5wYWNrID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIGNvbnN0IHJhZGlpID0gQ2FydGVzaWFuM19kZWZhdWx0LnVucGFjayhhcnJheSwgc3RhcnRpbmdJbmRleCk7CiAgICByZXR1cm4gRWxsaXBzb2lkLmZyb21DYXJ0ZXNpYW4zKHJhZGlpLCByZXN1bHQpOwogIH07CiAgRWxsaXBzb2lkLnByb3RvdHlwZS5nZW9jZW50cmljU3VyZmFjZU5vcm1hbCA9IENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemU7CiAgRWxsaXBzb2lkLnByb3RvdHlwZS5nZW9kZXRpY1N1cmZhY2VOb3JtYWxDYXJ0b2dyYXBoaWMgPSBmdW5jdGlvbihjYXJ0b2dyYXBoaWMsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0b2dyYXBoaWMiLCBjYXJ0b2dyYXBoaWMpOwogICAgY29uc3QgbG9uZ2l0dWRlID0gY2FydG9ncmFwaGljLmxvbmdpdHVkZTsKICAgIGNvbnN0IGxhdGl0dWRlID0gY2FydG9ncmFwaGljLmxhdGl0dWRlOwogICAgY29uc3QgY29zTGF0aXR1ZGUgPSBNYXRoLmNvcyhsYXRpdHVkZSk7CiAgICBjb25zdCB4ID0gY29zTGF0aXR1ZGUgKiBNYXRoLmNvcyhsb25naXR1ZGUpOwogICAgY29uc3QgeSA9IGNvc0xhdGl0dWRlICogTWF0aC5zaW4obG9uZ2l0dWRlKTsKICAgIGNvbnN0IHogPSBNYXRoLnNpbihsYXRpdHVkZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJlc3VsdC56ID0gejsKICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKHJlc3VsdCwgcmVzdWx0KTsKICB9OwogIEVsbGlwc29pZC5wcm90b3R5cGUuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIGlmIChDYXJ0ZXNpYW4zX2RlZmF1bHQuZXF1YWxzRXBzaWxvbihjYXJ0ZXNpYW4sIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCBNYXRoX2RlZmF1bHQuRVBTSUxPTjE0KSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgICB9CiAgICByZXN1bHQgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlDb21wb25lbnRzKAogICAgICBjYXJ0ZXNpYW4sCiAgICAgIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQsCiAgICAgIHJlc3VsdAogICAgKTsKICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKHJlc3VsdCwgcmVzdWx0KTsKICB9OwogIHZhciBjYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbk5vcm1hbCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW5LID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIEVsbGlwc29pZC5wcm90b3R5cGUuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4gPSBmdW5jdGlvbihjYXJ0b2dyYXBoaWMsIHJlc3VsdCkgewogICAgY29uc3QgbiA9IGNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuTm9ybWFsOwogICAgY29uc3QgayA9IGNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuSzsKICAgIHRoaXMuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsQ2FydG9ncmFwaGljKGNhcnRvZ3JhcGhpYywgbik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlDb21wb25lbnRzKHRoaXMuX3JhZGlpU3F1YXJlZCwgbiwgayk7CiAgICBjb25zdCBnYW1tYSA9IE1hdGguc3FydChDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KG4sIGspKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5kaXZpZGVCeVNjYWxhcihrLCBnYW1tYSwgayk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihuLCBjYXJ0b2dyYXBoaWMuaGVpZ2h0LCBuKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogICAgfQogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoaywgbiwgcmVzdWx0KTsKICB9OwogIEVsbGlwc29pZC5wcm90b3R5cGUuY2FydG9ncmFwaGljQXJyYXlUb0NhcnRlc2lhbkFycmF5ID0gZnVuY3Rpb24oY2FydG9ncmFwaGljcywgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImNhcnRvZ3JhcGhpY3MiLCBjYXJ0b2dyYXBoaWNzKTsKICAgIGNvbnN0IGxlbmd0aCA9IGNhcnRvZ3JhcGhpY3MubGVuZ3RoOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgIHJlc3VsdFtpXSA9IHRoaXMuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oY2FydG9ncmFwaGljc1tpXSwgcmVzdWx0W2ldKTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNOMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNQMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNIMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBFbGxpcHNvaWQucHJvdG90eXBlLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIGNvbnN0IHAgPSB0aGlzLnNjYWxlVG9HZW9kZXRpY1N1cmZhY2UoY2FydGVzaWFuLCBjYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY1AyKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHApKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCBuID0gdGhpcy5nZW9kZXRpY1N1cmZhY2VOb3JtYWwocCwgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNOMik7CiAgICBjb25zdCBoID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNhcnRlc2lhbiwgcCwgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNIMik7CiAgICBjb25zdCBsb25naXR1ZGUgPSBNYXRoLmF0YW4yKG4ueSwgbi54KTsKICAgIGNvbnN0IGxhdGl0dWRlID0gTWF0aC5hc2luKG4ueik7CiAgICBjb25zdCBoZWlnaHQgPSBNYXRoX2RlZmF1bHQuc2lnbihDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KGgsIGNhcnRlc2lhbikpICogQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZShoKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdChsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQpOwogICAgfQogICAgcmVzdWx0LmxvbmdpdHVkZSA9IGxvbmdpdHVkZTsKICAgIHJlc3VsdC5sYXRpdHVkZSA9IGxhdGl0dWRlOwogICAgcmVzdWx0LmhlaWdodCA9IGhlaWdodDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBFbGxpcHNvaWQucHJvdG90eXBlLmNhcnRlc2lhbkFycmF5VG9DYXJ0b2dyYXBoaWNBcnJheSA9IGZ1bmN0aW9uKGNhcnRlc2lhbnMsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjYXJ0ZXNpYW5zIiwgY2FydGVzaWFucyk7CiAgICBjb25zdCBsZW5ndGggPSBjYXJ0ZXNpYW5zLmxlbmd0aDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoOwogICAgfQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICByZXN1bHRbaV0gPSB0aGlzLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKGNhcnRlc2lhbnNbaV0sIHJlc3VsdFtpXSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgRWxsaXBzb2lkLnByb3RvdHlwZS5zY2FsZVRvR2VvZGV0aWNTdXJmYWNlID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIHJldHVybiBzY2FsZVRvR2VvZGV0aWNTdXJmYWNlX2RlZmF1bHQoCiAgICAgIGNhcnRlc2lhbiwKICAgICAgdGhpcy5fb25lT3ZlclJhZGlpLAogICAgICB0aGlzLl9vbmVPdmVyUmFkaWlTcXVhcmVkLAogICAgICB0aGlzLl9jZW50ZXJUb2xlcmFuY2VTcXVhcmVkLAogICAgICByZXN1bHQKICAgICk7CiAgfTsKICBFbGxpcHNvaWQucHJvdG90eXBlLnNjYWxlVG9HZW9jZW50cmljU3VyZmFjZSA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIGNvbnN0IHBvc2l0aW9uWCA9IGNhcnRlc2lhbi54OwogICAgY29uc3QgcG9zaXRpb25ZID0gY2FydGVzaWFuLnk7CiAgICBjb25zdCBwb3NpdGlvblogPSBjYXJ0ZXNpYW4uejsKICAgIGNvbnN0IG9uZU92ZXJSYWRpaVNxdWFyZWQgPSB0aGlzLl9vbmVPdmVyUmFkaWlTcXVhcmVkOwogICAgY29uc3QgYmV0YSA9IDEgLyBNYXRoLnNxcnQoCiAgICAgIHBvc2l0aW9uWCAqIHBvc2l0aW9uWCAqIG9uZU92ZXJSYWRpaVNxdWFyZWQueCArIHBvc2l0aW9uWSAqIHBvc2l0aW9uWSAqIG9uZU92ZXJSYWRpaVNxdWFyZWQueSArIHBvc2l0aW9uWiAqIHBvc2l0aW9uWiAqIG9uZU92ZXJSYWRpaVNxdWFyZWQuegogICAgKTsKICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihjYXJ0ZXNpYW4sIGJldGEsIHJlc3VsdCk7CiAgfTsKICBFbGxpcHNvaWQucHJvdG90eXBlLnRyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogICAgfQogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUNvbXBvbmVudHMocG9zaXRpb24sIHRoaXMuX29uZU92ZXJSYWRpaSwgcmVzdWx0KTsKICB9OwogIEVsbGlwc29pZC5wcm90b3R5cGUudHJhbnNmb3JtUG9zaXRpb25Gcm9tU2NhbGVkU3BhY2UgPSBmdW5jdGlvbihwb3NpdGlvbiwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlDb21wb25lbnRzKHBvc2l0aW9uLCB0aGlzLl9yYWRpaSwgcmVzdWx0KTsKICB9OwogIEVsbGlwc29pZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocmlnaHQpIHsKICAgIHJldHVybiB0aGlzID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIENhcnRlc2lhbjNfZGVmYXVsdC5lcXVhbHModGhpcy5fcmFkaWksIHJpZ2h0Ll9yYWRpaSk7CiAgfTsKICBFbGxpcHNvaWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdGhpcy5fcmFkaWkudG9TdHJpbmcoKTsKICB9OwogIEVsbGlwc29pZC5wcm90b3R5cGUuZ2V0U3VyZmFjZU5vcm1hbEludGVyc2VjdGlvbldpdGhaQXhpcyA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBidWZmZXIsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJwb3NpdGlvbiIsIHBvc2l0aW9uKTsKICAgIGlmICghTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIHRoaXMuX3JhZGlpLngsCiAgICAgIHRoaXMuX3JhZGlpLnksCiAgICAgIE1hdGhfZGVmYXVsdC5FUFNJTE9OMTUKICAgICkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgIkVsbGlwc29pZCBtdXN0IGJlIGFuIGVsbGlwc29pZCBvZiByZXZvbHV0aW9uIChyYWRpaS54ID09IHJhZGlpLnkpIgogICAgICApOwogICAgfQogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuKCJFbGxpcHNvaWQucmFkaWkueiIsIHRoaXMuX3JhZGlpLnosIDApOwogICAgYnVmZmVyID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoYnVmZmVyLCAwKTsKICAgIGNvbnN0IHNxdWFyZWRYT3ZlclNxdWFyZWRaID0gdGhpcy5fc3F1YXJlZFhPdmVyU3F1YXJlZFo7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIHJlc3VsdC54ID0gMDsKICAgIHJlc3VsdC55ID0gMDsKICAgIHJlc3VsdC56ID0gcG9zaXRpb24ueiAqICgxIC0gc3F1YXJlZFhPdmVyU3F1YXJlZFopOwogICAgaWYgKE1hdGguYWJzKHJlc3VsdC56KSA+PSB0aGlzLl9yYWRpaS56IC0gYnVmZmVyKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIGFic2Npc3NhcyA9IFsKICAgIDAuMTQ4ODc0MzM4OTgxNjMsCiAgICAwLjQzMzM5NTM5NDEyOTI1LAogICAgMC42Nzk0MDk1NjgyOTkwMiwKICAgIDAuODY1MDYzMzY2Njg4OTgsCiAgICAwLjk3MzkwNjUyODUxNzE3LAogICAgMAogIF07CiAgdmFyIHdlaWdodHMgPSBbCiAgICAwLjI5NTUyNDIyNDcxNDc1LAogICAgMC4yNjkyNjY3MTkzMDk5OSwKICAgIDAuMjE5MDg2MzYyNTE1OTgsCiAgICAwLjE0OTQ1MTM0OTE1MDU4LAogICAgMC4wNjY2NzEzNDQzMDg2ODQsCiAgICAwCiAgXTsKICBmdW5jdGlvbiBnYXVzc0xlZ2VuZHJlUXVhZHJhdHVyZShhMywgYiwgZnVuYykgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJhIiwgYTMpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJiIiwgYik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5mdW5jKCJmdW5jIiwgZnVuYyk7CiAgICBjb25zdCB4TWVhbiA9IDAuNSAqIChiICsgYTMpOwogICAgY29uc3QgeFJhbmdlID0gMC41ICogKGIgLSBhMyk7CiAgICBsZXQgc3VtID0gMDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7CiAgICAgIGNvbnN0IGR4ID0geFJhbmdlICogYWJzY2lzc2FzW2ldOwogICAgICBzdW0gKz0gd2VpZ2h0c1tpXSAqIChmdW5jKHhNZWFuICsgZHgpICsgZnVuYyh4TWVhbiAtIGR4KSk7CiAgICB9CiAgICBzdW0gKj0geFJhbmdlOwogICAgcmV0dXJuIHN1bTsKICB9CiAgRWxsaXBzb2lkLnByb3RvdHlwZS5zdXJmYWNlQXJlYSA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZWN0YW5nbGUiLCByZWN0YW5nbGUpOwogICAgY29uc3QgbWluTG9uZ2l0dWRlID0gcmVjdGFuZ2xlLndlc3Q7CiAgICBsZXQgbWF4TG9uZ2l0dWRlID0gcmVjdGFuZ2xlLmVhc3Q7CiAgICBjb25zdCBtaW5MYXRpdHVkZSA9IHJlY3RhbmdsZS5zb3V0aDsKICAgIGNvbnN0IG1heExhdGl0dWRlID0gcmVjdGFuZ2xlLm5vcnRoOwogICAgd2hpbGUgKG1heExvbmdpdHVkZSA8IG1pbkxvbmdpdHVkZSkgewogICAgICBtYXhMb25naXR1ZGUgKz0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgIH0KICAgIGNvbnN0IHJhZGlpU3F1YXJlZCA9IHRoaXMuX3JhZGlpU3F1YXJlZDsKICAgIGNvbnN0IGEyMiA9IHJhZGlpU3F1YXJlZC54OwogICAgY29uc3QgYjIgPSByYWRpaVNxdWFyZWQueTsKICAgIGNvbnN0IGMyID0gcmFkaWlTcXVhcmVkLno7CiAgICBjb25zdCBhMmIyID0gYTIyICogYjI7CiAgICByZXR1cm4gZ2F1c3NMZWdlbmRyZVF1YWRyYXR1cmUobWluTGF0aXR1ZGUsIG1heExhdGl0dWRlLCBmdW5jdGlvbihsYXQpIHsKICAgICAgY29uc3Qgc2luUGhpID0gTWF0aC5jb3MobGF0KTsKICAgICAgY29uc3QgY29zUGhpID0gTWF0aC5zaW4obGF0KTsKICAgICAgcmV0dXJuIE1hdGguY29zKGxhdCkgKiBnYXVzc0xlZ2VuZHJlUXVhZHJhdHVyZShtaW5Mb25naXR1ZGUsIG1heExvbmdpdHVkZSwgZnVuY3Rpb24obG9uKSB7CiAgICAgICAgY29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyhsb24pOwogICAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4obG9uKTsKICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KAogICAgICAgICAgYTJiMiAqIGNvc1BoaSAqIGNvc1BoaSArIGMyICogKGIyICogY29zVGhldGEgKiBjb3NUaGV0YSArIGEyMiAqIHNpblRoZXRhICogc2luVGhldGEpICogc2luUGhpICogc2luUGhpCiAgICAgICAgKTsKICAgICAgfSk7CiAgICB9KTsKICB9OwogIHZhciBFbGxpcHNvaWRfZGVmYXVsdCA9IEVsbGlwc29pZDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0dlb2dyYXBoaWNQcm9qZWN0aW9uLmpzCiAgZnVuY3Rpb24gR2VvZ3JhcGhpY1Byb2plY3Rpb24oZWxsaXBzb2lkKSB7CiAgICB0aGlzLl9lbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChlbGxpcHNvaWQsIEVsbGlwc29pZF9kZWZhdWx0LldHUzg0KTsKICAgIHRoaXMuX3NlbWltYWpvckF4aXMgPSB0aGlzLl9lbGxpcHNvaWQubWF4aW11bVJhZGl1czsKICAgIHRoaXMuX29uZU92ZXJTZW1pbWFqb3JBeGlzID0gMSAvIHRoaXMuX3NlbWltYWpvckF4aXM7CiAgfQogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEdlb2dyYXBoaWNQcm9qZWN0aW9uLnByb3RvdHlwZSwgewogICAgZWxsaXBzb2lkOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2VsbGlwc29pZDsKICAgICAgfQogICAgfQogIH0pOwogIEdlb2dyYXBoaWNQcm9qZWN0aW9uLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24oY2FydG9ncmFwaGljLCByZXN1bHQpIHsKICAgIGNvbnN0IHNlbWltYWpvckF4aXMgPSB0aGlzLl9zZW1pbWFqb3JBeGlzOwogICAgY29uc3QgeCA9IGNhcnRvZ3JhcGhpYy5sb25naXR1ZGUgKiBzZW1pbWFqb3JBeGlzOwogICAgY29uc3QgeSA9IGNhcnRvZ3JhcGhpYy5sYXRpdHVkZSAqIHNlbWltYWpvckF4aXM7CiAgICBjb25zdCB6ID0gY2FydG9ncmFwaGljLmhlaWdodDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoeCwgeSwgeik7CiAgICB9CiAgICByZXN1bHQueCA9IHg7CiAgICByZXN1bHQueSA9IHk7CiAgICByZXN1bHQueiA9IHo7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgR2VvZ3JhcGhpY1Byb2plY3Rpb24ucHJvdG90eXBlLnVucHJvamVjdCA9IGZ1bmN0aW9uKGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChjYXJ0ZXNpYW4pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJjYXJ0ZXNpYW4gaXMgcmVxdWlyZWQiKTsKICAgIH0KICAgIGNvbnN0IG9uZU92ZXJFYXJ0aFNlbWltYWpvckF4aXMgPSB0aGlzLl9vbmVPdmVyU2VtaW1ham9yQXhpczsKICAgIGNvbnN0IGxvbmdpdHVkZSA9IGNhcnRlc2lhbi54ICogb25lT3ZlckVhcnRoU2VtaW1ham9yQXhpczsKICAgIGNvbnN0IGxhdGl0dWRlID0gY2FydGVzaWFuLnkgKiBvbmVPdmVyRWFydGhTZW1pbWFqb3JBeGlzOwogICAgY29uc3QgaGVpZ2h0ID0gY2FydGVzaWFuLno7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydG9ncmFwaGljX2RlZmF1bHQobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0KTsKICAgIH0KICAgIHJlc3VsdC5sb25naXR1ZGUgPSBsb25naXR1ZGU7CiAgICByZXN1bHQubGF0aXR1ZGUgPSBsYXRpdHVkZTsKICAgIHJlc3VsdC5oZWlnaHQgPSBoZWlnaHQ7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIEdlb2dyYXBoaWNQcm9qZWN0aW9uX2RlZmF1bHQgPSBHZW9ncmFwaGljUHJvamVjdGlvbjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0ludGVyc2VjdC5qcwogIHZhciBJbnRlcnNlY3QgPSB7CiAgICBPVVRTSURFOiAtMSwKICAgIElOVEVSU0VDVElORzogMCwKICAgIElOU0lERTogMQogIH07CiAgdmFyIEludGVyc2VjdF9kZWZhdWx0ID0gT2JqZWN0LmZyZWV6ZShJbnRlcnNlY3QpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvUmVjdGFuZ2xlLmpzCiAgZnVuY3Rpb24gUmVjdGFuZ2xlKHdlc3QsIHNvdXRoLCBlYXN0LCBub3J0aCkgewogICAgdGhpcy53ZXN0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQod2VzdCwgMCk7CiAgICB0aGlzLnNvdXRoID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc291dGgsIDApOwogICAgdGhpcy5lYXN0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZWFzdCwgMCk7CiAgICB0aGlzLm5vcnRoID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQobm9ydGgsIDApOwogIH0KICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWN0YW5nbGUucHJvdG90eXBlLCB7CiAgICB3aWR0aDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBSZWN0YW5nbGUuY29tcHV0ZVdpZHRoKHRoaXMpOwogICAgICB9CiAgICB9LAogICAgaGVpZ2h0OiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5jb21wdXRlSGVpZ2h0KHRoaXMpOwogICAgICB9CiAgICB9CiAgfSk7CiAgUmVjdGFuZ2xlLnBhY2tlZExlbmd0aCA9IDQ7CiAgUmVjdGFuZ2xlLnBhY2sgPSBmdW5jdGlvbih2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgidmFsdWUiLCB2YWx1ZSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0YXJ0aW5nSW5kZXgsIDApOwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLndlc3Q7CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuc291dGg7CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuZWFzdDsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXhdID0gdmFsdWUubm9ydGg7CiAgICByZXR1cm4gYXJyYXk7CiAgfTsKICBSZWN0YW5nbGUudW5wYWNrID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZSgpOwogICAgfQogICAgcmVzdWx0Lndlc3QgPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0LnNvdXRoID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdC5lYXN0ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdC5ub3J0aCA9IGFycmF5W3N0YXJ0aW5nSW5kZXhdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFJlY3RhbmdsZS5jb21wdXRlV2lkdGggPSBmdW5jdGlvbihyZWN0YW5nbGUpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVjdGFuZ2xlIiwgcmVjdGFuZ2xlKTsKICAgIGxldCBlYXN0ID0gcmVjdGFuZ2xlLmVhc3Q7CiAgICBjb25zdCB3ZXN0ID0gcmVjdGFuZ2xlLndlc3Q7CiAgICBpZiAoZWFzdCA8IHdlc3QpIHsKICAgICAgZWFzdCArPSBNYXRoX2RlZmF1bHQuVFdPX1BJOwogICAgfQogICAgcmV0dXJuIGVhc3QgLSB3ZXN0OwogIH07CiAgUmVjdGFuZ2xlLmNvbXB1dGVIZWlnaHQgPSBmdW5jdGlvbihyZWN0YW5nbGUpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVjdGFuZ2xlIiwgcmVjdGFuZ2xlKTsKICAgIHJldHVybiByZWN0YW5nbGUubm9ydGggLSByZWN0YW5nbGUuc291dGg7CiAgfTsKICBSZWN0YW5nbGUuZnJvbURlZ3JlZXMgPSBmdW5jdGlvbih3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGgsIHJlc3VsdCkgewogICAgd2VzdCA9IE1hdGhfZGVmYXVsdC50b1JhZGlhbnMoZGVmYXVsdFZhbHVlX2RlZmF1bHQod2VzdCwgMCkpOwogICAgc291dGggPSBNYXRoX2RlZmF1bHQudG9SYWRpYW5zKGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHNvdXRoLCAwKSk7CiAgICBlYXN0ID0gTWF0aF9kZWZhdWx0LnRvUmFkaWFucyhkZWZhdWx0VmFsdWVfZGVmYXVsdChlYXN0LCAwKSk7CiAgICBub3J0aCA9IE1hdGhfZGVmYXVsdC50b1JhZGlhbnMoZGVmYXVsdFZhbHVlX2RlZmF1bHQobm9ydGgsIDApKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKTsKICAgIH0KICAgIHJlc3VsdC53ZXN0ID0gd2VzdDsKICAgIHJlc3VsdC5zb3V0aCA9IHNvdXRoOwogICAgcmVzdWx0LmVhc3QgPSBlYXN0OwogICAgcmVzdWx0Lm5vcnRoID0gbm9ydGg7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUmVjdGFuZ2xlLmZyb21SYWRpYW5zID0gZnVuY3Rpb24od2VzdCwgc291dGgsIGVhc3QsIG5vcnRoLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKTsKICAgIH0KICAgIHJlc3VsdC53ZXN0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQod2VzdCwgMCk7CiAgICByZXN1bHQuc291dGggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzb3V0aCwgMCk7CiAgICByZXN1bHQuZWFzdCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGVhc3QsIDApOwogICAgcmVzdWx0Lm5vcnRoID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQobm9ydGgsIDApOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFJlY3RhbmdsZS5mcm9tQ2FydG9ncmFwaGljQXJyYXkgPSBmdW5jdGlvbihjYXJ0b2dyYXBoaWNzLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiY2FydG9ncmFwaGljcyIsIGNhcnRvZ3JhcGhpY3MpOwogICAgbGV0IHdlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFOwogICAgbGV0IGVhc3QgPSAtTnVtYmVyLk1BWF9WQUxVRTsKICAgIGxldCB3ZXN0T3ZlcklETCA9IE51bWJlci5NQVhfVkFMVUU7CiAgICBsZXQgZWFzdE92ZXJJREwgPSAtTnVtYmVyLk1BWF9WQUxVRTsKICAgIGxldCBzb3V0aCA9IE51bWJlci5NQVhfVkFMVUU7CiAgICBsZXQgbm9ydGggPSAtTnVtYmVyLk1BWF9WQUxVRTsKICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYXJ0b2dyYXBoaWNzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgIGNvbnN0IHBvc2l0aW9uID0gY2FydG9ncmFwaGljc1tpXTsKICAgICAgd2VzdCA9IE1hdGgubWluKHdlc3QsIHBvc2l0aW9uLmxvbmdpdHVkZSk7CiAgICAgIGVhc3QgPSBNYXRoLm1heChlYXN0LCBwb3NpdGlvbi5sb25naXR1ZGUpOwogICAgICBzb3V0aCA9IE1hdGgubWluKHNvdXRoLCBwb3NpdGlvbi5sYXRpdHVkZSk7CiAgICAgIG5vcnRoID0gTWF0aC5tYXgobm9ydGgsIHBvc2l0aW9uLmxhdGl0dWRlKTsKICAgICAgY29uc3QgbG9uQWRqdXN0ZWQgPSBwb3NpdGlvbi5sb25naXR1ZGUgPj0gMCA/IHBvc2l0aW9uLmxvbmdpdHVkZSA6IHBvc2l0aW9uLmxvbmdpdHVkZSArIE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICAgIHdlc3RPdmVySURMID0gTWF0aC5taW4od2VzdE92ZXJJREwsIGxvbkFkanVzdGVkKTsKICAgICAgZWFzdE92ZXJJREwgPSBNYXRoLm1heChlYXN0T3ZlcklETCwgbG9uQWRqdXN0ZWQpOwogICAgfQogICAgaWYgKGVhc3QgLSB3ZXN0ID4gZWFzdE92ZXJJREwgLSB3ZXN0T3ZlcklETCkgewogICAgICB3ZXN0ID0gd2VzdE92ZXJJREw7CiAgICAgIGVhc3QgPSBlYXN0T3ZlcklETDsKICAgICAgaWYgKGVhc3QgPiBNYXRoX2RlZmF1bHQuUEkpIHsKICAgICAgICBlYXN0ID0gZWFzdCAtIE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICAgIH0KICAgICAgaWYgKHdlc3QgPiBNYXRoX2RlZmF1bHQuUEkpIHsKICAgICAgICB3ZXN0ID0gd2VzdCAtIE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICAgIH0KICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKTsKICAgIH0KICAgIHJlc3VsdC53ZXN0ID0gd2VzdDsKICAgIHJlc3VsdC5zb3V0aCA9IHNvdXRoOwogICAgcmVzdWx0LmVhc3QgPSBlYXN0OwogICAgcmVzdWx0Lm5vcnRoID0gbm9ydGg7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUmVjdGFuZ2xlLmZyb21DYXJ0ZXNpYW5BcnJheSA9IGZ1bmN0aW9uKGNhcnRlc2lhbnMsIGVsbGlwc29pZCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImNhcnRlc2lhbnMiLCBjYXJ0ZXNpYW5zKTsKICAgIGVsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGVsbGlwc29pZCwgRWxsaXBzb2lkX2RlZmF1bHQuV0dTODQpOwogICAgbGV0IHdlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFOwogICAgbGV0IGVhc3QgPSAtTnVtYmVyLk1BWF9WQUxVRTsKICAgIGxldCB3ZXN0T3ZlcklETCA9IE51bWJlci5NQVhfVkFMVUU7CiAgICBsZXQgZWFzdE92ZXJJREwgPSAtTnVtYmVyLk1BWF9WQUxVRTsKICAgIGxldCBzb3V0aCA9IE51bWJlci5NQVhfVkFMVUU7CiAgICBsZXQgbm9ydGggPSAtTnVtYmVyLk1BWF9WQUxVRTsKICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYXJ0ZXNpYW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZWxsaXBzb2lkLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKGNhcnRlc2lhbnNbaV0pOwogICAgICB3ZXN0ID0gTWF0aC5taW4od2VzdCwgcG9zaXRpb24ubG9uZ2l0dWRlKTsKICAgICAgZWFzdCA9IE1hdGgubWF4KGVhc3QsIHBvc2l0aW9uLmxvbmdpdHVkZSk7CiAgICAgIHNvdXRoID0gTWF0aC5taW4oc291dGgsIHBvc2l0aW9uLmxhdGl0dWRlKTsKICAgICAgbm9ydGggPSBNYXRoLm1heChub3J0aCwgcG9zaXRpb24ubGF0aXR1ZGUpOwogICAgICBjb25zdCBsb25BZGp1c3RlZCA9IHBvc2l0aW9uLmxvbmdpdHVkZSA+PSAwID8gcG9zaXRpb24ubG9uZ2l0dWRlIDogcG9zaXRpb24ubG9uZ2l0dWRlICsgTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgICAgd2VzdE92ZXJJREwgPSBNYXRoLm1pbih3ZXN0T3ZlcklETCwgbG9uQWRqdXN0ZWQpOwogICAgICBlYXN0T3ZlcklETCA9IE1hdGgubWF4KGVhc3RPdmVySURMLCBsb25BZGp1c3RlZCk7CiAgICB9CiAgICBpZiAoZWFzdCAtIHdlc3QgPiBlYXN0T3ZlcklETCAtIHdlc3RPdmVySURMKSB7CiAgICAgIHdlc3QgPSB3ZXN0T3ZlcklETDsKICAgICAgZWFzdCA9IGVhc3RPdmVySURMOwogICAgICBpZiAoZWFzdCA+IE1hdGhfZGVmYXVsdC5QSSkgewogICAgICAgIGVhc3QgPSBlYXN0IC0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgICAgfQogICAgICBpZiAod2VzdCA+IE1hdGhfZGVmYXVsdC5QSSkgewogICAgICAgIHdlc3QgPSB3ZXN0IC0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgICAgfQogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGgpOwogICAgfQogICAgcmVzdWx0Lndlc3QgPSB3ZXN0OwogICAgcmVzdWx0LnNvdXRoID0gc291dGg7CiAgICByZXN1bHQuZWFzdCA9IGVhc3Q7CiAgICByZXN1bHQubm9ydGggPSBub3J0aDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBSZWN0YW5nbGUuY2xvbmUgPSBmdW5jdGlvbihyZWN0YW5nbGUsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVjdGFuZ2xlKSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgKICAgICAgICByZWN0YW5nbGUud2VzdCwKICAgICAgICByZWN0YW5nbGUuc291dGgsCiAgICAgICAgcmVjdGFuZ2xlLmVhc3QsCiAgICAgICAgcmVjdGFuZ2xlLm5vcnRoCiAgICAgICk7CiAgICB9CiAgICByZXN1bHQud2VzdCA9IHJlY3RhbmdsZS53ZXN0OwogICAgcmVzdWx0LnNvdXRoID0gcmVjdGFuZ2xlLnNvdXRoOwogICAgcmVzdWx0LmVhc3QgPSByZWN0YW5nbGUuZWFzdDsKICAgIHJlc3VsdC5ub3J0aCA9IHJlY3RhbmdsZS5ub3J0aDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBSZWN0YW5nbGUuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBhYnNvbHV0ZUVwc2lsb24pIHsKICAgIGFic29sdXRlRXBzaWxvbiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGFic29sdXRlRXBzaWxvbiwgMCk7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgTWF0aC5hYnMobGVmdC53ZXN0IC0gcmlnaHQud2VzdCkgPD0gYWJzb2x1dGVFcHNpbG9uICYmIE1hdGguYWJzKGxlZnQuc291dGggLSByaWdodC5zb3V0aCkgPD0gYWJzb2x1dGVFcHNpbG9uICYmIE1hdGguYWJzKGxlZnQuZWFzdCAtIHJpZ2h0LmVhc3QpIDw9IGFic29sdXRlRXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0Lm5vcnRoIC0gcmlnaHQubm9ydGgpIDw9IGFic29sdXRlRXBzaWxvbjsKICB9OwogIFJlY3RhbmdsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHsKICAgIHJldHVybiBSZWN0YW5nbGUuY2xvbmUodGhpcywgcmVzdWx0KTsKICB9OwogIFJlY3RhbmdsZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHsKICAgIHJldHVybiBSZWN0YW5nbGUuZXF1YWxzKHRoaXMsIG90aGVyKTsKICB9OwogIFJlY3RhbmdsZS5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIGxlZnQud2VzdCA9PT0gcmlnaHQud2VzdCAmJiBsZWZ0LnNvdXRoID09PSByaWdodC5zb3V0aCAmJiBsZWZ0LmVhc3QgPT09IHJpZ2h0LmVhc3QgJiYgbGVmdC5ub3J0aCA9PT0gcmlnaHQubm9ydGg7CiAgfTsKICBSZWN0YW5nbGUucHJvdG90eXBlLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbihvdGhlciwgZXBzaWxvbikgewogICAgcmV0dXJuIFJlY3RhbmdsZS5lcXVhbHNFcHNpbG9uKHRoaXMsIG90aGVyLCBlcHNpbG9uKTsKICB9OwogIFJlY3RhbmdsZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZWN0YW5nbGUiLCByZWN0YW5nbGUpOwogICAgY29uc3Qgbm9ydGggPSByZWN0YW5nbGUubm9ydGg7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygKICAgICAgIm5vcnRoIiwKICAgICAgbm9ydGgsCiAgICAgIC1NYXRoX2RlZmF1bHQuUElfT1ZFUl9UV08KICAgICk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygibm9ydGgiLCBub3J0aCwgTWF0aF9kZWZhdWx0LlBJX09WRVJfVFdPKTsKICAgIGNvbnN0IHNvdXRoID0gcmVjdGFuZ2xlLnNvdXRoOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoCiAgICAgICJzb3V0aCIsCiAgICAgIHNvdXRoLAogICAgICAtTWF0aF9kZWZhdWx0LlBJX09WRVJfVFdPCiAgICApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoInNvdXRoIiwgc291dGgsIE1hdGhfZGVmYXVsdC5QSV9PVkVSX1RXTyk7CiAgICBjb25zdCB3ZXN0ID0gcmVjdGFuZ2xlLndlc3Q7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygid2VzdCIsIHdlc3QsIC1NYXRoLlBJKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJ3ZXN0Iiwgd2VzdCwgTWF0aC5QSSk7CiAgICBjb25zdCBlYXN0ID0gcmVjdGFuZ2xlLmVhc3Q7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiZWFzdCIsIGVhc3QsIC1NYXRoLlBJKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJlYXN0IiwgZWFzdCwgTWF0aC5QSSk7CiAgfTsKICBSZWN0YW5nbGUuc291dGh3ZXN0ID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVjdGFuZ2xlIiwgcmVjdGFuZ2xlKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdChyZWN0YW5nbGUud2VzdCwgcmVjdGFuZ2xlLnNvdXRoKTsKICAgIH0KICAgIHJlc3VsdC5sb25naXR1ZGUgPSByZWN0YW5nbGUud2VzdDsKICAgIHJlc3VsdC5sYXRpdHVkZSA9IHJlY3RhbmdsZS5zb3V0aDsKICAgIHJlc3VsdC5oZWlnaHQgPSAwOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFJlY3RhbmdsZS5ub3J0aHdlc3QgPSBmdW5jdGlvbihyZWN0YW5nbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZWN0YW5nbGUiLCByZWN0YW5nbGUpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IENhcnRvZ3JhcGhpY19kZWZhdWx0KHJlY3RhbmdsZS53ZXN0LCByZWN0YW5nbGUubm9ydGgpOwogICAgfQogICAgcmVzdWx0LmxvbmdpdHVkZSA9IHJlY3RhbmdsZS53ZXN0OwogICAgcmVzdWx0LmxhdGl0dWRlID0gcmVjdGFuZ2xlLm5vcnRoOwogICAgcmVzdWx0LmhlaWdodCA9IDA7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUmVjdGFuZ2xlLm5vcnRoZWFzdCA9IGZ1bmN0aW9uKHJlY3RhbmdsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlY3RhbmdsZSIsIHJlY3RhbmdsZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydG9ncmFwaGljX2RlZmF1bHQocmVjdGFuZ2xlLmVhc3QsIHJlY3RhbmdsZS5ub3J0aCk7CiAgICB9CiAgICByZXN1bHQubG9uZ2l0dWRlID0gcmVjdGFuZ2xlLmVhc3Q7CiAgICByZXN1bHQubGF0aXR1ZGUgPSByZWN0YW5nbGUubm9ydGg7CiAgICByZXN1bHQuaGVpZ2h0ID0gMDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBSZWN0YW5nbGUuc291dGhlYXN0ID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVjdGFuZ2xlIiwgcmVjdGFuZ2xlKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdChyZWN0YW5nbGUuZWFzdCwgcmVjdGFuZ2xlLnNvdXRoKTsKICAgIH0KICAgIHJlc3VsdC5sb25naXR1ZGUgPSByZWN0YW5nbGUuZWFzdDsKICAgIHJlc3VsdC5sYXRpdHVkZSA9IHJlY3RhbmdsZS5zb3V0aDsKICAgIHJlc3VsdC5oZWlnaHQgPSAwOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFJlY3RhbmdsZS5jZW50ZXIgPSBmdW5jdGlvbihyZWN0YW5nbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZWN0YW5nbGUiLCByZWN0YW5nbGUpOwogICAgbGV0IGVhc3QgPSByZWN0YW5nbGUuZWFzdDsKICAgIGNvbnN0IHdlc3QgPSByZWN0YW5nbGUud2VzdDsKICAgIGlmIChlYXN0IDwgd2VzdCkgewogICAgICBlYXN0ICs9IE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICB9CiAgICBjb25zdCBsb25naXR1ZGUgPSBNYXRoX2RlZmF1bHQubmVnYXRpdmVQaVRvUGkoKHdlc3QgKyBlYXN0KSAqIDAuNSk7CiAgICBjb25zdCBsYXRpdHVkZSA9IChyZWN0YW5nbGUuc291dGggKyByZWN0YW5nbGUubm9ydGgpICogMC41OwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IENhcnRvZ3JhcGhpY19kZWZhdWx0KGxvbmdpdHVkZSwgbGF0aXR1ZGUpOwogICAgfQogICAgcmVzdWx0LmxvbmdpdHVkZSA9IGxvbmdpdHVkZTsKICAgIHJlc3VsdC5sYXRpdHVkZSA9IGxhdGl0dWRlOwogICAgcmVzdWx0LmhlaWdodCA9IDA7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUmVjdGFuZ2xlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHJlY3RhbmdsZSwgb3RoZXJSZWN0YW5nbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZWN0YW5nbGUiLCByZWN0YW5nbGUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJvdGhlclJlY3RhbmdsZSIsIG90aGVyUmVjdGFuZ2xlKTsKICAgIGxldCByZWN0YW5nbGVFYXN0ID0gcmVjdGFuZ2xlLmVhc3Q7CiAgICBsZXQgcmVjdGFuZ2xlV2VzdCA9IHJlY3RhbmdsZS53ZXN0OwogICAgbGV0IG90aGVyUmVjdGFuZ2xlRWFzdCA9IG90aGVyUmVjdGFuZ2xlLmVhc3Q7CiAgICBsZXQgb3RoZXJSZWN0YW5nbGVXZXN0ID0gb3RoZXJSZWN0YW5nbGUud2VzdDsKICAgIGlmIChyZWN0YW5nbGVFYXN0IDwgcmVjdGFuZ2xlV2VzdCAmJiBvdGhlclJlY3RhbmdsZUVhc3QgPiAwKSB7CiAgICAgIHJlY3RhbmdsZUVhc3QgKz0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgIH0gZWxzZSBpZiAob3RoZXJSZWN0YW5nbGVFYXN0IDwgb3RoZXJSZWN0YW5nbGVXZXN0ICYmIHJlY3RhbmdsZUVhc3QgPiAwKSB7CiAgICAgIG90aGVyUmVjdGFuZ2xlRWFzdCArPSBNYXRoX2RlZmF1bHQuVFdPX1BJOwogICAgfQogICAgaWYgKHJlY3RhbmdsZUVhc3QgPCByZWN0YW5nbGVXZXN0ICYmIG90aGVyUmVjdGFuZ2xlV2VzdCA8IDApIHsKICAgICAgb3RoZXJSZWN0YW5nbGVXZXN0ICs9IE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICB9IGVsc2UgaWYgKG90aGVyUmVjdGFuZ2xlRWFzdCA8IG90aGVyUmVjdGFuZ2xlV2VzdCAmJiByZWN0YW5nbGVXZXN0IDwgMCkgewogICAgICByZWN0YW5nbGVXZXN0ICs9IE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICB9CiAgICBjb25zdCB3ZXN0ID0gTWF0aF9kZWZhdWx0Lm5lZ2F0aXZlUGlUb1BpKAogICAgICBNYXRoLm1heChyZWN0YW5nbGVXZXN0LCBvdGhlclJlY3RhbmdsZVdlc3QpCiAgICApOwogICAgY29uc3QgZWFzdCA9IE1hdGhfZGVmYXVsdC5uZWdhdGl2ZVBpVG9QaSgKICAgICAgTWF0aC5taW4ocmVjdGFuZ2xlRWFzdCwgb3RoZXJSZWN0YW5nbGVFYXN0KQogICAgKTsKICAgIGlmICgocmVjdGFuZ2xlLndlc3QgPCByZWN0YW5nbGUuZWFzdCB8fCBvdGhlclJlY3RhbmdsZS53ZXN0IDwgb3RoZXJSZWN0YW5nbGUuZWFzdCkgJiYgZWFzdCA8PSB3ZXN0KSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCBzb3V0aCA9IE1hdGgubWF4KHJlY3RhbmdsZS5zb3V0aCwgb3RoZXJSZWN0YW5nbGUuc291dGgpOwogICAgY29uc3Qgbm9ydGggPSBNYXRoLm1pbihyZWN0YW5nbGUubm9ydGgsIG90aGVyUmVjdGFuZ2xlLm5vcnRoKTsKICAgIGlmIChzb3V0aCA+PSBub3J0aCkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGgpOwogICAgfQogICAgcmVzdWx0Lndlc3QgPSB3ZXN0OwogICAgcmVzdWx0LnNvdXRoID0gc291dGg7CiAgICByZXN1bHQuZWFzdCA9IGVhc3Q7CiAgICByZXN1bHQubm9ydGggPSBub3J0aDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBSZWN0YW5nbGUuc2ltcGxlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCBvdGhlclJlY3RhbmdsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlY3RhbmdsZSIsIHJlY3RhbmdsZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm90aGVyUmVjdGFuZ2xlIiwgb3RoZXJSZWN0YW5nbGUpOwogICAgY29uc3Qgd2VzdCA9IE1hdGgubWF4KHJlY3RhbmdsZS53ZXN0LCBvdGhlclJlY3RhbmdsZS53ZXN0KTsKICAgIGNvbnN0IHNvdXRoID0gTWF0aC5tYXgocmVjdGFuZ2xlLnNvdXRoLCBvdGhlclJlY3RhbmdsZS5zb3V0aCk7CiAgICBjb25zdCBlYXN0ID0gTWF0aC5taW4ocmVjdGFuZ2xlLmVhc3QsIG90aGVyUmVjdGFuZ2xlLmVhc3QpOwogICAgY29uc3Qgbm9ydGggPSBNYXRoLm1pbihyZWN0YW5nbGUubm9ydGgsIG90aGVyUmVjdGFuZ2xlLm5vcnRoKTsKICAgIGlmIChzb3V0aCA+PSBub3J0aCB8fCB3ZXN0ID49IGVhc3QpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKTsKICAgIH0KICAgIHJlc3VsdC53ZXN0ID0gd2VzdDsKICAgIHJlc3VsdC5zb3V0aCA9IHNvdXRoOwogICAgcmVzdWx0LmVhc3QgPSBlYXN0OwogICAgcmVzdWx0Lm5vcnRoID0gbm9ydGg7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUmVjdGFuZ2xlLnVuaW9uID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCBvdGhlclJlY3RhbmdsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlY3RhbmdsZSIsIHJlY3RhbmdsZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm90aGVyUmVjdGFuZ2xlIiwgb3RoZXJSZWN0YW5nbGUpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKCk7CiAgICB9CiAgICBsZXQgcmVjdGFuZ2xlRWFzdCA9IHJlY3RhbmdsZS5lYXN0OwogICAgbGV0IHJlY3RhbmdsZVdlc3QgPSByZWN0YW5nbGUud2VzdDsKICAgIGxldCBvdGhlclJlY3RhbmdsZUVhc3QgPSBvdGhlclJlY3RhbmdsZS5lYXN0OwogICAgbGV0IG90aGVyUmVjdGFuZ2xlV2VzdCA9IG90aGVyUmVjdGFuZ2xlLndlc3Q7CiAgICBpZiAocmVjdGFuZ2xlRWFzdCA8IHJlY3RhbmdsZVdlc3QgJiYgb3RoZXJSZWN0YW5nbGVFYXN0ID4gMCkgewogICAgICByZWN0YW5nbGVFYXN0ICs9IE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICB9IGVsc2UgaWYgKG90aGVyUmVjdGFuZ2xlRWFzdCA8IG90aGVyUmVjdGFuZ2xlV2VzdCAmJiByZWN0YW5nbGVFYXN0ID4gMCkgewogICAgICBvdGhlclJlY3RhbmdsZUVhc3QgKz0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgIH0KICAgIGlmIChyZWN0YW5nbGVFYXN0IDwgcmVjdGFuZ2xlV2VzdCAmJiBvdGhlclJlY3RhbmdsZVdlc3QgPCAwKSB7CiAgICAgIG90aGVyUmVjdGFuZ2xlV2VzdCArPSBNYXRoX2RlZmF1bHQuVFdPX1BJOwogICAgfSBlbHNlIGlmIChvdGhlclJlY3RhbmdsZUVhc3QgPCBvdGhlclJlY3RhbmdsZVdlc3QgJiYgcmVjdGFuZ2xlV2VzdCA8IDApIHsKICAgICAgcmVjdGFuZ2xlV2VzdCArPSBNYXRoX2RlZmF1bHQuVFdPX1BJOwogICAgfQogICAgY29uc3Qgd2VzdCA9IE1hdGhfZGVmYXVsdC5uZWdhdGl2ZVBpVG9QaSgKICAgICAgTWF0aC5taW4ocmVjdGFuZ2xlV2VzdCwgb3RoZXJSZWN0YW5nbGVXZXN0KQogICAgKTsKICAgIGNvbnN0IGVhc3QgPSBNYXRoX2RlZmF1bHQubmVnYXRpdmVQaVRvUGkoCiAgICAgIE1hdGgubWF4KHJlY3RhbmdsZUVhc3QsIG90aGVyUmVjdGFuZ2xlRWFzdCkKICAgICk7CiAgICByZXN1bHQud2VzdCA9IHdlc3Q7CiAgICByZXN1bHQuc291dGggPSBNYXRoLm1pbihyZWN0YW5nbGUuc291dGgsIG90aGVyUmVjdGFuZ2xlLnNvdXRoKTsKICAgIHJlc3VsdC5lYXN0ID0gZWFzdDsKICAgIHJlc3VsdC5ub3J0aCA9IE1hdGgubWF4KHJlY3RhbmdsZS5ub3J0aCwgb3RoZXJSZWN0YW5nbGUubm9ydGgpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFJlY3RhbmdsZS5leHBhbmQgPSBmdW5jdGlvbihyZWN0YW5nbGUsIGNhcnRvZ3JhcGhpYywgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlY3RhbmdsZSIsIHJlY3RhbmdsZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRvZ3JhcGhpYyIsIGNhcnRvZ3JhcGhpYyk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoKTsKICAgIH0KICAgIHJlc3VsdC53ZXN0ID0gTWF0aC5taW4ocmVjdGFuZ2xlLndlc3QsIGNhcnRvZ3JhcGhpYy5sb25naXR1ZGUpOwogICAgcmVzdWx0LnNvdXRoID0gTWF0aC5taW4ocmVjdGFuZ2xlLnNvdXRoLCBjYXJ0b2dyYXBoaWMubGF0aXR1ZGUpOwogICAgcmVzdWx0LmVhc3QgPSBNYXRoLm1heChyZWN0YW5nbGUuZWFzdCwgY2FydG9ncmFwaGljLmxvbmdpdHVkZSk7CiAgICByZXN1bHQubm9ydGggPSBNYXRoLm1heChyZWN0YW5nbGUubm9ydGgsIGNhcnRvZ3JhcGhpYy5sYXRpdHVkZSk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUmVjdGFuZ2xlLmNvbnRhaW5zID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCBjYXJ0b2dyYXBoaWMpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVjdGFuZ2xlIiwgcmVjdGFuZ2xlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydG9ncmFwaGljIiwgY2FydG9ncmFwaGljKTsKICAgIGxldCBsb25naXR1ZGUgPSBjYXJ0b2dyYXBoaWMubG9uZ2l0dWRlOwogICAgY29uc3QgbGF0aXR1ZGUgPSBjYXJ0b2dyYXBoaWMubGF0aXR1ZGU7CiAgICBjb25zdCB3ZXN0ID0gcmVjdGFuZ2xlLndlc3Q7CiAgICBsZXQgZWFzdCA9IHJlY3RhbmdsZS5lYXN0OwogICAgaWYgKGVhc3QgPCB3ZXN0KSB7CiAgICAgIGVhc3QgKz0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgICAgaWYgKGxvbmdpdHVkZSA8IDApIHsKICAgICAgICBsb25naXR1ZGUgKz0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIChsb25naXR1ZGUgPiB3ZXN0IHx8IE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKGxvbmdpdHVkZSwgd2VzdCwgTWF0aF9kZWZhdWx0LkVQU0lMT04xNCkpICYmIChsb25naXR1ZGUgPCBlYXN0IHx8IE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKGxvbmdpdHVkZSwgZWFzdCwgTWF0aF9kZWZhdWx0LkVQU0lMT04xNCkpICYmIGxhdGl0dWRlID49IHJlY3RhbmdsZS5zb3V0aCAmJiBsYXRpdHVkZSA8PSByZWN0YW5nbGUubm9ydGg7CiAgfTsKICB2YXIgc3Vic2FtcGxlTGxhU2NyYXRjaCA9IG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdCgpOwogIFJlY3RhbmdsZS5zdWJzYW1wbGUgPSBmdW5jdGlvbihyZWN0YW5nbGUsIGVsbGlwc29pZCwgc3VyZmFjZUhlaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlY3RhbmdsZSIsIHJlY3RhbmdsZSk7CiAgICBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChlbGxpcHNvaWQsIEVsbGlwc29pZF9kZWZhdWx0LldHUzg0KTsKICAgIHN1cmZhY2VIZWlnaHQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdXJmYWNlSGVpZ2h0LCAwKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gW107CiAgICB9CiAgICBsZXQgbGVuZ3RoID0gMDsKICAgIGNvbnN0IG5vcnRoID0gcmVjdGFuZ2xlLm5vcnRoOwogICAgY29uc3Qgc291dGggPSByZWN0YW5nbGUuc291dGg7CiAgICBjb25zdCBlYXN0ID0gcmVjdGFuZ2xlLmVhc3Q7CiAgICBjb25zdCB3ZXN0ID0gcmVjdGFuZ2xlLndlc3Q7CiAgICBjb25zdCBsbGEgPSBzdWJzYW1wbGVMbGFTY3JhdGNoOwogICAgbGxhLmhlaWdodCA9IHN1cmZhY2VIZWlnaHQ7CiAgICBsbGEubG9uZ2l0dWRlID0gd2VzdDsKICAgIGxsYS5sYXRpdHVkZSA9IG5vcnRoOwogICAgcmVzdWx0W2xlbmd0aF0gPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4obGxhLCByZXN1bHRbbGVuZ3RoXSk7CiAgICBsZW5ndGgrKzsKICAgIGxsYS5sb25naXR1ZGUgPSBlYXN0OwogICAgcmVzdWx0W2xlbmd0aF0gPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4obGxhLCByZXN1bHRbbGVuZ3RoXSk7CiAgICBsZW5ndGgrKzsKICAgIGxsYS5sYXRpdHVkZSA9IHNvdXRoOwogICAgcmVzdWx0W2xlbmd0aF0gPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4obGxhLCByZXN1bHRbbGVuZ3RoXSk7CiAgICBsZW5ndGgrKzsKICAgIGxsYS5sb25naXR1ZGUgPSB3ZXN0OwogICAgcmVzdWx0W2xlbmd0aF0gPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4obGxhLCByZXN1bHRbbGVuZ3RoXSk7CiAgICBsZW5ndGgrKzsKICAgIGlmIChub3J0aCA8IDApIHsKICAgICAgbGxhLmxhdGl0dWRlID0gbm9ydGg7CiAgICB9IGVsc2UgaWYgKHNvdXRoID4gMCkgewogICAgICBsbGEubGF0aXR1ZGUgPSBzb3V0aDsKICAgIH0gZWxzZSB7CiAgICAgIGxsYS5sYXRpdHVkZSA9IDA7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7ICsraSkgewogICAgICBsbGEubG9uZ2l0dWRlID0gLU1hdGguUEkgKyBpICogTWF0aF9kZWZhdWx0LlBJX09WRVJfVFdPOwogICAgICBpZiAoUmVjdGFuZ2xlLmNvbnRhaW5zKHJlY3RhbmdsZSwgbGxhKSkgewogICAgICAgIHJlc3VsdFtsZW5ndGhdID0gZWxsaXBzb2lkLmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKGxsYSwgcmVzdWx0W2xlbmd0aF0pOwogICAgICAgIGxlbmd0aCsrOwogICAgICB9CiAgICB9CiAgICBpZiAobGxhLmxhdGl0dWRlID09PSAwKSB7CiAgICAgIGxsYS5sb25naXR1ZGUgPSB3ZXN0OwogICAgICByZXN1bHRbbGVuZ3RoXSA9IGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihsbGEsIHJlc3VsdFtsZW5ndGhdKTsKICAgICAgbGVuZ3RoKys7CiAgICAgIGxsYS5sb25naXR1ZGUgPSBlYXN0OwogICAgICByZXN1bHRbbGVuZ3RoXSA9IGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihsbGEsIHJlc3VsdFtsZW5ndGhdKTsKICAgICAgbGVuZ3RoKys7CiAgICB9CiAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFJlY3RhbmdsZS5zdWJzZWN0aW9uID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCB3ZXN0TGVycCwgc291dGhMZXJwLCBlYXN0TGVycCwgbm9ydGhMZXJwLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVjdGFuZ2xlIiwgcmVjdGFuZ2xlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJ3ZXN0TGVycCIsIHdlc3RMZXJwLCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJ3ZXN0TGVycCIsIHdlc3RMZXJwLCAxKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJzb3V0aExlcnAiLCBzb3V0aExlcnAsIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoInNvdXRoTGVycCIsIHNvdXRoTGVycCwgMSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiZWFzdExlcnAiLCBlYXN0TGVycCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygiZWFzdExlcnAiLCBlYXN0TGVycCwgMSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygibm9ydGhMZXJwIiwgbm9ydGhMZXJwLCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJub3J0aExlcnAiLCBub3J0aExlcnAsIDEpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoIndlc3RMZXJwIiwgd2VzdExlcnAsIGVhc3RMZXJwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJzb3V0aExlcnAiLCBzb3V0aExlcnAsIG5vcnRoTGVycCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoKTsKICAgIH0KICAgIGlmIChyZWN0YW5nbGUud2VzdCA8PSByZWN0YW5nbGUuZWFzdCkgewogICAgICBjb25zdCB3aWR0aCA9IHJlY3RhbmdsZS5lYXN0IC0gcmVjdGFuZ2xlLndlc3Q7CiAgICAgIHJlc3VsdC53ZXN0ID0gcmVjdGFuZ2xlLndlc3QgKyB3ZXN0TGVycCAqIHdpZHRoOwogICAgICByZXN1bHQuZWFzdCA9IHJlY3RhbmdsZS53ZXN0ICsgZWFzdExlcnAgKiB3aWR0aDsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aF9kZWZhdWx0LlRXT19QSSArIHJlY3RhbmdsZS5lYXN0IC0gcmVjdGFuZ2xlLndlc3Q7CiAgICAgIHJlc3VsdC53ZXN0ID0gTWF0aF9kZWZhdWx0Lm5lZ2F0aXZlUGlUb1BpKHJlY3RhbmdsZS53ZXN0ICsgd2VzdExlcnAgKiB3aWR0aCk7CiAgICAgIHJlc3VsdC5lYXN0ID0gTWF0aF9kZWZhdWx0Lm5lZ2F0aXZlUGlUb1BpKHJlY3RhbmdsZS53ZXN0ICsgZWFzdExlcnAgKiB3aWR0aCk7CiAgICB9CiAgICBjb25zdCBoZWlnaHQgPSByZWN0YW5nbGUubm9ydGggLSByZWN0YW5nbGUuc291dGg7CiAgICByZXN1bHQuc291dGggPSByZWN0YW5nbGUuc291dGggKyBzb3V0aExlcnAgKiBoZWlnaHQ7CiAgICByZXN1bHQubm9ydGggPSByZWN0YW5nbGUuc291dGggKyBub3J0aExlcnAgKiBoZWlnaHQ7CiAgICBpZiAod2VzdExlcnAgPT09IDEpIHsKICAgICAgcmVzdWx0Lndlc3QgPSByZWN0YW5nbGUuZWFzdDsKICAgIH0KICAgIGlmIChlYXN0TGVycCA9PT0gMSkgewogICAgICByZXN1bHQuZWFzdCA9IHJlY3RhbmdsZS5lYXN0OwogICAgfQogICAgaWYgKHNvdXRoTGVycCA9PT0gMSkgewogICAgICByZXN1bHQuc291dGggPSByZWN0YW5nbGUubm9ydGg7CiAgICB9CiAgICBpZiAobm9ydGhMZXJwID09PSAxKSB7CiAgICAgIHJlc3VsdC5ub3J0aCA9IHJlY3RhbmdsZS5ub3J0aDsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBSZWN0YW5nbGUuTUFYX1ZBTFVFID0gT2JqZWN0LmZyZWV6ZSgKICAgIG5ldyBSZWN0YW5nbGUoCiAgICAgIC1NYXRoLlBJLAogICAgICAtTWF0aF9kZWZhdWx0LlBJX09WRVJfVFdPLAogICAgICBNYXRoLlBJLAogICAgICBNYXRoX2RlZmF1bHQuUElfT1ZFUl9UV08KICAgICkKICApOwogIHZhciBSZWN0YW5nbGVfZGVmYXVsdCA9IFJlY3RhbmdsZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL01hdHJpeDIuanMKICBmdW5jdGlvbiBNYXRyaXgyKGNvbHVtbjBSb3cwLCBjb2x1bW4xUm93MCwgY29sdW1uMFJvdzEsIGNvbHVtbjFSb3cxKSB7CiAgICB0aGlzWzBdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMFJvdzAsIDApOwogICAgdGhpc1sxXSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNvbHVtbjBSb3cxLCAwKTsKICAgIHRoaXNbMl0gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjb2x1bW4xUm93MCwgMCk7CiAgICB0aGlzWzNdID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY29sdW1uMVJvdzEsIDApOwogIH0KICBNYXRyaXgyLnBhY2tlZExlbmd0aCA9IDQ7CiAgTWF0cml4Mi5wYWNrID0gZnVuY3Rpb24odmFsdWUsIGFycmF5LCBzdGFydGluZ0luZGV4KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInZhbHVlIiwgdmFsdWUpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZVswXTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZVsxXTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZVsyXTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZVszXTsKICAgIHJldHVybiBhcnJheTsKICB9OwogIE1hdHJpeDIudW5wYWNrID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IE1hdHJpeDIoKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXN1bHRbMV0gPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0WzJdID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTsKICAgIHJlc3VsdFszXSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5wYWNrQXJyYXkgPSBmdW5jdGlvbihhcnJheSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFycmF5IiwgYXJyYXkpOwogICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogICAgY29uc3QgcmVzdWx0TGVuZ3RoID0gbGVuZ3RoICogNDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHJlc3VsdExlbmd0aCk7CiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCAhPT0gcmVzdWx0TGVuZ3RoKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJJZiByZXN1bHQgaXMgYSB0eXBlZCBhcnJheSwgaXQgbXVzdCBoYXZlIGV4YWN0bHkgYXJyYXkubGVuZ3RoICogNCBlbGVtZW50cyIKICAgICAgKTsKICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gcmVzdWx0TGVuZ3RoKSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSByZXN1bHRMZW5ndGg7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgIE1hdHJpeDIucGFjayhhcnJheVtpXSwgcmVzdWx0LCBpICogNCk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi51bnBhY2tBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiYXJyYXkubGVuZ3RoIiwgYXJyYXkubGVuZ3RoLCA0KTsKICAgIGlmIChhcnJheS5sZW5ndGggJSA0ICE9PSAwKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhcnJheSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQuIik7CiAgICB9CiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGggLyA0KTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyA0OwogICAgfQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gNCkgewogICAgICBjb25zdCBpbmRleCA9IGkgLyA0OwogICAgICByZXN1bHRbaW5kZXhdID0gTWF0cml4Mi51bnBhY2soYXJyYXksIGksIHJlc3VsdFtpbmRleF0pOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDIuY2xvbmUgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQobWF0cml4KSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IE1hdHJpeDIobWF0cml4WzBdLCBtYXRyaXhbMl0sIG1hdHJpeFsxXSwgbWF0cml4WzNdKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXTsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFsxXTsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLmZyb21BcnJheSA9IE1hdHJpeDIudW5wYWNrOwogIE1hdHJpeDIuZnJvbUNvbHVtbk1ham9yQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ2YWx1ZXMiLCB2YWx1ZXMpOwogICAgcmV0dXJuIE1hdHJpeDIuY2xvbmUodmFsdWVzLCByZXN1bHQpOwogIH07CiAgTWF0cml4Mi5mcm9tUm93TWFqb3JBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcywgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInZhbHVlcyIsIHZhbHVlcyk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgTWF0cml4Mih2YWx1ZXNbMF0sIHZhbHVlc1sxXSwgdmFsdWVzWzJdLCB2YWx1ZXNbM10pOwogICAgfQogICAgcmVzdWx0WzBdID0gdmFsdWVzWzBdOwogICAgcmVzdWx0WzFdID0gdmFsdWVzWzJdOwogICAgcmVzdWx0WzJdID0gdmFsdWVzWzFdOwogICAgcmVzdWx0WzNdID0gdmFsdWVzWzNdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDIuZnJvbVNjYWxlID0gZnVuY3Rpb24oc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzY2FsZSIsIHNjYWxlKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBNYXRyaXgyKHNjYWxlLngsIDAsIDAsIHNjYWxlLnkpOwogICAgfQogICAgcmVzdWx0WzBdID0gc2NhbGUueDsKICAgIHJlc3VsdFsxXSA9IDA7CiAgICByZXN1bHRbMl0gPSAwOwogICAgcmVzdWx0WzNdID0gc2NhbGUueTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLmZyb21Vbmlmb3JtU2NhbGUgPSBmdW5jdGlvbihzY2FsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxlIiwgc2NhbGUpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IE1hdHJpeDIoc2NhbGUsIDAsIDAsIHNjYWxlKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IHNjYWxlOwogICAgcmVzdWx0WzFdID0gMDsKICAgIHJlc3VsdFsyXSA9IDA7CiAgICByZXN1bHRbM10gPSBzY2FsZTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKGFuZ2xlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigiYW5nbGUiLCBhbmdsZSk7CiAgICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTsKICAgIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IE1hdHJpeDIoY29zQW5nbGUsIC1zaW5BbmdsZSwgc2luQW5nbGUsIGNvc0FuZ2xlKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IGNvc0FuZ2xlOwogICAgcmVzdWx0WzFdID0gc2luQW5nbGU7CiAgICByZXN1bHRbMl0gPSAtc2luQW5nbGU7CiAgICByZXN1bHRbM10gPSBjb3NBbmdsZTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLnRvQXJyYXkgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gW21hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXV07CiAgICB9CiAgICByZXN1bHRbMF0gPSBtYXRyaXhbMF07CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV07CiAgICByZXN1bHRbMl0gPSBtYXRyaXhbMl07CiAgICByZXN1bHRbM10gPSBtYXRyaXhbM107CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5nZXRFbGVtZW50SW5kZXggPSBmdW5jdGlvbihjb2x1bW4sIHJvdykgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoInJvdyIsIHJvdywgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygicm93Iiwgcm93LCAxKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJjb2x1bW4iLCBjb2x1bW4sIDApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmxlc3NUaGFuT3JFcXVhbHMoImNvbHVtbiIsIGNvbHVtbiwgMSk7CiAgICByZXR1cm4gY29sdW1uICogMiArIHJvdzsKICB9OwogIE1hdHJpeDIuZ2V0Q29sdW1uID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXggKiAyOwogICAgY29uc3QgeCA9IG1hdHJpeFtzdGFydEluZGV4XTsKICAgIGNvbnN0IHkgPSBtYXRyaXhbc3RhcnRJbmRleCArIDFdOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDIuc2V0Q29sdW1uID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCwgY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKCJpbmRleCIsIGluZGV4LCAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbk9yRXF1YWxzKCJpbmRleCIsIGluZGV4LCAxKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdCA9IE1hdHJpeDIuY2xvbmUobWF0cml4LCByZXN1bHQpOwogICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4ICogMjsKICAgIHJlc3VsdFtzdGFydEluZGV4XSA9IGNhcnRlc2lhbi54OwogICAgcmVzdWx0W3N0YXJ0SW5kZXggKyAxXSA9IGNhcnRlc2lhbi55OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDIuZ2V0Um93ID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCB4ID0gbWF0cml4W2luZGV4XTsKICAgIGNvbnN0IHkgPSBtYXRyaXhbaW5kZXggKyAyXTsKICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLnNldFJvdyA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgsIGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIubGVzc1RoYW5PckVxdWFscygiaW5kZXgiLCBpbmRleCwgMSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQgPSBNYXRyaXgyLmNsb25lKG1hdHJpeCwgcmVzdWx0KTsKICAgIHJlc3VsdFtpbmRleF0gPSBjYXJ0ZXNpYW4ueDsKICAgIHJlc3VsdFtpbmRleCArIDJdID0gY2FydGVzaWFuLnk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjYWxlU2NyYXRjaDEzID0gbmV3IENhcnRlc2lhbjJfZGVmYXVsdCgpOwogIE1hdHJpeDIuc2V0U2NhbGUgPSBmdW5jdGlvbihtYXRyaXgsIHNjYWxlLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic2NhbGUiLCBzY2FsZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBleGlzdGluZ1NjYWxlID0gTWF0cml4Mi5nZXRTY2FsZShtYXRyaXgsIHNjYWxlU2NyYXRjaDEzKTsKICAgIGNvbnN0IHNjYWxlUmF0aW9YID0gc2NhbGUueCAvIGV4aXN0aW5nU2NhbGUueDsKICAgIGNvbnN0IHNjYWxlUmF0aW9ZID0gc2NhbGUueSAvIGV4aXN0aW5nU2NhbGUueTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAqIHNjYWxlUmF0aW9YOwogICAgcmVzdWx0WzFdID0gbWF0cml4WzFdICogc2NhbGVSYXRpb1g7CiAgICByZXN1bHRbMl0gPSBtYXRyaXhbMl0gKiBzY2FsZVJhdGlvWTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAqIHNjYWxlUmF0aW9ZOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY2FsZVNjcmF0Y2gyMyA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICBNYXRyaXgyLnNldFVuaWZvcm1TY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJzY2FsZSIsIHNjYWxlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGV4aXN0aW5nU2NhbGUgPSBNYXRyaXgyLmdldFNjYWxlKG1hdHJpeCwgc2NhbGVTY3JhdGNoMjMpOwogICAgY29uc3Qgc2NhbGVSYXRpb1ggPSBzY2FsZSAvIGV4aXN0aW5nU2NhbGUueDsKICAgIGNvbnN0IHNjYWxlUmF0aW9ZID0gc2NhbGUgLyBleGlzdGluZ1NjYWxlLnk7CiAgICByZXN1bHRbMF0gPSBtYXRyaXhbMF0gKiBzY2FsZVJhdGlvWDsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFsxXSAqIHNjYWxlUmF0aW9YOwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdICogc2NhbGVSYXRpb1k7CiAgICByZXN1bHRbM10gPSBtYXRyaXhbM10gKiBzY2FsZVJhdGlvWTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NyYXRjaENvbHVtbjMgPSBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KCk7CiAgTWF0cml4Mi5nZXRTY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IENhcnRlc2lhbjJfZGVmYXVsdC5tYWduaXR1ZGUoCiAgICAgIENhcnRlc2lhbjJfZGVmYXVsdC5mcm9tRWxlbWVudHMobWF0cml4WzBdLCBtYXRyaXhbMV0sIHNjcmF0Y2hDb2x1bW4zKQogICAgKTsKICAgIHJlc3VsdC55ID0gQ2FydGVzaWFuMl9kZWZhdWx0Lm1hZ25pdHVkZSgKICAgICAgQ2FydGVzaWFuMl9kZWZhdWx0LmZyb21FbGVtZW50cyhtYXRyaXhbMl0sIG1hdHJpeFszXSwgc2NyYXRjaENvbHVtbjMpCiAgICApOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY2FsZVNjcmF0Y2gzMyA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICBNYXRyaXgyLmdldE1heGltdW1TY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCkgewogICAgTWF0cml4Mi5nZXRTY2FsZShtYXRyaXgsIHNjYWxlU2NyYXRjaDMzKTsKICAgIHJldHVybiBDYXJ0ZXNpYW4yX2RlZmF1bHQubWF4aW11bUNvbXBvbmVudChzY2FsZVNjcmF0Y2gzMyk7CiAgfTsKICB2YXIgc2NhbGVTY3JhdGNoNDMgPSBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KCk7CiAgTWF0cml4Mi5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKG1hdHJpeCwgcm90YXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3Qgc2NhbGUgPSBNYXRyaXgyLmdldFNjYWxlKG1hdHJpeCwgc2NhbGVTY3JhdGNoNDMpOwogICAgcmVzdWx0WzBdID0gcm90YXRpb25bMF0gKiBzY2FsZS54OwogICAgcmVzdWx0WzFdID0gcm90YXRpb25bMV0gKiBzY2FsZS54OwogICAgcmVzdWx0WzJdID0gcm90YXRpb25bMl0gKiBzY2FsZS55OwogICAgcmVzdWx0WzNdID0gcm90YXRpb25bM10gKiBzY2FsZS55OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY2FsZVNjcmF0Y2g1MyA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICBNYXRyaXgyLmdldFJvdGF0aW9uID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IHNjYWxlID0gTWF0cml4Mi5nZXRTY2FsZShtYXRyaXgsIHNjYWxlU2NyYXRjaDUzKTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAvIHNjYWxlLng7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gLyBzY2FsZS54OwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdIC8gc2NhbGUueTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAvIHNjYWxlLnk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5tdWx0aXBseSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGNvbHVtbjBSb3cwID0gbGVmdFswXSAqIHJpZ2h0WzBdICsgbGVmdFsyXSAqIHJpZ2h0WzFdOwogICAgY29uc3QgY29sdW1uMVJvdzAgPSBsZWZ0WzBdICogcmlnaHRbMl0gKyBsZWZ0WzJdICogcmlnaHRbM107CiAgICBjb25zdCBjb2x1bW4wUm93MSA9IGxlZnRbMV0gKiByaWdodFswXSArIGxlZnRbM10gKiByaWdodFsxXTsKICAgIGNvbnN0IGNvbHVtbjFSb3cxID0gbGVmdFsxXSAqIHJpZ2h0WzJdICsgbGVmdFszXSAqIHJpZ2h0WzNdOwogICAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7CiAgICByZXN1bHRbMV0gPSBjb2x1bW4wUm93MTsKICAgIHJlc3VsdFsyXSA9IGNvbHVtbjFSb3cwOwogICAgcmVzdWx0WzNdID0gY29sdW1uMVJvdzE7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5hZGQgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHRbMF0gPSBsZWZ0WzBdICsgcmlnaHRbMF07CiAgICByZXN1bHRbMV0gPSBsZWZ0WzFdICsgcmlnaHRbMV07CiAgICByZXN1bHRbMl0gPSBsZWZ0WzJdICsgcmlnaHRbMl07CiAgICByZXN1bHRbM10gPSBsZWZ0WzNdICsgcmlnaHRbM107CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IGxlZnRbMF0gLSByaWdodFswXTsKICAgIHJlc3VsdFsxXSA9IGxlZnRbMV0gLSByaWdodFsxXTsKICAgIHJlc3VsdFsyXSA9IGxlZnRbMl0gLSByaWdodFsyXTsKICAgIHJlc3VsdFszXSA9IGxlZnRbM10gLSByaWdodFszXTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLm11bHRpcGx5QnlWZWN0b3IgPSBmdW5jdGlvbihtYXRyaXgsIGNhcnRlc2lhbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImNhcnRlc2lhbiIsIGNhcnRlc2lhbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCB4ID0gbWF0cml4WzBdICogY2FydGVzaWFuLnggKyBtYXRyaXhbMl0gKiBjYXJ0ZXNpYW4ueTsKICAgIGNvbnN0IHkgPSBtYXRyaXhbMV0gKiBjYXJ0ZXNpYW4ueCArIG1hdHJpeFszXSAqIGNhcnRlc2lhbi55OwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDIubXVsdGlwbHlCeVNjYWxhciA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGFyLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigic2NhbGFyIiwgc2NhbGFyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAqIHNjYWxhcjsKICAgIHJlc3VsdFsxXSA9IG1hdHJpeFsxXSAqIHNjYWxhcjsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXSAqIHNjYWxhcjsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAqIHNjYWxhcjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLm11bHRpcGx5QnlTY2FsZSA9IGZ1bmN0aW9uKG1hdHJpeCwgc2NhbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzY2FsZSIsIHNjYWxlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IG1hdHJpeFswXSAqIHNjYWxlLng7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZS54OwogICAgcmVzdWx0WzJdID0gbWF0cml4WzJdICogc2NhbGUueTsKICAgIHJlc3VsdFszXSA9IG1hdHJpeFszXSAqIHNjYWxlLnk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5tdWx0aXBseUJ5VW5pZm9ybVNjYWxlID0gZnVuY3Rpb24obWF0cml4LCBzY2FsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxlIiwgc2NhbGUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gbWF0cml4WzBdICogc2NhbGU7CiAgICByZXN1bHRbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZTsKICAgIHJlc3VsdFsyXSA9IG1hdHJpeFsyXSAqIHNjYWxlOwogICAgcmVzdWx0WzNdID0gbWF0cml4WzNdICogc2NhbGU7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5uZWdhdGUgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJtYXRyaXgiLCBtYXRyaXgpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgcmVzdWx0WzBdID0gLW1hdHJpeFswXTsKICAgIHJlc3VsdFsxXSA9IC1tYXRyaXhbMV07CiAgICByZXN1bHRbMl0gPSAtbWF0cml4WzJdOwogICAgcmVzdWx0WzNdID0gLW1hdHJpeFszXTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBNYXRyaXgyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBjb2x1bW4wUm93MCA9IG1hdHJpeFswXTsKICAgIGNvbnN0IGNvbHVtbjBSb3cxID0gbWF0cml4WzJdOwogICAgY29uc3QgY29sdW1uMVJvdzAgPSBtYXRyaXhbMV07CiAgICBjb25zdCBjb2x1bW4xUm93MSA9IG1hdHJpeFszXTsKICAgIHJlc3VsdFswXSA9IGNvbHVtbjBSb3cwOwogICAgcmVzdWx0WzFdID0gY29sdW1uMFJvdzE7CiAgICByZXN1bHRbMl0gPSBjb2x1bW4xUm93MDsKICAgIHJlc3VsdFszXSA9IGNvbHVtbjFSb3cxOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE1hdHJpeDIuYWJzID0gZnVuY3Rpb24obWF0cml4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibWF0cml4IiwgbWF0cml4KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdFswXSA9IE1hdGguYWJzKG1hdHJpeFswXSk7CiAgICByZXN1bHRbMV0gPSBNYXRoLmFicyhtYXRyaXhbMV0pOwogICAgcmVzdWx0WzJdID0gTWF0aC5hYnMobWF0cml4WzJdKTsKICAgIHJlc3VsdFszXSA9IE1hdGguYWJzKG1hdHJpeFszXSk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgTWF0cml4Mi5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIGxlZnRbMF0gPT09IHJpZ2h0WzBdICYmIGxlZnRbMV0gPT09IHJpZ2h0WzFdICYmIGxlZnRbMl0gPT09IHJpZ2h0WzJdICYmIGxlZnRbM10gPT09IHJpZ2h0WzNdOwogIH07CiAgTWF0cml4Mi5lcXVhbHNBcnJheSA9IGZ1bmN0aW9uKG1hdHJpeCwgYXJyYXksIG9mZnNldCkgewogICAgcmV0dXJuIG1hdHJpeFswXSA9PT0gYXJyYXlbb2Zmc2V0XSAmJiBtYXRyaXhbMV0gPT09IGFycmF5W29mZnNldCArIDFdICYmIG1hdHJpeFsyXSA9PT0gYXJyYXlbb2Zmc2V0ICsgMl0gJiYgbWF0cml4WzNdID09PSBhcnJheVtvZmZzZXQgKyAzXTsKICB9OwogIE1hdHJpeDIuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBlcHNpbG9uKSB7CiAgICBlcHNpbG9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZXBzaWxvbiwgMCk7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgTWF0aC5hYnMobGVmdFswXSAtIHJpZ2h0WzBdKSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnRbMV0gLSByaWdodFsxXSkgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0WzJdIC0gcmlnaHRbMl0pIDw9IGVwc2lsb24gJiYgTWF0aC5hYnMobGVmdFszXSAtIHJpZ2h0WzNdKSA8PSBlcHNpbG9uOwogIH07CiAgTWF0cml4Mi5JREVOVElUWSA9IE9iamVjdC5mcmVlemUobmV3IE1hdHJpeDIoMSwgMCwgMCwgMSkpOwogIE1hdHJpeDIuWkVSTyA9IE9iamVjdC5mcmVlemUobmV3IE1hdHJpeDIoMCwgMCwgMCwgMCkpOwogIE1hdHJpeDIuQ09MVU1OMFJPVzAgPSAwOwogIE1hdHJpeDIuQ09MVU1OMFJPVzEgPSAxOwogIE1hdHJpeDIuQ09MVU1OMVJPVzAgPSAyOwogIE1hdHJpeDIuQ09MVU1OMVJPVzEgPSAzOwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1hdHJpeDIucHJvdG90eXBlLCB7CiAgICBsZW5ndGg6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gTWF0cml4Mi5wYWNrZWRMZW5ndGg7CiAgICAgIH0KICAgIH0KICB9KTsKICBNYXRyaXgyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkgewogICAgcmV0dXJuIE1hdHJpeDIuY2xvbmUodGhpcywgcmVzdWx0KTsKICB9OwogIE1hdHJpeDIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHJpZ2h0KSB7CiAgICByZXR1cm4gTWF0cml4Mi5lcXVhbHModGhpcywgcmlnaHQpOwogIH07CiAgTWF0cml4Mi5wcm90b3R5cGUuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKHJpZ2h0LCBlcHNpbG9uKSB7CiAgICByZXR1cm4gTWF0cml4Mi5lcXVhbHNFcHNpbG9uKHRoaXMsIHJpZ2h0LCBlcHNpbG9uKTsKICB9OwogIE1hdHJpeDIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gYCgke3RoaXNbMF19LCAke3RoaXNbMl19KQooJHt0aGlzWzFdfSwgJHt0aGlzWzNdfSlgOwogIH07CiAgdmFyIE1hdHJpeDJfZGVmYXVsdCA9IE1hdHJpeDI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9jbG9uZS5qcwogIGZ1bmN0aW9uIGNsb25lKG9iamVjdCwgZGVlcCkgewogICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAib2JqZWN0IikgewogICAgICByZXR1cm4gb2JqZWN0OwogICAgfQogICAgZGVlcCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGRlZXAsIGZhbHNlKTsKICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBvYmplY3QuY29uc3RydWN0b3IoKTsKICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIGluIG9iamVjdCkgewogICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHsKICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3RbcHJvcGVydHlOYW1lXTsKICAgICAgICBpZiAoZGVlcCkgewogICAgICAgICAgdmFsdWUgPSBjbG9uZSh2YWx1ZSwgZGVlcCk7CiAgICAgICAgfQogICAgICAgIHJlc3VsdFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBjbG9uZV9kZWZhdWx0ID0gY2xvbmU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9Db21wb25lbnREYXRhdHlwZS5qcwogIHZhciBDb21wb25lbnREYXRhdHlwZSA9IHsKICAgIEJZVEU6IFdlYkdMQ29uc3RhbnRzX2RlZmF1bHQuQllURSwKICAgIFVOU0lHTkVEX0JZVEU6IFdlYkdMQ29uc3RhbnRzX2RlZmF1bHQuVU5TSUdORURfQllURSwKICAgIFNIT1JUOiBXZWJHTENvbnN0YW50c19kZWZhdWx0LlNIT1JULAogICAgVU5TSUdORURfU0hPUlQ6IFdlYkdMQ29uc3RhbnRzX2RlZmF1bHQuVU5TSUdORURfU0hPUlQsCiAgICBJTlQ6IFdlYkdMQ29uc3RhbnRzX2RlZmF1bHQuSU5ULAogICAgVU5TSUdORURfSU5UOiBXZWJHTENvbnN0YW50c19kZWZhdWx0LlVOU0lHTkVEX0lOVCwKICAgIEZMT0FUOiBXZWJHTENvbnN0YW50c19kZWZhdWx0LkZMT0FULAogICAgRE9VQkxFOiBXZWJHTENvbnN0YW50c19kZWZhdWx0LkRPVUJMRQogIH07CiAgQ29tcG9uZW50RGF0YXR5cGUuZ2V0U2l6ZUluQnl0ZXMgPSBmdW5jdGlvbihjb21wb25lbnREYXRhdHlwZSkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY29tcG9uZW50RGF0YXR5cGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ2YWx1ZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHN3aXRjaCAoY29tcG9uZW50RGF0YXR5cGUpIHsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5CWVRFOgogICAgICAgIHJldHVybiBJbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICAgIGNhc2UgQ29tcG9uZW50RGF0YXR5cGUuVU5TSUdORURfQllURToKICAgICAgICByZXR1cm4gVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5TSE9SVDoKICAgICAgICByZXR1cm4gSW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9TSE9SVDoKICAgICAgICByZXR1cm4gVWludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICAgIGNhc2UgQ29tcG9uZW50RGF0YXR5cGUuSU5UOgogICAgICAgIHJldHVybiBJbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOwogICAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0lOVDoKICAgICAgICByZXR1cm4gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICAgIGNhc2UgQ29tcG9uZW50RGF0YXR5cGUuRkxPQVQ6CiAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5ET1VCTEU6CiAgICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY29tcG9uZW50RGF0YXR5cGUgaXMgbm90IGEgdmFsaWQgdmFsdWUuIik7CiAgICB9CiAgfTsKICBDb21wb25lbnREYXRhdHlwZS5mcm9tVHlwZWRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7CiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHsKICAgICAgcmV0dXJuIENvbXBvbmVudERhdGF0eXBlLkJZVEU7CiAgICB9CiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7CiAgICAgIHJldHVybiBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFOwogICAgfQogICAgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSkgewogICAgICByZXR1cm4gQ29tcG9uZW50RGF0YXR5cGUuU0hPUlQ7CiAgICB9CiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkgewogICAgICByZXR1cm4gQ29tcG9uZW50RGF0YXR5cGUuVU5TSUdORURfU0hPUlQ7CiAgICB9CiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7CiAgICAgIHJldHVybiBDb21wb25lbnREYXRhdHlwZS5JTlQ7CiAgICB9CiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkgewogICAgICByZXR1cm4gQ29tcG9uZW50RGF0YXR5cGUuVU5TSUdORURfSU5UOwogICAgfQogICAgaWYgKGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7CiAgICAgIHJldHVybiBDb21wb25lbnREYXRhdHlwZS5GTE9BVDsKICAgIH0KICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkgewogICAgICByZXR1cm4gQ29tcG9uZW50RGF0YXR5cGUuRE9VQkxFOwogICAgfQogICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICJhcnJheSBtdXN0IGJlIGFuIEludDhBcnJheSwgVWludDhBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIG9yIEZsb2F0NjRBcnJheS4iCiAgICApOwogIH07CiAgQ29tcG9uZW50RGF0YXR5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihjb21wb25lbnREYXRhdHlwZSkgewogICAgcmV0dXJuIGRlZmluZWRfZGVmYXVsdChjb21wb25lbnREYXRhdHlwZSkgJiYgKGNvbXBvbmVudERhdGF0eXBlID09PSBDb21wb25lbnREYXRhdHlwZS5CWVRFIHx8IGNvbXBvbmVudERhdGF0eXBlID09PSBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFIHx8IGNvbXBvbmVudERhdGF0eXBlID09PSBDb21wb25lbnREYXRhdHlwZS5TSE9SVCB8fCBjb21wb25lbnREYXRhdHlwZSA9PT0gQ29tcG9uZW50RGF0YXR5cGUuVU5TSUdORURfU0hPUlQgfHwgY29tcG9uZW50RGF0YXR5cGUgPT09IENvbXBvbmVudERhdGF0eXBlLklOVCB8fCBjb21wb25lbnREYXRhdHlwZSA9PT0gQ29tcG9uZW50RGF0YXR5cGUuVU5TSUdORURfSU5UIHx8IGNvbXBvbmVudERhdGF0eXBlID09PSBDb21wb25lbnREYXRhdHlwZS5GTE9BVCB8fCBjb21wb25lbnREYXRhdHlwZSA9PT0gQ29tcG9uZW50RGF0YXR5cGUuRE9VQkxFKTsKICB9OwogIENvbXBvbmVudERhdGF0eXBlLmNyZWF0ZVR5cGVkQXJyYXkgPSBmdW5jdGlvbihjb21wb25lbnREYXRhdHlwZSwgdmFsdWVzT3JMZW5ndGgpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNvbXBvbmVudERhdGF0eXBlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY29tcG9uZW50RGF0YXR5cGUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh2YWx1ZXNPckxlbmd0aCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInZhbHVlc09yTGVuZ3RoIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgc3dpdGNoIChjb21wb25lbnREYXRhdHlwZSkgewogICAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLkJZVEU6CiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkodmFsdWVzT3JMZW5ndGgpOwogICAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0JZVEU6CiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlc09yTGVuZ3RoKTsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5TSE9SVDoKICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkodmFsdWVzT3JMZW5ndGgpOwogICAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX1NIT1JUOgogICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkodmFsdWVzT3JMZW5ndGgpOwogICAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLklOVDoKICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkodmFsdWVzT3JMZW5ndGgpOwogICAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0lOVDoKICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KHZhbHVlc09yTGVuZ3RoKTsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5GTE9BVDoKICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXNPckxlbmd0aCk7CiAgICAgIGNhc2UgQ29tcG9uZW50RGF0YXR5cGUuRE9VQkxFOgogICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KHZhbHVlc09yTGVuZ3RoKTsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY29tcG9uZW50RGF0YXR5cGUgaXMgbm90IGEgdmFsaWQgdmFsdWUuIik7CiAgICB9CiAgfTsKICBDb21wb25lbnREYXRhdHlwZS5jcmVhdGVBcnJheUJ1ZmZlclZpZXcgPSBmdW5jdGlvbihjb21wb25lbnREYXRhdHlwZSwgYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNvbXBvbmVudERhdGF0eXBlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY29tcG9uZW50RGF0YXR5cGUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChidWZmZXIpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJidWZmZXIgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBieXRlT2Zmc2V0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoYnl0ZU9mZnNldCwgMCk7CiAgICBsZW5ndGggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgbGVuZ3RoLAogICAgICAoYnVmZmVyLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0KSAvIENvbXBvbmVudERhdGF0eXBlLmdldFNpemVJbkJ5dGVzKGNvbXBvbmVudERhdGF0eXBlKQogICAgKTsKICAgIHN3aXRjaCAoY29tcG9uZW50RGF0YXR5cGUpIHsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5CWVRFOgogICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFOgogICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CiAgICAgIGNhc2UgQ29tcG9uZW50RGF0YXR5cGUuU0hPUlQ6CiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9TSE9SVDoKICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5JTlQ6CiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9JTlQ6CiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CiAgICAgIGNhc2UgQ29tcG9uZW50RGF0YXR5cGUuRkxPQVQ6CiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpOwogICAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLkRPVUJMRToKICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImNvbXBvbmVudERhdGF0eXBlIGlzIG5vdCBhIHZhbGlkIHZhbHVlLiIpOwogICAgfQogIH07CiAgQ29tcG9uZW50RGF0YXR5cGUuZnJvbU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7CiAgICBzd2l0Y2ggKG5hbWUpIHsKICAgICAgY2FzZSAiQllURSI6CiAgICAgICAgcmV0dXJuIENvbXBvbmVudERhdGF0eXBlLkJZVEU7CiAgICAgIGNhc2UgIlVOU0lHTkVEX0JZVEUiOgogICAgICAgIHJldHVybiBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFOwogICAgICBjYXNlICJTSE9SVCI6CiAgICAgICAgcmV0dXJuIENvbXBvbmVudERhdGF0eXBlLlNIT1JUOwogICAgICBjYXNlICJVTlNJR05FRF9TSE9SVCI6CiAgICAgICAgcmV0dXJuIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX1NIT1JUOwogICAgICBjYXNlICJJTlQiOgogICAgICAgIHJldHVybiBDb21wb25lbnREYXRhdHlwZS5JTlQ7CiAgICAgIGNhc2UgIlVOU0lHTkVEX0lOVCI6CiAgICAgICAgcmV0dXJuIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0lOVDsKICAgICAgY2FzZSAiRkxPQVQiOgogICAgICAgIHJldHVybiBDb21wb25lbnREYXRhdHlwZS5GTE9BVDsKICAgICAgY2FzZSAiRE9VQkxFIjoKICAgICAgICByZXR1cm4gQ29tcG9uZW50RGF0YXR5cGUuRE9VQkxFOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJuYW1lIGlzIG5vdCBhIHZhbGlkIHZhbHVlLiIpOwogICAgfQogIH07CiAgdmFyIENvbXBvbmVudERhdGF0eXBlX2RlZmF1bHQgPSBPYmplY3QuZnJlZXplKENvbXBvbmVudERhdGF0eXBlKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1F1YXRlcm5pb24uanMKICBmdW5jdGlvbiBRdWF0ZXJuaW9uKHgsIHksIHosIHcpIHsKICAgIHRoaXMueCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHgsIDApOwogICAgdGhpcy55ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoeSwgMCk7CiAgICB0aGlzLnogPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh6LCAwKTsKICAgIHRoaXMudyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHcsIDApOwogIH0KICB2YXIgZnJvbUF4aXNBbmdsZVNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgUXVhdGVybmlvbi5mcm9tQXhpc0FuZ2xlID0gZnVuY3Rpb24oYXhpcywgYW5nbGUsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJheGlzIiwgYXhpcyk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoImFuZ2xlIiwgYW5nbGUpOwogICAgY29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyOwogICAgY29uc3QgcyA9IE1hdGguc2luKGhhbGZBbmdsZSk7CiAgICBmcm9tQXhpc0FuZ2xlU2NyYXRjaCA9IENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUoYXhpcywgZnJvbUF4aXNBbmdsZVNjcmF0Y2gpOwogICAgY29uc3QgeCA9IGZyb21BeGlzQW5nbGVTY3JhdGNoLnggKiBzOwogICAgY29uc3QgeSA9IGZyb21BeGlzQW5nbGVTY3JhdGNoLnkgKiBzOwogICAgY29uc3QgeiA9IGZyb21BeGlzQW5nbGVTY3JhdGNoLnogKiBzOwogICAgY29uc3QgdyA9IE1hdGguY29zKGhhbGZBbmdsZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih4LCB5LCB6LCB3KTsKICAgIH0KICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJlc3VsdC56ID0gejsKICAgIHJlc3VsdC53ID0gdzsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgZnJvbVJvdGF0aW9uTWF0cml4TmV4dCA9IFsxLCAyLCAwXTsKICB2YXIgZnJvbVJvdGF0aW9uTWF0cml4UXVhdCA9IG5ldyBBcnJheSgzKTsKICBRdWF0ZXJuaW9uLmZyb21Sb3RhdGlvbk1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm1hdHJpeCIsIG1hdHJpeCk7CiAgICBsZXQgcm9vdDsKICAgIGxldCB4OwogICAgbGV0IHk7CiAgICBsZXQgejsKICAgIGxldCB3OwogICAgY29uc3QgbTAwID0gbWF0cml4W01hdHJpeDNfZGVmYXVsdC5DT0xVTU4wUk9XMF07CiAgICBjb25zdCBtMTEgPSBtYXRyaXhbTWF0cml4M19kZWZhdWx0LkNPTFVNTjFST1cxXTsKICAgIGNvbnN0IG0yMiA9IG1hdHJpeFtNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMlJPVzJdOwogICAgY29uc3QgdHJhY2UgPSBtMDAgKyBtMTEgKyBtMjI7CiAgICBpZiAodHJhY2UgPiAwKSB7CiAgICAgIHJvb3QgPSBNYXRoLnNxcnQodHJhY2UgKyAxKTsKICAgICAgdyA9IDAuNSAqIHJvb3Q7CiAgICAgIHJvb3QgPSAwLjUgLyByb290OwogICAgICB4ID0gKG1hdHJpeFtNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMVJPVzJdIC0gbWF0cml4W01hdHJpeDNfZGVmYXVsdC5DT0xVTU4yUk9XMV0pICogcm9vdDsKICAgICAgeSA9IChtYXRyaXhbTWF0cml4M19kZWZhdWx0LkNPTFVNTjJST1cwXSAtIG1hdHJpeFtNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMFJPVzJdKSAqIHJvb3Q7CiAgICAgIHogPSAobWF0cml4W01hdHJpeDNfZGVmYXVsdC5DT0xVTU4wUk9XMV0gLSBtYXRyaXhbTWF0cml4M19kZWZhdWx0LkNPTFVNTjFST1cwXSkgKiByb290OwogICAgfSBlbHNlIHsKICAgICAgY29uc3QgbmV4dCA9IGZyb21Sb3RhdGlvbk1hdHJpeE5leHQ7CiAgICAgIGxldCBpID0gMDsKICAgICAgaWYgKG0xMSA+IG0wMCkgewogICAgICAgIGkgPSAxOwogICAgICB9CiAgICAgIGlmIChtMjIgPiBtMDAgJiYgbTIyID4gbTExKSB7CiAgICAgICAgaSA9IDI7CiAgICAgIH0KICAgICAgY29uc3QgaiA9IG5leHRbaV07CiAgICAgIGNvbnN0IGsgPSBuZXh0W2pdOwogICAgICByb290ID0gTWF0aC5zcXJ0KAogICAgICAgIG1hdHJpeFtNYXRyaXgzX2RlZmF1bHQuZ2V0RWxlbWVudEluZGV4KGksIGkpXSAtIG1hdHJpeFtNYXRyaXgzX2RlZmF1bHQuZ2V0RWxlbWVudEluZGV4KGosIGopXSAtIG1hdHJpeFtNYXRyaXgzX2RlZmF1bHQuZ2V0RWxlbWVudEluZGV4KGssIGspXSArIDEKICAgICAgKTsKICAgICAgY29uc3QgcXVhdCA9IGZyb21Sb3RhdGlvbk1hdHJpeFF1YXQ7CiAgICAgIHF1YXRbaV0gPSAwLjUgKiByb290OwogICAgICByb290ID0gMC41IC8gcm9vdDsKICAgICAgdyA9IChtYXRyaXhbTWF0cml4M19kZWZhdWx0LmdldEVsZW1lbnRJbmRleChrLCBqKV0gLSBtYXRyaXhbTWF0cml4M19kZWZhdWx0LmdldEVsZW1lbnRJbmRleChqLCBrKV0pICogcm9vdDsKICAgICAgcXVhdFtqXSA9IChtYXRyaXhbTWF0cml4M19kZWZhdWx0LmdldEVsZW1lbnRJbmRleChqLCBpKV0gKyBtYXRyaXhbTWF0cml4M19kZWZhdWx0LmdldEVsZW1lbnRJbmRleChpLCBqKV0pICogcm9vdDsKICAgICAgcXVhdFtrXSA9IChtYXRyaXhbTWF0cml4M19kZWZhdWx0LmdldEVsZW1lbnRJbmRleChrLCBpKV0gKyBtYXRyaXhbTWF0cml4M19kZWZhdWx0LmdldEVsZW1lbnRJbmRleChpLCBrKV0pICogcm9vdDsKICAgICAgeCA9IC1xdWF0WzBdOwogICAgICB5ID0gLXF1YXRbMV07CiAgICAgIHogPSAtcXVhdFsyXTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHgsIHksIHosIHcpOwogICAgfQogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmVzdWx0LncgPSB3OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY3JhdGNoSFBSUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgdmFyIHNjcmF0Y2hIZWFkaW5nUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgdmFyIHNjcmF0Y2hQaXRjaFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpOwogIHZhciBzY3JhdGNoUm9sbFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpOwogIFF1YXRlcm5pb24uZnJvbUhlYWRpbmdQaXRjaFJvbGwgPSBmdW5jdGlvbihoZWFkaW5nUGl0Y2hSb2xsLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiaGVhZGluZ1BpdGNoUm9sbCIsIGhlYWRpbmdQaXRjaFJvbGwpOwogICAgc2NyYXRjaFJvbGxRdWF0ZXJuaW9uID0gUXVhdGVybmlvbi5mcm9tQXhpc0FuZ2xlKAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuVU5JVF9YLAogICAgICBoZWFkaW5nUGl0Y2hSb2xsLnJvbGwsCiAgICAgIHNjcmF0Y2hIUFJRdWF0ZXJuaW9uCiAgICApOwogICAgc2NyYXRjaFBpdGNoUXVhdGVybmlvbiA9IFF1YXRlcm5pb24uZnJvbUF4aXNBbmdsZSgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LlVOSVRfWSwKICAgICAgLWhlYWRpbmdQaXRjaFJvbGwucGl0Y2gsCiAgICAgIHJlc3VsdAogICAgKTsKICAgIHJlc3VsdCA9IFF1YXRlcm5pb24ubXVsdGlwbHkoCiAgICAgIHNjcmF0Y2hQaXRjaFF1YXRlcm5pb24sCiAgICAgIHNjcmF0Y2hSb2xsUXVhdGVybmlvbiwKICAgICAgc2NyYXRjaFBpdGNoUXVhdGVybmlvbgogICAgKTsKICAgIHNjcmF0Y2hIZWFkaW5nUXVhdGVybmlvbiA9IFF1YXRlcm5pb24uZnJvbUF4aXNBbmdsZSgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LlVOSVRfWiwKICAgICAgLWhlYWRpbmdQaXRjaFJvbGwuaGVhZGluZywKICAgICAgc2NyYXRjaEhQUlF1YXRlcm5pb24KICAgICk7CiAgICByZXR1cm4gUXVhdGVybmlvbi5tdWx0aXBseShzY3JhdGNoSGVhZGluZ1F1YXRlcm5pb24sIHJlc3VsdCwgcmVzdWx0KTsKICB9OwogIHZhciBzYW1wbGVkUXVhdGVybmlvbkF4aXMgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNhbXBsZWRRdWF0ZXJuaW9uUm90YXRpb24gPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNhbXBsZWRRdWF0ZXJuaW9uVGVtcFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpOwogIHZhciBzYW1wbGVkUXVhdGVybmlvblF1YXRlcm5pb24wID0gbmV3IFF1YXRlcm5pb24oKTsKICB2YXIgc2FtcGxlZFF1YXRlcm5pb25RdWF0ZXJuaW9uMENvbmp1Z2F0ZSA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgUXVhdGVybmlvbi5wYWNrZWRMZW5ndGggPSA0OwogIFF1YXRlcm5pb24ucGFjayA9IGZ1bmN0aW9uKHZhbHVlLCBhcnJheSwgc3RhcnRpbmdJbmRleCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ2YWx1ZSIsIHZhbHVlKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RhcnRpbmdJbmRleCwgMCk7CiAgICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUueDsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS55OwogICAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLno7CiAgICBhcnJheVtzdGFydGluZ0luZGV4XSA9IHZhbHVlLnc7CiAgICByZXR1cm4gYXJyYXk7CiAgfTsKICBRdWF0ZXJuaW9uLnVucGFjayA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydGluZ0luZGV4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RhcnRpbmdJbmRleCwgMCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICB9CiAgICByZXN1bHQueCA9IGFycmF5W3N0YXJ0aW5nSW5kZXhdOwogICAgcmVzdWx0LnkgPSBhcnJheVtzdGFydGluZ0luZGV4ICsgMV07CiAgICByZXN1bHQueiA9IGFycmF5W3N0YXJ0aW5nSW5kZXggKyAyXTsKICAgIHJlc3VsdC53ID0gYXJyYXlbc3RhcnRpbmdJbmRleCArIDNdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFF1YXRlcm5pb24ucGFja2VkSW50ZXJwb2xhdGlvbkxlbmd0aCA9IDM7CiAgUXVhdGVybmlvbi5jb252ZXJ0UGFja2VkQXJyYXlGb3JJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24ocGFja2VkQXJyYXksIHN0YXJ0aW5nSW5kZXgsIGxhc3RJbmRleCwgcmVzdWx0KSB7CiAgICBRdWF0ZXJuaW9uLnVucGFjaygKICAgICAgcGFja2VkQXJyYXksCiAgICAgIGxhc3RJbmRleCAqIDQsCiAgICAgIHNhbXBsZWRRdWF0ZXJuaW9uUXVhdGVybmlvbjBDb25qdWdhdGUKICAgICk7CiAgICBRdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgKICAgICAgc2FtcGxlZFF1YXRlcm5pb25RdWF0ZXJuaW9uMENvbmp1Z2F0ZSwKICAgICAgc2FtcGxlZFF1YXRlcm5pb25RdWF0ZXJuaW9uMENvbmp1Z2F0ZQogICAgKTsKICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXN0SW5kZXggLSBzdGFydGluZ0luZGV4ICsgMTsgaSA8IGxlbjsgaSsrKSB7CiAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiAzOwogICAgICBRdWF0ZXJuaW9uLnVucGFjaygKICAgICAgICBwYWNrZWRBcnJheSwKICAgICAgICAoc3RhcnRpbmdJbmRleCArIGkpICogNCwKICAgICAgICBzYW1wbGVkUXVhdGVybmlvblRlbXBRdWF0ZXJuaW9uCiAgICAgICk7CiAgICAgIFF1YXRlcm5pb24ubXVsdGlwbHkoCiAgICAgICAgc2FtcGxlZFF1YXRlcm5pb25UZW1wUXVhdGVybmlvbiwKICAgICAgICBzYW1wbGVkUXVhdGVybmlvblF1YXRlcm5pb24wQ29uanVnYXRlLAogICAgICAgIHNhbXBsZWRRdWF0ZXJuaW9uVGVtcFF1YXRlcm5pb24KICAgICAgKTsKICAgICAgaWYgKHNhbXBsZWRRdWF0ZXJuaW9uVGVtcFF1YXRlcm5pb24udyA8IDApIHsKICAgICAgICBRdWF0ZXJuaW9uLm5lZ2F0ZSgKICAgICAgICAgIHNhbXBsZWRRdWF0ZXJuaW9uVGVtcFF1YXRlcm5pb24sCiAgICAgICAgICBzYW1wbGVkUXVhdGVybmlvblRlbXBRdWF0ZXJuaW9uCiAgICAgICAgKTsKICAgICAgfQogICAgICBRdWF0ZXJuaW9uLmNvbXB1dGVBeGlzKAogICAgICAgIHNhbXBsZWRRdWF0ZXJuaW9uVGVtcFF1YXRlcm5pb24sCiAgICAgICAgc2FtcGxlZFF1YXRlcm5pb25BeGlzCiAgICAgICk7CiAgICAgIGNvbnN0IGFuZ2xlID0gUXVhdGVybmlvbi5jb21wdXRlQW5nbGUoc2FtcGxlZFF1YXRlcm5pb25UZW1wUXVhdGVybmlvbik7CiAgICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgICByZXN1bHQgPSBbXTsKICAgICAgfQogICAgICByZXN1bHRbb2Zmc2V0XSA9IHNhbXBsZWRRdWF0ZXJuaW9uQXhpcy54ICogYW5nbGU7CiAgICAgIHJlc3VsdFtvZmZzZXQgKyAxXSA9IHNhbXBsZWRRdWF0ZXJuaW9uQXhpcy55ICogYW5nbGU7CiAgICAgIHJlc3VsdFtvZmZzZXQgKyAyXSA9IHNhbXBsZWRRdWF0ZXJuaW9uQXhpcy56ICogYW5nbGU7CiAgICB9CiAgfTsKICBRdWF0ZXJuaW9uLnVucGFja0ludGVycG9sYXRpb25SZXN1bHQgPSBmdW5jdGlvbihhcnJheSwgc291cmNlQXJyYXksIGZpcnN0SW5kZXgsIGxhc3RJbmRleCwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbUFycmF5KGFycmF5LCAwLCBzYW1wbGVkUXVhdGVybmlvblJvdGF0aW9uKTsKICAgIGNvbnN0IG1hZ25pdHVkZSA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUoc2FtcGxlZFF1YXRlcm5pb25Sb3RhdGlvbik7CiAgICBRdWF0ZXJuaW9uLnVucGFjayhzb3VyY2VBcnJheSwgbGFzdEluZGV4ICogNCwgc2FtcGxlZFF1YXRlcm5pb25RdWF0ZXJuaW9uMCk7CiAgICBpZiAobWFnbml0dWRlID09PSAwKSB7CiAgICAgIFF1YXRlcm5pb24uY2xvbmUoUXVhdGVybmlvbi5JREVOVElUWSwgc2FtcGxlZFF1YXRlcm5pb25UZW1wUXVhdGVybmlvbik7CiAgICB9IGVsc2UgewogICAgICBRdWF0ZXJuaW9uLmZyb21BeGlzQW5nbGUoCiAgICAgICAgc2FtcGxlZFF1YXRlcm5pb25Sb3RhdGlvbiwKICAgICAgICBtYWduaXR1ZGUsCiAgICAgICAgc2FtcGxlZFF1YXRlcm5pb25UZW1wUXVhdGVybmlvbgogICAgICApOwogICAgfQogICAgcmV0dXJuIFF1YXRlcm5pb24ubXVsdGlwbHkoCiAgICAgIHNhbXBsZWRRdWF0ZXJuaW9uVGVtcFF1YXRlcm5pb24sCiAgICAgIHNhbXBsZWRRdWF0ZXJuaW9uUXVhdGVybmlvbjAsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIFF1YXRlcm5pb24uY2xvbmUgPSBmdW5jdGlvbihxdWF0ZXJuaW9uLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHF1YXRlcm5pb24pKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigKICAgICAgICBxdWF0ZXJuaW9uLngsCiAgICAgICAgcXVhdGVybmlvbi55LAogICAgICAgIHF1YXRlcm5pb24ueiwKICAgICAgICBxdWF0ZXJuaW9uLncKICAgICAgKTsKICAgIH0KICAgIHJlc3VsdC54ID0gcXVhdGVybmlvbi54OwogICAgcmVzdWx0LnkgPSBxdWF0ZXJuaW9uLnk7CiAgICByZXN1bHQueiA9IHF1YXRlcm5pb24uejsKICAgIHJlc3VsdC53ID0gcXVhdGVybmlvbi53OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFF1YXRlcm5pb24uY29uanVnYXRlID0gZnVuY3Rpb24ocXVhdGVybmlvbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInF1YXRlcm5pb24iLCBxdWF0ZXJuaW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gLXF1YXRlcm5pb24ueDsKICAgIHJlc3VsdC55ID0gLXF1YXRlcm5pb24ueTsKICAgIHJlc3VsdC56ID0gLXF1YXRlcm5pb24uejsKICAgIHJlc3VsdC53ID0gcXVhdGVybmlvbi53OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFF1YXRlcm5pb24ubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uKHF1YXRlcm5pb24pIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicXVhdGVybmlvbiIsIHF1YXRlcm5pb24pOwogICAgcmV0dXJuIHF1YXRlcm5pb24ueCAqIHF1YXRlcm5pb24ueCArIHF1YXRlcm5pb24ueSAqIHF1YXRlcm5pb24ueSArIHF1YXRlcm5pb24ueiAqIHF1YXRlcm5pb24ueiArIHF1YXRlcm5pb24udyAqIHF1YXRlcm5pb24udzsKICB9OwogIFF1YXRlcm5pb24ubWFnbml0dWRlID0gZnVuY3Rpb24ocXVhdGVybmlvbikgewogICAgcmV0dXJuIE1hdGguc3FydChRdWF0ZXJuaW9uLm1hZ25pdHVkZVNxdWFyZWQocXVhdGVybmlvbikpOwogIH07CiAgUXVhdGVybmlvbi5ub3JtYWxpemUgPSBmdW5jdGlvbihxdWF0ZXJuaW9uLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGludmVyc2VNYWduaXR1ZGUgPSAxIC8gUXVhdGVybmlvbi5tYWduaXR1ZGUocXVhdGVybmlvbik7CiAgICBjb25zdCB4ID0gcXVhdGVybmlvbi54ICogaW52ZXJzZU1hZ25pdHVkZTsKICAgIGNvbnN0IHkgPSBxdWF0ZXJuaW9uLnkgKiBpbnZlcnNlTWFnbml0dWRlOwogICAgY29uc3QgeiA9IHF1YXRlcm5pb24ueiAqIGludmVyc2VNYWduaXR1ZGU7CiAgICBjb25zdCB3ID0gcXVhdGVybmlvbi53ICogaW52ZXJzZU1hZ25pdHVkZTsKICAgIHJlc3VsdC54ID0geDsKICAgIHJlc3VsdC55ID0geTsKICAgIHJlc3VsdC56ID0gejsKICAgIHJlc3VsdC53ID0gdzsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBRdWF0ZXJuaW9uLmludmVyc2UgPSBmdW5jdGlvbihxdWF0ZXJuaW9uLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IG1hZ25pdHVkZVNxdWFyZWQgPSBRdWF0ZXJuaW9uLm1hZ25pdHVkZVNxdWFyZWQocXVhdGVybmlvbik7CiAgICByZXN1bHQgPSBRdWF0ZXJuaW9uLmNvbmp1Z2F0ZShxdWF0ZXJuaW9uLCByZXN1bHQpOwogICAgcmV0dXJuIFF1YXRlcm5pb24ubXVsdGlwbHlCeVNjYWxhcihyZXN1bHQsIDEgLyBtYWduaXR1ZGVTcXVhcmVkLCByZXN1bHQpOwogIH07CiAgUXVhdGVybmlvbi5hZGQgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IGxlZnQueCArIHJpZ2h0Lng7CiAgICByZXN1bHQueSA9IGxlZnQueSArIHJpZ2h0Lnk7CiAgICByZXN1bHQueiA9IGxlZnQueiArIHJpZ2h0Lno7CiAgICByZXN1bHQudyA9IGxlZnQudyArIHJpZ2h0Lnc7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUXVhdGVybmlvbi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gbGVmdC54IC0gcmlnaHQueDsKICAgIHJlc3VsdC55ID0gbGVmdC55IC0gcmlnaHQueTsKICAgIHJlc3VsdC56ID0gbGVmdC56IC0gcmlnaHQuejsKICAgIHJlc3VsdC53ID0gbGVmdC53IC0gcmlnaHQudzsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBRdWF0ZXJuaW9uLm5lZ2F0ZSA9IGZ1bmN0aW9uKHF1YXRlcm5pb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJxdWF0ZXJuaW9uIiwgcXVhdGVybmlvbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IC1xdWF0ZXJuaW9uLng7CiAgICByZXN1bHQueSA9IC1xdWF0ZXJuaW9uLnk7CiAgICByZXN1bHQueiA9IC1xdWF0ZXJuaW9uLno7CiAgICByZXN1bHQudyA9IC1xdWF0ZXJuaW9uLnc7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUXVhdGVybmlvbi5kb3QgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgcmV0dXJuIGxlZnQueCAqIHJpZ2h0LnggKyBsZWZ0LnkgKiByaWdodC55ICsgbGVmdC56ICogcmlnaHQueiArIGxlZnQudyAqIHJpZ2h0Lnc7CiAgfTsKICBRdWF0ZXJuaW9uLm11bHRpcGx5ID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJsZWZ0IiwgbGVmdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJpZ2h0IiwgcmlnaHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgbGVmdFggPSBsZWZ0Lng7CiAgICBjb25zdCBsZWZ0WSA9IGxlZnQueTsKICAgIGNvbnN0IGxlZnRaID0gbGVmdC56OwogICAgY29uc3QgbGVmdFcgPSBsZWZ0Lnc7CiAgICBjb25zdCByaWdodFggPSByaWdodC54OwogICAgY29uc3QgcmlnaHRZID0gcmlnaHQueTsKICAgIGNvbnN0IHJpZ2h0WiA9IHJpZ2h0Lno7CiAgICBjb25zdCByaWdodFcgPSByaWdodC53OwogICAgY29uc3QgeCA9IGxlZnRXICogcmlnaHRYICsgbGVmdFggKiByaWdodFcgKyBsZWZ0WSAqIHJpZ2h0WiAtIGxlZnRaICogcmlnaHRZOwogICAgY29uc3QgeSA9IGxlZnRXICogcmlnaHRZIC0gbGVmdFggKiByaWdodFogKyBsZWZ0WSAqIHJpZ2h0VyArIGxlZnRaICogcmlnaHRYOwogICAgY29uc3QgeiA9IGxlZnRXICogcmlnaHRaICsgbGVmdFggKiByaWdodFkgLSBsZWZ0WSAqIHJpZ2h0WCArIGxlZnRaICogcmlnaHRXOwogICAgY29uc3QgdyA9IGxlZnRXICogcmlnaHRXIC0gbGVmdFggKiByaWdodFggLSBsZWZ0WSAqIHJpZ2h0WSAtIGxlZnRaICogcmlnaHRaOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmVzdWx0LncgPSB3OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFF1YXRlcm5pb24ubXVsdGlwbHlCeVNjYWxhciA9IGZ1bmN0aW9uKHF1YXRlcm5pb24sIHNjYWxhciwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInF1YXRlcm5pb24iLCBxdWF0ZXJuaW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigic2NhbGFyIiwgc2NhbGFyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIHJlc3VsdC54ID0gcXVhdGVybmlvbi54ICogc2NhbGFyOwogICAgcmVzdWx0LnkgPSBxdWF0ZXJuaW9uLnkgKiBzY2FsYXI7CiAgICByZXN1bHQueiA9IHF1YXRlcm5pb24ueiAqIHNjYWxhcjsKICAgIHJlc3VsdC53ID0gcXVhdGVybmlvbi53ICogc2NhbGFyOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFF1YXRlcm5pb24uZGl2aWRlQnlTY2FsYXIgPSBmdW5jdGlvbihxdWF0ZXJuaW9uLCBzY2FsYXIsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJxdWF0ZXJuaW9uIiwgcXVhdGVybmlvbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInNjYWxhciIsIHNjYWxhcik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICByZXN1bHQueCA9IHF1YXRlcm5pb24ueCAvIHNjYWxhcjsKICAgIHJlc3VsdC55ID0gcXVhdGVybmlvbi55IC8gc2NhbGFyOwogICAgcmVzdWx0LnogPSBxdWF0ZXJuaW9uLnogLyBzY2FsYXI7CiAgICByZXN1bHQudyA9IHF1YXRlcm5pb24udyAvIHNjYWxhcjsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBRdWF0ZXJuaW9uLmNvbXB1dGVBeGlzID0gZnVuY3Rpb24ocXVhdGVybmlvbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInF1YXRlcm5pb24iLCBxdWF0ZXJuaW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IHcgPSBxdWF0ZXJuaW9uLnc7CiAgICBpZiAoTWF0aC5hYnModyAtIDEpIDwgTWF0aF9kZWZhdWx0LkVQU0lMT042KSB7CiAgICAgIHJlc3VsdC54ID0gcmVzdWx0LnkgPSByZXN1bHQueiA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBjb25zdCBzY2FsYXIgPSAxIC8gTWF0aC5zcXJ0KDEgLSB3ICogdyk7CiAgICByZXN1bHQueCA9IHF1YXRlcm5pb24ueCAqIHNjYWxhcjsKICAgIHJlc3VsdC55ID0gcXVhdGVybmlvbi55ICogc2NhbGFyOwogICAgcmVzdWx0LnogPSBxdWF0ZXJuaW9uLnogKiBzY2FsYXI7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgUXVhdGVybmlvbi5jb21wdXRlQW5nbGUgPSBmdW5jdGlvbihxdWF0ZXJuaW9uKSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInF1YXRlcm5pb24iLCBxdWF0ZXJuaW9uKTsKICAgIGlmIChNYXRoLmFicyhxdWF0ZXJuaW9uLncgLSAxKSA8IE1hdGhfZGVmYXVsdC5FUFNJTE9ONikgewogICAgICByZXR1cm4gMDsKICAgIH0KICAgIHJldHVybiAyICogTWF0aC5hY29zKHF1YXRlcm5pb24udyk7CiAgfTsKICB2YXIgbGVycFNjcmF0Y2g0ID0gbmV3IFF1YXRlcm5pb24oKTsKICBRdWF0ZXJuaW9uLmxlcnAgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic3RhcnQiLCBzdGFydCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImVuZCIsIGVuZCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInQiLCB0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGxlcnBTY3JhdGNoNCA9IFF1YXRlcm5pb24ubXVsdGlwbHlCeVNjYWxhcihlbmQsIHQsIGxlcnBTY3JhdGNoNCk7CiAgICByZXN1bHQgPSBRdWF0ZXJuaW9uLm11bHRpcGx5QnlTY2FsYXIoc3RhcnQsIDEgLSB0LCByZXN1bHQpOwogICAgcmV0dXJuIFF1YXRlcm5pb24uYWRkKGxlcnBTY3JhdGNoNCwgcmVzdWx0LCByZXN1bHQpOwogIH07CiAgdmFyIHNsZXJwRW5kTmVnYXRlZCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgdmFyIHNsZXJwU2NhbGVkUCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgdmFyIHNsZXJwU2NhbGVkUiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgUXVhdGVybmlvbi5zbGVycCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzdGFydCIsIHN0YXJ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZW5kIiwgZW5kKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigidCIsIHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgbGV0IGRvdCA9IFF1YXRlcm5pb24uZG90KHN0YXJ0LCBlbmQpOwogICAgbGV0IHIgPSBlbmQ7CiAgICBpZiAoZG90IDwgMCkgewogICAgICBkb3QgPSAtZG90OwogICAgICByID0gc2xlcnBFbmROZWdhdGVkID0gUXVhdGVybmlvbi5uZWdhdGUoZW5kLCBzbGVycEVuZE5lZ2F0ZWQpOwogICAgfQogICAgaWYgKDEgLSBkb3QgPCBNYXRoX2RlZmF1bHQuRVBTSUxPTjYpIHsKICAgICAgcmV0dXJuIFF1YXRlcm5pb24ubGVycChzdGFydCwgciwgdCwgcmVzdWx0KTsKICAgIH0KICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKGRvdCk7CiAgICBzbGVycFNjYWxlZFAgPSBRdWF0ZXJuaW9uLm11bHRpcGx5QnlTY2FsYXIoCiAgICAgIHN0YXJ0LAogICAgICBNYXRoLnNpbigoMSAtIHQpICogdGhldGEpLAogICAgICBzbGVycFNjYWxlZFAKICAgICk7CiAgICBzbGVycFNjYWxlZFIgPSBRdWF0ZXJuaW9uLm11bHRpcGx5QnlTY2FsYXIoCiAgICAgIHIsCiAgICAgIE1hdGguc2luKHQgKiB0aGV0YSksCiAgICAgIHNsZXJwU2NhbGVkUgogICAgKTsKICAgIHJlc3VsdCA9IFF1YXRlcm5pb24uYWRkKHNsZXJwU2NhbGVkUCwgc2xlcnBTY2FsZWRSLCByZXN1bHQpOwogICAgcmV0dXJuIFF1YXRlcm5pb24ubXVsdGlwbHlCeVNjYWxhcihyZXN1bHQsIDEgLyBNYXRoLnNpbih0aGV0YSksIHJlc3VsdCk7CiAgfTsKICBRdWF0ZXJuaW9uLmxvZyA9IGZ1bmN0aW9uKHF1YXRlcm5pb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJxdWF0ZXJuaW9uIiwgcXVhdGVybmlvbik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCB0aGV0YSA9IE1hdGhfZGVmYXVsdC5hY29zQ2xhbXBlZChxdWF0ZXJuaW9uLncpOwogICAgbGV0IHRoZXRhT3ZlclNpblRoZXRhID0gMDsKICAgIGlmICh0aGV0YSAhPT0gMCkgewogICAgICB0aGV0YU92ZXJTaW5UaGV0YSA9IHRoZXRhIC8gTWF0aC5zaW4odGhldGEpOwogICAgfQogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGFyKHF1YXRlcm5pb24sIHRoZXRhT3ZlclNpblRoZXRhLCByZXN1bHQpOwogIH07CiAgUXVhdGVybmlvbi5leHAgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgdGhldGEgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKGNhcnRlc2lhbik7CiAgICBsZXQgc2luVGhldGFPdmVyVGhldGEgPSAwOwogICAgaWYgKHRoZXRhICE9PSAwKSB7CiAgICAgIHNpblRoZXRhT3ZlclRoZXRhID0gTWF0aC5zaW4odGhldGEpIC8gdGhldGE7CiAgICB9CiAgICByZXN1bHQueCA9IGNhcnRlc2lhbi54ICogc2luVGhldGFPdmVyVGhldGE7CiAgICByZXN1bHQueSA9IGNhcnRlc2lhbi55ICogc2luVGhldGFPdmVyVGhldGE7CiAgICByZXN1bHQueiA9IGNhcnRlc2lhbi56ICogc2luVGhldGFPdmVyVGhldGE7CiAgICByZXN1bHQudyA9IE1hdGguY29zKHRoZXRhKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc3F1YWRTY3JhdGNoQ2FydGVzaWFuMCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc3F1YWRTY3JhdGNoQ2FydGVzaWFuMSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc3F1YWRTY3JhdGNoUXVhdGVybmlvbjAgPSBuZXcgUXVhdGVybmlvbigpOwogIHZhciBzcXVhZFNjcmF0Y2hRdWF0ZXJuaW9uMSA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgUXVhdGVybmlvbi5jb21wdXRlSW5uZXJRdWFkcmFuZ2xlID0gZnVuY3Rpb24ocTAsIHExLCBxMiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInEwIiwgcTApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJxMSIsIHExKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicTIiLCBxMik7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBxSW52ID0gUXVhdGVybmlvbi5jb25qdWdhdGUocTEsIHNxdWFkU2NyYXRjaFF1YXRlcm5pb24wKTsKICAgIFF1YXRlcm5pb24ubXVsdGlwbHkocUludiwgcTIsIHNxdWFkU2NyYXRjaFF1YXRlcm5pb24xKTsKICAgIGNvbnN0IGNhcnQwID0gUXVhdGVybmlvbi5sb2coc3F1YWRTY3JhdGNoUXVhdGVybmlvbjEsIHNxdWFkU2NyYXRjaENhcnRlc2lhbjApOwogICAgUXVhdGVybmlvbi5tdWx0aXBseShxSW52LCBxMCwgc3F1YWRTY3JhdGNoUXVhdGVybmlvbjEpOwogICAgY29uc3QgY2FydDEgPSBRdWF0ZXJuaW9uLmxvZyhzcXVhZFNjcmF0Y2hRdWF0ZXJuaW9uMSwgc3F1YWRTY3JhdGNoQ2FydGVzaWFuMSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNhcnQwLCBjYXJ0MSwgY2FydDApOwogICAgQ2FydGVzaWFuM19kZWZhdWx0Lm11bHRpcGx5QnlTY2FsYXIoY2FydDAsIDAuMjUsIGNhcnQwKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5uZWdhdGUoY2FydDAsIGNhcnQwKTsKICAgIFF1YXRlcm5pb24uZXhwKGNhcnQwLCBzcXVhZFNjcmF0Y2hRdWF0ZXJuaW9uMCk7CiAgICByZXR1cm4gUXVhdGVybmlvbi5tdWx0aXBseShxMSwgc3F1YWRTY3JhdGNoUXVhdGVybmlvbjAsIHJlc3VsdCk7CiAgfTsKICBRdWF0ZXJuaW9uLnNxdWFkID0gZnVuY3Rpb24ocTAsIHExLCBzMCwgczEsIHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJxMCIsIHEwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicTEiLCBxMSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInMwIiwgczApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzMSIsIHMxKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigidCIsIHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3Qgc2xlcnAwID0gUXVhdGVybmlvbi5zbGVycChxMCwgcTEsIHQsIHNxdWFkU2NyYXRjaFF1YXRlcm5pb24wKTsKICAgIGNvbnN0IHNsZXJwMSA9IFF1YXRlcm5pb24uc2xlcnAoczAsIHMxLCB0LCBzcXVhZFNjcmF0Y2hRdWF0ZXJuaW9uMSk7CiAgICByZXR1cm4gUXVhdGVybmlvbi5zbGVycChzbGVycDAsIHNsZXJwMSwgMiAqIHQgKiAoMSAtIHQpLCByZXN1bHQpOwogIH07CiAgdmFyIGZhc3RTbGVycFNjcmF0Y2hRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKICB2YXIgb3BtdSA9IDEuOTAxMTA3NDUzNTE3MzAwMzsKICB2YXIgdSA9IEZlYXR1cmVEZXRlY3Rpb25fZGVmYXVsdC5zdXBwb3J0c1R5cGVkQXJyYXlzKCkgPyBuZXcgRmxvYXQzMkFycmF5KDgpIDogW107CiAgdmFyIHYgPSBGZWF0dXJlRGV0ZWN0aW9uX2RlZmF1bHQuc3VwcG9ydHNUeXBlZEFycmF5cygpID8gbmV3IEZsb2F0MzJBcnJheSg4KSA6IFtdOwogIHZhciBiVCA9IEZlYXR1cmVEZXRlY3Rpb25fZGVmYXVsdC5zdXBwb3J0c1R5cGVkQXJyYXlzKCkgPyBuZXcgRmxvYXQzMkFycmF5KDgpIDogW107CiAgdmFyIGJEID0gRmVhdHVyZURldGVjdGlvbl9kZWZhdWx0LnN1cHBvcnRzVHlwZWRBcnJheXMoKSA/IG5ldyBGbG9hdDMyQXJyYXkoOCkgOiBbXTsKICBmb3IgKGxldCBpID0gMDsgaSA8IDc7ICsraSkgewogICAgY29uc3QgcyA9IGkgKyAxOwogICAgY29uc3QgdCA9IDIgKiBzICsgMTsKICAgIHVbaV0gPSAxIC8gKHMgKiB0KTsKICAgIHZbaV0gPSBzIC8gdDsKICB9CiAgdVs3XSA9IG9wbXUgLyAoOCAqIDE3KTsKICB2WzddID0gb3BtdSAqIDggLyAxNzsKICBRdWF0ZXJuaW9uLmZhc3RTbGVycCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzdGFydCIsIHN0YXJ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZW5kIiwgZW5kKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigidCIsIHQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgbGV0IHggPSBRdWF0ZXJuaW9uLmRvdChzdGFydCwgZW5kKTsKICAgIGxldCBzaWduMjsKICAgIGlmICh4ID49IDApIHsKICAgICAgc2lnbjIgPSAxOwogICAgfSBlbHNlIHsKICAgICAgc2lnbjIgPSAtMTsKICAgICAgeCA9IC14OwogICAgfQogICAgY29uc3QgeG0xID0geCAtIDE7CiAgICBjb25zdCBkID0gMSAtIHQ7CiAgICBjb25zdCBzcXJUID0gdCAqIHQ7CiAgICBjb25zdCBzcXJEID0gZCAqIGQ7CiAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyAtLWkpIHsKICAgICAgYlRbaV0gPSAodVtpXSAqIHNxclQgLSB2W2ldKSAqIHhtMTsKICAgICAgYkRbaV0gPSAodVtpXSAqIHNxckQgLSB2W2ldKSAqIHhtMTsKICAgIH0KICAgIGNvbnN0IGNUID0gc2lnbjIgKiB0ICogKDEgKyBiVFswXSAqICgxICsgYlRbMV0gKiAoMSArIGJUWzJdICogKDEgKyBiVFszXSAqICgxICsgYlRbNF0gKiAoMSArIGJUWzVdICogKDEgKyBiVFs2XSAqICgxICsgYlRbN10pKSkpKSkpKTsKICAgIGNvbnN0IGNEID0gZCAqICgxICsgYkRbMF0gKiAoMSArIGJEWzFdICogKDEgKyBiRFsyXSAqICgxICsgYkRbM10gKiAoMSArIGJEWzRdICogKDEgKyBiRFs1XSAqICgxICsgYkRbNl0gKiAoMSArIGJEWzddKSkpKSkpKSk7CiAgICBjb25zdCB0ZW1wID0gUXVhdGVybmlvbi5tdWx0aXBseUJ5U2NhbGFyKAogICAgICBzdGFydCwKICAgICAgY0QsCiAgICAgIGZhc3RTbGVycFNjcmF0Y2hRdWF0ZXJuaW9uCiAgICApOwogICAgUXVhdGVybmlvbi5tdWx0aXBseUJ5U2NhbGFyKGVuZCwgY1QsIHJlc3VsdCk7CiAgICByZXR1cm4gUXVhdGVybmlvbi5hZGQodGVtcCwgcmVzdWx0LCByZXN1bHQpOwogIH07CiAgUXVhdGVybmlvbi5mYXN0U3F1YWQgPSBmdW5jdGlvbihxMCwgcTEsIHMwLCBzMSwgdCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInEwIiwgcTApOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJxMSIsIHExKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiczAiLCBzMCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInMxIiwgczEpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJ0IiwgdCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCBzbGVycDAgPSBRdWF0ZXJuaW9uLmZhc3RTbGVycChxMCwgcTEsIHQsIHNxdWFkU2NyYXRjaFF1YXRlcm5pb24wKTsKICAgIGNvbnN0IHNsZXJwMSA9IFF1YXRlcm5pb24uZmFzdFNsZXJwKHMwLCBzMSwgdCwgc3F1YWRTY3JhdGNoUXVhdGVybmlvbjEpOwogICAgcmV0dXJuIFF1YXRlcm5pb24uZmFzdFNsZXJwKHNsZXJwMCwgc2xlcnAxLCAyICogdCAqICgxIC0gdCksIHJlc3VsdCk7CiAgfTsKICBRdWF0ZXJuaW9uLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgbGVmdC54ID09PSByaWdodC54ICYmIGxlZnQueSA9PT0gcmlnaHQueSAmJiBsZWZ0LnogPT09IHJpZ2h0LnogJiYgbGVmdC53ID09PSByaWdodC53OwogIH07CiAgUXVhdGVybmlvbi5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGVwc2lsb24pIHsKICAgIGVwc2lsb24gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChlcHNpbG9uLCAwKTsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBNYXRoLmFicyhsZWZ0LnggLSByaWdodC54KSA8PSBlcHNpbG9uICYmIE1hdGguYWJzKGxlZnQueSAtIHJpZ2h0LnkpIDw9IGVwc2lsb24gJiYgTWF0aC5hYnMobGVmdC56IC0gcmlnaHQueikgPD0gZXBzaWxvbiAmJiBNYXRoLmFicyhsZWZ0LncgLSByaWdodC53KSA8PSBlcHNpbG9uOwogIH07CiAgUXVhdGVybmlvbi5aRVJPID0gT2JqZWN0LmZyZWV6ZShuZXcgUXVhdGVybmlvbigwLCAwLCAwLCAwKSk7CiAgUXVhdGVybmlvbi5JREVOVElUWSA9IE9iamVjdC5mcmVlemUobmV3IFF1YXRlcm5pb24oMCwgMCwgMCwgMSkpOwogIFF1YXRlcm5pb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gUXVhdGVybmlvbi5jbG9uZSh0aGlzLCByZXN1bHQpOwogIH07CiAgUXVhdGVybmlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocmlnaHQpIHsKICAgIHJldHVybiBRdWF0ZXJuaW9uLmVxdWFscyh0aGlzLCByaWdodCk7CiAgfTsKICBRdWF0ZXJuaW9uLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24ocmlnaHQsIGVwc2lsb24pIHsKICAgIHJldHVybiBRdWF0ZXJuaW9uLmVxdWFsc0Vwc2lsb24odGhpcywgcmlnaHQsIGVwc2lsb24pOwogIH07CiAgUXVhdGVybmlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiBgKCR7dGhpcy54fSwgJHt0aGlzLnl9LCAke3RoaXMuen0sICR7dGhpcy53fSlgOwogIH07CiAgdmFyIFF1YXRlcm5pb25fZGVmYXVsdCA9IFF1YXRlcm5pb247CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9iaW5hcnlTZWFyY2guanMKICBmdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyYXksIGl0ZW1Ub0ZpbmQsIGNvbXBhcmF0b3IpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoIml0ZW1Ub0ZpbmQiLCBpdGVtVG9GaW5kKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiY29tcGFyYXRvciIsIGNvbXBhcmF0b3IpOwogICAgbGV0IGxvdyA9IDA7CiAgICBsZXQgaGlnaCA9IGFycmF5Lmxlbmd0aCAtIDE7CiAgICBsZXQgaTsKICAgIGxldCBjb21wYXJpc29uOwogICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7CiAgICAgIGkgPSB+figobG93ICsgaGlnaCkgLyAyKTsKICAgICAgY29tcGFyaXNvbiA9IGNvbXBhcmF0b3IoYXJyYXlbaV0sIGl0ZW1Ub0ZpbmQpOwogICAgICBpZiAoY29tcGFyaXNvbiA8IDApIHsKICAgICAgICBsb3cgPSBpICsgMTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoY29tcGFyaXNvbiA+IDApIHsKICAgICAgICBoaWdoID0gaSAtIDE7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgcmV0dXJuIGk7CiAgICB9CiAgICByZXR1cm4gfihoaWdoICsgMSk7CiAgfQogIHZhciBiaW5hcnlTZWFyY2hfZGVmYXVsdCA9IGJpbmFyeVNlYXJjaDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0VhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzU2FtcGxlLmpzCiAgZnVuY3Rpb24gRWFydGhPcmllbnRhdGlvblBhcmFtZXRlcnNTYW1wbGUoeFBvbGVXYW5kZXIsIHlQb2xlV2FuZGVyLCB4UG9sZU9mZnNldCwgeVBvbGVPZmZzZXQsIHV0MU1pbnVzVXRjKSB7CiAgICB0aGlzLnhQb2xlV2FuZGVyID0geFBvbGVXYW5kZXI7CiAgICB0aGlzLnlQb2xlV2FuZGVyID0geVBvbGVXYW5kZXI7CiAgICB0aGlzLnhQb2xlT2Zmc2V0ID0geFBvbGVPZmZzZXQ7CiAgICB0aGlzLnlQb2xlT2Zmc2V0ID0geVBvbGVPZmZzZXQ7CiAgICB0aGlzLnV0MU1pbnVzVXRjID0gdXQxTWludXNVdGM7CiAgfQogIHZhciBFYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVyc1NhbXBsZV9kZWZhdWx0ID0gRWFydGhPcmllbnRhdGlvblBhcmFtZXRlcnNTYW1wbGU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9HcmVnb3JpYW5EYXRlLmpzCiAgZnVuY3Rpb24gR3JlZ29yaWFuRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGlzTGVhcFNlY29uZCkgewogICAgdGhpcy55ZWFyID0geWVhcjsKICAgIHRoaXMubW9udGggPSBtb250aDsKICAgIHRoaXMuZGF5ID0gZGF5OwogICAgdGhpcy5ob3VyID0gaG91cjsKICAgIHRoaXMubWludXRlID0gbWludXRlOwogICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7CiAgICB0aGlzLm1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7CiAgICB0aGlzLmlzTGVhcFNlY29uZCA9IGlzTGVhcFNlY29uZDsKICB9CiAgdmFyIEdyZWdvcmlhbkRhdGVfZGVmYXVsdCA9IEdyZWdvcmlhbkRhdGU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9pc0xlYXBZZWFyLmpzCiAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7CiAgICBpZiAoeWVhciA9PT0gbnVsbCB8fCBpc05hTih5ZWFyKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgieWVhciBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIG51bWJlci4iKTsKICAgIH0KICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDA7CiAgfQogIHZhciBpc0xlYXBZZWFyX2RlZmF1bHQgPSBpc0xlYXBZZWFyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvTGVhcFNlY29uZC5qcwogIGZ1bmN0aW9uIExlYXBTZWNvbmQoZGF0ZSwgb2Zmc2V0KSB7CiAgICB0aGlzLmp1bGlhbkRhdGUgPSBkYXRlOwogICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7CiAgfQogIHZhciBMZWFwU2Vjb25kX2RlZmF1bHQgPSBMZWFwU2Vjb25kOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGltZUNvbnN0YW50cy5qcwogIHZhciBUaW1lQ29uc3RhbnRzID0gewogICAgU0VDT05EU19QRVJfTUlMTElTRUNPTkQ6IDFlLTMsCiAgICBTRUNPTkRTX1BFUl9NSU5VVEU6IDYwLAogICAgTUlOVVRFU19QRVJfSE9VUjogNjAsCiAgICBIT1VSU19QRVJfREFZOiAyNCwKICAgIFNFQ09ORFNfUEVSX0hPVVI6IDM2MDAsCiAgICBNSU5VVEVTX1BFUl9EQVk6IDE0NDAsCiAgICBTRUNPTkRTX1BFUl9EQVk6IDg2NDAwLAogICAgREFZU19QRVJfSlVMSUFOX0NFTlRVUlk6IDM2NTI1LAogICAgUElDT1NFQ09ORDogMWUtOSwKICAgIE1PRElGSUVEX0pVTElBTl9EQVRFX0RJRkZFUkVOQ0U6IDI0MDAwMDA1ZS0xCiAgfTsKICB2YXIgVGltZUNvbnN0YW50c19kZWZhdWx0ID0gT2JqZWN0LmZyZWV6ZShUaW1lQ29uc3RhbnRzKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RpbWVTdGFuZGFyZC5qcwogIHZhciBUaW1lU3RhbmRhcmQgPSB7CiAgICBVVEM6IDAsCiAgICBUQUk6IDEKICB9OwogIHZhciBUaW1lU3RhbmRhcmRfZGVmYXVsdCA9IE9iamVjdC5mcmVlemUoVGltZVN0YW5kYXJkKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0p1bGlhbkRhdGUuanMKICB2YXIgZ3JlZ29yaWFuRGF0ZVNjcmF0Y2ggPSBuZXcgR3JlZ29yaWFuRGF0ZV9kZWZhdWx0KCk7CiAgdmFyIGRheXNJbk1vbnRoID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdOwogIHZhciBkYXlzSW5MZWFwRmVidXJhcnkgPSAyOTsKICBmdW5jdGlvbiBjb21wYXJlTGVhcFNlY29uZERhdGVzKGxlYXBTZWNvbmQsIGRhdGVUb0ZpbmQpIHsKICAgIHJldHVybiBKdWxpYW5EYXRlLmNvbXBhcmUobGVhcFNlY29uZC5qdWxpYW5EYXRlLCBkYXRlVG9GaW5kLmp1bGlhbkRhdGUpOwogIH0KICB2YXIgYmluYXJ5U2VhcmNoU2NyYXRjaExlYXBTZWNvbmQgPSBuZXcgTGVhcFNlY29uZF9kZWZhdWx0KCk7CiAgZnVuY3Rpb24gY29udmVydFV0Y1RvVGFpKGp1bGlhbkRhdGUpIHsKICAgIGJpbmFyeVNlYXJjaFNjcmF0Y2hMZWFwU2Vjb25kLmp1bGlhbkRhdGUgPSBqdWxpYW5EYXRlOwogICAgY29uc3QgbGVhcFNlY29uZHMgPSBKdWxpYW5EYXRlLmxlYXBTZWNvbmRzOwogICAgbGV0IGluZGV4ID0gYmluYXJ5U2VhcmNoX2RlZmF1bHQoCiAgICAgIGxlYXBTZWNvbmRzLAogICAgICBiaW5hcnlTZWFyY2hTY3JhdGNoTGVhcFNlY29uZCwKICAgICAgY29tcGFyZUxlYXBTZWNvbmREYXRlcwogICAgKTsKICAgIGlmIChpbmRleCA8IDApIHsKICAgICAgaW5kZXggPSB+aW5kZXg7CiAgICB9CiAgICBpZiAoaW5kZXggPj0gbGVhcFNlY29uZHMubGVuZ3RoKSB7CiAgICAgIGluZGV4ID0gbGVhcFNlY29uZHMubGVuZ3RoIC0gMTsKICAgIH0KICAgIGxldCBvZmZzZXQgPSBsZWFwU2Vjb25kc1tpbmRleF0ub2Zmc2V0OwogICAgaWYgKGluZGV4ID4gMCkgewogICAgICBjb25zdCBkaWZmZXJlbmNlID0gSnVsaWFuRGF0ZS5zZWNvbmRzRGlmZmVyZW5jZSgKICAgICAgICBsZWFwU2Vjb25kc1tpbmRleF0uanVsaWFuRGF0ZSwKICAgICAgICBqdWxpYW5EYXRlCiAgICAgICk7CiAgICAgIGlmIChkaWZmZXJlbmNlID4gb2Zmc2V0KSB7CiAgICAgICAgaW5kZXgtLTsKICAgICAgICBvZmZzZXQgPSBsZWFwU2Vjb25kc1tpbmRleF0ub2Zmc2V0OwogICAgICB9CiAgICB9CiAgICBKdWxpYW5EYXRlLmFkZFNlY29uZHMoanVsaWFuRGF0ZSwgb2Zmc2V0LCBqdWxpYW5EYXRlKTsKICB9CiAgZnVuY3Rpb24gY29udmVydFRhaVRvVXRjKGp1bGlhbkRhdGUsIHJlc3VsdCkgewogICAgYmluYXJ5U2VhcmNoU2NyYXRjaExlYXBTZWNvbmQuanVsaWFuRGF0ZSA9IGp1bGlhbkRhdGU7CiAgICBjb25zdCBsZWFwU2Vjb25kcyA9IEp1bGlhbkRhdGUubGVhcFNlY29uZHM7CiAgICBsZXQgaW5kZXggPSBiaW5hcnlTZWFyY2hfZGVmYXVsdCgKICAgICAgbGVhcFNlY29uZHMsCiAgICAgIGJpbmFyeVNlYXJjaFNjcmF0Y2hMZWFwU2Vjb25kLAogICAgICBjb21wYXJlTGVhcFNlY29uZERhdGVzCiAgICApOwogICAgaWYgKGluZGV4IDwgMCkgewogICAgICBpbmRleCA9IH5pbmRleDsKICAgIH0KICAgIGlmIChpbmRleCA9PT0gMCkgewogICAgICByZXR1cm4gSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKGp1bGlhbkRhdGUsIC1sZWFwU2Vjb25kc1swXS5vZmZzZXQsIHJlc3VsdCk7CiAgICB9CiAgICBpZiAoaW5kZXggPj0gbGVhcFNlY29uZHMubGVuZ3RoKSB7CiAgICAgIHJldHVybiBKdWxpYW5EYXRlLmFkZFNlY29uZHMoCiAgICAgICAganVsaWFuRGF0ZSwKICAgICAgICAtbGVhcFNlY29uZHNbaW5kZXggLSAxXS5vZmZzZXQsCiAgICAgICAgcmVzdWx0CiAgICAgICk7CiAgICB9CiAgICBjb25zdCBkaWZmZXJlbmNlID0gSnVsaWFuRGF0ZS5zZWNvbmRzRGlmZmVyZW5jZSgKICAgICAgbGVhcFNlY29uZHNbaW5kZXhdLmp1bGlhbkRhdGUsCiAgICAgIGp1bGlhbkRhdGUKICAgICk7CiAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkgewogICAgICByZXR1cm4gSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKAogICAgICAgIGp1bGlhbkRhdGUsCiAgICAgICAgLWxlYXBTZWNvbmRzW2luZGV4XS5vZmZzZXQsCiAgICAgICAgcmVzdWx0CiAgICAgICk7CiAgICB9CiAgICBpZiAoZGlmZmVyZW5jZSA8PSAxKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICByZXR1cm4gSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKAogICAgICBqdWxpYW5EYXRlLAogICAgICAtbGVhcFNlY29uZHNbLS1pbmRleF0ub2Zmc2V0LAogICAgICByZXN1bHQKICAgICk7CiAgfQogIGZ1bmN0aW9uIHNldENvbXBvbmVudHMod2hvbGVEYXlzLCBzZWNvbmRzT2ZEYXksIGp1bGlhbkRhdGUpIHsKICAgIGNvbnN0IGV4dHJhRGF5cyA9IHNlY29uZHNPZkRheSAvIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9EQVkgfCAwOwogICAgd2hvbGVEYXlzICs9IGV4dHJhRGF5czsKICAgIHNlY29uZHNPZkRheSAtPSBUaW1lQ29uc3RhbnRzX2RlZmF1bHQuU0VDT05EU19QRVJfREFZICogZXh0cmFEYXlzOwogICAgaWYgKHNlY29uZHNPZkRheSA8IDApIHsKICAgICAgd2hvbGVEYXlzLS07CiAgICAgIHNlY29uZHNPZkRheSArPSBUaW1lQ29uc3RhbnRzX2RlZmF1bHQuU0VDT05EU19QRVJfREFZOwogICAgfQogICAganVsaWFuRGF0ZS5kYXlOdW1iZXIgPSB3aG9sZURheXM7CiAgICBqdWxpYW5EYXRlLnNlY29uZHNPZkRheSA9IHNlY29uZHNPZkRheTsKICAgIHJldHVybiBqdWxpYW5EYXRlOwogIH0KICBmdW5jdGlvbiBjb21wdXRlSnVsaWFuRGF0ZUNvbXBvbmVudHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSB7CiAgICBjb25zdCBhMyA9IChtb250aCAtIDE0KSAvIDEyIHwgMDsKICAgIGNvbnN0IGIgPSB5ZWFyICsgNDgwMCArIGEzOwogICAgbGV0IGRheU51bWJlciA9ICgxNDYxICogYiAvIDQgfCAwKSArICgzNjcgKiAobW9udGggLSAyIC0gMTIgKiBhMykgLyAxMiB8IDApIC0gKDMgKiAoKGIgKyAxMDApIC8gMTAwIHwgMCkgLyA0IHwgMCkgKyBkYXkgLSAzMjA3NTsKICAgIGhvdXIgPSBob3VyIC0gMTI7CiAgICBpZiAoaG91ciA8IDApIHsKICAgICAgaG91ciArPSAyNDsKICAgIH0KICAgIGNvbnN0IHNlY29uZHNPZkRheSA9IHNlY29uZCArIChob3VyICogVGltZUNvbnN0YW50c19kZWZhdWx0LlNFQ09ORFNfUEVSX0hPVVIgKyBtaW51dGUgKiBUaW1lQ29uc3RhbnRzX2RlZmF1bHQuU0VDT05EU19QRVJfTUlOVVRFICsgbWlsbGlzZWNvbmQgKiBUaW1lQ29uc3RhbnRzX2RlZmF1bHQuU0VDT05EU19QRVJfTUlMTElTRUNPTkQpOwogICAgaWYgKHNlY29uZHNPZkRheSA+PSA0MzIwMCkgewogICAgICBkYXlOdW1iZXIgLT0gMTsKICAgIH0KICAgIHJldHVybiBbZGF5TnVtYmVyLCBzZWNvbmRzT2ZEYXldOwogIH0KICB2YXIgbWF0Y2hDYWxlbmRhclllYXIgPSAvXihcZHs0fSkkLzsKICB2YXIgbWF0Y2hDYWxlbmRhck1vbnRoID0gL14oXGR7NH0pLShcZHsyfSkkLzsKICB2YXIgbWF0Y2hPcmRpbmFsRGF0ZSA9IC9eKFxkezR9KS0/KFxkezN9KSQvOwogIHZhciBtYXRjaFdlZWtEYXRlID0gL14oXGR7NH0pLT9XKFxkezJ9KS0/KFxkezF9KT8kLzsKICB2YXIgbWF0Y2hDYWxlbmRhckRhdGUgPSAvXihcZHs0fSktPyhcZHsyfSktPyhcZHsyfSkkLzsKICB2YXIgdXRjT2Zmc2V0ID0gLyhbWitcLV0pPyhcZHsyfSk/Oj8oXGR7Mn0pPyQvOwogIHZhciBtYXRjaEhvdXJzID0gL14oXGR7Mn0pKFwuXGQrKT8vLnNvdXJjZSArIHV0Y09mZnNldC5zb3VyY2U7CiAgdmFyIG1hdGNoSG91cnNNaW51dGVzID0gL14oXGR7Mn0pOj8oXGR7Mn0pKFwuXGQrKT8vLnNvdXJjZSArIHV0Y09mZnNldC5zb3VyY2U7CiAgdmFyIG1hdGNoSG91cnNNaW51dGVzU2Vjb25kcyA9IC9eKFxkezJ9KTo/KFxkezJ9KTo/KFxkezJ9KShcLlxkKyk/Ly5zb3VyY2UgKyB1dGNPZmZzZXQuc291cmNlOwogIHZhciBpc284NjAxRXJyb3JNZXNzYWdlID0gIkludmFsaWQgSVNPIDg2MDEgZGF0ZS4iOwogIGZ1bmN0aW9uIEp1bGlhbkRhdGUoanVsaWFuRGF5TnVtYmVyLCBzZWNvbmRzT2ZEYXksIHRpbWVTdGFuZGFyZCkgewogICAgdGhpcy5kYXlOdW1iZXIgPSB2b2lkIDA7CiAgICB0aGlzLnNlY29uZHNPZkRheSA9IHZvaWQgMDsKICAgIGp1bGlhbkRheU51bWJlciA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGp1bGlhbkRheU51bWJlciwgMCk7CiAgICBzZWNvbmRzT2ZEYXkgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzZWNvbmRzT2ZEYXksIDApOwogICAgdGltZVN0YW5kYXJkID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQodGltZVN0YW5kYXJkLCBUaW1lU3RhbmRhcmRfZGVmYXVsdC5VVEMpOwogICAgY29uc3Qgd2hvbGVEYXlzID0ganVsaWFuRGF5TnVtYmVyIHwgMDsKICAgIHNlY29uZHNPZkRheSA9IHNlY29uZHNPZkRheSArIChqdWxpYW5EYXlOdW1iZXIgLSB3aG9sZURheXMpICogVGltZUNvbnN0YW50c19kZWZhdWx0LlNFQ09ORFNfUEVSX0RBWTsKICAgIHNldENvbXBvbmVudHMod2hvbGVEYXlzLCBzZWNvbmRzT2ZEYXksIHRoaXMpOwogICAgaWYgKHRpbWVTdGFuZGFyZCA9PT0gVGltZVN0YW5kYXJkX2RlZmF1bHQuVVRDKSB7CiAgICAgIGNvbnZlcnRVdGNUb1RhaSh0aGlzKTsKICAgIH0KICB9CiAgSnVsaWFuRGF0ZS5mcm9tR3JlZ29yaWFuRGF0ZSA9IGZ1bmN0aW9uKGRhdGUsIHJlc3VsdCkgewogICAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIEdyZWdvcmlhbkRhdGVfZGVmYXVsdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImRhdGUgbXVzdCBiZSBhIHZhbGlkIEdyZWdvcmlhbkRhdGUuIik7CiAgICB9CiAgICBjb25zdCBjb21wb25lbnRzID0gY29tcHV0ZUp1bGlhbkRhdGVDb21wb25lbnRzKAogICAgICBkYXRlLnllYXIsCiAgICAgIGRhdGUubW9udGgsCiAgICAgIGRhdGUuZGF5LAogICAgICBkYXRlLmhvdXIsCiAgICAgIGRhdGUubWludXRlLAogICAgICBkYXRlLnNlY29uZCwKICAgICAgZGF0ZS5taWxsaXNlY29uZAogICAgKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBKdWxpYW5EYXRlKGNvbXBvbmVudHNbMF0sIGNvbXBvbmVudHNbMV0sIFRpbWVTdGFuZGFyZF9kZWZhdWx0LlVUQyk7CiAgICB9CiAgICBzZXRDb21wb25lbnRzKGNvbXBvbmVudHNbMF0sIGNvbXBvbmVudHNbMV0sIHJlc3VsdCk7CiAgICBjb252ZXJ0VXRjVG9UYWkocmVzdWx0KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBKdWxpYW5EYXRlLmZyb21EYXRlID0gZnVuY3Rpb24oZGF0ZSwgcmVzdWx0KSB7CiAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkgfHwgaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkYXRlIG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUuIik7CiAgICB9CiAgICBjb25zdCBjb21wb25lbnRzID0gY29tcHV0ZUp1bGlhbkRhdGVDb21wb25lbnRzKAogICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksCiAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsCiAgICAgIGRhdGUuZ2V0VVRDRGF0ZSgpLAogICAgICBkYXRlLmdldFVUQ0hvdXJzKCksCiAgICAgIGRhdGUuZ2V0VVRDTWludXRlcygpLAogICAgICBkYXRlLmdldFVUQ1NlY29uZHMoKSwKICAgICAgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKQogICAgKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBKdWxpYW5EYXRlKGNvbXBvbmVudHNbMF0sIGNvbXBvbmVudHNbMV0sIFRpbWVTdGFuZGFyZF9kZWZhdWx0LlVUQyk7CiAgICB9CiAgICBzZXRDb21wb25lbnRzKGNvbXBvbmVudHNbMF0sIGNvbXBvbmVudHNbMV0sIHJlc3VsdCk7CiAgICBjb252ZXJ0VXRjVG9UYWkocmVzdWx0KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBKdWxpYW5EYXRlLmZyb21Jc284NjAxID0gZnVuY3Rpb24oaXNvODYwMVN0cmluZywgcmVzdWx0KSB7CiAgICBpZiAodHlwZW9mIGlzbzg2MDFTdHJpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KGlzbzg2MDFFcnJvck1lc3NhZ2UpOwogICAgfQogICAgaXNvODYwMVN0cmluZyA9IGlzbzg2MDFTdHJpbmcucmVwbGFjZSgiLCIsICIuIik7CiAgICBsZXQgdG9rZW5zID0gaXNvODYwMVN0cmluZy5zcGxpdCgiVCIpOwogICAgbGV0IHllYXI7CiAgICBsZXQgbW9udGggPSAxOwogICAgbGV0IGRheSA9IDE7CiAgICBsZXQgaG91ciA9IDA7CiAgICBsZXQgbWludXRlID0gMDsKICAgIGxldCBzZWNvbmQgPSAwOwogICAgbGV0IG1pbGxpc2Vjb25kID0gMDsKICAgIGNvbnN0IGRhdGUgPSB0b2tlbnNbMF07CiAgICBjb25zdCB0aW1lID0gdG9rZW5zWzFdOwogICAgbGV0IHRtcDI7CiAgICBsZXQgaW5MZWFwWWVhcjsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGRhdGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KGlzbzg2MDFFcnJvck1lc3NhZ2UpOwogICAgfQogICAgbGV0IGRhc2hDb3VudDsKICAgIHRva2VucyA9IGRhdGUubWF0Y2gobWF0Y2hDYWxlbmRhckRhdGUpOwogICAgaWYgKHRva2VucyAhPT0gbnVsbCkgewogICAgICBkYXNoQ291bnQgPSBkYXRlLnNwbGl0KCItIikubGVuZ3RoIC0gMTsKICAgICAgaWYgKGRhc2hDb3VudCA+IDAgJiYgZGFzaENvdW50ICE9PSAyKSB7CiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoaXNvODYwMUVycm9yTWVzc2FnZSk7CiAgICAgIH0KICAgICAgeWVhciA9ICt0b2tlbnNbMV07CiAgICAgIG1vbnRoID0gK3Rva2Vuc1syXTsKICAgICAgZGF5ID0gK3Rva2Vuc1szXTsKICAgIH0gZWxzZSB7CiAgICAgIHRva2VucyA9IGRhdGUubWF0Y2gobWF0Y2hDYWxlbmRhck1vbnRoKTsKICAgICAgaWYgKHRva2VucyAhPT0gbnVsbCkgewogICAgICAgIHllYXIgPSArdG9rZW5zWzFdOwogICAgICAgIG1vbnRoID0gK3Rva2Vuc1syXTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0b2tlbnMgPSBkYXRlLm1hdGNoKG1hdGNoQ2FsZW5kYXJZZWFyKTsKICAgICAgICBpZiAodG9rZW5zICE9PSBudWxsKSB7CiAgICAgICAgICB5ZWFyID0gK3Rva2Vuc1sxXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGV0IGRheU9mWWVhcjsKICAgICAgICAgIHRva2VucyA9IGRhdGUubWF0Y2gobWF0Y2hPcmRpbmFsRGF0ZSk7CiAgICAgICAgICBpZiAodG9rZW5zICE9PSBudWxsKSB7CiAgICAgICAgICAgIHllYXIgPSArdG9rZW5zWzFdOwogICAgICAgICAgICBkYXlPZlllYXIgPSArdG9rZW5zWzJdOwogICAgICAgICAgICBpbkxlYXBZZWFyID0gaXNMZWFwWWVhcl9kZWZhdWx0KHllYXIpOwogICAgICAgICAgICBpZiAoZGF5T2ZZZWFyIDwgMSB8fCBpbkxlYXBZZWFyICYmIGRheU9mWWVhciA+IDM2NiB8fCAhaW5MZWFwWWVhciAmJiBkYXlPZlllYXIgPiAzNjUpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdChpc284NjAxRXJyb3JNZXNzYWdlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdG9rZW5zID0gZGF0ZS5tYXRjaChtYXRjaFdlZWtEYXRlKTsKICAgICAgICAgICAgaWYgKHRva2VucyAhPT0gbnVsbCkgewogICAgICAgICAgICAgIHllYXIgPSArdG9rZW5zWzFdOwogICAgICAgICAgICAgIGNvbnN0IHdlZWtOdW1iZXIgPSArdG9rZW5zWzJdOwogICAgICAgICAgICAgIGNvbnN0IGRheU9mV2VlayA9ICt0b2tlbnNbM10gfHwgMDsKICAgICAgICAgICAgICBkYXNoQ291bnQgPSBkYXRlLnNwbGl0KCItIikubGVuZ3RoIC0gMTsKICAgICAgICAgICAgICBpZiAoZGFzaENvdW50ID4gMCAmJiAoIWRlZmluZWRfZGVmYXVsdCh0b2tlbnNbM10pICYmIGRhc2hDb3VudCAhPT0gMSB8fCBkZWZpbmVkX2RlZmF1bHQodG9rZW5zWzNdKSAmJiBkYXNoQ291bnQgIT09IDIpKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdChpc284NjAxRXJyb3JNZXNzYWdlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY29uc3QgamFudWFyeTQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAwLCA0KSk7CiAgICAgICAgICAgICAgZGF5T2ZZZWFyID0gd2Vla051bWJlciAqIDcgKyBkYXlPZldlZWsgLSBqYW51YXJ5NC5nZXRVVENEYXkoKSAtIDM7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoaXNvODYwMUVycm9yTWVzc2FnZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHRtcDIgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAwLCAxKSk7CiAgICAgICAgICB0bXAyLnNldFVUQ0RhdGUoZGF5T2ZZZWFyKTsKICAgICAgICAgIG1vbnRoID0gdG1wMi5nZXRVVENNb250aCgpICsgMTsKICAgICAgICAgIGRheSA9IHRtcDIuZ2V0VVRDRGF0ZSgpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaW5MZWFwWWVhciA9IGlzTGVhcFllYXJfZGVmYXVsdCh5ZWFyKTsKICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMiB8fCBkYXkgPCAxIHx8IChtb250aCAhPT0gMiB8fCAhaW5MZWFwWWVhcikgJiYgZGF5ID4gZGF5c0luTW9udGhbbW9udGggLSAxXSB8fCBpbkxlYXBZZWFyICYmIG1vbnRoID09PSAyICYmIGRheSA+IGRheXNJbkxlYXBGZWJ1cmFyeSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdChpc284NjAxRXJyb3JNZXNzYWdlKTsKICAgIH0KICAgIGxldCBvZmZzZXRJbmRleDsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQodGltZSkpIHsKICAgICAgdG9rZW5zID0gdGltZS5tYXRjaChtYXRjaEhvdXJzTWludXRlc1NlY29uZHMpOwogICAgICBpZiAodG9rZW5zICE9PSBudWxsKSB7CiAgICAgICAgZGFzaENvdW50ID0gdGltZS5zcGxpdCgiOiIpLmxlbmd0aCAtIDE7CiAgICAgICAgaWYgKGRhc2hDb3VudCA+IDAgJiYgZGFzaENvdW50ICE9PSAyICYmIGRhc2hDb3VudCAhPT0gMykgewogICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoaXNvODYwMUVycm9yTWVzc2FnZSk7CiAgICAgICAgfQogICAgICAgIGhvdXIgPSArdG9rZW5zWzFdOwogICAgICAgIG1pbnV0ZSA9ICt0b2tlbnNbMl07CiAgICAgICAgc2Vjb25kID0gK3Rva2Vuc1szXTsKICAgICAgICBtaWxsaXNlY29uZCA9ICsodG9rZW5zWzRdIHx8IDApICogMWUzOwogICAgICAgIG9mZnNldEluZGV4ID0gNTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0b2tlbnMgPSB0aW1lLm1hdGNoKG1hdGNoSG91cnNNaW51dGVzKTsKICAgICAgICBpZiAodG9rZW5zICE9PSBudWxsKSB7CiAgICAgICAgICBkYXNoQ291bnQgPSB0aW1lLnNwbGl0KCI6IikubGVuZ3RoIC0gMTsKICAgICAgICAgIGlmIChkYXNoQ291bnQgPiAyKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KGlzbzg2MDFFcnJvck1lc3NhZ2UpOwogICAgICAgICAgfQogICAgICAgICAgaG91ciA9ICt0b2tlbnNbMV07CiAgICAgICAgICBtaW51dGUgPSArdG9rZW5zWzJdOwogICAgICAgICAgc2Vjb25kID0gKyh0b2tlbnNbM10gfHwgMCkgKiA2MDsKICAgICAgICAgIG9mZnNldEluZGV4ID0gNDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdG9rZW5zID0gdGltZS5tYXRjaChtYXRjaEhvdXJzKTsKICAgICAgICAgIGlmICh0b2tlbnMgIT09IG51bGwpIHsKICAgICAgICAgICAgaG91ciA9ICt0b2tlbnNbMV07CiAgICAgICAgICAgIG1pbnV0ZSA9ICsodG9rZW5zWzJdIHx8IDApICogNjA7CiAgICAgICAgICAgIG9mZnNldEluZGV4ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KGlzbzg2MDFFcnJvck1lc3NhZ2UpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZiAobWludXRlID49IDYwIHx8IHNlY29uZCA+PSA2MSB8fCBob3VyID4gMjQgfHwgaG91ciA9PT0gMjQgJiYgKG1pbnV0ZSA+IDAgfHwgc2Vjb25kID4gMCB8fCBtaWxsaXNlY29uZCA+IDApKSB7CiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoaXNvODYwMUVycm9yTWVzc2FnZSk7CiAgICAgIH0KICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW5zW29mZnNldEluZGV4XTsKICAgICAgY29uc3Qgb2Zmc2V0SG91cnMgPSArdG9rZW5zW29mZnNldEluZGV4ICsgMV07CiAgICAgIGNvbnN0IG9mZnNldE1pbnV0ZXMgPSArKHRva2Vuc1tvZmZzZXRJbmRleCArIDJdIHx8IDApOwogICAgICBzd2l0Y2ggKG9mZnNldCkgewogICAgICAgIGNhc2UgIisiOgogICAgICAgICAgaG91ciA9IGhvdXIgLSBvZmZzZXRIb3VyczsKICAgICAgICAgIG1pbnV0ZSA9IG1pbnV0ZSAtIG9mZnNldE1pbnV0ZXM7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICItIjoKICAgICAgICAgIGhvdXIgPSBob3VyICsgb2Zmc2V0SG91cnM7CiAgICAgICAgICBtaW51dGUgPSBtaW51dGUgKyBvZmZzZXRNaW51dGVzOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiWiI6CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgbWludXRlID0gbWludXRlICsgbmV3IERhdGUoCiAgICAgICAgICAgIERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyLCBtaW51dGUpCiAgICAgICAgICApLmdldFRpbWV6b25lT2Zmc2V0KCk7CiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgY29uc3QgaXNMZWFwU2Vjb25kID0gc2Vjb25kID09PSA2MDsKICAgIGlmIChpc0xlYXBTZWNvbmQpIHsKICAgICAgc2Vjb25kLS07CiAgICB9CiAgICB3aGlsZSAobWludXRlID49IDYwKSB7CiAgICAgIG1pbnV0ZSAtPSA2MDsKICAgICAgaG91cisrOwogICAgfQogICAgd2hpbGUgKGhvdXIgPj0gMjQpIHsKICAgICAgaG91ciAtPSAyNDsKICAgICAgZGF5Kys7CiAgICB9CiAgICB0bXAyID0gaW5MZWFwWWVhciAmJiBtb250aCA9PT0gMiA/IGRheXNJbkxlYXBGZWJ1cmFyeSA6IGRheXNJbk1vbnRoW21vbnRoIC0gMV07CiAgICB3aGlsZSAoZGF5ID4gdG1wMikgewogICAgICBkYXkgLT0gdG1wMjsKICAgICAgbW9udGgrKzsKICAgICAgaWYgKG1vbnRoID4gMTIpIHsKICAgICAgICBtb250aCAtPSAxMjsKICAgICAgICB5ZWFyKys7CiAgICAgIH0KICAgICAgdG1wMiA9IGluTGVhcFllYXIgJiYgbW9udGggPT09IDIgPyBkYXlzSW5MZWFwRmVidXJhcnkgOiBkYXlzSW5Nb250aFttb250aCAtIDFdOwogICAgfQogICAgd2hpbGUgKG1pbnV0ZSA8IDApIHsKICAgICAgbWludXRlICs9IDYwOwogICAgICBob3VyLS07CiAgICB9CiAgICB3aGlsZSAoaG91ciA8IDApIHsKICAgICAgaG91ciArPSAyNDsKICAgICAgZGF5LS07CiAgICB9CiAgICB3aGlsZSAoZGF5IDwgMSkgewogICAgICBtb250aC0tOwogICAgICBpZiAobW9udGggPCAxKSB7CiAgICAgICAgbW9udGggKz0gMTI7CiAgICAgICAgeWVhci0tOwogICAgICB9CiAgICAgIHRtcDIgPSBpbkxlYXBZZWFyICYmIG1vbnRoID09PSAyID8gZGF5c0luTGVhcEZlYnVyYXJ5IDogZGF5c0luTW9udGhbbW9udGggLSAxXTsKICAgICAgZGF5ICs9IHRtcDI7CiAgICB9CiAgICBjb25zdCBjb21wb25lbnRzID0gY29tcHV0ZUp1bGlhbkRhdGVDb21wb25lbnRzKAogICAgICB5ZWFyLAogICAgICBtb250aCwKICAgICAgZGF5LAogICAgICBob3VyLAogICAgICBtaW51dGUsCiAgICAgIHNlY29uZCwKICAgICAgbWlsbGlzZWNvbmQKICAgICk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBKdWxpYW5EYXRlKGNvbXBvbmVudHNbMF0sIGNvbXBvbmVudHNbMV0sIFRpbWVTdGFuZGFyZF9kZWZhdWx0LlVUQyk7CiAgICB9IGVsc2UgewogICAgICBzZXRDb21wb25lbnRzKGNvbXBvbmVudHNbMF0sIGNvbXBvbmVudHNbMV0sIHJlc3VsdCk7CiAgICAgIGNvbnZlcnRVdGNUb1RhaShyZXN1bHQpOwogICAgfQogICAgaWYgKGlzTGVhcFNlY29uZCkgewogICAgICBKdWxpYW5EYXRlLmFkZFNlY29uZHMocmVzdWx0LCAxLCByZXN1bHQpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEp1bGlhbkRhdGUubm93ID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gSnVsaWFuRGF0ZS5mcm9tRGF0ZShuZXcgRGF0ZSgpLCByZXN1bHQpOwogIH07CiAgdmFyIHRvR3JlZ29yaWFuRGF0ZVNjcmF0Y2ggPSBuZXcgSnVsaWFuRGF0ZSgwLCAwLCBUaW1lU3RhbmRhcmRfZGVmYXVsdC5UQUkpOwogIEp1bGlhbkRhdGUudG9HcmVnb3JpYW5EYXRlID0gZnVuY3Rpb24oanVsaWFuRGF0ZSwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChqdWxpYW5EYXRlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgianVsaWFuRGF0ZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGxldCBpc0xlYXBTZWNvbmQgPSBmYWxzZTsKICAgIGxldCB0aGlzVXRjID0gY29udmVydFRhaVRvVXRjKGp1bGlhbkRhdGUsIHRvR3JlZ29yaWFuRGF0ZVNjcmF0Y2gpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpc1V0YykpIHsKICAgICAgSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKGp1bGlhbkRhdGUsIC0xLCB0b0dyZWdvcmlhbkRhdGVTY3JhdGNoKTsKICAgICAgdGhpc1V0YyA9IGNvbnZlcnRUYWlUb1V0Yyh0b0dyZWdvcmlhbkRhdGVTY3JhdGNoLCB0b0dyZWdvcmlhbkRhdGVTY3JhdGNoKTsKICAgICAgaXNMZWFwU2Vjb25kID0gdHJ1ZTsKICAgIH0KICAgIGxldCBqdWxpYW5EYXlOdW1iZXIgPSB0aGlzVXRjLmRheU51bWJlcjsKICAgIGNvbnN0IHNlY29uZHNPZkRheSA9IHRoaXNVdGMuc2Vjb25kc09mRGF5OwogICAgaWYgKHNlY29uZHNPZkRheSA+PSA0MzIwMCkgewogICAgICBqdWxpYW5EYXlOdW1iZXIgKz0gMTsKICAgIH0KICAgIGxldCBMID0ganVsaWFuRGF5TnVtYmVyICsgNjg1NjkgfCAwOwogICAgY29uc3QgTiA9IDQgKiBMIC8gMTQ2MDk3IHwgMDsKICAgIEwgPSBMIC0gKCgxNDYwOTcgKiBOICsgMykgLyA0IHwgMCkgfCAwOwogICAgY29uc3QgSSA9IDRlMyAqIChMICsgMSkgLyAxNDYxMDAxIHwgMDsKICAgIEwgPSBMIC0gKDE0NjEgKiBJIC8gNCB8IDApICsgMzEgfCAwOwogICAgY29uc3QgSiA9IDgwICogTCAvIDI0NDcgfCAwOwogICAgY29uc3QgZGF5ID0gTCAtICgyNDQ3ICogSiAvIDgwIHwgMCkgfCAwOwogICAgTCA9IEogLyAxMSB8IDA7CiAgICBjb25zdCBtb250aCA9IEogKyAyIC0gMTIgKiBMIHwgMDsKICAgIGNvbnN0IHllYXIgPSAxMDAgKiAoTiAtIDQ5KSArIEkgKyBMIHwgMDsKICAgIGxldCBob3VyID0gc2Vjb25kc09mRGF5IC8gVGltZUNvbnN0YW50c19kZWZhdWx0LlNFQ09ORFNfUEVSX0hPVVIgfCAwOwogICAgbGV0IHJlbWFpbmluZ1NlY29uZHMgPSBzZWNvbmRzT2ZEYXkgLSBob3VyICogVGltZUNvbnN0YW50c19kZWZhdWx0LlNFQ09ORFNfUEVSX0hPVVI7CiAgICBjb25zdCBtaW51dGUgPSByZW1haW5pbmdTZWNvbmRzIC8gVGltZUNvbnN0YW50c19kZWZhdWx0LlNFQ09ORFNfUEVSX01JTlVURSB8IDA7CiAgICByZW1haW5pbmdTZWNvbmRzID0gcmVtYWluaW5nU2Vjb25kcyAtIG1pbnV0ZSAqIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9NSU5VVEU7CiAgICBsZXQgc2Vjb25kID0gcmVtYWluaW5nU2Vjb25kcyB8IDA7CiAgICBjb25zdCBtaWxsaXNlY29uZCA9IChyZW1haW5pbmdTZWNvbmRzIC0gc2Vjb25kKSAvIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9NSUxMSVNFQ09ORDsKICAgIGhvdXIgKz0gMTI7CiAgICBpZiAoaG91ciA+IDIzKSB7CiAgICAgIGhvdXIgLT0gMjQ7CiAgICB9CiAgICBpZiAoaXNMZWFwU2Vjb25kKSB7CiAgICAgIHNlY29uZCArPSAxOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IEdyZWdvcmlhbkRhdGVfZGVmYXVsdCgKICAgICAgICB5ZWFyLAogICAgICAgIG1vbnRoLAogICAgICAgIGRheSwKICAgICAgICBob3VyLAogICAgICAgIG1pbnV0ZSwKICAgICAgICBzZWNvbmQsCiAgICAgICAgbWlsbGlzZWNvbmQsCiAgICAgICAgaXNMZWFwU2Vjb25kCiAgICAgICk7CiAgICB9CiAgICByZXN1bHQueWVhciA9IHllYXI7CiAgICByZXN1bHQubW9udGggPSBtb250aDsKICAgIHJlc3VsdC5kYXkgPSBkYXk7CiAgICByZXN1bHQuaG91ciA9IGhvdXI7CiAgICByZXN1bHQubWludXRlID0gbWludXRlOwogICAgcmVzdWx0LnNlY29uZCA9IHNlY29uZDsKICAgIHJlc3VsdC5taWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kOwogICAgcmVzdWx0LmlzTGVhcFNlY29uZCA9IGlzTGVhcFNlY29uZDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBKdWxpYW5EYXRlLnRvRGF0ZSA9IGZ1bmN0aW9uKGp1bGlhbkRhdGUpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGp1bGlhbkRhdGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJqdWxpYW5EYXRlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgZ0RhdGUgPSBKdWxpYW5EYXRlLnRvR3JlZ29yaWFuRGF0ZShqdWxpYW5EYXRlLCBncmVnb3JpYW5EYXRlU2NyYXRjaCk7CiAgICBsZXQgc2Vjb25kID0gZ0RhdGUuc2Vjb25kOwogICAgaWYgKGdEYXRlLmlzTGVhcFNlY29uZCkgewogICAgICBzZWNvbmQgLT0gMTsKICAgIH0KICAgIHJldHVybiBuZXcgRGF0ZSgKICAgICAgRGF0ZS5VVEMoCiAgICAgICAgZ0RhdGUueWVhciwKICAgICAgICBnRGF0ZS5tb250aCAtIDEsCiAgICAgICAgZ0RhdGUuZGF5LAogICAgICAgIGdEYXRlLmhvdXIsCiAgICAgICAgZ0RhdGUubWludXRlLAogICAgICAgIHNlY29uZCwKICAgICAgICBnRGF0ZS5taWxsaXNlY29uZAogICAgICApCiAgICApOwogIH07CiAgSnVsaWFuRGF0ZS50b0lzbzg2MDEgPSBmdW5jdGlvbihqdWxpYW5EYXRlLCBwcmVjaXNpb24pIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGp1bGlhbkRhdGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJqdWxpYW5EYXRlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgZ0RhdGUgPSBKdWxpYW5EYXRlLnRvR3JlZ29yaWFuRGF0ZShqdWxpYW5EYXRlLCBncmVnb3JpYW5EYXRlU2NyYXRjaCk7CiAgICBsZXQgeWVhciA9IGdEYXRlLnllYXI7CiAgICBsZXQgbW9udGggPSBnRGF0ZS5tb250aDsKICAgIGxldCBkYXkgPSBnRGF0ZS5kYXk7CiAgICBsZXQgaG91ciA9IGdEYXRlLmhvdXI7CiAgICBjb25zdCBtaW51dGUgPSBnRGF0ZS5taW51dGU7CiAgICBjb25zdCBzZWNvbmQgPSBnRGF0ZS5zZWNvbmQ7CiAgICBjb25zdCBtaWxsaXNlY29uZCA9IGdEYXRlLm1pbGxpc2Vjb25kOwogICAgaWYgKHllYXIgPT09IDFlNCAmJiBtb250aCA9PT0gMSAmJiBkYXkgPT09IDEgJiYgaG91ciA9PT0gMCAmJiBtaW51dGUgPT09IDAgJiYgc2Vjb25kID09PSAwICYmIG1pbGxpc2Vjb25kID09PSAwKSB7CiAgICAgIHllYXIgPSA5OTk5OwogICAgICBtb250aCA9IDEyOwogICAgICBkYXkgPSAzMTsKICAgICAgaG91ciA9IDI0OwogICAgfQogICAgbGV0IG1pbGxpc2Vjb25kU3RyOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocHJlY2lzaW9uKSAmJiBtaWxsaXNlY29uZCAhPT0gMCkgewogICAgICBtaWxsaXNlY29uZFN0ciA9IChtaWxsaXNlY29uZCAqIDAuMDEpLnRvU3RyaW5nKCkucmVwbGFjZSgiLiIsICIiKTsKICAgICAgcmV0dXJuIGAke3llYXIudG9TdHJpbmcoKS5wYWRTdGFydCg0LCAiMCIpfS0ke21vbnRoLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgIjAiKX0tJHtkYXkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAiMCIpfVQke2hvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAiMCIpfToke21pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICIwIil9OiR7c2Vjb25kLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgIjAiKX0uJHttaWxsaXNlY29uZFN0cn1aYDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHByZWNpc2lvbikgfHwgcHJlY2lzaW9uID09PSAwKSB7CiAgICAgIHJldHVybiBgJHt5ZWFyLnRvU3RyaW5nKCkucGFkU3RhcnQoNCwgIjAiKX0tJHttb250aC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICIwIil9LSR7ZGF5LnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgIjAiKX1UJHtob3VyLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgIjAiKX06JHttaW51dGUudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAiMCIpfToke3NlY29uZC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICIwIil9WmA7CiAgICB9CiAgICBtaWxsaXNlY29uZFN0ciA9IChtaWxsaXNlY29uZCAqIDAuMDEpLnRvRml4ZWQocHJlY2lzaW9uKS5yZXBsYWNlKCIuIiwgIiIpLnNsaWNlKDAsIHByZWNpc2lvbik7CiAgICByZXR1cm4gYCR7eWVhci50b1N0cmluZygpLnBhZFN0YXJ0KDQsICIwIil9LSR7bW9udGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAiMCIpfS0ke2RheS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICIwIil9VCR7aG91ci50b1N0cmluZygpLnBhZFN0YXJ0KDIsICIwIil9OiR7bWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgIjAiKX06JHtzZWNvbmQudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAiMCIpfS4ke21pbGxpc2Vjb25kU3RyfVpgOwogIH07CiAgSnVsaWFuRGF0ZS5jbG9uZSA9IGZ1bmN0aW9uKGp1bGlhbkRhdGUsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoanVsaWFuRGF0ZSkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBKdWxpYW5EYXRlKAogICAgICAgIGp1bGlhbkRhdGUuZGF5TnVtYmVyLAogICAgICAgIGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5LAogICAgICAgIFRpbWVTdGFuZGFyZF9kZWZhdWx0LlRBSQogICAgICApOwogICAgfQogICAgcmVzdWx0LmRheU51bWJlciA9IGp1bGlhbkRhdGUuZGF5TnVtYmVyOwogICAgcmVzdWx0LnNlY29uZHNPZkRheSA9IGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEp1bGlhbkRhdGUuY29tcGFyZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsZWZ0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgibGVmdCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicmlnaHQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBqdWxpYW5EYXlOdW1iZXJEaWZmZXJlbmNlID0gbGVmdC5kYXlOdW1iZXIgLSByaWdodC5kYXlOdW1iZXI7CiAgICBpZiAoanVsaWFuRGF5TnVtYmVyRGlmZmVyZW5jZSAhPT0gMCkgewogICAgICByZXR1cm4ganVsaWFuRGF5TnVtYmVyRGlmZmVyZW5jZTsKICAgIH0KICAgIHJldHVybiBsZWZ0LnNlY29uZHNPZkRheSAtIHJpZ2h0LnNlY29uZHNPZkRheTsKICB9OwogIEp1bGlhbkRhdGUuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBsZWZ0LmRheU51bWJlciA9PT0gcmlnaHQuZGF5TnVtYmVyICYmIGxlZnQuc2Vjb25kc09mRGF5ID09PSByaWdodC5zZWNvbmRzT2ZEYXk7CiAgfTsKICBKdWxpYW5EYXRlLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgZXBzaWxvbikgewogICAgZXBzaWxvbiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGVwc2lsb24sIDApOwogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIE1hdGguYWJzKEp1bGlhbkRhdGUuc2Vjb25kc0RpZmZlcmVuY2UobGVmdCwgcmlnaHQpKSA8PSBlcHNpbG9uOwogIH07CiAgSnVsaWFuRGF0ZS50b3RhbERheXMgPSBmdW5jdGlvbihqdWxpYW5EYXRlKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChqdWxpYW5EYXRlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgianVsaWFuRGF0ZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHJldHVybiBqdWxpYW5EYXRlLmRheU51bWJlciArIGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5IC8gVGltZUNvbnN0YW50c19kZWZhdWx0LlNFQ09ORFNfUEVSX0RBWTsKICB9OwogIEp1bGlhbkRhdGUuc2Vjb25kc0RpZmZlcmVuY2UgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQobGVmdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImxlZnQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJpZ2h0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgZGF5RGlmZmVyZW5jZSA9IChsZWZ0LmRheU51bWJlciAtIHJpZ2h0LmRheU51bWJlcikgKiBUaW1lQ29uc3RhbnRzX2RlZmF1bHQuU0VDT05EU19QRVJfREFZOwogICAgcmV0dXJuIGRheURpZmZlcmVuY2UgKyAobGVmdC5zZWNvbmRzT2ZEYXkgLSByaWdodC5zZWNvbmRzT2ZEYXkpOwogIH07CiAgSnVsaWFuRGF0ZS5kYXlzRGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsZWZ0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgibGVmdCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicmlnaHQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBkYXlEaWZmZXJlbmNlID0gbGVmdC5kYXlOdW1iZXIgLSByaWdodC5kYXlOdW1iZXI7CiAgICBjb25zdCBzZWNvbmREaWZmZXJlbmNlID0gKGxlZnQuc2Vjb25kc09mRGF5IC0gcmlnaHQuc2Vjb25kc09mRGF5KSAvIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9EQVk7CiAgICByZXR1cm4gZGF5RGlmZmVyZW5jZSArIHNlY29uZERpZmZlcmVuY2U7CiAgfTsKICBKdWxpYW5EYXRlLmNvbXB1dGVUYWlNaW51c1V0YyA9IGZ1bmN0aW9uKGp1bGlhbkRhdGUpIHsKICAgIGJpbmFyeVNlYXJjaFNjcmF0Y2hMZWFwU2Vjb25kLmp1bGlhbkRhdGUgPSBqdWxpYW5EYXRlOwogICAgY29uc3QgbGVhcFNlY29uZHMgPSBKdWxpYW5EYXRlLmxlYXBTZWNvbmRzOwogICAgbGV0IGluZGV4ID0gYmluYXJ5U2VhcmNoX2RlZmF1bHQoCiAgICAgIGxlYXBTZWNvbmRzLAogICAgICBiaW5hcnlTZWFyY2hTY3JhdGNoTGVhcFNlY29uZCwKICAgICAgY29tcGFyZUxlYXBTZWNvbmREYXRlcwogICAgKTsKICAgIGlmIChpbmRleCA8IDApIHsKICAgICAgaW5kZXggPSB+aW5kZXg7CiAgICAgIC0taW5kZXg7CiAgICAgIGlmIChpbmRleCA8IDApIHsKICAgICAgICBpbmRleCA9IDA7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBsZWFwU2Vjb25kc1tpbmRleF0ub2Zmc2V0OwogIH07CiAgSnVsaWFuRGF0ZS5hZGRTZWNvbmRzID0gZnVuY3Rpb24oanVsaWFuRGF0ZSwgc2Vjb25kcywgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChqdWxpYW5EYXRlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgianVsaWFuRGF0ZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHNlY29uZHMpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJzZWNvbmRzIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicmVzdWx0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgcmV0dXJuIHNldENvbXBvbmVudHMoCiAgICAgIGp1bGlhbkRhdGUuZGF5TnVtYmVyLAogICAgICBqdWxpYW5EYXRlLnNlY29uZHNPZkRheSArIHNlY29uZHMsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIEp1bGlhbkRhdGUuYWRkTWludXRlcyA9IGZ1bmN0aW9uKGp1bGlhbkRhdGUsIG1pbnV0ZXMsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoanVsaWFuRGF0ZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImp1bGlhbkRhdGUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChtaW51dGVzKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgibWludXRlcyBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJlc3VsdCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IG5ld1NlY29uZHNPZkRheSA9IGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5ICsgbWludXRlcyAqIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9NSU5VVEU7CiAgICByZXR1cm4gc2V0Q29tcG9uZW50cyhqdWxpYW5EYXRlLmRheU51bWJlciwgbmV3U2Vjb25kc09mRGF5LCByZXN1bHQpOwogIH07CiAgSnVsaWFuRGF0ZS5hZGRIb3VycyA9IGZ1bmN0aW9uKGp1bGlhbkRhdGUsIGhvdXJzLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGp1bGlhbkRhdGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJqdWxpYW5EYXRlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaG91cnMpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJob3VycyBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJlc3VsdCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IG5ld1NlY29uZHNPZkRheSA9IGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5ICsgaG91cnMgKiBUaW1lQ29uc3RhbnRzX2RlZmF1bHQuU0VDT05EU19QRVJfSE9VUjsKICAgIHJldHVybiBzZXRDb21wb25lbnRzKGp1bGlhbkRhdGUuZGF5TnVtYmVyLCBuZXdTZWNvbmRzT2ZEYXksIHJlc3VsdCk7CiAgfTsKICBKdWxpYW5EYXRlLmFkZERheXMgPSBmdW5jdGlvbihqdWxpYW5EYXRlLCBkYXlzLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGp1bGlhbkRhdGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJqdWxpYW5EYXRlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZGF5cykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImRheXMgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJyZXN1bHQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBuZXdKdWxpYW5EYXlOdW1iZXIgPSBqdWxpYW5EYXRlLmRheU51bWJlciArIGRheXM7CiAgICByZXR1cm4gc2V0Q29tcG9uZW50cyhuZXdKdWxpYW5EYXlOdW1iZXIsIGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5LCByZXN1bHQpOwogIH07CiAgSnVsaWFuRGF0ZS5sZXNzVGhhbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICByZXR1cm4gSnVsaWFuRGF0ZS5jb21wYXJlKGxlZnQsIHJpZ2h0KSA8IDA7CiAgfTsKICBKdWxpYW5EYXRlLmxlc3NUaGFuT3JFcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgcmV0dXJuIEp1bGlhbkRhdGUuY29tcGFyZShsZWZ0LCByaWdodCkgPD0gMDsKICB9OwogIEp1bGlhbkRhdGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgcmV0dXJuIEp1bGlhbkRhdGUuY29tcGFyZShsZWZ0LCByaWdodCkgPiAwOwogIH07CiAgSnVsaWFuRGF0ZS5ncmVhdGVyVGhhbk9yRXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBKdWxpYW5EYXRlLmNvbXBhcmUobGVmdCwgcmlnaHQpID49IDA7CiAgfTsKICBKdWxpYW5EYXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkgewogICAgcmV0dXJuIEp1bGlhbkRhdGUuY2xvbmUodGhpcywgcmVzdWx0KTsKICB9OwogIEp1bGlhbkRhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHJpZ2h0KSB7CiAgICByZXR1cm4gSnVsaWFuRGF0ZS5lcXVhbHModGhpcywgcmlnaHQpOwogIH07CiAgSnVsaWFuRGF0ZS5wcm90b3R5cGUuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKHJpZ2h0LCBlcHNpbG9uKSB7CiAgICByZXR1cm4gSnVsaWFuRGF0ZS5lcXVhbHNFcHNpbG9uKHRoaXMsIHJpZ2h0LCBlcHNpbG9uKTsKICB9OwogIEp1bGlhbkRhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gSnVsaWFuRGF0ZS50b0lzbzg2MDEodGhpcyk7CiAgfTsKICBKdWxpYW5EYXRlLmxlYXBTZWNvbmRzID0gWwogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQxMzE3LCA0MzIxMCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTApLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQxNDk5LCA0MzIxMSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTEpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQxNjgzLCA0MzIxMiwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTIpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQyMDQ4LCA0MzIxMywgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTMpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQyNDEzLCA0MzIxNCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTQpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQyNzc4LCA0MzIxNSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTUpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQzMTQ0LCA0MzIxNiwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTYpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQzNTA5LCA0MzIxNywgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTcpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQzODc0LCA0MzIxOCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTgpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ0MjM5LCA0MzIxOSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMTkpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ0Nzg2LCA0MzIyMCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjApLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ1MTUxLCA0MzIyMSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjEpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ1NTE2LCA0MzIyMiwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjIpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ2MjQ3LCA0MzIyMywgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjMpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ3MTYxLCA0MzIyNCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjQpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ3ODkyLCA0MzIyNSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjUpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ4MjU3LCA0MzIyNiwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjYpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ4ODA0LCA0MzIyNywgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjcpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ5MTY5LCA0MzIyOCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjgpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDQ5NTM0LCA0MzIyOSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMjkpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDUwMDgzLCA0MzIzMCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzApLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDUwNjMwLCA0MzIzMSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzEpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDUxMTc5LCA0MzIzMiwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzIpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDUzNzM2LCA0MzIzMywgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzMpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDU0ODMyLCA0MzIzNCwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzQpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDU2MTA5LCA0MzIzNSwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzUpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDU3MjA0LCA0MzIzNiwgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzYpLAogICAgbmV3IExlYXBTZWNvbmRfZGVmYXVsdChuZXcgSnVsaWFuRGF0ZSgyNDU3NzU0LCA0MzIzNywgVGltZVN0YW5kYXJkX2RlZmF1bHQuVEFJKSwgMzcpCiAgXTsKICB2YXIgSnVsaWFuRGF0ZV9kZWZhdWx0ID0gSnVsaWFuRGF0ZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1Jlc291cmNlLmpzCiAgdmFyIGltcG9ydF91cmlqczYgPSBfX3RvRVNNKHJlcXVpcmVfVVJJKCksIDEpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvYXBwZW5kRm9yd2FyZFNsYXNoLmpzCiAgZnVuY3Rpb24gYXBwZW5kRm9yd2FyZFNsYXNoKHVybCkgewogICAgaWYgKHVybC5sZW5ndGggPT09IDAgfHwgdXJsW3VybC5sZW5ndGggLSAxXSAhPT0gIi8iKSB7CiAgICAgIHVybCA9IGAke3VybH0vYDsKICAgIH0KICAgIHJldHVybiB1cmw7CiAgfQogIHZhciBhcHBlbmRGb3J3YXJkU2xhc2hfZGVmYXVsdCA9IGFwcGVuZEZvcndhcmRTbGFzaDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2NvbWJpbmUuanMKICBmdW5jdGlvbiBjb21iaW5lKG9iamVjdDEsIG9iamVjdDIsIGRlZXApIHsKICAgIGRlZXAgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChkZWVwLCBmYWxzZSk7CiAgICBjb25zdCByZXN1bHQgPSB7fTsKICAgIGNvbnN0IG9iamVjdDFEZWZpbmVkID0gZGVmaW5lZF9kZWZhdWx0KG9iamVjdDEpOwogICAgY29uc3Qgb2JqZWN0MkRlZmluZWQgPSBkZWZpbmVkX2RlZmF1bHQob2JqZWN0Mik7CiAgICBsZXQgcHJvcGVydHk7CiAgICBsZXQgb2JqZWN0MVZhbHVlOwogICAgbGV0IG9iamVjdDJWYWx1ZTsKICAgIGlmIChvYmplY3QxRGVmaW5lZCkgewogICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdDEpIHsKICAgICAgICBpZiAob2JqZWN0MS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHsKICAgICAgICAgIG9iamVjdDFWYWx1ZSA9IG9iamVjdDFbcHJvcGVydHldOwogICAgICAgICAgaWYgKG9iamVjdDJEZWZpbmVkICYmIGRlZXAgJiYgdHlwZW9mIG9iamVjdDFWYWx1ZSA9PT0gIm9iamVjdCIgJiYgb2JqZWN0Mi5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHsKICAgICAgICAgICAgb2JqZWN0MlZhbHVlID0gb2JqZWN0Mltwcm9wZXJ0eV07CiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0MlZhbHVlID09PSAib2JqZWN0IikgewogICAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBjb21iaW5lKG9iamVjdDFWYWx1ZSwgb2JqZWN0MlZhbHVlLCBkZWVwKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gb2JqZWN0MVZhbHVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gb2JqZWN0MVZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYgKG9iamVjdDJEZWZpbmVkKSB7CiAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0MikgewogICAgICAgIGlmIChvYmplY3QyLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiAhcmVzdWx0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkgewogICAgICAgICAgb2JqZWN0MlZhbHVlID0gb2JqZWN0Mltwcm9wZXJ0eV07CiAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gb2JqZWN0MlZhbHVlOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGNvbWJpbmVfZGVmYXVsdCA9IGNvbWJpbmU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9kZWZlci5qcwogIGZ1bmN0aW9uIGRlZmVyKCkgewogICAgbGV0IHJlc29sdmU7CiAgICBsZXQgcmVqZWN0OwogICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlcywgcmVqKSB7CiAgICAgIHJlc29sdmUgPSByZXM7CiAgICAgIHJlamVjdCA9IHJlajsKICAgIH0pOwogICAgcmV0dXJuIHsKICAgICAgcmVzb2x2ZSwKICAgICAgcmVqZWN0LAogICAgICBwcm9taXNlCiAgICB9OwogIH0KICB2YXIgZGVmZXJfZGVmYXVsdCA9IGRlZmVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvZ2V0QWJzb2x1dGVVcmkuanMKICB2YXIgaW1wb3J0X3VyaWpzID0gX190b0VTTShyZXF1aXJlX1VSSSgpLCAxKTsKICBmdW5jdGlvbiBnZXRBYnNvbHV0ZVVyaShyZWxhdGl2ZSwgYmFzZSkgewogICAgbGV0IGRvY3VtZW50T2JqZWN0OwogICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgZG9jdW1lbnRPYmplY3QgPSBkb2N1bWVudDsKICAgIH0KICAgIHJldHVybiBnZXRBYnNvbHV0ZVVyaS5faW1wbGVtZW50YXRpb24ocmVsYXRpdmUsIGJhc2UsIGRvY3VtZW50T2JqZWN0KTsKICB9CiAgZ2V0QWJzb2x1dGVVcmkuX2ltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24ocmVsYXRpdmUsIGJhc2UsIGRvY3VtZW50T2JqZWN0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZWxhdGl2ZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJlbGF0aXZlIHVyaSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJhc2UpKSB7CiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRPYmplY3QgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgcmV0dXJuIHJlbGF0aXZlOwogICAgICB9CiAgICAgIGJhc2UgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChkb2N1bWVudE9iamVjdC5iYXNlVVJJLCBkb2N1bWVudE9iamVjdC5sb2NhdGlvbi5ocmVmKTsKICAgIH0KICAgIGNvbnN0IHJlbGF0aXZlVXJpID0gbmV3IGltcG9ydF91cmlqcy5kZWZhdWx0KHJlbGF0aXZlKTsKICAgIGlmIChyZWxhdGl2ZVVyaS5zY2hlbWUoKSAhPT0gIiIpIHsKICAgICAgcmV0dXJuIHJlbGF0aXZlVXJpLnRvU3RyaW5nKCk7CiAgICB9CiAgICByZXR1cm4gcmVsYXRpdmVVcmkuYWJzb2x1dGVUbyhiYXNlKS50b1N0cmluZygpOwogIH07CiAgdmFyIGdldEFic29sdXRlVXJpX2RlZmF1bHQgPSBnZXRBYnNvbHV0ZVVyaTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2dldEJhc2VVcmkuanMKICB2YXIgaW1wb3J0X3VyaWpzMiA9IF9fdG9FU00ocmVxdWlyZV9VUkkoKSwgMSk7CiAgZnVuY3Rpb24gZ2V0QmFzZVVyaSh1cmksIGluY2x1ZGVRdWVyeSkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodXJpKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidXJpIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgbGV0IGJhc2VQYXRoID0gIiI7CiAgICBjb25zdCBpID0gdXJpLmxhc3RJbmRleE9mKCIvIik7CiAgICBpZiAoaSAhPT0gLTEpIHsKICAgICAgYmFzZVBhdGggPSB1cmkuc3Vic3RyaW5nKDAsIGkgKyAxKTsKICAgIH0KICAgIGlmICghaW5jbHVkZVF1ZXJ5KSB7CiAgICAgIHJldHVybiBiYXNlUGF0aDsKICAgIH0KICAgIHVyaSA9IG5ldyBpbXBvcnRfdXJpanMyLmRlZmF1bHQodXJpKTsKICAgIGlmICh1cmkucXVlcnkoKS5sZW5ndGggIT09IDApIHsKICAgICAgYmFzZVBhdGggKz0gYD8ke3VyaS5xdWVyeSgpfWA7CiAgICB9CiAgICBpZiAodXJpLmZyYWdtZW50KCkubGVuZ3RoICE9PSAwKSB7CiAgICAgIGJhc2VQYXRoICs9IGAjJHt1cmkuZnJhZ21lbnQoKX1gOwogICAgfQogICAgcmV0dXJuIGJhc2VQYXRoOwogIH0KICB2YXIgZ2V0QmFzZVVyaV9kZWZhdWx0ID0gZ2V0QmFzZVVyaTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2dldEV4dGVuc2lvbkZyb21VcmkuanMKICB2YXIgaW1wb3J0X3VyaWpzMyA9IF9fdG9FU00ocmVxdWlyZV9VUkkoKSwgMSk7CiAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRnJvbVVyaSh1cmkpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHVyaSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInVyaSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IHVyaU9iamVjdCA9IG5ldyBpbXBvcnRfdXJpanMzLmRlZmF1bHQodXJpKTsKICAgIHVyaU9iamVjdC5ub3JtYWxpemUoKTsKICAgIGxldCBwYXRoID0gdXJpT2JqZWN0LnBhdGgoKTsKICAgIGxldCBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoIi8iKTsKICAgIGlmIChpbmRleCAhPT0gLTEpIHsKICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKGluZGV4ICsgMSk7CiAgICB9CiAgICBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoIi4iKTsKICAgIGlmIChpbmRleCA9PT0gLTEpIHsKICAgICAgcGF0aCA9ICIiOwogICAgfSBlbHNlIHsKICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKGluZGV4ICsgMSk7CiAgICB9CiAgICByZXR1cm4gcGF0aDsKICB9CiAgdmFyIGdldEV4dGVuc2lvbkZyb21VcmlfZGVmYXVsdCA9IGdldEV4dGVuc2lvbkZyb21Vcmk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9nZXRJbWFnZVBpeGVscy5qcwogIHZhciBjb250ZXh0MkRzQnlXaWR0aEFuZEhlaWdodCA9IHt9OwogIGZ1bmN0aW9uIGdldEltYWdlUGl4ZWxzKGltYWdlLCB3aWR0aCwgaGVpZ2h0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh3aWR0aCkpIHsKICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGhlaWdodCkpIHsKICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0OwogICAgfQogICAgbGV0IGNvbnRleHQyRHNCeUhlaWdodCA9IGNvbnRleHQyRHNCeVdpZHRoQW5kSGVpZ2h0W3dpZHRoXTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNvbnRleHQyRHNCeUhlaWdodCkpIHsKICAgICAgY29udGV4dDJEc0J5SGVpZ2h0ID0ge307CiAgICAgIGNvbnRleHQyRHNCeVdpZHRoQW5kSGVpZ2h0W3dpZHRoXSA9IGNvbnRleHQyRHNCeUhlaWdodDsKICAgIH0KICAgIGxldCBjb250ZXh0MmQgPSBjb250ZXh0MkRzQnlIZWlnaHRbaGVpZ2h0XTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNvbnRleHQyZCkpIHsKICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7CiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoOwogICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0OwogICAgICBjb250ZXh0MmQgPSBjYW52YXMuZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY29udGV4dDJkLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICJjb3B5IjsKICAgICAgY29udGV4dDJEc0J5SGVpZ2h0W2hlaWdodF0gPSBjb250ZXh0MmQ7CiAgICB9CiAgICBjb250ZXh0MmQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIHJldHVybiBjb250ZXh0MmQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7CiAgfQogIHZhciBnZXRJbWFnZVBpeGVsc19kZWZhdWx0ID0gZ2V0SW1hZ2VQaXhlbHM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9pc0Jsb2JVcmkuanMKICB2YXIgYmxvYlVyaVJlZ2V4ID0gL15ibG9iOi9pOwogIGZ1bmN0aW9uIGlzQmxvYlVyaSh1cmkpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLnN0cmluZygidXJpIiwgdXJpKTsKICAgIHJldHVybiBibG9iVXJpUmVnZXgudGVzdCh1cmkpOwogIH0KICB2YXIgaXNCbG9iVXJpX2RlZmF1bHQgPSBpc0Jsb2JVcmk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9pc0Nyb3NzT3JpZ2luVXJsLmpzCiAgdmFyIGE7CiAgZnVuY3Rpb24gaXNDcm9zc09yaWdpblVybCh1cmwpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGEpKSB7CiAgICAgIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7CiAgICB9CiAgICBhLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjsKICAgIGNvbnN0IGhvc3QgPSBhLmhvc3Q7CiAgICBjb25zdCBwcm90b2NvbCA9IGEucHJvdG9jb2w7CiAgICBhLmhyZWYgPSB1cmw7CiAgICBhLmhyZWYgPSBhLmhyZWY7CiAgICByZXR1cm4gcHJvdG9jb2wgIT09IGEucHJvdG9jb2wgfHwgaG9zdCAhPT0gYS5ob3N0OwogIH0KICB2YXIgaXNDcm9zc09yaWdpblVybF9kZWZhdWx0ID0gaXNDcm9zc09yaWdpblVybDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2lzRGF0YVVyaS5qcwogIHZhciBkYXRhVXJpUmVnZXggPSAvXmRhdGE6L2k7CiAgZnVuY3Rpb24gaXNEYXRhVXJpKHVyaSkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yuc3RyaW5nKCJ1cmkiLCB1cmkpOwogICAgcmV0dXJuIGRhdGFVcmlSZWdleC50ZXN0KHVyaSk7CiAgfQogIHZhciBpc0RhdGFVcmlfZGVmYXVsdCA9IGlzRGF0YVVyaTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2xvYWRBbmRFeGVjdXRlU2NyaXB0LmpzCiAgZnVuY3Rpb24gbG9hZEFuZEV4ZWN1dGVTY3JpcHQodXJsKSB7CiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTsKICAgIHNjcmlwdC5hc3luYyA9IHRydWU7CiAgICBzY3JpcHQuc3JjID0gdXJsOwogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgICAgaWYgKHdpbmRvdy5jcm9zc09yaWdpbklzb2xhdGVkKSB7CiAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgiY3Jvc3NvcmlnaW4iLCAiYW5vbnltb3VzIik7CiAgICAgIH0KICAgICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF07CiAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHsKICAgICAgICBzY3JpcHQub25sb2FkID0gdm9pZCAwOwogICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTsKICAgICAgICByZXNvbHZlKCk7CiAgICAgIH07CiAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oZSkgewogICAgICAgIHJlamVjdChlKTsKICAgICAgfTsKICAgICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpOwogICAgfSk7CiAgfQogIHZhciBsb2FkQW5kRXhlY3V0ZVNjcmlwdF9kZWZhdWx0ID0gbG9hZEFuZEV4ZWN1dGVTY3JpcHQ7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9vYmplY3RUb1F1ZXJ5LmpzCiAgZnVuY3Rpb24gb2JqZWN0VG9RdWVyeShvYmopIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9iaikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9iaiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGxldCByZXN1bHQgPSAiIjsKICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gb2JqKSB7CiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7CiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpbcHJvcE5hbWVdOwogICAgICAgIGNvbnN0IHBhcnQgPSBgJHtlbmNvZGVVUklDb21wb25lbnQocHJvcE5hbWUpfT1gOwogICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgewogICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICAgIHJlc3VsdCArPSBgJHtwYXJ0ICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2ldKX0mYDsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmVzdWx0ICs9IGAke3BhcnQgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfSZgOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIC0xKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBvYmplY3RUb1F1ZXJ5X2RlZmF1bHQgPSBvYmplY3RUb1F1ZXJ5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvcXVlcnlUb09iamVjdC5qcwogIGZ1bmN0aW9uIHF1ZXJ5VG9PYmplY3QocXVlcnlTdHJpbmcpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHF1ZXJ5U3RyaW5nKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicXVlcnlTdHJpbmcgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCByZXN1bHQgPSB7fTsKICAgIGlmIChxdWVyeVN0cmluZyA9PT0gIiIpIHsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIGNvbnN0IHBhcnRzID0gcXVlcnlTdHJpbmcucmVwbGFjZSgvXCsvZywgIiUyMCIpLnNwbGl0KC9bJjtdLyk7CiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICAgICAgY29uc3Qgc3VicGFydHMgPSBwYXJ0c1tpXS5zcGxpdCgiPSIpOwogICAgICBjb25zdCBuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHN1YnBhcnRzWzBdKTsKICAgICAgbGV0IHZhbHVlID0gc3VicGFydHNbMV07CiAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQodmFsdWUpKSB7CiAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpOwogICAgICB9IGVsc2UgewogICAgICAgIHZhbHVlID0gIiI7CiAgICAgIH0KICAgICAgY29uc3QgcmVzdWx0VmFsdWUgPSByZXN1bHRbbmFtZV07CiAgICAgIGlmICh0eXBlb2YgcmVzdWx0VmFsdWUgPT09ICJzdHJpbmciKSB7CiAgICAgICAgcmVzdWx0W25hbWVdID0gW3Jlc3VsdFZhbHVlLCB2YWx1ZV07CiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRWYWx1ZSkpIHsKICAgICAgICByZXN1bHRWYWx1ZS5wdXNoKHZhbHVlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIHF1ZXJ5VG9PYmplY3RfZGVmYXVsdCA9IHF1ZXJ5VG9PYmplY3Q7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9SZXF1ZXN0U3RhdGUuanMKICB2YXIgUmVxdWVzdFN0YXRlID0gewogICAgVU5JU1NVRUQ6IDAsCiAgICBJU1NVRUQ6IDEsCiAgICBBQ1RJVkU6IDIsCiAgICBSRUNFSVZFRDogMywKICAgIENBTkNFTExFRDogNCwKICAgIEZBSUxFRDogNQogIH07CiAgdmFyIFJlcXVlc3RTdGF0ZV9kZWZhdWx0ID0gT2JqZWN0LmZyZWV6ZShSZXF1ZXN0U3RhdGUpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvUmVxdWVzdFR5cGUuanMKICB2YXIgUmVxdWVzdFR5cGUgPSB7CiAgICBURVJSQUlOOiAwLAogICAgSU1BR0VSWTogMSwKICAgIFRJTEVTM0Q6IDIsCiAgICBPVEhFUjogMwogIH07CiAgdmFyIFJlcXVlc3RUeXBlX2RlZmF1bHQgPSBPYmplY3QuZnJlZXplKFJlcXVlc3RUeXBlKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1JlcXVlc3QuanMKICBmdW5jdGlvbiBSZXF1ZXN0KG9wdGlvbnMpIHsKICAgIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLCBkZWZhdWx0VmFsdWVfZGVmYXVsdC5FTVBUWV9PQkpFQ1QpOwogICAgY29uc3QgdGhyb3R0bGVCeVNlcnZlciA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMudGhyb3R0bGVCeVNlcnZlciwgZmFsc2UpOwogICAgY29uc3QgdGhyb3R0bGUgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLnRocm90dGxlLCBmYWxzZSk7CiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsOwogICAgdGhpcy5yZXF1ZXN0RnVuY3Rpb24gPSBvcHRpb25zLnJlcXVlc3RGdW5jdGlvbjsKICAgIHRoaXMuY2FuY2VsRnVuY3Rpb24gPSBvcHRpb25zLmNhbmNlbEZ1bmN0aW9uOwogICAgdGhpcy5wcmlvcml0eUZ1bmN0aW9uID0gb3B0aW9ucy5wcmlvcml0eUZ1bmN0aW9uOwogICAgdGhpcy5wcmlvcml0eSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMucHJpb3JpdHksIDApOwogICAgdGhpcy50aHJvdHRsZSA9IHRocm90dGxlOwogICAgdGhpcy50aHJvdHRsZUJ5U2VydmVyID0gdGhyb3R0bGVCeVNlcnZlcjsKICAgIHRoaXMudHlwZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMudHlwZSwgUmVxdWVzdFR5cGVfZGVmYXVsdC5PVEhFUik7CiAgICB0aGlzLnNlcnZlcktleSA9IHZvaWQgMDsKICAgIHRoaXMuc3RhdGUgPSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5VTklTU1VFRDsKICAgIHRoaXMuZGVmZXJyZWQgPSB2b2lkIDA7CiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlOwogIH0KICBSZXF1ZXN0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHsKICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTsKICB9OwogIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKTsKICAgIH0KICAgIHJlc3VsdC51cmwgPSB0aGlzLnVybDsKICAgIHJlc3VsdC5yZXF1ZXN0RnVuY3Rpb24gPSB0aGlzLnJlcXVlc3RGdW5jdGlvbjsKICAgIHJlc3VsdC5jYW5jZWxGdW5jdGlvbiA9IHRoaXMuY2FuY2VsRnVuY3Rpb247CiAgICByZXN1bHQucHJpb3JpdHlGdW5jdGlvbiA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbjsKICAgIHJlc3VsdC5wcmlvcml0eSA9IHRoaXMucHJpb3JpdHk7CiAgICByZXN1bHQudGhyb3R0bGUgPSB0aGlzLnRocm90dGxlOwogICAgcmVzdWx0LnRocm90dGxlQnlTZXJ2ZXIgPSB0aGlzLnRocm90dGxlQnlTZXJ2ZXI7CiAgICByZXN1bHQudHlwZSA9IHRoaXMudHlwZTsKICAgIHJlc3VsdC5zZXJ2ZXJLZXkgPSB0aGlzLnNlcnZlcktleTsKICAgIHJlc3VsdC5zdGF0ZSA9IHRoaXMuUmVxdWVzdFN0YXRlLlVOSVNTVUVEOwogICAgcmVzdWx0LmRlZmVycmVkID0gdm9pZCAwOwogICAgcmVzdWx0LmNhbmNlbGxlZCA9IGZhbHNlOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBSZXF1ZXN0X2RlZmF1bHQgPSBSZXF1ZXN0OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvcGFyc2VSZXNwb25zZUhlYWRlcnMuanMKICBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlSGVhZGVycyhoZWFkZXJTdHJpbmcpIHsKICAgIGNvbnN0IGhlYWRlcnMgPSB7fTsKICAgIGlmICghaGVhZGVyU3RyaW5nKSB7CiAgICAgIHJldHVybiBoZWFkZXJzOwogICAgfQogICAgY29uc3QgaGVhZGVyUGFpcnMgPSBoZWFkZXJTdHJpbmcuc3BsaXQoIlxyXG4iKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVyUGFpcnMubGVuZ3RoOyArK2kpIHsKICAgICAgY29uc3QgaGVhZGVyUGFpciA9IGhlYWRlclBhaXJzW2ldOwogICAgICBjb25zdCBpbmRleCA9IGhlYWRlclBhaXIuaW5kZXhPZigiOiAiKTsKICAgICAgaWYgKGluZGV4ID4gMCkgewogICAgICAgIGNvbnN0IGtleSA9IGhlYWRlclBhaXIuc3Vic3RyaW5nKDAsIGluZGV4KTsKICAgICAgICBjb25zdCB2YWwgPSBoZWFkZXJQYWlyLnN1YnN0cmluZyhpbmRleCArIDIpOwogICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbDsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGhlYWRlcnM7CiAgfQogIHZhciBwYXJzZVJlc3BvbnNlSGVhZGVyc19kZWZhdWx0ID0gcGFyc2VSZXNwb25zZUhlYWRlcnM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9SZXF1ZXN0RXJyb3JFdmVudC5qcwogIGZ1bmN0aW9uIFJlcXVlc3RFcnJvckV2ZW50KHN0YXR1c0NvZGUsIHJlc3BvbnNlLCByZXNwb25zZUhlYWRlcnMpIHsKICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7CiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7CiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVyczsKICAgIGlmICh0eXBlb2YgdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICJzdHJpbmciKSB7CiAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcGFyc2VSZXNwb25zZUhlYWRlcnNfZGVmYXVsdCh0aGlzLnJlc3BvbnNlSGVhZGVycyk7CiAgICB9CiAgfQogIFJlcXVlc3RFcnJvckV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogICAgbGV0IHN0ciA9ICJSZXF1ZXN0IGhhcyBmYWlsZWQuIjsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQodGhpcy5zdGF0dXNDb2RlKSkgewogICAgICBzdHIgKz0gYCBTdGF0dXMgQ29kZTogJHt0aGlzLnN0YXR1c0NvZGV9YDsKICAgIH0KICAgIHJldHVybiBzdHI7CiAgfTsKICB2YXIgUmVxdWVzdEVycm9yRXZlbnRfZGVmYXVsdCA9IFJlcXVlc3RFcnJvckV2ZW50OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvUmVxdWVzdFNjaGVkdWxlci5qcwogIHZhciBpbXBvcnRfdXJpanM0ID0gX190b0VTTShyZXF1aXJlX1VSSSgpLCAxKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0V2ZW50LmpzCiAgZnVuY3Rpb24gRXZlbnQoKSB7CiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTsKICAgIHRoaXMuX3Njb3BlcyA9IFtdOwogICAgdGhpcy5fdG9SZW1vdmUgPSBbXTsKICAgIHRoaXMuX2luc2lkZVJhaXNlRXZlbnQgPSBmYWxzZTsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnQucHJvdG90eXBlLCB7CiAgICBudW1iZXJPZkxpc3RlbmVyczogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoIC0gdGhpcy5fdG9SZW1vdmUubGVuZ3RoOwogICAgICB9CiAgICB9CiAgfSk7CiAgRXZlbnQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lciwgc2NvcGUpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLmZ1bmMoImxpc3RlbmVyIiwgbGlzdGVuZXIpOwogICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpOwogICAgdGhpcy5fc2NvcGVzLnB1c2goc2NvcGUpOwogICAgY29uc3QgZXZlbnQgPSB0aGlzOwogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICBldmVudC5yZW1vdmVFdmVudExpc3RlbmVyKGxpc3RlbmVyLCBzY29wZSk7CiAgICB9OwogIH07CiAgRXZlbnQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lciwgc2NvcGUpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLmZ1bmMoImxpc3RlbmVyIiwgbGlzdGVuZXIpOwogICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwogICAgY29uc3Qgc2NvcGVzID0gdGhpcy5fc2NvcGVzOwogICAgbGV0IGluZGV4ID0gLTE7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgewogICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciAmJiBzY29wZXNbaV0gPT09IHNjb3BlKSB7CiAgICAgICAgaW5kZXggPSBpOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgICBpZiAoaW5kZXggIT09IC0xKSB7CiAgICAgIGlmICh0aGlzLl9pbnNpZGVSYWlzZUV2ZW50KSB7CiAgICAgICAgdGhpcy5fdG9SZW1vdmUucHVzaChpbmRleCk7CiAgICAgICAgbGlzdGVuZXJzW2luZGV4XSA9IHZvaWQgMDsKICAgICAgICBzY29wZXNbaW5kZXhdID0gdm9pZCAwOwogICAgICB9IGVsc2UgewogICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpOwogICAgICAgIHNjb3Blcy5zcGxpY2UoaW5kZXgsIDEpOwogICAgICB9CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH07CiAgZnVuY3Rpb24gY29tcGFyZU51bWJlcihhMywgYikgewogICAgcmV0dXJuIGIgLSBhMzsKICB9CiAgRXZlbnQucHJvdG90eXBlLnJhaXNlRXZlbnQgPSBmdW5jdGlvbigpIHsKICAgIHRoaXMuX2luc2lkZVJhaXNlRXZlbnQgPSB0cnVlOwogICAgbGV0IGk7CiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7CiAgICBjb25zdCBzY29wZXMgPSB0aGlzLl9zY29wZXM7CiAgICBsZXQgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsKICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChsaXN0ZW5lcikpIHsKICAgICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2NvcGVzW2ldLCBhcmd1bWVudHMpOwogICAgICB9CiAgICB9CiAgICBjb25zdCB0b1JlbW92ZSA9IHRoaXMuX3RvUmVtb3ZlOwogICAgbGVuZ3RoID0gdG9SZW1vdmUubGVuZ3RoOwogICAgaWYgKGxlbmd0aCA+IDApIHsKICAgICAgdG9SZW1vdmUuc29ydChjb21wYXJlTnVtYmVyKTsKICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgaW5kZXggPSB0b1JlbW92ZVtpXTsKICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgICBzY29wZXMuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgfQogICAgICB0b1JlbW92ZS5sZW5ndGggPSAwOwogICAgfQogICAgdGhpcy5faW5zaWRlUmFpc2VFdmVudCA9IGZhbHNlOwogIH07CiAgdmFyIEV2ZW50X2RlZmF1bHQgPSBFdmVudDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0hlYXAuanMKICBmdW5jdGlvbiBIZWFwKG9wdGlvbnMpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgib3B0aW9ucyIsIG9wdGlvbnMpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJvcHRpb25zLmNvbXBhcmF0b3IiLCBvcHRpb25zLmNvbXBhcmF0b3IpOwogICAgdGhpcy5fY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjsKICAgIHRoaXMuX2FycmF5ID0gW107CiAgICB0aGlzLl9sZW5ndGggPSAwOwogICAgdGhpcy5fbWF4aW11bUxlbmd0aCA9IHZvaWQgMDsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVhcC5wcm90b3R5cGUsIHsKICAgIGxlbmd0aDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7CiAgICAgIH0KICAgIH0sCiAgICBpbnRlcm5hbEFycmF5OiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5OwogICAgICB9CiAgICB9LAogICAgbWF4aW11bUxlbmd0aDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9tYXhpbXVtTGVuZ3RoOwogICAgICB9LAogICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoIm1heGltdW1MZW5ndGgiLCB2YWx1ZSwgMCk7CiAgICAgICAgY29uc3Qgb3JpZ2luYWxMZW5ndGggPSB0aGlzLl9sZW5ndGg7CiAgICAgICAgaWYgKHZhbHVlIDwgb3JpZ2luYWxMZW5ndGgpIHsKICAgICAgICAgIGNvbnN0IGFycmF5ID0gdGhpcy5fYXJyYXk7CiAgICAgICAgICBmb3IgKGxldCBpID0gdmFsdWU7IGkgPCBvcmlnaW5hbExlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGFycmF5W2ldID0gdm9pZCAwOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fbGVuZ3RoID0gdmFsdWU7CiAgICAgICAgICBhcnJheS5sZW5ndGggPSB2YWx1ZTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fbWF4aW11bUxlbmd0aCA9IHZhbHVlOwogICAgICB9CiAgICB9LAogICAgY29tcGFyYXRvcjogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9jb21wYXJhdG9yOwogICAgICB9CiAgICB9CiAgfSk7CiAgZnVuY3Rpb24gc3dhcChhcnJheSwgYTMsIGIpIHsKICAgIGNvbnN0IHRlbXAgPSBhcnJheVthM107CiAgICBhcnJheVthM10gPSBhcnJheVtiXTsKICAgIGFycmF5W2JdID0gdGVtcDsKICB9CiAgSGVhcC5wcm90b3R5cGUucmVzZXJ2ZSA9IGZ1bmN0aW9uKGxlbmd0aCkgewogICAgbGVuZ3RoID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQobGVuZ3RoLCB0aGlzLl9sZW5ndGgpOwogICAgdGhpcy5fYXJyYXkubGVuZ3RoID0gbGVuZ3RoOwogIH07CiAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKGluZGV4KSB7CiAgICBpbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGluZGV4LCAwKTsKICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX2xlbmd0aDsKICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yOwogICAgY29uc3QgYXJyYXkgPSB0aGlzLl9hcnJheTsKICAgIGxldCBjYW5kaWRhdGUgPSAtMTsKICAgIGxldCBpbnNlcnRpbmcgPSB0cnVlOwogICAgd2hpbGUgKGluc2VydGluZykgewogICAgICBjb25zdCByaWdodCA9IDIgKiAoaW5kZXggKyAxKTsKICAgICAgY29uc3QgbGVmdCA9IHJpZ2h0IC0gMTsKICAgICAgaWYgKGxlZnQgPCBsZW5ndGggJiYgY29tcGFyYXRvcihhcnJheVtsZWZ0XSwgYXJyYXlbaW5kZXhdKSA8IDApIHsKICAgICAgICBjYW5kaWRhdGUgPSBsZWZ0OwogICAgICB9IGVsc2UgewogICAgICAgIGNhbmRpZGF0ZSA9IGluZGV4OwogICAgICB9CiAgICAgIGlmIChyaWdodCA8IGxlbmd0aCAmJiBjb21wYXJhdG9yKGFycmF5W3JpZ2h0XSwgYXJyYXlbY2FuZGlkYXRlXSkgPCAwKSB7CiAgICAgICAgY2FuZGlkYXRlID0gcmlnaHQ7CiAgICAgIH0KICAgICAgaWYgKGNhbmRpZGF0ZSAhPT0gaW5kZXgpIHsKICAgICAgICBzd2FwKGFycmF5LCBjYW5kaWRhdGUsIGluZGV4KTsKICAgICAgICBpbmRleCA9IGNhbmRpZGF0ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnNlcnRpbmcgPSBmYWxzZTsKICAgICAgfQogICAgfQogIH07CiAgSGVhcC5wcm90b3R5cGUucmVzb3J0ID0gZnVuY3Rpb24oKSB7CiAgICBjb25zdCBsZW5ndGggPSB0aGlzLl9sZW5ndGg7CiAgICBmb3IgKGxldCBpID0gTWF0aC5jZWlsKGxlbmd0aCAvIDIpOyBpID49IDA7IC0taSkgewogICAgICB0aGlzLmhlYXBpZnkoaSk7CiAgICB9CiAgfTsKICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImVsZW1lbnQiLCBlbGVtZW50KTsKICAgIGNvbnN0IGFycmF5ID0gdGhpcy5fYXJyYXk7CiAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjsKICAgIGNvbnN0IG1heGltdW1MZW5ndGggPSB0aGlzLl9tYXhpbXVtTGVuZ3RoOwogICAgbGV0IGluZGV4ID0gdGhpcy5fbGVuZ3RoKys7CiAgICBpZiAoaW5kZXggPCBhcnJheS5sZW5ndGgpIHsKICAgICAgYXJyYXlbaW5kZXhdID0gZWxlbWVudDsKICAgIH0gZWxzZSB7CiAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7CiAgICB9CiAgICB3aGlsZSAoaW5kZXggIT09IDApIHsKICAgICAgY29uc3QgcGFyZW50ID0gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpOwogICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIGFycmF5W3BhcmVudF0pIDwgMCkgewogICAgICAgIHN3YXAoYXJyYXksIGluZGV4LCBwYXJlbnQpOwogICAgICAgIGluZGV4ID0gcGFyZW50OwogICAgICB9IGVsc2UgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgICBsZXQgcmVtb3ZlZEVsZW1lbnQ7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KG1heGltdW1MZW5ndGgpICYmIHRoaXMuX2xlbmd0aCA+IG1heGltdW1MZW5ndGgpIHsKICAgICAgcmVtb3ZlZEVsZW1lbnQgPSBhcnJheVttYXhpbXVtTGVuZ3RoXTsKICAgICAgdGhpcy5fbGVuZ3RoID0gbWF4aW11bUxlbmd0aDsKICAgIH0KICAgIHJldHVybiByZW1vdmVkRWxlbWVudDsKICB9OwogIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKGluZGV4KSB7CiAgICBpbmRleCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGluZGV4LCAwKTsKICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5sZXNzVGhhbigiaW5kZXgiLCBpbmRleCwgdGhpcy5fbGVuZ3RoKTsKICAgIGNvbnN0IGFycmF5ID0gdGhpcy5fYXJyYXk7CiAgICBjb25zdCByb290ID0gYXJyYXlbaW5kZXhdOwogICAgc3dhcChhcnJheSwgaW5kZXgsIC0tdGhpcy5fbGVuZ3RoKTsKICAgIHRoaXMuaGVhcGlmeShpbmRleCk7CiAgICBhcnJheVt0aGlzLl9sZW5ndGhdID0gdm9pZCAwOwogICAgcmV0dXJuIHJvb3Q7CiAgfTsKICB2YXIgSGVhcF9kZWZhdWx0ID0gSGVhcDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1JlcXVlc3RTY2hlZHVsZXIuanMKICBmdW5jdGlvbiBzb3J0UmVxdWVzdHMoYTMsIGIpIHsKICAgIHJldHVybiBhMy5wcmlvcml0eSAtIGIucHJpb3JpdHk7CiAgfQogIHZhciBzdGF0aXN0aWNzID0gewogICAgbnVtYmVyT2ZBdHRlbXB0ZWRSZXF1ZXN0czogMCwKICAgIG51bWJlck9mQWN0aXZlUmVxdWVzdHM6IDAsCiAgICBudW1iZXJPZkNhbmNlbGxlZFJlcXVlc3RzOiAwLAogICAgbnVtYmVyT2ZDYW5jZWxsZWRBY3RpdmVSZXF1ZXN0czogMCwKICAgIG51bWJlck9mRmFpbGVkUmVxdWVzdHM6IDAsCiAgICBudW1iZXJPZkFjdGl2ZVJlcXVlc3RzRXZlcjogMCwKICAgIGxhc3ROdW1iZXJPZkFjdGl2ZVJlcXVlc3RzOiAwCiAgfTsKICB2YXIgcHJpb3JpdHlIZWFwTGVuZ3RoID0gMjA7CiAgdmFyIHJlcXVlc3RIZWFwID0gbmV3IEhlYXBfZGVmYXVsdCh7CiAgICBjb21wYXJhdG9yOiBzb3J0UmVxdWVzdHMKICB9KTsKICByZXF1ZXN0SGVhcC5tYXhpbXVtTGVuZ3RoID0gcHJpb3JpdHlIZWFwTGVuZ3RoOwogIHJlcXVlc3RIZWFwLnJlc2VydmUocHJpb3JpdHlIZWFwTGVuZ3RoKTsKICB2YXIgYWN0aXZlUmVxdWVzdHMgPSBbXTsKICB2YXIgbnVtYmVyT2ZBY3RpdmVSZXF1ZXN0c0J5U2VydmVyID0ge307CiAgdmFyIHBhZ2VVcmkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICJ1bmRlZmluZWQiID8gbmV3IGltcG9ydF91cmlqczQuZGVmYXVsdChkb2N1bWVudC5sb2NhdGlvbi5ocmVmKSA6IG5ldyBpbXBvcnRfdXJpanM0LmRlZmF1bHQoKTsKICB2YXIgcmVxdWVzdENvbXBsZXRlZEV2ZW50ID0gbmV3IEV2ZW50X2RlZmF1bHQoKTsKICBmdW5jdGlvbiBSZXF1ZXN0U2NoZWR1bGVyKCkgewogIH0KICBSZXF1ZXN0U2NoZWR1bGVyLm1heGltdW1SZXF1ZXN0cyA9IDUwOwogIFJlcXVlc3RTY2hlZHVsZXIubWF4aW11bVJlcXVlc3RzUGVyU2VydmVyID0gNjsKICBSZXF1ZXN0U2NoZWR1bGVyLnJlcXVlc3RzQnlTZXJ2ZXIgPSB7CiAgICAiYXBpLmNlc2l1bS5jb206NDQzIjogMTgsCiAgICAiYXNzZXRzLmNlc2l1bS5jb206NDQzIjogMTgKICB9OwogIFJlcXVlc3RTY2hlZHVsZXIudGhyb3R0bGVSZXF1ZXN0cyA9IHRydWU7CiAgUmVxdWVzdFNjaGVkdWxlci5kZWJ1Z1Nob3dTdGF0aXN0aWNzID0gZmFsc2U7CiAgUmVxdWVzdFNjaGVkdWxlci5yZXF1ZXN0Q29tcGxldGVkRXZlbnQgPSByZXF1ZXN0Q29tcGxldGVkRXZlbnQ7CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdFNjaGVkdWxlciwgewogICAgc3RhdGlzdGljczogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBzdGF0aXN0aWNzOwogICAgICB9CiAgICB9LAogICAgcHJpb3JpdHlIZWFwTGVuZ3RoOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHByaW9yaXR5SGVhcExlbmd0aDsKICAgICAgfSwKICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkgewogICAgICAgIGlmICh2YWx1ZSA8IHByaW9yaXR5SGVhcExlbmd0aCkgewogICAgICAgICAgd2hpbGUgKHJlcXVlc3RIZWFwLmxlbmd0aCA+IHZhbHVlKSB7CiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0SGVhcC5wb3AoKTsKICAgICAgICAgICAgY2FuY2VsUmVxdWVzdChyZXF1ZXN0KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcHJpb3JpdHlIZWFwTGVuZ3RoID0gdmFsdWU7CiAgICAgICAgcmVxdWVzdEhlYXAubWF4aW11bUxlbmd0aCA9IHZhbHVlOwogICAgICAgIHJlcXVlc3RIZWFwLnJlc2VydmUodmFsdWUpOwogICAgICB9CiAgICB9CiAgfSk7CiAgZnVuY3Rpb24gdXBkYXRlUHJpb3JpdHkocmVxdWVzdCkgewogICAgaWYgKGRlZmluZWRfZGVmYXVsdChyZXF1ZXN0LnByaW9yaXR5RnVuY3Rpb24pKSB7CiAgICAgIHJlcXVlc3QucHJpb3JpdHkgPSByZXF1ZXN0LnByaW9yaXR5RnVuY3Rpb24oKTsKICAgIH0KICB9CiAgUmVxdWVzdFNjaGVkdWxlci5zZXJ2ZXJIYXNPcGVuU2xvdHMgPSBmdW5jdGlvbihzZXJ2ZXJLZXksIGRlc2lyZWRSZXF1ZXN0cykgewogICAgZGVzaXJlZFJlcXVlc3RzID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZGVzaXJlZFJlcXVlc3RzLCAxKTsKICAgIGNvbnN0IG1heFJlcXVlc3RzID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIFJlcXVlc3RTY2hlZHVsZXIucmVxdWVzdHNCeVNlcnZlcltzZXJ2ZXJLZXldLAogICAgICBSZXF1ZXN0U2NoZWR1bGVyLm1heGltdW1SZXF1ZXN0c1BlclNlcnZlcgogICAgKTsKICAgIGNvbnN0IGhhc09wZW5TbG90c1NlcnZlciA9IG51bWJlck9mQWN0aXZlUmVxdWVzdHNCeVNlcnZlcltzZXJ2ZXJLZXldICsgZGVzaXJlZFJlcXVlc3RzIDw9IG1heFJlcXVlc3RzOwogICAgcmV0dXJuIGhhc09wZW5TbG90c1NlcnZlcjsKICB9OwogIFJlcXVlc3RTY2hlZHVsZXIuaGVhcEhhc09wZW5TbG90cyA9IGZ1bmN0aW9uKGRlc2lyZWRSZXF1ZXN0cykgewogICAgY29uc3QgaGFzT3BlblNsb3RzSGVhcCA9IHJlcXVlc3RIZWFwLmxlbmd0aCArIGRlc2lyZWRSZXF1ZXN0cyA8PSBwcmlvcml0eUhlYXBMZW5ndGg7CiAgICByZXR1cm4gaGFzT3BlblNsb3RzSGVhcDsKICB9OwogIGZ1bmN0aW9uIGlzc3VlUmVxdWVzdChyZXF1ZXN0KSB7CiAgICBpZiAocmVxdWVzdC5zdGF0ZSA9PT0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuVU5JU1NVRUQpIHsKICAgICAgcmVxdWVzdC5zdGF0ZSA9IFJlcXVlc3RTdGF0ZV9kZWZhdWx0LklTU1VFRDsKICAgICAgcmVxdWVzdC5kZWZlcnJlZCA9IGRlZmVyX2RlZmF1bHQoKTsKICAgIH0KICAgIHJldHVybiByZXF1ZXN0LmRlZmVycmVkLnByb21pc2U7CiAgfQogIGZ1bmN0aW9uIGdldFJlcXVlc3RSZWNlaXZlZEZ1bmN0aW9uKHJlcXVlc3QpIHsKICAgIHJldHVybiBmdW5jdGlvbihyZXN1bHRzKSB7CiAgICAgIGlmIChyZXF1ZXN0LnN0YXRlID09PSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5DQU5DRUxMRUQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgY29uc3QgZGVmZXJyZWQgPSByZXF1ZXN0LmRlZmVycmVkOwogICAgICAtLXN0YXRpc3RpY3MubnVtYmVyT2ZBY3RpdmVSZXF1ZXN0czsKICAgICAgLS1udW1iZXJPZkFjdGl2ZVJlcXVlc3RzQnlTZXJ2ZXJbcmVxdWVzdC5zZXJ2ZXJLZXldOwogICAgICByZXF1ZXN0Q29tcGxldGVkRXZlbnQucmFpc2VFdmVudCgpOwogICAgICByZXF1ZXN0LnN0YXRlID0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuUkVDRUlWRUQ7CiAgICAgIHJlcXVlc3QuZGVmZXJyZWQgPSB2b2lkIDA7CiAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0cyk7CiAgICB9OwogIH0KICBmdW5jdGlvbiBnZXRSZXF1ZXN0RmFpbGVkRnVuY3Rpb24ocmVxdWVzdCkgewogICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7CiAgICAgIGlmIChyZXF1ZXN0LnN0YXRlID09PSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5DQU5DRUxMRUQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgKytzdGF0aXN0aWNzLm51bWJlck9mRmFpbGVkUmVxdWVzdHM7CiAgICAgIC0tc3RhdGlzdGljcy5udW1iZXJPZkFjdGl2ZVJlcXVlc3RzOwogICAgICAtLW51bWJlck9mQWN0aXZlUmVxdWVzdHNCeVNlcnZlcltyZXF1ZXN0LnNlcnZlcktleV07CiAgICAgIHJlcXVlc3RDb21wbGV0ZWRFdmVudC5yYWlzZUV2ZW50KGVycm9yKTsKICAgICAgcmVxdWVzdC5zdGF0ZSA9IFJlcXVlc3RTdGF0ZV9kZWZhdWx0LkZBSUxFRDsKICAgICAgcmVxdWVzdC5kZWZlcnJlZC5yZWplY3QoZXJyb3IpOwogICAgfTsKICB9CiAgZnVuY3Rpb24gc3RhcnRSZXF1ZXN0KHJlcXVlc3QpIHsKICAgIGNvbnN0IHByb21pc2UgPSBpc3N1ZVJlcXVlc3QocmVxdWVzdCk7CiAgICByZXF1ZXN0LnN0YXRlID0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuQUNUSVZFOwogICAgYWN0aXZlUmVxdWVzdHMucHVzaChyZXF1ZXN0KTsKICAgICsrc3RhdGlzdGljcy5udW1iZXJPZkFjdGl2ZVJlcXVlc3RzOwogICAgKytzdGF0aXN0aWNzLm51bWJlck9mQWN0aXZlUmVxdWVzdHNFdmVyOwogICAgKytudW1iZXJPZkFjdGl2ZVJlcXVlc3RzQnlTZXJ2ZXJbcmVxdWVzdC5zZXJ2ZXJLZXldOwogICAgcmVxdWVzdC5yZXF1ZXN0RnVuY3Rpb24oKS50aGVuKGdldFJlcXVlc3RSZWNlaXZlZEZ1bmN0aW9uKHJlcXVlc3QpKS5jYXRjaChnZXRSZXF1ZXN0RmFpbGVkRnVuY3Rpb24ocmVxdWVzdCkpOwogICAgcmV0dXJuIHByb21pc2U7CiAgfQogIGZ1bmN0aW9uIGNhbmNlbFJlcXVlc3QocmVxdWVzdCkgewogICAgY29uc3QgYWN0aXZlID0gcmVxdWVzdC5zdGF0ZSA9PT0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuQUNUSVZFOwogICAgcmVxdWVzdC5zdGF0ZSA9IFJlcXVlc3RTdGF0ZV9kZWZhdWx0LkNBTkNFTExFRDsKICAgICsrc3RhdGlzdGljcy5udW1iZXJPZkNhbmNlbGxlZFJlcXVlc3RzOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChyZXF1ZXN0LmRlZmVycmVkKSkgewogICAgICBjb25zdCBkZWZlcnJlZCA9IHJlcXVlc3QuZGVmZXJyZWQ7CiAgICAgIHJlcXVlc3QuZGVmZXJyZWQgPSB2b2lkIDA7CiAgICAgIGRlZmVycmVkLnJlamVjdCgpOwogICAgfQogICAgaWYgKGFjdGl2ZSkgewogICAgICAtLXN0YXRpc3RpY3MubnVtYmVyT2ZBY3RpdmVSZXF1ZXN0czsKICAgICAgLS1udW1iZXJPZkFjdGl2ZVJlcXVlc3RzQnlTZXJ2ZXJbcmVxdWVzdC5zZXJ2ZXJLZXldOwogICAgICArK3N0YXRpc3RpY3MubnVtYmVyT2ZDYW5jZWxsZWRBY3RpdmVSZXF1ZXN0czsKICAgIH0KICAgIGlmIChkZWZpbmVkX2RlZmF1bHQocmVxdWVzdC5jYW5jZWxGdW5jdGlvbikpIHsKICAgICAgcmVxdWVzdC5jYW5jZWxGdW5jdGlvbigpOwogICAgfQogIH0KICBSZXF1ZXN0U2NoZWR1bGVyLnVwZGF0ZSA9IGZ1bmN0aW9uKCkgewogICAgbGV0IGk7CiAgICBsZXQgcmVxdWVzdDsKICAgIGxldCByZW1vdmVDb3VudCA9IDA7CiAgICBjb25zdCBhY3RpdmVMZW5ndGggPSBhY3RpdmVSZXF1ZXN0cy5sZW5ndGg7CiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlTGVuZ3RoOyArK2kpIHsKICAgICAgcmVxdWVzdCA9IGFjdGl2ZVJlcXVlc3RzW2ldOwogICAgICBpZiAocmVxdWVzdC5jYW5jZWxsZWQpIHsKICAgICAgICBjYW5jZWxSZXF1ZXN0KHJlcXVlc3QpOwogICAgICB9CiAgICAgIGlmIChyZXF1ZXN0LnN0YXRlICE9PSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5BQ1RJVkUpIHsKICAgICAgICArK3JlbW92ZUNvdW50OwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIGlmIChyZW1vdmVDb3VudCA+IDApIHsKICAgICAgICBhY3RpdmVSZXF1ZXN0c1tpIC0gcmVtb3ZlQ291bnRdID0gcmVxdWVzdDsKICAgICAgfQogICAgfQogICAgYWN0aXZlUmVxdWVzdHMubGVuZ3RoIC09IHJlbW92ZUNvdW50OwogICAgY29uc3QgaXNzdWVkUmVxdWVzdHMgPSByZXF1ZXN0SGVhcC5pbnRlcm5hbEFycmF5OwogICAgY29uc3QgaXNzdWVkTGVuZ3RoID0gcmVxdWVzdEhlYXAubGVuZ3RoOwogICAgZm9yIChpID0gMDsgaSA8IGlzc3VlZExlbmd0aDsgKytpKSB7CiAgICAgIHVwZGF0ZVByaW9yaXR5KGlzc3VlZFJlcXVlc3RzW2ldKTsKICAgIH0KICAgIHJlcXVlc3RIZWFwLnJlc29ydCgpOwogICAgY29uc3Qgb3BlblNsb3RzID0gTWF0aC5tYXgoCiAgICAgIFJlcXVlc3RTY2hlZHVsZXIubWF4aW11bVJlcXVlc3RzIC0gYWN0aXZlUmVxdWVzdHMubGVuZ3RoLAogICAgICAwCiAgICApOwogICAgbGV0IGZpbGxlZFNsb3RzID0gMDsKICAgIHdoaWxlIChmaWxsZWRTbG90cyA8IG9wZW5TbG90cyAmJiByZXF1ZXN0SGVhcC5sZW5ndGggPiAwKSB7CiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0SGVhcC5wb3AoKTsKICAgICAgaWYgKHJlcXVlc3QuY2FuY2VsbGVkKSB7CiAgICAgICAgY2FuY2VsUmVxdWVzdChyZXF1ZXN0KTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAocmVxdWVzdC50aHJvdHRsZUJ5U2VydmVyICYmICFSZXF1ZXN0U2NoZWR1bGVyLnNlcnZlckhhc09wZW5TbG90cyhyZXF1ZXN0LnNlcnZlcktleSkpIHsKICAgICAgICBjYW5jZWxSZXF1ZXN0KHJlcXVlc3QpOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIHN0YXJ0UmVxdWVzdChyZXF1ZXN0KTsKICAgICAgKytmaWxsZWRTbG90czsKICAgIH0KICAgIHVwZGF0ZVN0YXRpc3RpY3MoKTsKICB9OwogIFJlcXVlc3RTY2hlZHVsZXIuZ2V0U2VydmVyS2V5ID0gZnVuY3Rpb24odXJsKSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5zdHJpbmcoInVybCIsIHVybCk7CiAgICBsZXQgdXJpID0gbmV3IGltcG9ydF91cmlqczQuZGVmYXVsdCh1cmwpOwogICAgaWYgKHVyaS5zY2hlbWUoKSA9PT0gIiIpIHsKICAgICAgdXJpID0gbmV3IGltcG9ydF91cmlqczQuZGVmYXVsdCh1cmwpLmFic29sdXRlVG8ocGFnZVVyaSk7CiAgICAgIHVyaS5ub3JtYWxpemUoKTsKICAgIH0KICAgIGxldCBzZXJ2ZXJLZXkgPSB1cmkuYXV0aG9yaXR5KCk7CiAgICBpZiAoIS86Ly50ZXN0KHNlcnZlcktleSkpIHsKICAgICAgc2VydmVyS2V5ID0gYCR7c2VydmVyS2V5fToke3VyaS5zY2hlbWUoKSA9PT0gImh0dHBzIiA/ICI0NDMiIDogIjgwIn1gOwogICAgfQogICAgY29uc3QgbGVuZ3RoID0gbnVtYmVyT2ZBY3RpdmVSZXF1ZXN0c0J5U2VydmVyW3NlcnZlcktleV07CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsZW5ndGgpKSB7CiAgICAgIG51bWJlck9mQWN0aXZlUmVxdWVzdHNCeVNlcnZlcltzZXJ2ZXJLZXldID0gMDsKICAgIH0KICAgIHJldHVybiBzZXJ2ZXJLZXk7CiAgfTsKICBSZXF1ZXN0U2NoZWR1bGVyLnJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJlcXVlc3QiLCByZXF1ZXN0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLnN0cmluZygicmVxdWVzdC51cmwiLCByZXF1ZXN0LnVybCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5mdW5jKCJyZXF1ZXN0LnJlcXVlc3RGdW5jdGlvbiIsIHJlcXVlc3QucmVxdWVzdEZ1bmN0aW9uKTsKICAgIGlmIChpc0RhdGFVcmlfZGVmYXVsdChyZXF1ZXN0LnVybCkgfHwgaXNCbG9iVXJpX2RlZmF1bHQocmVxdWVzdC51cmwpKSB7CiAgICAgIHJlcXVlc3RDb21wbGV0ZWRFdmVudC5yYWlzZUV2ZW50KCk7CiAgICAgIHJlcXVlc3Quc3RhdGUgPSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5SRUNFSVZFRDsKICAgICAgcmV0dXJuIHJlcXVlc3QucmVxdWVzdEZ1bmN0aW9uKCk7CiAgICB9CiAgICArK3N0YXRpc3RpY3MubnVtYmVyT2ZBdHRlbXB0ZWRSZXF1ZXN0czsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlcXVlc3Quc2VydmVyS2V5KSkgewogICAgICByZXF1ZXN0LnNlcnZlcktleSA9IFJlcXVlc3RTY2hlZHVsZXIuZ2V0U2VydmVyS2V5KHJlcXVlc3QudXJsKTsKICAgIH0KICAgIGlmIChSZXF1ZXN0U2NoZWR1bGVyLnRocm90dGxlUmVxdWVzdHMgJiYgcmVxdWVzdC50aHJvdHRsZUJ5U2VydmVyICYmICFSZXF1ZXN0U2NoZWR1bGVyLnNlcnZlckhhc09wZW5TbG90cyhyZXF1ZXN0LnNlcnZlcktleSkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghUmVxdWVzdFNjaGVkdWxlci50aHJvdHRsZVJlcXVlc3RzIHx8ICFyZXF1ZXN0LnRocm90dGxlKSB7CiAgICAgIHJldHVybiBzdGFydFJlcXVlc3QocmVxdWVzdCk7CiAgICB9CiAgICBpZiAoYWN0aXZlUmVxdWVzdHMubGVuZ3RoID49IFJlcXVlc3RTY2hlZHVsZXIubWF4aW11bVJlcXVlc3RzKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICB1cGRhdGVQcmlvcml0eShyZXF1ZXN0KTsKICAgIGNvbnN0IHJlbW92ZWRSZXF1ZXN0ID0gcmVxdWVzdEhlYXAuaW5zZXJ0KHJlcXVlc3QpOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChyZW1vdmVkUmVxdWVzdCkpIHsKICAgICAgaWYgKHJlbW92ZWRSZXF1ZXN0ID09PSByZXF1ZXN0KSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICBjYW5jZWxSZXF1ZXN0KHJlbW92ZWRSZXF1ZXN0KTsKICAgIH0KICAgIHJldHVybiBpc3N1ZVJlcXVlc3QocmVxdWVzdCk7CiAgfTsKICBmdW5jdGlvbiB1cGRhdGVTdGF0aXN0aWNzKCkgewogICAgaWYgKCFSZXF1ZXN0U2NoZWR1bGVyLmRlYnVnU2hvd1N0YXRpc3RpY3MpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgaWYgKHN0YXRpc3RpY3MubnVtYmVyT2ZBY3RpdmVSZXF1ZXN0cyA9PT0gMCAmJiBzdGF0aXN0aWNzLmxhc3ROdW1iZXJPZkFjdGl2ZVJlcXVlc3RzID4gMCkgewogICAgICBpZiAoc3RhdGlzdGljcy5udW1iZXJPZkF0dGVtcHRlZFJlcXVlc3RzID4gMCkgewogICAgICAgIGNvbnNvbGUubG9nKAogICAgICAgICAgYE51bWJlciBvZiBhdHRlbXB0ZWQgcmVxdWVzdHM6ICR7c3RhdGlzdGljcy5udW1iZXJPZkF0dGVtcHRlZFJlcXVlc3RzfWAKICAgICAgICApOwogICAgICAgIHN0YXRpc3RpY3MubnVtYmVyT2ZBdHRlbXB0ZWRSZXF1ZXN0cyA9IDA7CiAgICAgIH0KICAgICAgaWYgKHN0YXRpc3RpY3MubnVtYmVyT2ZDYW5jZWxsZWRSZXF1ZXN0cyA+IDApIHsKICAgICAgICBjb25zb2xlLmxvZygKICAgICAgICAgIGBOdW1iZXIgb2YgY2FuY2VsbGVkIHJlcXVlc3RzOiAke3N0YXRpc3RpY3MubnVtYmVyT2ZDYW5jZWxsZWRSZXF1ZXN0c31gCiAgICAgICAgKTsKICAgICAgICBzdGF0aXN0aWNzLm51bWJlck9mQ2FuY2VsbGVkUmVxdWVzdHMgPSAwOwogICAgICB9CiAgICAgIGlmIChzdGF0aXN0aWNzLm51bWJlck9mQ2FuY2VsbGVkQWN0aXZlUmVxdWVzdHMgPiAwKSB7CiAgICAgICAgY29uc29sZS5sb2coCiAgICAgICAgICBgTnVtYmVyIG9mIGNhbmNlbGxlZCBhY3RpdmUgcmVxdWVzdHM6ICR7c3RhdGlzdGljcy5udW1iZXJPZkNhbmNlbGxlZEFjdGl2ZVJlcXVlc3RzfWAKICAgICAgICApOwogICAgICAgIHN0YXRpc3RpY3MubnVtYmVyT2ZDYW5jZWxsZWRBY3RpdmVSZXF1ZXN0cyA9IDA7CiAgICAgIH0KICAgICAgaWYgKHN0YXRpc3RpY3MubnVtYmVyT2ZGYWlsZWRSZXF1ZXN0cyA+IDApIHsKICAgICAgICBjb25zb2xlLmxvZygKICAgICAgICAgIGBOdW1iZXIgb2YgZmFpbGVkIHJlcXVlc3RzOiAke3N0YXRpc3RpY3MubnVtYmVyT2ZGYWlsZWRSZXF1ZXN0c31gCiAgICAgICAgKTsKICAgICAgICBzdGF0aXN0aWNzLm51bWJlck9mRmFpbGVkUmVxdWVzdHMgPSAwOwogICAgICB9CiAgICB9CiAgICBzdGF0aXN0aWNzLmxhc3ROdW1iZXJPZkFjdGl2ZVJlcXVlc3RzID0gc3RhdGlzdGljcy5udW1iZXJPZkFjdGl2ZVJlcXVlc3RzOwogIH0KICBSZXF1ZXN0U2NoZWR1bGVyLmNsZWFyRm9yU3BlY3MgPSBmdW5jdGlvbigpIHsKICAgIHdoaWxlIChyZXF1ZXN0SGVhcC5sZW5ndGggPiAwKSB7CiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0SGVhcC5wb3AoKTsKICAgICAgY2FuY2VsUmVxdWVzdChyZXF1ZXN0KTsKICAgIH0KICAgIGNvbnN0IGxlbmd0aCA9IGFjdGl2ZVJlcXVlc3RzLmxlbmd0aDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgY2FuY2VsUmVxdWVzdChhY3RpdmVSZXF1ZXN0c1tpXSk7CiAgICB9CiAgICBhY3RpdmVSZXF1ZXN0cy5sZW5ndGggPSAwOwogICAgbnVtYmVyT2ZBY3RpdmVSZXF1ZXN0c0J5U2VydmVyID0ge307CiAgICBzdGF0aXN0aWNzLm51bWJlck9mQXR0ZW1wdGVkUmVxdWVzdHMgPSAwOwogICAgc3RhdGlzdGljcy5udW1iZXJPZkFjdGl2ZVJlcXVlc3RzID0gMDsKICAgIHN0YXRpc3RpY3MubnVtYmVyT2ZDYW5jZWxsZWRSZXF1ZXN0cyA9IDA7CiAgICBzdGF0aXN0aWNzLm51bWJlck9mQ2FuY2VsbGVkQWN0aXZlUmVxdWVzdHMgPSAwOwogICAgc3RhdGlzdGljcy5udW1iZXJPZkZhaWxlZFJlcXVlc3RzID0gMDsKICAgIHN0YXRpc3RpY3MubnVtYmVyT2ZBY3RpdmVSZXF1ZXN0c0V2ZXIgPSAwOwogICAgc3RhdGlzdGljcy5sYXN0TnVtYmVyT2ZBY3RpdmVSZXF1ZXN0cyA9IDA7CiAgfTsKICBSZXF1ZXN0U2NoZWR1bGVyLm51bWJlck9mQWN0aXZlUmVxdWVzdHNCeVNlcnZlciA9IGZ1bmN0aW9uKHNlcnZlcktleSkgewogICAgcmV0dXJuIG51bWJlck9mQWN0aXZlUmVxdWVzdHNCeVNlcnZlcltzZXJ2ZXJLZXldOwogIH07CiAgUmVxdWVzdFNjaGVkdWxlci5yZXF1ZXN0SGVhcCA9IHJlcXVlc3RIZWFwOwogIHZhciBSZXF1ZXN0U2NoZWR1bGVyX2RlZmF1bHQgPSBSZXF1ZXN0U2NoZWR1bGVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVHJ1c3RlZFNlcnZlcnMuanMKICB2YXIgaW1wb3J0X3VyaWpzNSA9IF9fdG9FU00ocmVxdWlyZV9VUkkoKSwgMSk7CiAgdmFyIFRydXN0ZWRTZXJ2ZXJzID0ge307CiAgdmFyIF9zZXJ2ZXJzID0ge307CiAgVHJ1c3RlZFNlcnZlcnMuYWRkID0gZnVuY3Rpb24oaG9zdCwgcG9ydCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaG9zdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImhvc3QgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwb3J0KSB8fCBwb3J0IDw9IDApIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInBvcnQgaXMgcmVxdWlyZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAuIik7CiAgICB9CiAgICBjb25zdCBhdXRob3JpdHkgPSBgJHtob3N0LnRvTG93ZXJDYXNlKCl9OiR7cG9ydH1gOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoX3NlcnZlcnNbYXV0aG9yaXR5XSkpIHsKICAgICAgX3NlcnZlcnNbYXV0aG9yaXR5XSA9IHRydWU7CiAgICB9CiAgfTsKICBUcnVzdGVkU2VydmVycy5yZW1vdmUgPSBmdW5jdGlvbihob3N0LCBwb3J0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChob3N0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiaG9zdCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBvcnQpIHx8IHBvcnQgPD0gMCkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicG9ydCBpcyByZXF1aXJlZCB0byBiZSBncmVhdGVyIHRoYW4gMC4iKTsKICAgIH0KICAgIGNvbnN0IGF1dGhvcml0eSA9IGAke2hvc3QudG9Mb3dlckNhc2UoKX06JHtwb3J0fWA7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KF9zZXJ2ZXJzW2F1dGhvcml0eV0pKSB7CiAgICAgIGRlbGV0ZSBfc2VydmVyc1thdXRob3JpdHldOwogICAgfQogIH07CiAgZnVuY3Rpb24gZ2V0QXV0aG9yaXR5KHVybCkgewogICAgY29uc3QgdXJpID0gbmV3IGltcG9ydF91cmlqczUuZGVmYXVsdCh1cmwpOwogICAgdXJpLm5vcm1hbGl6ZSgpOwogICAgbGV0IGF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkoKTsKICAgIGlmIChhdXRob3JpdHkubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICB1cmkuYXV0aG9yaXR5KGF1dGhvcml0eSk7CiAgICBpZiAoYXV0aG9yaXR5LmluZGV4T2YoIkAiKSAhPT0gLTEpIHsKICAgICAgY29uc3QgcGFydHMgPSBhdXRob3JpdHkuc3BsaXQoIkAiKTsKICAgICAgYXV0aG9yaXR5ID0gcGFydHNbMV07CiAgICB9CiAgICBpZiAoYXV0aG9yaXR5LmluZGV4T2YoIjoiKSA9PT0gLTEpIHsKICAgICAgbGV0IHNjaGVtZSA9IHVyaS5zY2hlbWUoKTsKICAgICAgaWYgKHNjaGVtZS5sZW5ndGggPT09IDApIHsKICAgICAgICBzY2hlbWUgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7CiAgICAgICAgc2NoZW1lID0gc2NoZW1lLnN1YnN0cmluZygwLCBzY2hlbWUubGVuZ3RoIC0gMSk7CiAgICAgIH0KICAgICAgaWYgKHNjaGVtZSA9PT0gImh0dHAiKSB7CiAgICAgICAgYXV0aG9yaXR5ICs9ICI6ODAiOwogICAgICB9IGVsc2UgaWYgKHNjaGVtZSA9PT0gImh0dHBzIikgewogICAgICAgIGF1dGhvcml0eSArPSAiOjQ0MyI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGF1dGhvcml0eTsKICB9CiAgVHJ1c3RlZFNlcnZlcnMuY29udGFpbnMgPSBmdW5jdGlvbih1cmwpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHVybCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInVybCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IGF1dGhvcml0eSA9IGdldEF1dGhvcml0eSh1cmwpOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChhdXRob3JpdHkpICYmIGRlZmluZWRfZGVmYXVsdChfc2VydmVyc1thdXRob3JpdHldKSkgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIHJldHVybiBmYWxzZTsKICB9OwogIFRydXN0ZWRTZXJ2ZXJzLmNsZWFyID0gZnVuY3Rpb24oKSB7CiAgICBfc2VydmVycyA9IHt9OwogIH07CiAgdmFyIFRydXN0ZWRTZXJ2ZXJzX2RlZmF1bHQgPSBUcnVzdGVkU2VydmVyczsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1Jlc291cmNlLmpzCiAgdmFyIHhockJsb2JTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHsKICAgIHRyeSB7CiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogICAgICB4aHIub3BlbigiR0VUIiwgIiMiLCB0cnVlKTsKICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICJibG9iIjsKICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09ICJibG9iIjsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogIH0oKTsKICBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHVyaSwgcmVzb3VyY2UsIG1lcmdlLCBwcmVzZXJ2ZVF1ZXJ5UGFyYW1ldGVycykgewogICAgY29uc3QgcXVlcnlTdHJpbmcgPSB1cmkucXVlcnkoKTsKICAgIGlmIChxdWVyeVN0cmluZy5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIHt9OwogICAgfQogICAgbGV0IHF1ZXJ5OwogICAgaWYgKHF1ZXJ5U3RyaW5nLmluZGV4T2YoIj0iKSA9PT0gLTEpIHsKICAgICAgY29uc3QgcmVzdWx0ID0ge307CiAgICAgIHJlc3VsdFtxdWVyeVN0cmluZ10gPSB2b2lkIDA7CiAgICAgIHF1ZXJ5ID0gcmVzdWx0OwogICAgfSBlbHNlIHsKICAgICAgcXVlcnkgPSBxdWVyeVRvT2JqZWN0X2RlZmF1bHQocXVlcnlTdHJpbmcpOwogICAgfQogICAgaWYgKG1lcmdlKSB7CiAgICAgIHJlc291cmNlLl9xdWVyeVBhcmFtZXRlcnMgPSBjb21iaW5lUXVlcnlQYXJhbWV0ZXJzKAogICAgICAgIHF1ZXJ5LAogICAgICAgIHJlc291cmNlLl9xdWVyeVBhcmFtZXRlcnMsCiAgICAgICAgcHJlc2VydmVRdWVyeVBhcmFtZXRlcnMKICAgICAgKTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc291cmNlLl9xdWVyeVBhcmFtZXRlcnMgPSBxdWVyeTsKICAgIH0KICAgIHVyaS5zZWFyY2goIiIpOwogIH0KICBmdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSh1cmksIHJlc291cmNlKSB7CiAgICBjb25zdCBxdWVyeU9iamVjdCA9IHJlc291cmNlLl9xdWVyeVBhcmFtZXRlcnM7CiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnlPYmplY3QpOwogICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmICFkZWZpbmVkX2RlZmF1bHQocXVlcnlPYmplY3Rba2V5c1swXV0pKSB7CiAgICAgIHVyaS5zZWFyY2goa2V5c1swXSk7CiAgICB9IGVsc2UgewogICAgICB1cmkuc2VhcmNoKG9iamVjdFRvUXVlcnlfZGVmYXVsdChxdWVyeU9iamVjdCkpOwogICAgfQogIH0KICBmdW5jdGlvbiBkZWZhdWx0Q2xvbmUodmFsLCBkZWZhdWx0VmFsKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh2YWwpKSB7CiAgICAgIHJldHVybiBkZWZhdWx0VmFsOwogICAgfQogICAgcmV0dXJuIGRlZmluZWRfZGVmYXVsdCh2YWwuY2xvbmUpID8gdmFsLmNsb25lKCkgOiBjbG9uZV9kZWZhdWx0KHZhbCk7CiAgfQogIGZ1bmN0aW9uIGNoZWNrQW5kUmVzZXRSZXF1ZXN0KHJlcXVlc3QpIHsKICAgIGlmIChyZXF1ZXN0LnN0YXRlID09PSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5JU1NVRUQgfHwgcmVxdWVzdC5zdGF0ZSA9PT0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuQUNUSVZFKSB7CiAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3JfZGVmYXVsdCgiVGhlIFJlc291cmNlIGlzIGFscmVhZHkgYmVpbmcgZmV0Y2hlZC4iKTsKICAgIH0KICAgIHJlcXVlc3Quc3RhdGUgPSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5VTklTU1VFRDsKICAgIHJlcXVlc3QuZGVmZXJyZWQgPSB2b2lkIDA7CiAgfQogIGZ1bmN0aW9uIGNvbWJpbmVRdWVyeVBhcmFtZXRlcnMocTEsIHEyLCBwcmVzZXJ2ZVF1ZXJ5UGFyYW1ldGVycykgewogICAgaWYgKCFwcmVzZXJ2ZVF1ZXJ5UGFyYW1ldGVycykgewogICAgICByZXR1cm4gY29tYmluZV9kZWZhdWx0KHExLCBxMik7CiAgICB9CiAgICBjb25zdCByZXN1bHQgPSBjbG9uZV9kZWZhdWx0KHExLCB0cnVlKTsKICAgIGZvciAoY29uc3QgcGFyYW0gaW4gcTIpIHsKICAgICAgaWYgKHEyLmhhc093blByb3BlcnR5KHBhcmFtKSkgewogICAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdFtwYXJhbV07CiAgICAgICAgY29uc3QgcTJWYWx1ZSA9IHEyW3BhcmFtXTsKICAgICAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KHZhbHVlKSkgewogICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgewogICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdFtwYXJhbV0gPSBbdmFsdWVdOwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0W3BhcmFtXSA9IHZhbHVlLmNvbmNhdChxMlZhbHVlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmVzdWx0W3BhcmFtXSA9IEFycmF5LmlzQXJyYXkocTJWYWx1ZSkgPyBxMlZhbHVlLnNsaWNlKCkgOiBxMlZhbHVlOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgZnVuY3Rpb24gUmVzb3VyY2Uob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMsIGRlZmF1bHRWYWx1ZV9kZWZhdWx0LkVNUFRZX09CSkVDVCk7CiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICJzdHJpbmciKSB7CiAgICAgIG9wdGlvbnMgPSB7CiAgICAgICAgdXJsOiBvcHRpb25zCiAgICAgIH07CiAgICB9CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5zdHJpbmcoIm9wdGlvbnMudXJsIiwgb3B0aW9ucy51cmwpOwogICAgdGhpcy5fdXJsID0gdm9pZCAwOwogICAgdGhpcy5fdGVtcGxhdGVWYWx1ZXMgPSBkZWZhdWx0Q2xvbmUob3B0aW9ucy50ZW1wbGF0ZVZhbHVlcywge30pOwogICAgdGhpcy5fcXVlcnlQYXJhbWV0ZXJzID0gZGVmYXVsdENsb25lKG9wdGlvbnMucXVlcnlQYXJhbWV0ZXJzLCB7fSk7CiAgICB0aGlzLmhlYWRlcnMgPSBkZWZhdWx0Q2xvbmUob3B0aW9ucy5oZWFkZXJzLCB7fSk7CiAgICB0aGlzLnJlcXVlc3QgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLnJlcXVlc3QsIG5ldyBSZXF1ZXN0X2RlZmF1bHQoKSk7CiAgICB0aGlzLnByb3h5ID0gb3B0aW9ucy5wcm94eTsKICAgIHRoaXMucmV0cnlDYWxsYmFjayA9IG9wdGlvbnMucmV0cnlDYWxsYmFjazsKICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMucmV0cnlBdHRlbXB0cywgMCk7CiAgICB0aGlzLl9yZXRyeUNvdW50ID0gMDsKICAgIGNvbnN0IHVyaSA9IG5ldyBpbXBvcnRfdXJpanM2LmRlZmF1bHQob3B0aW9ucy51cmwpOwogICAgcGFyc2VRdWVyeSh1cmksIHRoaXMsIHRydWUsIHRydWUpOwogICAgdXJpLmZyYWdtZW50KCIiKTsKICAgIHRoaXMuX3VybCA9IHVyaS50b1N0cmluZygpOwogIH0KICBSZXNvdXJjZS5jcmVhdGVJZk5lZWRlZCA9IGZ1bmN0aW9uKHJlc291cmNlKSB7CiAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBSZXNvdXJjZSkgewogICAgICByZXR1cm4gcmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHsKICAgICAgICByZXF1ZXN0OiByZXNvdXJjZS5yZXF1ZXN0CiAgICAgIH0pOwogICAgfQogICAgaWYgKHR5cGVvZiByZXNvdXJjZSAhPT0gInN0cmluZyIpIHsKICAgICAgcmV0dXJuIHJlc291cmNlOwogICAgfQogICAgcmV0dXJuIG5ldyBSZXNvdXJjZSh7CiAgICAgIHVybDogcmVzb3VyY2UKICAgIH0pOwogIH07CiAgdmFyIHN1cHBvcnRzSW1hZ2VCaXRtYXBPcHRpb25zUHJvbWlzZTsKICBSZXNvdXJjZS5zdXBwb3J0c0ltYWdlQml0bWFwT3B0aW9ucyA9IGZ1bmN0aW9uKCkgewogICAgaWYgKGRlZmluZWRfZGVmYXVsdChzdXBwb3J0c0ltYWdlQml0bWFwT3B0aW9uc1Byb21pc2UpKSB7CiAgICAgIHJldHVybiBzdXBwb3J0c0ltYWdlQml0bWFwT3B0aW9uc1Byb21pc2U7CiAgICB9CiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgIHN1cHBvcnRzSW1hZ2VCaXRtYXBPcHRpb25zUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShmYWxzZSk7CiAgICAgIHJldHVybiBzdXBwb3J0c0ltYWdlQml0bWFwT3B0aW9uc1Byb21pc2U7CiAgICB9CiAgICBjb25zdCBpbWFnZURhdGFVcmkgPSAiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FJQUFBQ1FkMVBlQUFBQUJHZEJUVUVBQUU0ZzNyRWlEZ0FBQUNCalNGSk5BQUI2SmdBQWdJUUFBUG9BQUFDQTZBQUFkVEFBQU9wZ0FBQTZtQUFBRjNDY3VsRThBQUFBREVsRVFWUUkxMk5nNkdBQUFBRVVBSW5nRTNaaUFBQUFBRWxGVGtTdVFtQ0MiOwogICAgc3VwcG9ydHNJbWFnZUJpdG1hcE9wdGlvbnNQcm9taXNlID0gUmVzb3VyY2UuZmV0Y2hCbG9iKHsKICAgICAgdXJsOiBpbWFnZURhdGFVcmkKICAgIH0pLnRoZW4oZnVuY3Rpb24oYmxvYikgewogICAgICBjb25zdCBpbWFnZUJpdG1hcE9wdGlvbnMgPSB7CiAgICAgICAgaW1hZ2VPcmllbnRhdGlvbjogImZsaXBZIiwKICAgICAgICBwcmVtdWx0aXBseUFscGhhOiAibm9uZSIsCiAgICAgICAgY29sb3JTcGFjZUNvbnZlcnNpb246ICJub25lIgogICAgICB9OwogICAgICByZXR1cm4gUHJvbWlzZS5hbGwoWwogICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIGltYWdlQml0bWFwT3B0aW9ucyksCiAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYikKICAgICAgXSk7CiAgICB9KS50aGVuKGZ1bmN0aW9uKGltYWdlQml0bWFwcykgewogICAgICBjb25zdCBjb2xvcldpdGhPcHRpb25zID0gZ2V0SW1hZ2VQaXhlbHNfZGVmYXVsdChpbWFnZUJpdG1hcHNbMF0pOwogICAgICBjb25zdCBjb2xvcldpdGhEZWZhdWx0cyA9IGdldEltYWdlUGl4ZWxzX2RlZmF1bHQoaW1hZ2VCaXRtYXBzWzFdKTsKICAgICAgcmV0dXJuIGNvbG9yV2l0aE9wdGlvbnNbMV0gIT09IGNvbG9yV2l0aERlZmF1bHRzWzFdOwogICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0pOwogICAgcmV0dXJuIHN1cHBvcnRzSW1hZ2VCaXRtYXBPcHRpb25zUHJvbWlzZTsKICB9OwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc291cmNlLCB7CiAgICBpc0Jsb2JTdXBwb3J0ZWQ6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4geGhyQmxvYlN1cHBvcnRlZDsKICAgICAgfQogICAgfQogIH0pOwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc291cmNlLnByb3RvdHlwZSwgewogICAgcXVlcnlQYXJhbWV0ZXJzOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UGFyYW1ldGVyczsKICAgICAgfQogICAgfSwKICAgIHRlbXBsYXRlVmFsdWVzOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlVmFsdWVzOwogICAgICB9CiAgICB9LAogICAgdXJsOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXJsQ29tcG9uZW50KHRydWUsIHRydWUpOwogICAgICB9LAogICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgY29uc3QgdXJpID0gbmV3IGltcG9ydF91cmlqczYuZGVmYXVsdCh2YWx1ZSk7CiAgICAgICAgcGFyc2VRdWVyeSh1cmksIHRoaXMsIGZhbHNlKTsKICAgICAgICB1cmkuZnJhZ21lbnQoIiIpOwogICAgICAgIHRoaXMuX3VybCA9IHVyaS50b1N0cmluZygpOwogICAgICB9CiAgICB9LAogICAgZXh0ZW5zaW9uOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIGdldEV4dGVuc2lvbkZyb21VcmlfZGVmYXVsdCh0aGlzLl91cmwpOwogICAgICB9CiAgICB9LAogICAgaXNEYXRhVXJpOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIGlzRGF0YVVyaV9kZWZhdWx0KHRoaXMuX3VybCk7CiAgICAgIH0KICAgIH0sCiAgICBpc0Jsb2JVcmk6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gaXNCbG9iVXJpX2RlZmF1bHQodGhpcy5fdXJsKTsKICAgICAgfQogICAgfSwKICAgIGlzQ3Jvc3NPcmlnaW5Vcmw6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gaXNDcm9zc09yaWdpblVybF9kZWZhdWx0KHRoaXMuX3VybCk7CiAgICAgIH0KICAgIH0sCiAgICBoYXNIZWFkZXJzOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycykubGVuZ3RoID4gMDsKICAgICAgfQogICAgfQogIH0pOwogIFJlc291cmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMuZ2V0VXJsQ29tcG9uZW50KHRydWUsIHRydWUpOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLmdldFVybENvbXBvbmVudCA9IGZ1bmN0aW9uKHF1ZXJ5LCBwcm94eSkgewogICAgaWYgKHRoaXMuaXNEYXRhVXJpKSB7CiAgICAgIHJldHVybiB0aGlzLl91cmw7CiAgICB9CiAgICBjb25zdCB1cmkgPSBuZXcgaW1wb3J0X3VyaWpzNi5kZWZhdWx0KHRoaXMuX3VybCk7CiAgICBpZiAocXVlcnkpIHsKICAgICAgc3RyaW5naWZ5UXVlcnkodXJpLCB0aGlzKTsKICAgIH0KICAgIGxldCB1cmwgPSB1cmkudG9TdHJpbmcoKS5yZXBsYWNlKC8lN0IvZywgInsiKS5yZXBsYWNlKC8lN0QvZywgIn0iKTsKICAgIGNvbnN0IHRlbXBsYXRlVmFsdWVzID0gdGhpcy5fdGVtcGxhdGVWYWx1ZXM7CiAgICB1cmwgPSB1cmwucmVwbGFjZSgveyguKj8pfS9nLCBmdW5jdGlvbihtYXRjaCwga2V5KSB7CiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gdGVtcGxhdGVWYWx1ZXNba2V5XTsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChyZXBsYWNlbWVudCkpIHsKICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHJlcGxhY2VtZW50KTsKICAgICAgfQogICAgICByZXR1cm4gbWF0Y2g7CiAgICB9KTsKICAgIGlmIChwcm94eSAmJiBkZWZpbmVkX2RlZmF1bHQodGhpcy5wcm94eSkpIHsKICAgICAgdXJsID0gdGhpcy5wcm94eS5nZXRVUkwodXJsKTsKICAgIH0KICAgIHJldHVybiB1cmw7CiAgfTsKICBSZXNvdXJjZS5wcm90b3R5cGUuc2V0UXVlcnlQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zLCB1c2VBc0RlZmF1bHQpIHsKICAgIGlmICh1c2VBc0RlZmF1bHQpIHsKICAgICAgdGhpcy5fcXVlcnlQYXJhbWV0ZXJzID0gY29tYmluZVF1ZXJ5UGFyYW1ldGVycygKICAgICAgICB0aGlzLl9xdWVyeVBhcmFtZXRlcnMsCiAgICAgICAgcGFyYW1zLAogICAgICAgIGZhbHNlCiAgICAgICk7CiAgICB9IGVsc2UgewogICAgICB0aGlzLl9xdWVyeVBhcmFtZXRlcnMgPSBjb21iaW5lUXVlcnlQYXJhbWV0ZXJzKAogICAgICAgIHBhcmFtcywKICAgICAgICB0aGlzLl9xdWVyeVBhcmFtZXRlcnMsCiAgICAgICAgZmFsc2UKICAgICAgKTsKICAgIH0KICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5hcHBlbmRRdWVyeVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHsKICAgIHRoaXMuX3F1ZXJ5UGFyYW1ldGVycyA9IGNvbWJpbmVRdWVyeVBhcmFtZXRlcnMoCiAgICAgIHBhcmFtcywKICAgICAgdGhpcy5fcXVlcnlQYXJhbWV0ZXJzLAogICAgICB0cnVlCiAgICApOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLnNldFRlbXBsYXRlVmFsdWVzID0gZnVuY3Rpb24odGVtcGxhdGUsIHVzZUFzRGVmYXVsdCkgewogICAgaWYgKHVzZUFzRGVmYXVsdCkgewogICAgICB0aGlzLl90ZW1wbGF0ZVZhbHVlcyA9IGNvbWJpbmVfZGVmYXVsdCh0aGlzLl90ZW1wbGF0ZVZhbHVlcywgdGVtcGxhdGUpOwogICAgfSBlbHNlIHsKICAgICAgdGhpcy5fdGVtcGxhdGVWYWx1ZXMgPSBjb21iaW5lX2RlZmF1bHQodGVtcGxhdGUsIHRoaXMuX3RlbXBsYXRlVmFsdWVzKTsKICAgIH0KICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5nZXREZXJpdmVkUmVzb3VyY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7CiAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMuY2xvbmUoKTsKICAgIHJlc291cmNlLl9yZXRyeUNvdW50ID0gMDsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy51cmwpKSB7CiAgICAgIGNvbnN0IHVyaSA9IG5ldyBpbXBvcnRfdXJpanM2LmRlZmF1bHQob3B0aW9ucy51cmwpOwogICAgICBjb25zdCBwcmVzZXJ2ZVF1ZXJ5UGFyYW1ldGVycyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICAgIG9wdGlvbnMucHJlc2VydmVRdWVyeVBhcmFtZXRlcnMsCiAgICAgICAgZmFsc2UKICAgICAgKTsKICAgICAgcGFyc2VRdWVyeSh1cmksIHJlc291cmNlLCB0cnVlLCBwcmVzZXJ2ZVF1ZXJ5UGFyYW1ldGVycyk7CiAgICAgIHVyaS5mcmFnbWVudCgiIik7CiAgICAgIGlmICh1cmkuc2NoZW1lKCkgIT09ICIiKSB7CiAgICAgICAgcmVzb3VyY2UuX3VybCA9IHVyaS50b1N0cmluZygpOwogICAgICB9IGVsc2UgewogICAgICAgIHJlc291cmNlLl91cmwgPSB1cmkuYWJzb2x1dGVUbyhuZXcgaW1wb3J0X3VyaWpzNi5kZWZhdWx0KGdldEFic29sdXRlVXJpX2RlZmF1bHQodGhpcy5fdXJsKSkpLnRvU3RyaW5nKCk7CiAgICAgIH0KICAgIH0KICAgIGlmIChkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMpKSB7CiAgICAgIHJlc291cmNlLl9xdWVyeVBhcmFtZXRlcnMgPSBjb21iaW5lX2RlZmF1bHQoCiAgICAgICAgb3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMsCiAgICAgICAgcmVzb3VyY2UuX3F1ZXJ5UGFyYW1ldGVycwogICAgICApOwogICAgfQogICAgaWYgKGRlZmluZWRfZGVmYXVsdChvcHRpb25zLnRlbXBsYXRlVmFsdWVzKSkgewogICAgICByZXNvdXJjZS5fdGVtcGxhdGVWYWx1ZXMgPSBjb21iaW5lX2RlZmF1bHQoCiAgICAgICAgb3B0aW9ucy50ZW1wbGF0ZVZhbHVlcywKICAgICAgICByZXNvdXJjZS50ZW1wbGF0ZVZhbHVlcwogICAgICApOwogICAgfQogICAgaWYgKGRlZmluZWRfZGVmYXVsdChvcHRpb25zLmhlYWRlcnMpKSB7CiAgICAgIHJlc291cmNlLmhlYWRlcnMgPSBjb21iaW5lX2RlZmF1bHQob3B0aW9ucy5oZWFkZXJzLCByZXNvdXJjZS5oZWFkZXJzKTsKICAgIH0KICAgIGlmIChkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5wcm94eSkpIHsKICAgICAgcmVzb3VyY2UucHJveHkgPSBvcHRpb25zLnByb3h5OwogICAgfQogICAgaWYgKGRlZmluZWRfZGVmYXVsdChvcHRpb25zLnJlcXVlc3QpKSB7CiAgICAgIHJlc291cmNlLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7CiAgICB9CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMucmV0cnlDYWxsYmFjaykpIHsKICAgICAgcmVzb3VyY2UucmV0cnlDYWxsYmFjayA9IG9wdGlvbnMucmV0cnlDYWxsYmFjazsKICAgIH0KICAgIGlmIChkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5yZXRyeUF0dGVtcHRzKSkgewogICAgICByZXNvdXJjZS5yZXRyeUF0dGVtcHRzID0gb3B0aW9ucy5yZXRyeUF0dGVtcHRzOwogICAgfQogICAgcmV0dXJuIHJlc291cmNlOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLnJldHJ5T25FcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7CiAgICBjb25zdCByZXRyeUNhbGxiYWNrMiA9IHRoaXMucmV0cnlDYWxsYmFjazsKICAgIGlmICh0eXBlb2YgcmV0cnlDYWxsYmFjazIgIT09ICJmdW5jdGlvbiIgfHwgdGhpcy5fcmV0cnlDb3VudCA+PSB0aGlzLnJldHJ5QXR0ZW1wdHMpIHsKICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7CiAgICB9CiAgICBjb25zdCB0aGF0ID0gdGhpczsKICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmV0cnlDYWxsYmFjazIodGhpcywgZXJyb3IpKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkgewogICAgICArK3RoYXQuX3JldHJ5Q291bnQ7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9KTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgUmVzb3VyY2UoewogICAgICAgIHVybDogdGhpcy5fdXJsCiAgICAgIH0pOwogICAgfQogICAgcmVzdWx0Ll91cmwgPSB0aGlzLl91cmw7CiAgICByZXN1bHQuX3F1ZXJ5UGFyYW1ldGVycyA9IGNsb25lX2RlZmF1bHQodGhpcy5fcXVlcnlQYXJhbWV0ZXJzKTsKICAgIHJlc3VsdC5fdGVtcGxhdGVWYWx1ZXMgPSBjbG9uZV9kZWZhdWx0KHRoaXMuX3RlbXBsYXRlVmFsdWVzKTsKICAgIHJlc3VsdC5oZWFkZXJzID0gY2xvbmVfZGVmYXVsdCh0aGlzLmhlYWRlcnMpOwogICAgcmVzdWx0LnByb3h5ID0gdGhpcy5wcm94eTsKICAgIHJlc3VsdC5yZXRyeUNhbGxiYWNrID0gdGhpcy5yZXRyeUNhbGxiYWNrOwogICAgcmVzdWx0LnJldHJ5QXR0ZW1wdHMgPSB0aGlzLnJldHJ5QXR0ZW1wdHM7CiAgICByZXN1bHQuX3JldHJ5Q291bnQgPSAwOwogICAgcmVzdWx0LnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuY2xvbmUoKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBSZXNvdXJjZS5wcm90b3R5cGUuZ2V0QmFzZVVyaSA9IGZ1bmN0aW9uKGluY2x1ZGVRdWVyeSkgewogICAgcmV0dXJuIGdldEJhc2VVcmlfZGVmYXVsdCh0aGlzLmdldFVybENvbXBvbmVudChpbmNsdWRlUXVlcnkpLCBpbmNsdWRlUXVlcnkpOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLmFwcGVuZEZvcndhcmRTbGFzaCA9IGZ1bmN0aW9uKCkgewogICAgdGhpcy5fdXJsID0gYXBwZW5kRm9yd2FyZFNsYXNoX2RlZmF1bHQodGhpcy5fdXJsKTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5mZXRjaEFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdGhpcy5mZXRjaCh7CiAgICAgIHJlc3BvbnNlVHlwZTogImFycmF5YnVmZmVyIgogICAgfSk7CiAgfTsKICBSZXNvdXJjZS5mZXRjaEFycmF5QnVmZmVyID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2Uob3B0aW9ucyk7CiAgICByZXR1cm4gcmVzb3VyY2UuZmV0Y2hBcnJheUJ1ZmZlcigpOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLmZldGNoQmxvYiA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMuZmV0Y2goewogICAgICByZXNwb25zZVR5cGU6ICJibG9iIgogICAgfSk7CiAgfTsKICBSZXNvdXJjZS5mZXRjaEJsb2IgPSBmdW5jdGlvbihvcHRpb25zKSB7CiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShvcHRpb25zKTsKICAgIHJldHVybiByZXNvdXJjZS5mZXRjaEJsb2IoKTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5mZXRjaEltYWdlID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMsIGRlZmF1bHRWYWx1ZV9kZWZhdWx0LkVNUFRZX09CSkVDVCk7CiAgICBjb25zdCBwcmVmZXJJbWFnZUJpdG1hcCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMucHJlZmVySW1hZ2VCaXRtYXAsIGZhbHNlKTsKICAgIGNvbnN0IHByZWZlckJsb2IgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLnByZWZlckJsb2IsIGZhbHNlKTsKICAgIGNvbnN0IGZsaXBZID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5mbGlwWSwgZmFsc2UpOwogICAgY29uc3Qgc2tpcENvbG9yU3BhY2VDb252ZXJzaW9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIG9wdGlvbnMuc2tpcENvbG9yU3BhY2VDb252ZXJzaW9uLAogICAgICBmYWxzZQogICAgKTsKICAgIGNoZWNrQW5kUmVzZXRSZXF1ZXN0KHRoaXMucmVxdWVzdCk7CiAgICBpZiAoIXhockJsb2JTdXBwb3J0ZWQgfHwgdGhpcy5pc0RhdGFVcmkgfHwgdGhpcy5pc0Jsb2JVcmkgfHwgIXRoaXMuaGFzSGVhZGVycyAmJiAhcHJlZmVyQmxvYikgewogICAgICByZXR1cm4gZmV0Y2hJbWFnZSh7CiAgICAgICAgcmVzb3VyY2U6IHRoaXMsCiAgICAgICAgZmxpcFksCiAgICAgICAgc2tpcENvbG9yU3BhY2VDb252ZXJzaW9uLAogICAgICAgIHByZWZlckltYWdlQml0bWFwCiAgICAgIH0pOwogICAgfQogICAgY29uc3QgYmxvYlByb21pc2UgPSB0aGlzLmZldGNoQmxvYigpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYmxvYlByb21pc2UpKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGxldCBzdXBwb3J0c0ltYWdlQml0bWFwOwogICAgbGV0IHVzZUltYWdlQml0bWFwOwogICAgbGV0IGdlbmVyYXRlZEJsb2JSZXNvdXJjZTsKICAgIGxldCBnZW5lcmF0ZWRCbG9iOwogICAgcmV0dXJuIFJlc291cmNlLnN1cHBvcnRzSW1hZ2VCaXRtYXBPcHRpb25zKCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHsKICAgICAgc3VwcG9ydHNJbWFnZUJpdG1hcCA9IHJlc3VsdDsKICAgICAgdXNlSW1hZ2VCaXRtYXAgPSBzdXBwb3J0c0ltYWdlQml0bWFwICYmIHByZWZlckltYWdlQml0bWFwOwogICAgICByZXR1cm4gYmxvYlByb21pc2U7CiAgICB9KS50aGVuKGZ1bmN0aW9uKGJsb2IpIHsKICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYmxvYikpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgZ2VuZXJhdGVkQmxvYiA9IGJsb2I7CiAgICAgIGlmICh1c2VJbWFnZUJpdG1hcCkgewogICAgICAgIHJldHVybiBSZXNvdXJjZS5jcmVhdGVJbWFnZUJpdG1hcEZyb21CbG9iKGJsb2IsIHsKICAgICAgICAgIGZsaXBZLAogICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogZmFsc2UsCiAgICAgICAgICBza2lwQ29sb3JTcGFjZUNvbnZlcnNpb24KICAgICAgICB9KTsKICAgICAgfQogICAgICBjb25zdCBibG9iVXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7CiAgICAgIGdlbmVyYXRlZEJsb2JSZXNvdXJjZSA9IG5ldyBSZXNvdXJjZSh7CiAgICAgICAgdXJsOiBibG9iVXJsCiAgICAgIH0pOwogICAgICByZXR1cm4gZmV0Y2hJbWFnZSh7CiAgICAgICAgcmVzb3VyY2U6IGdlbmVyYXRlZEJsb2JSZXNvdXJjZSwKICAgICAgICBmbGlwWSwKICAgICAgICBza2lwQ29sb3JTcGFjZUNvbnZlcnNpb24sCiAgICAgICAgcHJlZmVySW1hZ2VCaXRtYXA6IGZhbHNlCiAgICAgIH0pOwogICAgfSkudGhlbihmdW5jdGlvbihpbWFnZSkgewogICAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpbWFnZSkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaW1hZ2UuYmxvYiA9IGdlbmVyYXRlZEJsb2I7CiAgICAgIGlmICh1c2VJbWFnZUJpdG1hcCkgewogICAgICAgIHJldHVybiBpbWFnZTsKICAgICAgfQogICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChnZW5lcmF0ZWRCbG9iUmVzb3VyY2UudXJsKTsKICAgICAgcmV0dXJuIGltYWdlOwogICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChnZW5lcmF0ZWRCbG9iUmVzb3VyY2UpKSB7CiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwoZ2VuZXJhdGVkQmxvYlJlc291cmNlLnVybCk7CiAgICAgIH0KICAgICAgZXJyb3IuYmxvYiA9IGdlbmVyYXRlZEJsb2I7CiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7CiAgICB9KTsKICB9OwogIGZ1bmN0aW9uIGZldGNoSW1hZ2Uob3B0aW9ucykgewogICAgY29uc3QgcmVzb3VyY2UgPSBvcHRpb25zLnJlc291cmNlOwogICAgY29uc3QgZmxpcFkgPSBvcHRpb25zLmZsaXBZOwogICAgY29uc3Qgc2tpcENvbG9yU3BhY2VDb252ZXJzaW9uID0gb3B0aW9ucy5za2lwQ29sb3JTcGFjZUNvbnZlcnNpb247CiAgICBjb25zdCBwcmVmZXJJbWFnZUJpdG1hcCA9IG9wdGlvbnMucHJlZmVySW1hZ2VCaXRtYXA7CiAgICBjb25zdCByZXF1ZXN0ID0gcmVzb3VyY2UucmVxdWVzdDsKICAgIHJlcXVlc3QudXJsID0gcmVzb3VyY2UudXJsOwogICAgcmVxdWVzdC5yZXF1ZXN0RnVuY3Rpb24gPSBmdW5jdGlvbigpIHsKICAgICAgbGV0IGNyb3NzT3JpZ2luID0gZmFsc2U7CiAgICAgIGlmICghcmVzb3VyY2UuaXNEYXRhVXJpICYmICFyZXNvdXJjZS5pc0Jsb2JVcmkpIHsKICAgICAgICBjcm9zc09yaWdpbiA9IHJlc291cmNlLmlzQ3Jvc3NPcmlnaW5Vcmw7CiAgICAgIH0KICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcl9kZWZhdWx0KCk7CiAgICAgIFJlc291cmNlLl9JbXBsZW1lbnRhdGlvbnMuY3JlYXRlSW1hZ2UoCiAgICAgICAgcmVxdWVzdCwKICAgICAgICBjcm9zc09yaWdpbiwKICAgICAgICBkZWZlcnJlZCwKICAgICAgICBmbGlwWSwKICAgICAgICBza2lwQ29sb3JTcGFjZUNvbnZlcnNpb24sCiAgICAgICAgcHJlZmVySW1hZ2VCaXRtYXAKICAgICAgKTsKICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7CiAgICB9OwogICAgY29uc3QgcHJvbWlzZSA9IFJlcXVlc3RTY2hlZHVsZXJfZGVmYXVsdC5yZXF1ZXN0KHJlcXVlc3QpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocHJvbWlzZSkpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgcmV0dXJuIHByb21pc2UuY2F0Y2goZnVuY3Rpb24oZSkgewogICAgICBpZiAocmVxdWVzdC5zdGF0ZSAhPT0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuRkFJTEVEKSB7CiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOwogICAgICB9CiAgICAgIHJldHVybiByZXNvdXJjZS5yZXRyeU9uRXJyb3IoZSkudGhlbihmdW5jdGlvbihyZXRyeSkgewogICAgICAgIGlmIChyZXRyeSkgewogICAgICAgICAgcmVxdWVzdC5zdGF0ZSA9IFJlcXVlc3RTdGF0ZV9kZWZhdWx0LlVOSVNTVUVEOwogICAgICAgICAgcmVxdWVzdC5kZWZlcnJlZCA9IHZvaWQgMDsKICAgICAgICAgIHJldHVybiBmZXRjaEltYWdlKHsKICAgICAgICAgICAgcmVzb3VyY2UsCiAgICAgICAgICAgIGZsaXBZLAogICAgICAgICAgICBza2lwQ29sb3JTcGFjZUNvbnZlcnNpb24sCiAgICAgICAgICAgIHByZWZlckltYWdlQml0bWFwCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOwogICAgICB9KTsKICAgIH0pOwogIH0KICBSZXNvdXJjZS5mZXRjaEltYWdlID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2Uob3B0aW9ucyk7CiAgICByZXR1cm4gcmVzb3VyY2UuZmV0Y2hJbWFnZSh7CiAgICAgIGZsaXBZOiBvcHRpb25zLmZsaXBZLAogICAgICBza2lwQ29sb3JTcGFjZUNvbnZlcnNpb246IG9wdGlvbnMuc2tpcENvbG9yU3BhY2VDb252ZXJzaW9uLAogICAgICBwcmVmZXJCbG9iOiBvcHRpb25zLnByZWZlckJsb2IsCiAgICAgIHByZWZlckltYWdlQml0bWFwOiBvcHRpb25zLnByZWZlckltYWdlQml0bWFwCiAgICB9KTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5mZXRjaFRleHQgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiB0aGlzLmZldGNoKHsKICAgICAgcmVzcG9uc2VUeXBlOiAidGV4dCIKICAgIH0pOwogIH07CiAgUmVzb3VyY2UuZmV0Y2hUZXh0ID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2Uob3B0aW9ucyk7CiAgICByZXR1cm4gcmVzb3VyY2UuZmV0Y2hUZXh0KCk7CiAgfTsKICBSZXNvdXJjZS5wcm90b3R5cGUuZmV0Y2hKc29uID0gZnVuY3Rpb24oKSB7CiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5mZXRjaCh7CiAgICAgIHJlc3BvbnNlVHlwZTogInRleHQiLAogICAgICBoZWFkZXJzOiB7CiAgICAgICAgQWNjZXB0OiAiYXBwbGljYXRpb24vanNvbiwqLyo7cT0wLjAxIgogICAgICB9CiAgICB9KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHByb21pc2UpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHZhbHVlKSkgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7CiAgICB9KTsKICB9OwogIFJlc291cmNlLmZldGNoSnNvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFJlc291cmNlKG9wdGlvbnMpOwogICAgcmV0dXJuIHJlc291cmNlLmZldGNoSnNvbigpOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLmZldGNoWE1MID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdGhpcy5mZXRjaCh7CiAgICAgIHJlc3BvbnNlVHlwZTogImRvY3VtZW50IiwKICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogInRleHQveG1sIgogICAgfSk7CiAgfTsKICBSZXNvdXJjZS5mZXRjaFhNTCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFJlc291cmNlKG9wdGlvbnMpOwogICAgcmV0dXJuIHJlc291cmNlLmZldGNoWE1MKCk7CiAgfTsKICBSZXNvdXJjZS5wcm90b3R5cGUuZmV0Y2hKc29ucCA9IGZ1bmN0aW9uKGNhbGxiYWNrUGFyYW1ldGVyTmFtZSkgewogICAgY2FsbGJhY2tQYXJhbWV0ZXJOYW1lID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoY2FsbGJhY2tQYXJhbWV0ZXJOYW1lLCAiY2FsbGJhY2siKTsKICAgIGNoZWNrQW5kUmVzZXRSZXF1ZXN0KHRoaXMucmVxdWVzdCk7CiAgICBsZXQgZnVuY3Rpb25OYW1lOwogICAgZG8gewogICAgICBmdW5jdGlvbk5hbWUgPSBgbG9hZEpzb25wJHtNYXRoX2RlZmF1bHQubmV4dFJhbmRvbU51bWJlcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsIDgpfWA7CiAgICB9IHdoaWxlIChkZWZpbmVkX2RlZmF1bHQod2luZG93W2Z1bmN0aW9uTmFtZV0pKTsKICAgIHJldHVybiBmZXRjaEpzb25wKHRoaXMsIGNhbGxiYWNrUGFyYW1ldGVyTmFtZSwgZnVuY3Rpb25OYW1lKTsKICB9OwogIGZ1bmN0aW9uIGZldGNoSnNvbnAocmVzb3VyY2UsIGNhbGxiYWNrUGFyYW1ldGVyTmFtZSwgZnVuY3Rpb25OYW1lKSB7CiAgICBjb25zdCBjYWxsYmFja1F1ZXJ5ID0ge307CiAgICBjYWxsYmFja1F1ZXJ5W2NhbGxiYWNrUGFyYW1ldGVyTmFtZV0gPSBmdW5jdGlvbk5hbWU7CiAgICByZXNvdXJjZS5zZXRRdWVyeVBhcmFtZXRlcnMoY2FsbGJhY2tRdWVyeSk7CiAgICBjb25zdCByZXF1ZXN0ID0gcmVzb3VyY2UucmVxdWVzdDsKICAgIHJlcXVlc3QudXJsID0gcmVzb3VyY2UudXJsOwogICAgcmVxdWVzdC5yZXF1ZXN0RnVuY3Rpb24gPSBmdW5jdGlvbigpIHsKICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcl9kZWZhdWx0KCk7CiAgICAgIHdpbmRvd1tmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24oZGF0YSkgewogICAgICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YSk7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbZnVuY3Rpb25OYW1lXTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICB3aW5kb3dbZnVuY3Rpb25OYW1lXSA9IHZvaWQgMDsKICAgICAgICB9CiAgICAgIH07CiAgICAgIFJlc291cmNlLl9JbXBsZW1lbnRhdGlvbnMubG9hZEFuZEV4ZWN1dGVTY3JpcHQoCiAgICAgICAgcmVzb3VyY2UudXJsLAogICAgICAgIGZ1bmN0aW9uTmFtZSwKICAgICAgICBkZWZlcnJlZAogICAgICApOwogICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTsKICAgIH07CiAgICBjb25zdCBwcm9taXNlID0gUmVxdWVzdFNjaGVkdWxlcl9kZWZhdWx0LnJlcXVlc3QocmVxdWVzdCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwcm9taXNlKSkgewogICAgICByZXR1cm47CiAgICB9CiAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChmdW5jdGlvbihlKSB7CiAgICAgIGlmIChyZXF1ZXN0LnN0YXRlICE9PSBSZXF1ZXN0U3RhdGVfZGVmYXVsdC5GQUlMRUQpIHsKICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHJlc291cmNlLnJldHJ5T25FcnJvcihlKS50aGVuKGZ1bmN0aW9uKHJldHJ5KSB7CiAgICAgICAgaWYgKHJldHJ5KSB7CiAgICAgICAgICByZXF1ZXN0LnN0YXRlID0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuVU5JU1NVRUQ7CiAgICAgICAgICByZXF1ZXN0LmRlZmVycmVkID0gdm9pZCAwOwogICAgICAgICAgcmV0dXJuIGZldGNoSnNvbnAocmVzb3VyY2UsIGNhbGxiYWNrUGFyYW1ldGVyTmFtZSwgZnVuY3Rpb25OYW1lKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOwogICAgICB9KTsKICAgIH0pOwogIH0KICBSZXNvdXJjZS5mZXRjaEpzb25wID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2Uob3B0aW9ucyk7CiAgICByZXR1cm4gcmVzb3VyY2UuZmV0Y2hKc29ucChvcHRpb25zLmNhbGxiYWNrUGFyYW1ldGVyTmFtZSk7CiAgfTsKICBSZXNvdXJjZS5wcm90b3R5cGUuX21ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzOwogICAgY2hlY2tBbmRSZXNldFJlcXVlc3QocmVzb3VyY2UucmVxdWVzdCk7CiAgICBjb25zdCByZXF1ZXN0ID0gcmVzb3VyY2UucmVxdWVzdDsKICAgIHJlcXVlc3QudXJsID0gcmVzb3VyY2UudXJsOwogICAgcmVxdWVzdC5yZXF1ZXN0RnVuY3Rpb24gPSBmdW5jdGlvbigpIHsKICAgICAgY29uc3QgcmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7CiAgICAgIGNvbnN0IGhlYWRlcnMgPSBjb21iaW5lX2RlZmF1bHQob3B0aW9ucy5oZWFkZXJzLCByZXNvdXJjZS5oZWFkZXJzKTsKICAgICAgY29uc3Qgb3ZlcnJpZGVNaW1lVHlwZSA9IG9wdGlvbnMub3ZlcnJpZGVNaW1lVHlwZTsKICAgICAgY29uc3QgbWV0aG9kID0gb3B0aW9ucy5tZXRob2Q7CiAgICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLmRhdGE7CiAgICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXJfZGVmYXVsdCgpOwogICAgICBjb25zdCB4aHIgPSBSZXNvdXJjZS5fSW1wbGVtZW50YXRpb25zLmxvYWRXaXRoWGhyKAogICAgICAgIHJlc291cmNlLnVybCwKICAgICAgICByZXNwb25zZVR5cGUsCiAgICAgICAgbWV0aG9kLAogICAgICAgIGRhdGEsCiAgICAgICAgaGVhZGVycywKICAgICAgICBkZWZlcnJlZCwKICAgICAgICBvdmVycmlkZU1pbWVUeXBlCiAgICAgICk7CiAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoeGhyKSAmJiBkZWZpbmVkX2RlZmF1bHQoeGhyLmFib3J0KSkgewogICAgICAgIHJlcXVlc3QuY2FuY2VsRnVuY3Rpb24gPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHhoci5hYm9ydCgpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7CiAgICB9OwogICAgY29uc3QgcHJvbWlzZSA9IFJlcXVlc3RTY2hlZHVsZXJfZGVmYXVsdC5yZXF1ZXN0KHJlcXVlc3QpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocHJvbWlzZSkpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7CiAgICAgIHJlcXVlc3QuY2FuY2VsRnVuY3Rpb24gPSB2b2lkIDA7CiAgICAgIHJldHVybiBkYXRhOwogICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkgewogICAgICByZXF1ZXN0LmNhbmNlbEZ1bmN0aW9uID0gdm9pZCAwOwogICAgICBpZiAocmVxdWVzdC5zdGF0ZSAhPT0gUmVxdWVzdFN0YXRlX2RlZmF1bHQuRkFJTEVEKSB7CiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOwogICAgICB9CiAgICAgIHJldHVybiByZXNvdXJjZS5yZXRyeU9uRXJyb3IoZSkudGhlbihmdW5jdGlvbihyZXRyeSkgewogICAgICAgIGlmIChyZXRyeSkgewogICAgICAgICAgcmVxdWVzdC5zdGF0ZSA9IFJlcXVlc3RTdGF0ZV9kZWZhdWx0LlVOSVNTVUVEOwogICAgICAgICAgcmVxdWVzdC5kZWZlcnJlZCA9IHZvaWQgMDsKICAgICAgICAgIHJldHVybiByZXNvdXJjZS5mZXRjaChvcHRpb25zKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOwogICAgICB9KTsKICAgIH0pOwogIH07CiAgdmFyIGRhdGFVcmlSZWdleDIgPSAvXmRhdGE6KC4qPykoO2Jhc2U2NCk/LCguKikkLzsKICBmdW5jdGlvbiBkZWNvZGVEYXRhVXJpVGV4dChpc0Jhc2U2NCwgZGF0YSkgewogICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpOwogICAgaWYgKGlzQmFzZTY0KSB7CiAgICAgIHJldHVybiBhdG9iKHJlc3VsdCk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICBmdW5jdGlvbiBkZWNvZGVEYXRhVXJpQXJyYXlCdWZmZXIoaXNCYXNlNjQsIGRhdGEpIHsKICAgIGNvbnN0IGJ5dGVTdHJpbmcgPSBkZWNvZGVEYXRhVXJpVGV4dChpc0Jhc2U2NCwgZGF0YSk7CiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpOwogICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHsKICAgICAgdmlld1tpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTsKICAgIH0KICAgIHJldHVybiBidWZmZXI7CiAgfQogIGZ1bmN0aW9uIGRlY29kZURhdGFVcmkoZGF0YVVyaVJlZ2V4UmVzdWx0LCByZXNwb25zZVR5cGUpIHsKICAgIHJlc3BvbnNlVHlwZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHJlc3BvbnNlVHlwZSwgIiIpOwogICAgY29uc3QgbWltZVR5cGUgPSBkYXRhVXJpUmVnZXhSZXN1bHRbMV07CiAgICBjb25zdCBpc0Jhc2U2NCA9ICEhZGF0YVVyaVJlZ2V4UmVzdWx0WzJdOwogICAgY29uc3QgZGF0YSA9IGRhdGFVcmlSZWdleFJlc3VsdFszXTsKICAgIGxldCBidWZmZXI7CiAgICBsZXQgcGFyc2VyOwogICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHsKICAgICAgY2FzZSAiIjoKICAgICAgY2FzZSAidGV4dCI6CiAgICAgICAgcmV0dXJuIGRlY29kZURhdGFVcmlUZXh0KGlzQmFzZTY0LCBkYXRhKTsKICAgICAgY2FzZSAiYXJyYXlidWZmZXIiOgogICAgICAgIHJldHVybiBkZWNvZGVEYXRhVXJpQXJyYXlCdWZmZXIoaXNCYXNlNjQsIGRhdGEpOwogICAgICBjYXNlICJibG9iIjoKICAgICAgICBidWZmZXIgPSBkZWNvZGVEYXRhVXJpQXJyYXlCdWZmZXIoaXNCYXNlNjQsIGRhdGEpOwogICAgICAgIHJldHVybiBuZXcgQmxvYihbYnVmZmVyXSwgewogICAgICAgICAgdHlwZTogbWltZVR5cGUKICAgICAgICB9KTsKICAgICAgY2FzZSAiZG9jdW1lbnQiOgogICAgICAgIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTsKICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZygKICAgICAgICAgIGRlY29kZURhdGFVcmlUZXh0KGlzQmFzZTY0LCBkYXRhKSwKICAgICAgICAgIG1pbWVUeXBlCiAgICAgICAgKTsKICAgICAgY2FzZSAianNvbiI6CiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlRGF0YVVyaVRleHQoaXNCYXNlNjQsIGRhdGEpKTsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdChgVW5oYW5kbGVkIHJlc3BvbnNlVHlwZTogJHtyZXNwb25zZVR5cGV9YCk7CiAgICB9CiAgfQogIFJlc291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIG9wdGlvbnMgPSBkZWZhdWx0Q2xvbmUob3B0aW9ucywge30pOwogICAgb3B0aW9ucy5tZXRob2QgPSAiR0VUIjsKICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdChvcHRpb25zKTsKICB9OwogIFJlc291cmNlLmZldGNoID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2Uob3B0aW9ucyk7CiAgICByZXR1cm4gcmVzb3VyY2UuZmV0Y2goewogICAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMucmVzcG9uc2VUeXBlLAogICAgICBvdmVycmlkZU1pbWVUeXBlOiBvcHRpb25zLm92ZXJyaWRlTWltZVR5cGUKICAgIH0pOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIG9wdGlvbnMgPSBkZWZhdWx0Q2xvbmUob3B0aW9ucywge30pOwogICAgb3B0aW9ucy5tZXRob2QgPSAiREVMRVRFIjsKICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdChvcHRpb25zKTsKICB9OwogIFJlc291cmNlLmRlbGV0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFJlc291cmNlKG9wdGlvbnMpOwogICAgcmV0dXJuIHJlc291cmNlLmRlbGV0ZSh7CiAgICAgIHJlc3BvbnNlVHlwZTogb3B0aW9ucy5yZXNwb25zZVR5cGUsCiAgICAgIG92ZXJyaWRlTWltZVR5cGU6IG9wdGlvbnMub3ZlcnJpZGVNaW1lVHlwZSwKICAgICAgZGF0YTogb3B0aW9ucy5kYXRhCiAgICB9KTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRDbG9uZShvcHRpb25zLCB7fSk7CiAgICBvcHRpb25zLm1ldGhvZCA9ICJIRUFEIjsKICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdChvcHRpb25zKTsKICB9OwogIFJlc291cmNlLmhlYWQgPSBmdW5jdGlvbihvcHRpb25zKSB7CiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShvcHRpb25zKTsKICAgIHJldHVybiByZXNvdXJjZS5oZWFkKHsKICAgICAgcmVzcG9uc2VUeXBlOiBvcHRpb25zLnJlc3BvbnNlVHlwZSwKICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogb3B0aW9ucy5vdmVycmlkZU1pbWVUeXBlCiAgICB9KTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRDbG9uZShvcHRpb25zLCB7fSk7CiAgICBvcHRpb25zLm1ldGhvZCA9ICJPUFRJT05TIjsKICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdChvcHRpb25zKTsKICB9OwogIFJlc291cmNlLm9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7CiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShvcHRpb25zKTsKICAgIHJldHVybiByZXNvdXJjZS5vcHRpb25zKHsKICAgICAgcmVzcG9uc2VUeXBlOiBvcHRpb25zLnJlc3BvbnNlVHlwZSwKICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogb3B0aW9ucy5vdmVycmlkZU1pbWVUeXBlCiAgICB9KTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJkYXRhIiwgZGF0YSk7CiAgICBvcHRpb25zID0gZGVmYXVsdENsb25lKG9wdGlvbnMsIHt9KTsKICAgIG9wdGlvbnMubWV0aG9kID0gIlBPU1QiOwogICAgb3B0aW9ucy5kYXRhID0gZGF0YTsKICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdChvcHRpb25zKTsKICB9OwogIFJlc291cmNlLnBvc3QgPSBmdW5jdGlvbihvcHRpb25zKSB7CiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShvcHRpb25zKTsKICAgIHJldHVybiByZXNvdXJjZS5wb3N0KG9wdGlvbnMuZGF0YSwgewogICAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMucmVzcG9uc2VUeXBlLAogICAgICBvdmVycmlkZU1pbWVUeXBlOiBvcHRpb25zLm92ZXJyaWRlTWltZVR5cGUKICAgIH0pOwogIH07CiAgUmVzb3VyY2UucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiZGF0YSIsIGRhdGEpOwogICAgb3B0aW9ucyA9IGRlZmF1bHRDbG9uZShvcHRpb25zLCB7fSk7CiAgICBvcHRpb25zLm1ldGhvZCA9ICJQVVQiOwogICAgb3B0aW9ucy5kYXRhID0gZGF0YTsKICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdChvcHRpb25zKTsKICB9OwogIFJlc291cmNlLnB1dCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFJlc291cmNlKG9wdGlvbnMpOwogICAgcmV0dXJuIHJlc291cmNlLnB1dChvcHRpb25zLmRhdGEsIHsKICAgICAgcmVzcG9uc2VUeXBlOiBvcHRpb25zLnJlc3BvbnNlVHlwZSwKICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogb3B0aW9ucy5vdmVycmlkZU1pbWVUeXBlCiAgICB9KTsKICB9OwogIFJlc291cmNlLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiZGF0YSIsIGRhdGEpOwogICAgb3B0aW9ucyA9IGRlZmF1bHRDbG9uZShvcHRpb25zLCB7fSk7CiAgICBvcHRpb25zLm1ldGhvZCA9ICJQQVRDSCI7CiAgICBvcHRpb25zLmRhdGEgPSBkYXRhOwogICAgcmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KG9wdGlvbnMpOwogIH07CiAgUmVzb3VyY2UucGF0Y2ggPSBmdW5jdGlvbihvcHRpb25zKSB7CiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShvcHRpb25zKTsKICAgIHJldHVybiByZXNvdXJjZS5wYXRjaChvcHRpb25zLmRhdGEsIHsKICAgICAgcmVzcG9uc2VUeXBlOiBvcHRpb25zLnJlc3BvbnNlVHlwZSwKICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogb3B0aW9ucy5vdmVycmlkZU1pbWVUeXBlCiAgICB9KTsKICB9OwogIFJlc291cmNlLl9JbXBsZW1lbnRhdGlvbnMgPSB7fTsKICBSZXNvdXJjZS5fSW1wbGVtZW50YXRpb25zLmxvYWRJbWFnZUVsZW1lbnQgPSBmdW5jdGlvbih1cmwsIGNyb3NzT3JpZ2luLCBkZWZlcnJlZCkgewogICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsKICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkgewogICAgICBpZiAoaW1hZ2UubmF0dXJhbFdpZHRoID09PSAwICYmIGltYWdlLm5hdHVyYWxIZWlnaHQgPT09IDAgJiYgaW1hZ2Uud2lkdGggPT09IDAgJiYgaW1hZ2UuaGVpZ2h0ID09PSAwKSB7CiAgICAgICAgaW1hZ2Uud2lkdGggPSAzMDA7CiAgICAgICAgaW1hZ2UuaGVpZ2h0ID0gMTUwOwogICAgICB9CiAgICAgIGRlZmVycmVkLnJlc29sdmUoaW1hZ2UpOwogICAgfTsKICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7CiAgICAgIGRlZmVycmVkLnJlamVjdChlKTsKICAgIH07CiAgICBpZiAoY3Jvc3NPcmlnaW4pIHsKICAgICAgaWYgKFRydXN0ZWRTZXJ2ZXJzX2RlZmF1bHQuY29udGFpbnModXJsKSkgewogICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gInVzZS1jcmVkZW50aWFscyI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAiIjsKICAgICAgfQogICAgfQogICAgaW1hZ2Uuc3JjID0gdXJsOwogIH07CiAgUmVzb3VyY2UuX0ltcGxlbWVudGF0aW9ucy5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIGNyb3NzT3JpZ2luLCBkZWZlcnJlZCwgZmxpcFksIHNraXBDb2xvclNwYWNlQ29udmVyc2lvbiwgcHJlZmVySW1hZ2VCaXRtYXApIHsKICAgIGNvbnN0IHVybCA9IHJlcXVlc3QudXJsOwogICAgUmVzb3VyY2Uuc3VwcG9ydHNJbWFnZUJpdG1hcE9wdGlvbnMoKS50aGVuKGZ1bmN0aW9uKHN1cHBvcnRzSW1hZ2VCaXRtYXApIHsKICAgICAgaWYgKCEoc3VwcG9ydHNJbWFnZUJpdG1hcCAmJiBwcmVmZXJJbWFnZUJpdG1hcCkpIHsKICAgICAgICBSZXNvdXJjZS5fSW1wbGVtZW50YXRpb25zLmxvYWRJbWFnZUVsZW1lbnQodXJsLCBjcm9zc09yaWdpbiwgZGVmZXJyZWQpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBjb25zdCByZXNwb25zZVR5cGUgPSAiYmxvYiI7CiAgICAgIGNvbnN0IG1ldGhvZCA9ICJHRVQiOwogICAgICBjb25zdCB4aHJEZWZlcnJlZCA9IGRlZmVyX2RlZmF1bHQoKTsKICAgICAgY29uc3QgeGhyID0gUmVzb3VyY2UuX0ltcGxlbWVudGF0aW9ucy5sb2FkV2l0aFhocigKICAgICAgICB1cmwsCiAgICAgICAgcmVzcG9uc2VUeXBlLAogICAgICAgIG1ldGhvZCwKICAgICAgICB2b2lkIDAsCiAgICAgICAgdm9pZCAwLAogICAgICAgIHhockRlZmVycmVkLAogICAgICAgIHZvaWQgMCwKICAgICAgICB2b2lkIDAsCiAgICAgICAgdm9pZCAwCiAgICAgICk7CiAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoeGhyKSAmJiBkZWZpbmVkX2RlZmF1bHQoeGhyLmFib3J0KSkgewogICAgICAgIHJlcXVlc3QuY2FuY2VsRnVuY3Rpb24gPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHhoci5hYm9ydCgpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgcmV0dXJuIHhockRlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbihibG9iKSB7CiAgICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYmxvYikpIHsKICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgKICAgICAgICAgICAgbmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KAogICAgICAgICAgICAgIGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkICR7dXJsfSBidXQgaXQgY29udGFpbmVkIG5vIGNvbnRlbnQuYAogICAgICAgICAgICApCiAgICAgICAgICApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICByZXR1cm4gUmVzb3VyY2UuY3JlYXRlSW1hZ2VCaXRtYXBGcm9tQmxvYihibG9iLCB7CiAgICAgICAgICBmbGlwWSwKICAgICAgICAgIHByZW11bHRpcGx5QWxwaGE6IGZhbHNlLAogICAgICAgICAgc2tpcENvbG9yU3BhY2VDb252ZXJzaW9uCiAgICAgICAgfSk7CiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oaW1hZ2UpIHsKICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGltYWdlKTsKICAgICAgfSk7CiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7CiAgICAgIGRlZmVycmVkLnJlamVjdChlKTsKICAgIH0pOwogIH07CiAgUmVzb3VyY2UuY3JlYXRlSW1hZ2VCaXRtYXBGcm9tQmxvYiA9IGZ1bmN0aW9uKGJsb2IsIG9wdGlvbnMpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgib3B0aW9ucyIsIG9wdGlvbnMpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YuYm9vbCgib3B0aW9ucy5mbGlwWSIsIG9wdGlvbnMuZmxpcFkpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YuYm9vbCgib3B0aW9ucy5wcmVtdWx0aXBseUFscGhhIiwgb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLmJvb2woCiAgICAgICJvcHRpb25zLnNraXBDb2xvclNwYWNlQ29udmVyc2lvbiIsCiAgICAgIG9wdGlvbnMuc2tpcENvbG9yU3BhY2VDb252ZXJzaW9uCiAgICApOwogICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIHsKICAgICAgaW1hZ2VPcmllbnRhdGlvbjogb3B0aW9ucy5mbGlwWSA/ICJmbGlwWSIgOiAibm9uZSIsCiAgICAgIHByZW11bHRpcGx5QWxwaGE6IG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYSA/ICJwcmVtdWx0aXBseSIgOiAibm9uZSIsCiAgICAgIGNvbG9yU3BhY2VDb252ZXJzaW9uOiBvcHRpb25zLnNraXBDb2xvclNwYWNlQ29udmVyc2lvbiA/ICJub25lIiA6ICJkZWZhdWx0IgogICAgfSk7CiAgfTsKICBmdW5jdGlvbiBkZWNvZGVSZXNwb25zZShsb2FkV2l0aEh0dHBSZXNwb25zZSwgcmVzcG9uc2VUeXBlKSB7CiAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkgewogICAgICBjYXNlICJ0ZXh0IjoKICAgICAgICByZXR1cm4gbG9hZFdpdGhIdHRwUmVzcG9uc2UudG9TdHJpbmcoInV0ZjgiKTsKICAgICAgY2FzZSAianNvbiI6CiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UobG9hZFdpdGhIdHRwUmVzcG9uc2UudG9TdHJpbmcoInV0ZjgiKSk7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxvYWRXaXRoSHR0cFJlc3BvbnNlKS5idWZmZXI7CiAgICB9CiAgfQogIGZ1bmN0aW9uIGxvYWRXaXRoSHR0cFJlcXVlc3QodXJsLCByZXNwb25zZVR5cGUsIG1ldGhvZCwgZGF0YSwgaGVhZGVycywgZGVmZXJyZWQsIG92ZXJyaWRlTWltZVR5cGUpIHsKICAgIGxldCBVUkw7CiAgICBsZXQgemxpYjsKICAgIFByb21pc2UuYWxsKFtQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9fdG9FU00ocmVxdWlyZV91cmwoKSwgMSkpLCBpbXBvcnQoInpsaWIiKV0pLnRoZW4oKFt1cmxJbXBvcnQsIHpsaWJJbXBvcnRdKSA9PiB7CiAgICAgIFVSTCA9IHVybEltcG9ydC5wYXJzZSh1cmwpOwogICAgICB6bGliID0gemxpYkltcG9ydDsKICAgICAgcmV0dXJuIFVSTC5wcm90b2NvbCA9PT0gImh0dHBzOiIgPyBpbXBvcnQoImh0dHBzIikgOiBpbXBvcnQoImh0dHAiKTsKICAgIH0pLnRoZW4oKGh0dHApID0+IHsKICAgICAgY29uc3Qgb3B0aW9ucyA9IHsKICAgICAgICBwcm90b2NvbDogVVJMLnByb3RvY29sLAogICAgICAgIGhvc3RuYW1lOiBVUkwuaG9zdG5hbWUsCiAgICAgICAgcG9ydDogVVJMLnBvcnQsCiAgICAgICAgcGF0aDogVVJMLnBhdGgsCiAgICAgICAgcXVlcnk6IFVSTC5xdWVyeSwKICAgICAgICBtZXRob2QsCiAgICAgICAgaGVhZGVycwogICAgICB9OwogICAgICBodHRwLnJlcXVlc3Qob3B0aW9ucykub24oInJlc3BvbnNlIiwgZnVuY3Rpb24ocmVzKSB7CiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlcy5zdGF0dXNDb2RlID49IDMwMCkgewogICAgICAgICAgZGVmZXJyZWQucmVqZWN0KAogICAgICAgICAgICBuZXcgUmVxdWVzdEVycm9yRXZlbnRfZGVmYXVsdChyZXMuc3RhdHVzQ29kZSwgcmVzLCByZXMuaGVhZGVycykKICAgICAgICAgICk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGNvbnN0IGNodW5rQXJyYXkgPSBbXTsKICAgICAgICByZXMub24oImRhdGEiLCBmdW5jdGlvbihjaHVuaykgewogICAgICAgICAgY2h1bmtBcnJheS5wdXNoKGNodW5rKTsKICAgICAgICB9KTsKICAgICAgICByZXMub24oImVuZCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChjaHVua0FycmF5KTsKICAgICAgICAgIGlmIChyZXMuaGVhZGVyc1siY29udGVudC1lbmNvZGluZyJdID09PSAiZ3ppcCIpIHsKICAgICAgICAgICAgemxpYi5ndW56aXAocmVzdWx0LCBmdW5jdGlvbihlcnJvciwgcmVzdWx0VW56aXBwZWQpIHsKICAgICAgICAgICAgICBpZiAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgKICAgICAgICAgICAgICAgICAgbmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KCJFcnJvciBkZWNvbXByZXNzaW5nIHJlc3BvbnNlLiIpCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKAogICAgICAgICAgICAgICAgICBkZWNvZGVSZXNwb25zZShyZXN1bHRVbnppcHBlZCwgcmVzcG9uc2VUeXBlKQogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkZWNvZGVSZXNwb25zZShyZXN1bHQsIHJlc3BvbnNlVHlwZSkpOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9KS5vbigiZXJyb3IiLCBmdW5jdGlvbihlKSB7CiAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBSZXF1ZXN0RXJyb3JFdmVudF9kZWZhdWx0KCkpOwogICAgICB9KS5lbmQoKTsKICAgIH0pOwogIH0KICB2YXIgbm9YTUxIdHRwUmVxdWVzdCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gInVuZGVmaW5lZCI7CiAgUmVzb3VyY2UuX0ltcGxlbWVudGF0aW9ucy5sb2FkV2l0aFhociA9IGZ1bmN0aW9uKHVybCwgcmVzcG9uc2VUeXBlLCBtZXRob2QsIGRhdGEsIGhlYWRlcnMsIGRlZmVycmVkLCBvdmVycmlkZU1pbWVUeXBlKSB7CiAgICBjb25zdCBkYXRhVXJpUmVnZXhSZXN1bHQgPSBkYXRhVXJpUmVnZXgyLmV4ZWModXJsKTsKICAgIGlmIChkYXRhVXJpUmVnZXhSZXN1bHQgIT09IG51bGwpIHsKICAgICAgZGVmZXJyZWQucmVzb2x2ZShkZWNvZGVEYXRhVXJpKGRhdGFVcmlSZWdleFJlc3VsdCwgcmVzcG9uc2VUeXBlKSk7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmIChub1hNTEh0dHBSZXF1ZXN0KSB7CiAgICAgIGxvYWRXaXRoSHR0cFJlcXVlc3QoCiAgICAgICAgdXJsLAogICAgICAgIHJlc3BvbnNlVHlwZSwKICAgICAgICBtZXRob2QsCiAgICAgICAgZGF0YSwKICAgICAgICBoZWFkZXJzLAogICAgICAgIGRlZmVycmVkLAogICAgICAgIG92ZXJyaWRlTWltZVR5cGUKICAgICAgKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICBpZiAoVHJ1c3RlZFNlcnZlcnNfZGVmYXVsdC5jb250YWlucyh1cmwpKSB7CiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlOwogICAgfQogICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChvdmVycmlkZU1pbWVUeXBlKSAmJiBkZWZpbmVkX2RlZmF1bHQoeGhyLm92ZXJyaWRlTWltZVR5cGUpKSB7CiAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG92ZXJyaWRlTWltZVR5cGUpOwogICAgfQogICAgaWYgKGRlZmluZWRfZGVmYXVsdChoZWFkZXJzKSkgewogICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7CiAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkgewogICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYgKGRlZmluZWRfZGVmYXVsdChyZXNwb25zZVR5cGUpKSB7CiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7CiAgICB9CiAgICBsZXQgbG9jYWxGaWxlID0gZmFsc2U7CiAgICBpZiAodHlwZW9mIHVybCA9PT0gInN0cmluZyIpIHsKICAgICAgbG9jYWxGaWxlID0gdXJsLmluZGV4T2YoImZpbGU6Ly8iKSA9PT0gMCB8fCB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiAmJiB3aW5kb3cubG9jYXRpb24ub3JpZ2luID09PSAiZmlsZTovLyI7CiAgICB9CiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7CiAgICAgIGlmICgoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID49IDMwMCkgJiYgIShsb2NhbEZpbGUgJiYgeGhyLnN0YXR1cyA9PT0gMCkpIHsKICAgICAgICBkZWZlcnJlZC5yZWplY3QoCiAgICAgICAgICBuZXcgUmVxdWVzdEVycm9yRXZlbnRfZGVmYXVsdCgKICAgICAgICAgICAgeGhyLnN0YXR1cywKICAgICAgICAgICAgeGhyLnJlc3BvbnNlLAogICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkKICAgICAgICAgICkKICAgICAgICApOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBjb25zdCByZXNwb25zZSA9IHhoci5yZXNwb25zZTsKICAgICAgY29uc3QgYnJvd3NlclJlc3BvbnNlVHlwZSA9IHhoci5yZXNwb25zZVR5cGU7CiAgICAgIGlmIChtZXRob2QgPT09ICJIRUFEIiB8fCBtZXRob2QgPT09ICJPUFRJT05TIikgewogICAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVyU3RyaW5nID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpOwogICAgICAgIGNvbnN0IHNwbGl0SGVhZGVycyA9IHJlc3BvbnNlSGVhZGVyU3RyaW5nLnRyaW0oKS5zcGxpdCgvW1xyXG5dKy8pOwogICAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IHt9OwogICAgICAgIHNwbGl0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHsKICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgiOiAiKTsKICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHBhcnRzLnNoaWZ0KCk7CiAgICAgICAgICByZXNwb25zZUhlYWRlcnNbaGVhZGVyXSA9IHBhcnRzLmpvaW4oIjogIik7CiAgICAgICAgfSk7CiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXNwb25zZUhlYWRlcnMpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjA0KSB7CiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpOwogICAgICB9IGVsc2UgaWYgKGRlZmluZWRfZGVmYXVsdChyZXNwb25zZSkgJiYgKCFkZWZpbmVkX2RlZmF1bHQocmVzcG9uc2VUeXBlKSB8fCBicm93c2VyUmVzcG9uc2VUeXBlID09PSByZXNwb25zZVR5cGUpKSB7CiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXNwb25zZSk7CiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAianNvbiIgJiYgdHlwZW9mIHJlc3BvbnNlID09PSAic3RyaW5nIikgewogICAgICAgIHRyeSB7CiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKEpTT04ucGFyc2UocmVzcG9uc2UpKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKChicm93c2VyUmVzcG9uc2VUeXBlID09PSAiIiB8fCBicm93c2VyUmVzcG9uc2VUeXBlID09PSAiZG9jdW1lbnQiKSAmJiBkZWZpbmVkX2RlZmF1bHQoeGhyLnJlc3BvbnNlWE1MKSAmJiB4aHIucmVzcG9uc2VYTUwuaGFzQ2hpbGROb2RlcygpKSB7CiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh4aHIucmVzcG9uc2VYTUwpOwogICAgICB9IGVsc2UgaWYgKChicm93c2VyUmVzcG9uc2VUeXBlID09PSAiIiB8fCBicm93c2VyUmVzcG9uc2VUeXBlID09PSAidGV4dCIpICYmIGRlZmluZWRfZGVmYXVsdCh4aHIucmVzcG9uc2VUZXh0KSkgewogICAgICAgIGRlZmVycmVkLnJlc29sdmUoeGhyLnJlc3BvbnNlVGV4dCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVmZXJyZWQucmVqZWN0KAogICAgICAgICAgbmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KCJJbnZhbGlkIFhNTEh0dHBSZXF1ZXN0IHJlc3BvbnNlIHR5cGUuIikKICAgICAgICApOwogICAgICB9CiAgICB9OwogICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7CiAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgUmVxdWVzdEVycm9yRXZlbnRfZGVmYXVsdCgpKTsKICAgIH07CiAgICB4aHIuc2VuZChkYXRhKTsKICAgIHJldHVybiB4aHI7CiAgfTsKICBSZXNvdXJjZS5fSW1wbGVtZW50YXRpb25zLmxvYWRBbmRFeGVjdXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsLCBmdW5jdGlvbk5hbWUsIGRlZmVycmVkKSB7CiAgICByZXR1cm4gbG9hZEFuZEV4ZWN1dGVTY3JpcHRfZGVmYXVsdCh1cmwsIGZ1bmN0aW9uTmFtZSkuY2F0Y2goZnVuY3Rpb24oZSkgewogICAgICBkZWZlcnJlZC5yZWplY3QoZSk7CiAgICB9KTsKICB9OwogIFJlc291cmNlLl9EZWZhdWx0SW1wbGVtZW50YXRpb25zID0ge307CiAgUmVzb3VyY2UuX0RlZmF1bHRJbXBsZW1lbnRhdGlvbnMuY3JlYXRlSW1hZ2UgPSBSZXNvdXJjZS5fSW1wbGVtZW50YXRpb25zLmNyZWF0ZUltYWdlOwogIFJlc291cmNlLl9EZWZhdWx0SW1wbGVtZW50YXRpb25zLmxvYWRXaXRoWGhyID0gUmVzb3VyY2UuX0ltcGxlbWVudGF0aW9ucy5sb2FkV2l0aFhocjsKICBSZXNvdXJjZS5fRGVmYXVsdEltcGxlbWVudGF0aW9ucy5sb2FkQW5kRXhlY3V0ZVNjcmlwdCA9IFJlc291cmNlLl9JbXBsZW1lbnRhdGlvbnMubG9hZEFuZEV4ZWN1dGVTY3JpcHQ7CiAgUmVzb3VyY2UuREVGQVVMVCA9IE9iamVjdC5mcmVlemUoCiAgICBuZXcgUmVzb3VyY2UoewogICAgICB1cmw6IHR5cGVvZiBkb2N1bWVudCA9PT0gInVuZGVmaW5lZCIgPyAiIiA6IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYuc3BsaXQoIj8iKVswXQogICAgfSkKICApOwogIHZhciBSZXNvdXJjZV9kZWZhdWx0ID0gUmVzb3VyY2U7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9FYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVycy5qcwogIGZ1bmN0aW9uIEVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzKG9wdGlvbnMpIHsKICAgIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLCBkZWZhdWx0VmFsdWVfZGVmYXVsdC5FTVBUWV9PQkpFQ1QpOwogICAgdGhpcy5fZGF0ZXMgPSB2b2lkIDA7CiAgICB0aGlzLl9zYW1wbGVzID0gdm9pZCAwOwogICAgdGhpcy5fZGF0ZUNvbHVtbiA9IC0xOwogICAgdGhpcy5feFBvbGVXYW5kZXJSYWRpYW5zQ29sdW1uID0gLTE7CiAgICB0aGlzLl95UG9sZVdhbmRlclJhZGlhbnNDb2x1bW4gPSAtMTsKICAgIHRoaXMuX3V0MU1pbnVzVXRjU2Vjb25kc0NvbHVtbiA9IC0xOwogICAgdGhpcy5feENlbGVzdGlhbFBvbGVPZmZzZXRSYWRpYW5zQ29sdW1uID0gLTE7CiAgICB0aGlzLl95Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnNDb2x1bW4gPSAtMTsKICAgIHRoaXMuX3RhaU1pbnVzVXRjU2Vjb25kc0NvbHVtbiA9IC0xOwogICAgdGhpcy5fY29sdW1uQ291bnQgPSAwOwogICAgdGhpcy5fbGFzdEluZGV4ID0gLTE7CiAgICB0aGlzLl9kb3dubG9hZFByb21pc2UgPSB2b2lkIDA7CiAgICB0aGlzLl9kYXRhRXJyb3IgPSB2b2lkIDA7CiAgICB0aGlzLl9hZGROZXdMZWFwU2Vjb25kcyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMuYWRkTmV3TGVhcFNlY29uZHMsIHRydWUpOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChvcHRpb25zLmRhdGEpKSB7CiAgICAgIG9uRGF0YVJlYWR5KHRoaXMsIG9wdGlvbnMuZGF0YSk7CiAgICB9IGVsc2UgaWYgKGRlZmluZWRfZGVmYXVsdChvcHRpb25zLnVybCkpIHsKICAgICAgY29uc3QgcmVzb3VyY2UgPSBSZXNvdXJjZV9kZWZhdWx0LmNyZWF0ZUlmTmVlZGVkKG9wdGlvbnMudXJsKTsKICAgICAgY29uc3QgdGhhdCA9IHRoaXM7CiAgICAgIHRoaXMuX2Rvd25sb2FkUHJvbWlzZSA9IHJlc291cmNlLmZldGNoSnNvbigpLnRoZW4oZnVuY3Rpb24oZW9wRGF0YSkgewogICAgICAgIG9uRGF0YVJlYWR5KHRoYXQsIGVvcERhdGEpOwogICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHsKICAgICAgICB0aGF0Ll9kYXRhRXJyb3IgPSBgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmV0cmlldmluZyB0aGUgRU9QIGRhdGEgZnJvbSB0aGUgVVJMICR7cmVzb3VyY2UudXJsfS5gOwogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIG9uRGF0YVJlYWR5KHRoaXMsIHsKICAgICAgICBjb2x1bW5OYW1lczogWwogICAgICAgICAgImRhdGVJc284NjAxIiwKICAgICAgICAgICJtb2RpZmllZEp1bGlhbkRhdGVVdGMiLAogICAgICAgICAgInhQb2xlV2FuZGVyUmFkaWFucyIsCiAgICAgICAgICAieVBvbGVXYW5kZXJSYWRpYW5zIiwKICAgICAgICAgICJ1dDFNaW51c1V0Y1NlY29uZHMiLAogICAgICAgICAgImxlbmd0aE9mRGF5Q29ycmVjdGlvblNlY29uZHMiLAogICAgICAgICAgInhDZWxlc3RpYWxQb2xlT2Zmc2V0UmFkaWFucyIsCiAgICAgICAgICAieUNlbGVzdGlhbFBvbGVPZmZzZXRSYWRpYW5zIiwKICAgICAgICAgICJ0YWlNaW51c1V0Y1NlY29uZHMiCiAgICAgICAgXSwKICAgICAgICBzYW1wbGVzOiBbXQogICAgICB9KTsKICAgIH0KICB9CiAgRWFydGhPcmllbnRhdGlvblBhcmFtZXRlcnMuTk9ORSA9IE9iamVjdC5mcmVlemUoewogICAgZ2V0UHJvbWlzZVRvTG9hZDogZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsKICAgIH0sCiAgICBjb21wdXRlOiBmdW5jdGlvbihkYXRlLCByZXN1bHQpIHsKICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICAgIHJlc3VsdCA9IG5ldyBFYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVyc1NhbXBsZV9kZWZhdWx0KDAsIDAsIDAsIDAsIDApOwogICAgICB9IGVsc2UgewogICAgICAgIHJlc3VsdC54UG9sZVdhbmRlciA9IDA7CiAgICAgICAgcmVzdWx0LnlQb2xlV2FuZGVyID0gMDsKICAgICAgICByZXN1bHQueFBvbGVPZmZzZXQgPSAwOwogICAgICAgIHJlc3VsdC55UG9sZU9mZnNldCA9IDA7CiAgICAgICAgcmVzdWx0LnV0MU1pbnVzVXRjID0gMDsKICAgICAgfQogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogIH0pOwogIEVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRQcm9taXNlVG9Mb2FkID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2Rvd25sb2FkUHJvbWlzZSk7CiAgfTsKICBFYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVycy5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKGRhdGUsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpcy5fc2FtcGxlcykpIHsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdCh0aGlzLl9kYXRhRXJyb3IpKSB7CiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KHRoaXMuX2RhdGFFcnJvcik7CiAgICAgIH0KICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzU2FtcGxlX2RlZmF1bHQoMCwgMCwgMCwgMCwgMCk7CiAgICB9CiAgICBpZiAodGhpcy5fc2FtcGxlcy5sZW5ndGggPT09IDApIHsKICAgICAgcmVzdWx0LnhQb2xlV2FuZGVyID0gMDsKICAgICAgcmVzdWx0LnlQb2xlV2FuZGVyID0gMDsKICAgICAgcmVzdWx0LnhQb2xlT2Zmc2V0ID0gMDsKICAgICAgcmVzdWx0LnlQb2xlT2Zmc2V0ID0gMDsKICAgICAgcmVzdWx0LnV0MU1pbnVzVXRjID0gMDsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIGNvbnN0IGRhdGVzID0gdGhpcy5fZGF0ZXM7CiAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLl9sYXN0SW5kZXg7CiAgICBsZXQgYmVmb3JlID0gMDsKICAgIGxldCBhZnRlciA9IDA7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KGxhc3RJbmRleCkpIHsKICAgICAgY29uc3QgcHJldmlvdXNJbmRleERhdGUgPSBkYXRlc1tsYXN0SW5kZXhdOwogICAgICBjb25zdCBuZXh0SW5kZXhEYXRlID0gZGF0ZXNbbGFzdEluZGV4ICsgMV07CiAgICAgIGNvbnN0IGlzQWZ0ZXJQcmV2aW91cyA9IEp1bGlhbkRhdGVfZGVmYXVsdC5sZXNzVGhhbk9yRXF1YWxzKAogICAgICAgIHByZXZpb3VzSW5kZXhEYXRlLAogICAgICAgIGRhdGUKICAgICAgKTsKICAgICAgY29uc3QgaXNBZnRlckxhc3RTYW1wbGUgPSAhZGVmaW5lZF9kZWZhdWx0KG5leHRJbmRleERhdGUpOwogICAgICBjb25zdCBpc0JlZm9yZU5leHQgPSBpc0FmdGVyTGFzdFNhbXBsZSB8fCBKdWxpYW5EYXRlX2RlZmF1bHQuZ3JlYXRlclRoYW5PckVxdWFscyhuZXh0SW5kZXhEYXRlLCBkYXRlKTsKICAgICAgaWYgKGlzQWZ0ZXJQcmV2aW91cyAmJiBpc0JlZm9yZU5leHQpIHsKICAgICAgICBiZWZvcmUgPSBsYXN0SW5kZXg7CiAgICAgICAgaWYgKCFpc0FmdGVyTGFzdFNhbXBsZSAmJiBuZXh0SW5kZXhEYXRlLmVxdWFscyhkYXRlKSkgewogICAgICAgICAgKytiZWZvcmU7CiAgICAgICAgfQogICAgICAgIGFmdGVyID0gYmVmb3JlICsgMTsKICAgICAgICBpbnRlcnBvbGF0ZSh0aGlzLCBkYXRlcywgdGhpcy5fc2FtcGxlcywgZGF0ZSwgYmVmb3JlLCBhZnRlciwgcmVzdWx0KTsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICB9CiAgICBsZXQgaW5kZXggPSBiaW5hcnlTZWFyY2hfZGVmYXVsdChkYXRlcywgZGF0ZSwgSnVsaWFuRGF0ZV9kZWZhdWx0LmNvbXBhcmUsIHRoaXMuX2RhdGVDb2x1bW4pOwogICAgaWYgKGluZGV4ID49IDApIHsKICAgICAgaWYgKGluZGV4IDwgZGF0ZXMubGVuZ3RoIC0gMSAmJiBkYXRlc1tpbmRleCArIDFdLmVxdWFscyhkYXRlKSkgewogICAgICAgICsraW5kZXg7CiAgICAgIH0KICAgICAgYmVmb3JlID0gaW5kZXg7CiAgICAgIGFmdGVyID0gaW5kZXg7CiAgICB9IGVsc2UgewogICAgICBhZnRlciA9IH5pbmRleDsKICAgICAgYmVmb3JlID0gYWZ0ZXIgLSAxOwogICAgICBpZiAoYmVmb3JlIDwgMCkgewogICAgICAgIGJlZm9yZSA9IDA7CiAgICAgIH0KICAgIH0KICAgIHRoaXMuX2xhc3RJbmRleCA9IGJlZm9yZTsKICAgIGludGVycG9sYXRlKHRoaXMsIGRhdGVzLCB0aGlzLl9zYW1wbGVzLCBkYXRlLCBiZWZvcmUsIGFmdGVyLCByZXN1bHQpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIGZ1bmN0aW9uIGNvbXBhcmVMZWFwU2Vjb25kRGF0ZXMyKGxlYXBTZWNvbmQsIGRhdGVUb0ZpbmQpIHsKICAgIHJldHVybiBKdWxpYW5EYXRlX2RlZmF1bHQuY29tcGFyZShsZWFwU2Vjb25kLmp1bGlhbkRhdGUsIGRhdGVUb0ZpbmQpOwogIH0KICBmdW5jdGlvbiBvbkRhdGFSZWFkeShlb3AsIGVvcERhdGEpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGVvcERhdGEuY29sdW1uTmFtZXMpKSB7CiAgICAgIGVvcC5fZGF0YUVycm9yID0gIkVycm9yIGluIGxvYWRlZCBFT1AgZGF0YTogVGhlIGNvbHVtbk5hbWVzIHByb3BlcnR5IGlzIHJlcXVpcmVkLiI7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGVvcERhdGEuc2FtcGxlcykpIHsKICAgICAgZW9wLl9kYXRhRXJyb3IgPSAiRXJyb3IgaW4gbG9hZGVkIEVPUCBkYXRhOiBUaGUgc2FtcGxlcyBwcm9wZXJ0eSBpcyByZXF1aXJlZC4iOwogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCBkYXRlQ29sdW1uID0gZW9wRGF0YS5jb2x1bW5OYW1lcy5pbmRleE9mKCJtb2RpZmllZEp1bGlhbkRhdGVVdGMiKTsKICAgIGNvbnN0IHhQb2xlV2FuZGVyUmFkaWFuc0NvbHVtbiA9IGVvcERhdGEuY29sdW1uTmFtZXMuaW5kZXhPZigKICAgICAgInhQb2xlV2FuZGVyUmFkaWFucyIKICAgICk7CiAgICBjb25zdCB5UG9sZVdhbmRlclJhZGlhbnNDb2x1bW4gPSBlb3BEYXRhLmNvbHVtbk5hbWVzLmluZGV4T2YoCiAgICAgICJ5UG9sZVdhbmRlclJhZGlhbnMiCiAgICApOwogICAgY29uc3QgdXQxTWludXNVdGNTZWNvbmRzQ29sdW1uID0gZW9wRGF0YS5jb2x1bW5OYW1lcy5pbmRleE9mKAogICAgICAidXQxTWludXNVdGNTZWNvbmRzIgogICAgKTsKICAgIGNvbnN0IHhDZWxlc3RpYWxQb2xlT2Zmc2V0UmFkaWFuc0NvbHVtbiA9IGVvcERhdGEuY29sdW1uTmFtZXMuaW5kZXhPZigKICAgICAgInhDZWxlc3RpYWxQb2xlT2Zmc2V0UmFkaWFucyIKICAgICk7CiAgICBjb25zdCB5Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnNDb2x1bW4gPSBlb3BEYXRhLmNvbHVtbk5hbWVzLmluZGV4T2YoCiAgICAgICJ5Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnMiCiAgICApOwogICAgY29uc3QgdGFpTWludXNVdGNTZWNvbmRzQ29sdW1uID0gZW9wRGF0YS5jb2x1bW5OYW1lcy5pbmRleE9mKAogICAgICAidGFpTWludXNVdGNTZWNvbmRzIgogICAgKTsKICAgIGlmIChkYXRlQ29sdW1uIDwgMCB8fCB4UG9sZVdhbmRlclJhZGlhbnNDb2x1bW4gPCAwIHx8IHlQb2xlV2FuZGVyUmFkaWFuc0NvbHVtbiA8IDAgfHwgdXQxTWludXNVdGNTZWNvbmRzQ29sdW1uIDwgMCB8fCB4Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnNDb2x1bW4gPCAwIHx8IHlDZWxlc3RpYWxQb2xlT2Zmc2V0UmFkaWFuc0NvbHVtbiA8IDAgfHwgdGFpTWludXNVdGNTZWNvbmRzQ29sdW1uIDwgMCkgewogICAgICBlb3AuX2RhdGFFcnJvciA9ICJFcnJvciBpbiBsb2FkZWQgRU9QIGRhdGE6IFRoZSBjb2x1bW5OYW1lcyBwcm9wZXJ0eSBtdXN0IGluY2x1ZGUgbW9kaWZpZWRKdWxpYW5EYXRlVXRjLCB4UG9sZVdhbmRlclJhZGlhbnMsIHlQb2xlV2FuZGVyUmFkaWFucywgdXQxTWludXNVdGNTZWNvbmRzLCB4Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnMsIHlDZWxlc3RpYWxQb2xlT2Zmc2V0UmFkaWFucywgYW5kIHRhaU1pbnVzVXRjU2Vjb25kcyBjb2x1bW5zIjsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3Qgc2FtcGxlcyA9IGVvcC5fc2FtcGxlcyA9IGVvcERhdGEuc2FtcGxlczsKICAgIGNvbnN0IGRhdGVzID0gZW9wLl9kYXRlcyA9IFtdOwogICAgZW9wLl9kYXRlQ29sdW1uID0gZGF0ZUNvbHVtbjsKICAgIGVvcC5feFBvbGVXYW5kZXJSYWRpYW5zQ29sdW1uID0geFBvbGVXYW5kZXJSYWRpYW5zQ29sdW1uOwogICAgZW9wLl95UG9sZVdhbmRlclJhZGlhbnNDb2x1bW4gPSB5UG9sZVdhbmRlclJhZGlhbnNDb2x1bW47CiAgICBlb3AuX3V0MU1pbnVzVXRjU2Vjb25kc0NvbHVtbiA9IHV0MU1pbnVzVXRjU2Vjb25kc0NvbHVtbjsKICAgIGVvcC5feENlbGVzdGlhbFBvbGVPZmZzZXRSYWRpYW5zQ29sdW1uID0geENlbGVzdGlhbFBvbGVPZmZzZXRSYWRpYW5zQ29sdW1uOwogICAgZW9wLl95Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnNDb2x1bW4gPSB5Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnNDb2x1bW47CiAgICBlb3AuX3RhaU1pbnVzVXRjU2Vjb25kc0NvbHVtbiA9IHRhaU1pbnVzVXRjU2Vjb25kc0NvbHVtbjsKICAgIGVvcC5fY29sdW1uQ291bnQgPSBlb3BEYXRhLmNvbHVtbk5hbWVzLmxlbmd0aDsKICAgIGVvcC5fbGFzdEluZGV4ID0gdm9pZCAwOwogICAgbGV0IGxhc3RUYWlNaW51c1V0YzsKICAgIGNvbnN0IGFkZE5ld0xlYXBTZWNvbmRzID0gZW9wLl9hZGROZXdMZWFwU2Vjb25kczsKICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzYW1wbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSBlb3AuX2NvbHVtbkNvdW50KSB7CiAgICAgIGNvbnN0IG1qZCA9IHNhbXBsZXNbaSArIGRhdGVDb2x1bW5dOwogICAgICBjb25zdCB0YWlNaW51c1V0YyA9IHNhbXBsZXNbaSArIHRhaU1pbnVzVXRjU2Vjb25kc0NvbHVtbl07CiAgICAgIGNvbnN0IGRheSA9IG1qZCArIFRpbWVDb25zdGFudHNfZGVmYXVsdC5NT0RJRklFRF9KVUxJQU5fREFURV9ESUZGRVJFTkNFOwogICAgICBjb25zdCBkYXRlID0gbmV3IEp1bGlhbkRhdGVfZGVmYXVsdChkYXksIHRhaU1pbnVzVXRjLCBUaW1lU3RhbmRhcmRfZGVmYXVsdC5UQUkpOwogICAgICBkYXRlcy5wdXNoKGRhdGUpOwogICAgICBpZiAoYWRkTmV3TGVhcFNlY29uZHMpIHsKICAgICAgICBpZiAodGFpTWludXNVdGMgIT09IGxhc3RUYWlNaW51c1V0YyAmJiBkZWZpbmVkX2RlZmF1bHQobGFzdFRhaU1pbnVzVXRjKSkgewogICAgICAgICAgY29uc3QgbGVhcFNlY29uZHMgPSBKdWxpYW5EYXRlX2RlZmF1bHQubGVhcFNlY29uZHM7CiAgICAgICAgICBjb25zdCBsZWFwU2Vjb25kSW5kZXggPSBiaW5hcnlTZWFyY2hfZGVmYXVsdCgKICAgICAgICAgICAgbGVhcFNlY29uZHMsCiAgICAgICAgICAgIGRhdGUsCiAgICAgICAgICAgIGNvbXBhcmVMZWFwU2Vjb25kRGF0ZXMyCiAgICAgICAgICApOwogICAgICAgICAgaWYgKGxlYXBTZWNvbmRJbmRleCA8IDApIHsKICAgICAgICAgICAgY29uc3QgbGVhcFNlY29uZCA9IG5ldyBMZWFwU2Vjb25kX2RlZmF1bHQoZGF0ZSwgdGFpTWludXNVdGMpOwogICAgICAgICAgICBsZWFwU2Vjb25kcy5zcGxpY2UofmxlYXBTZWNvbmRJbmRleCwgMCwgbGVhcFNlY29uZCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGxhc3RUYWlNaW51c1V0YyA9IHRhaU1pbnVzVXRjOwogICAgICB9CiAgICB9CiAgfQogIGZ1bmN0aW9uIGZpbGxSZXN1bHRGcm9tSW5kZXgoZW9wLCBzYW1wbGVzLCBpbmRleCwgY29sdW1uQ291bnQsIHJlc3VsdCkgewogICAgY29uc3Qgc3RhcnQgPSBpbmRleCAqIGNvbHVtbkNvdW50OwogICAgcmVzdWx0LnhQb2xlV2FuZGVyID0gc2FtcGxlc1tzdGFydCArIGVvcC5feFBvbGVXYW5kZXJSYWRpYW5zQ29sdW1uXTsKICAgIHJlc3VsdC55UG9sZVdhbmRlciA9IHNhbXBsZXNbc3RhcnQgKyBlb3AuX3lQb2xlV2FuZGVyUmFkaWFuc0NvbHVtbl07CiAgICByZXN1bHQueFBvbGVPZmZzZXQgPSBzYW1wbGVzW3N0YXJ0ICsgZW9wLl94Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnNDb2x1bW5dOwogICAgcmVzdWx0LnlQb2xlT2Zmc2V0ID0gc2FtcGxlc1tzdGFydCArIGVvcC5feUNlbGVzdGlhbFBvbGVPZmZzZXRSYWRpYW5zQ29sdW1uXTsKICAgIHJlc3VsdC51dDFNaW51c1V0YyA9IHNhbXBsZXNbc3RhcnQgKyBlb3AuX3V0MU1pbnVzVXRjU2Vjb25kc0NvbHVtbl07CiAgfQogIGZ1bmN0aW9uIGxpbmVhckludGVycChkeCwgeTEsIHkyKSB7CiAgICByZXR1cm4geTEgKyBkeCAqICh5MiAtIHkxKTsKICB9CiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZW9wLCBkYXRlcywgc2FtcGxlcywgZGF0ZSwgYmVmb3JlLCBhZnRlciwgcmVzdWx0KSB7CiAgICBjb25zdCBjb2x1bW5Db3VudCA9IGVvcC5fY29sdW1uQ291bnQ7CiAgICBpZiAoYWZ0ZXIgPiBkYXRlcy5sZW5ndGggLSAxKSB7CiAgICAgIHJlc3VsdC54UG9sZVdhbmRlciA9IDA7CiAgICAgIHJlc3VsdC55UG9sZVdhbmRlciA9IDA7CiAgICAgIHJlc3VsdC54UG9sZU9mZnNldCA9IDA7CiAgICAgIHJlc3VsdC55UG9sZU9mZnNldCA9IDA7CiAgICAgIHJlc3VsdC51dDFNaW51c1V0YyA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBjb25zdCBiZWZvcmVEYXRlID0gZGF0ZXNbYmVmb3JlXTsKICAgIGNvbnN0IGFmdGVyRGF0ZSA9IGRhdGVzW2FmdGVyXTsKICAgIGlmIChiZWZvcmVEYXRlLmVxdWFscyhhZnRlckRhdGUpIHx8IGRhdGUuZXF1YWxzKGJlZm9yZURhdGUpKSB7CiAgICAgIGZpbGxSZXN1bHRGcm9tSW5kZXgoZW9wLCBzYW1wbGVzLCBiZWZvcmUsIGNvbHVtbkNvdW50LCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfSBlbHNlIGlmIChkYXRlLmVxdWFscyhhZnRlckRhdGUpKSB7CiAgICAgIGZpbGxSZXN1bHRGcm9tSW5kZXgoZW9wLCBzYW1wbGVzLCBhZnRlciwgY29sdW1uQ291bnQsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBjb25zdCBmYWN0b3IgPSBKdWxpYW5EYXRlX2RlZmF1bHQuc2Vjb25kc0RpZmZlcmVuY2UoZGF0ZSwgYmVmb3JlRGF0ZSkgLyBKdWxpYW5EYXRlX2RlZmF1bHQuc2Vjb25kc0RpZmZlcmVuY2UoYWZ0ZXJEYXRlLCBiZWZvcmVEYXRlKTsKICAgIGNvbnN0IHN0YXJ0QmVmb3JlID0gYmVmb3JlICogY29sdW1uQ291bnQ7CiAgICBjb25zdCBzdGFydEFmdGVyID0gYWZ0ZXIgKiBjb2x1bW5Db3VudDsKICAgIGxldCBiZWZvcmVVdDFNaW51c1V0YyA9IHNhbXBsZXNbc3RhcnRCZWZvcmUgKyBlb3AuX3V0MU1pbnVzVXRjU2Vjb25kc0NvbHVtbl07CiAgICBsZXQgYWZ0ZXJVdDFNaW51c1V0YyA9IHNhbXBsZXNbc3RhcnRBZnRlciArIGVvcC5fdXQxTWludXNVdGNTZWNvbmRzQ29sdW1uXTsKICAgIGNvbnN0IG9mZnNldERpZmZlcmVuY2UgPSBhZnRlclV0MU1pbnVzVXRjIC0gYmVmb3JlVXQxTWludXNVdGM7CiAgICBpZiAob2Zmc2V0RGlmZmVyZW5jZSA+IDAuNSB8fCBvZmZzZXREaWZmZXJlbmNlIDwgLTAuNSkgewogICAgICBjb25zdCBiZWZvcmVUYWlNaW51c1V0YyA9IHNhbXBsZXNbc3RhcnRCZWZvcmUgKyBlb3AuX3RhaU1pbnVzVXRjU2Vjb25kc0NvbHVtbl07CiAgICAgIGNvbnN0IGFmdGVyVGFpTWludXNVdGMgPSBzYW1wbGVzW3N0YXJ0QWZ0ZXIgKyBlb3AuX3RhaU1pbnVzVXRjU2Vjb25kc0NvbHVtbl07CiAgICAgIGlmIChiZWZvcmVUYWlNaW51c1V0YyAhPT0gYWZ0ZXJUYWlNaW51c1V0YykgewogICAgICAgIGlmIChhZnRlckRhdGUuZXF1YWxzKGRhdGUpKSB7CiAgICAgICAgICBiZWZvcmVVdDFNaW51c1V0YyA9IGFmdGVyVXQxTWludXNVdGM7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFmdGVyVXQxTWludXNVdGMgLT0gYWZ0ZXJUYWlNaW51c1V0YyAtIGJlZm9yZVRhaU1pbnVzVXRjOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmVzdWx0LnhQb2xlV2FuZGVyID0gbGluZWFySW50ZXJwKAogICAgICBmYWN0b3IsCiAgICAgIHNhbXBsZXNbc3RhcnRCZWZvcmUgKyBlb3AuX3hQb2xlV2FuZGVyUmFkaWFuc0NvbHVtbl0sCiAgICAgIHNhbXBsZXNbc3RhcnRBZnRlciArIGVvcC5feFBvbGVXYW5kZXJSYWRpYW5zQ29sdW1uXQogICAgKTsKICAgIHJlc3VsdC55UG9sZVdhbmRlciA9IGxpbmVhckludGVycCgKICAgICAgZmFjdG9yLAogICAgICBzYW1wbGVzW3N0YXJ0QmVmb3JlICsgZW9wLl95UG9sZVdhbmRlclJhZGlhbnNDb2x1bW5dLAogICAgICBzYW1wbGVzW3N0YXJ0QWZ0ZXIgKyBlb3AuX3lQb2xlV2FuZGVyUmFkaWFuc0NvbHVtbl0KICAgICk7CiAgICByZXN1bHQueFBvbGVPZmZzZXQgPSBsaW5lYXJJbnRlcnAoCiAgICAgIGZhY3RvciwKICAgICAgc2FtcGxlc1tzdGFydEJlZm9yZSArIGVvcC5feENlbGVzdGlhbFBvbGVPZmZzZXRSYWRpYW5zQ29sdW1uXSwKICAgICAgc2FtcGxlc1tzdGFydEFmdGVyICsgZW9wLl94Q2VsZXN0aWFsUG9sZU9mZnNldFJhZGlhbnNDb2x1bW5dCiAgICApOwogICAgcmVzdWx0LnlQb2xlT2Zmc2V0ID0gbGluZWFySW50ZXJwKAogICAgICBmYWN0b3IsCiAgICAgIHNhbXBsZXNbc3RhcnRCZWZvcmUgKyBlb3AuX3lDZWxlc3RpYWxQb2xlT2Zmc2V0UmFkaWFuc0NvbHVtbl0sCiAgICAgIHNhbXBsZXNbc3RhcnRBZnRlciArIGVvcC5feUNlbGVzdGlhbFBvbGVPZmZzZXRSYWRpYW5zQ29sdW1uXQogICAgKTsKICAgIHJlc3VsdC51dDFNaW51c1V0YyA9IGxpbmVhckludGVycCgKICAgICAgZmFjdG9yLAogICAgICBiZWZvcmVVdDFNaW51c1V0YywKICAgICAgYWZ0ZXJVdDFNaW51c1V0YwogICAgKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBFYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVyc19kZWZhdWx0ID0gRWFydGhPcmllbnRhdGlvblBhcmFtZXRlcnM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9IZWFkaW5nUGl0Y2hSb2xsLmpzCiAgZnVuY3Rpb24gSGVhZGluZ1BpdGNoUm9sbChoZWFkaW5nLCBwaXRjaCwgcm9sbCkgewogICAgdGhpcy5oZWFkaW5nID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoaGVhZGluZywgMCk7CiAgICB0aGlzLnBpdGNoID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQocGl0Y2gsIDApOwogICAgdGhpcy5yb2xsID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQocm9sbCwgMCk7CiAgfQogIEhlYWRpbmdQaXRjaFJvbGwuZnJvbVF1YXRlcm5pb24gPSBmdW5jdGlvbihxdWF0ZXJuaW9uLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHF1YXRlcm5pb24pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJxdWF0ZXJuaW9uIGlzIHJlcXVpcmVkIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBIZWFkaW5nUGl0Y2hSb2xsKCk7CiAgICB9CiAgICBjb25zdCB0ZXN0ID0gMiAqIChxdWF0ZXJuaW9uLncgKiBxdWF0ZXJuaW9uLnkgLSBxdWF0ZXJuaW9uLnogKiBxdWF0ZXJuaW9uLngpOwogICAgY29uc3QgZGVub21pbmF0b3JSb2xsID0gMSAtIDIgKiAocXVhdGVybmlvbi54ICogcXVhdGVybmlvbi54ICsgcXVhdGVybmlvbi55ICogcXVhdGVybmlvbi55KTsKICAgIGNvbnN0IG51bWVyYXRvclJvbGwgPSAyICogKHF1YXRlcm5pb24udyAqIHF1YXRlcm5pb24ueCArIHF1YXRlcm5pb24ueSAqIHF1YXRlcm5pb24ueik7CiAgICBjb25zdCBkZW5vbWluYXRvckhlYWRpbmcgPSAxIC0gMiAqIChxdWF0ZXJuaW9uLnkgKiBxdWF0ZXJuaW9uLnkgKyBxdWF0ZXJuaW9uLnogKiBxdWF0ZXJuaW9uLnopOwogICAgY29uc3QgbnVtZXJhdG9ySGVhZGluZyA9IDIgKiAocXVhdGVybmlvbi53ICogcXVhdGVybmlvbi56ICsgcXVhdGVybmlvbi54ICogcXVhdGVybmlvbi55KTsKICAgIHJlc3VsdC5oZWFkaW5nID0gLU1hdGguYXRhbjIobnVtZXJhdG9ySGVhZGluZywgZGVub21pbmF0b3JIZWFkaW5nKTsKICAgIHJlc3VsdC5yb2xsID0gTWF0aC5hdGFuMihudW1lcmF0b3JSb2xsLCBkZW5vbWluYXRvclJvbGwpOwogICAgcmVzdWx0LnBpdGNoID0gLU1hdGhfZGVmYXVsdC5hc2luQ2xhbXBlZCh0ZXN0KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBIZWFkaW5nUGl0Y2hSb2xsLmZyb21EZWdyZWVzID0gZnVuY3Rpb24oaGVhZGluZywgcGl0Y2gsIHJvbGwsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaGVhZGluZykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImhlYWRpbmcgaXMgcmVxdWlyZWQiKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBpdGNoKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicGl0Y2ggaXMgcmVxdWlyZWQiKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJvbGwpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJyb2xsIGlzIHJlcXVpcmVkIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBIZWFkaW5nUGl0Y2hSb2xsKCk7CiAgICB9CiAgICByZXN1bHQuaGVhZGluZyA9IGhlYWRpbmcgKiBNYXRoX2RlZmF1bHQuUkFESUFOU19QRVJfREVHUkVFOwogICAgcmVzdWx0LnBpdGNoID0gcGl0Y2ggKiBNYXRoX2RlZmF1bHQuUkFESUFOU19QRVJfREVHUkVFOwogICAgcmVzdWx0LnJvbGwgPSByb2xsICogTWF0aF9kZWZhdWx0LlJBRElBTlNfUEVSX0RFR1JFRTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBIZWFkaW5nUGl0Y2hSb2xsLmNsb25lID0gZnVuY3Rpb24oaGVhZGluZ1BpdGNoUm9sbCwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChoZWFkaW5nUGl0Y2hSb2xsKSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IEhlYWRpbmdQaXRjaFJvbGwoCiAgICAgICAgaGVhZGluZ1BpdGNoUm9sbC5oZWFkaW5nLAogICAgICAgIGhlYWRpbmdQaXRjaFJvbGwucGl0Y2gsCiAgICAgICAgaGVhZGluZ1BpdGNoUm9sbC5yb2xsCiAgICAgICk7CiAgICB9CiAgICByZXN1bHQuaGVhZGluZyA9IGhlYWRpbmdQaXRjaFJvbGwuaGVhZGluZzsKICAgIHJlc3VsdC5waXRjaCA9IGhlYWRpbmdQaXRjaFJvbGwucGl0Y2g7CiAgICByZXN1bHQucm9sbCA9IGhlYWRpbmdQaXRjaFJvbGwucm9sbDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBIZWFkaW5nUGl0Y2hSb2xsLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgbGVmdC5oZWFkaW5nID09PSByaWdodC5oZWFkaW5nICYmIGxlZnQucGl0Y2ggPT09IHJpZ2h0LnBpdGNoICYmIGxlZnQucm9sbCA9PT0gcmlnaHQucm9sbDsKICB9OwogIEhlYWRpbmdQaXRjaFJvbGwuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZWxhdGl2ZUVwc2lsb24sIGFic29sdXRlRXBzaWxvbikgewogICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IGRlZmluZWRfZGVmYXVsdChsZWZ0KSAmJiBkZWZpbmVkX2RlZmF1bHQocmlnaHQpICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LmhlYWRpbmcsCiAgICAgIHJpZ2h0LmhlYWRpbmcsCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKAogICAgICBsZWZ0LnBpdGNoLAogICAgICByaWdodC5waXRjaCwKICAgICAgcmVsYXRpdmVFcHNpbG9uLAogICAgICBhYnNvbHV0ZUVwc2lsb24KICAgICkgJiYgTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIGxlZnQucm9sbCwKICAgICAgcmlnaHQucm9sbCwKICAgICAgcmVsYXRpdmVFcHNpbG9uLAogICAgICBhYnNvbHV0ZUVwc2lsb24KICAgICk7CiAgfTsKICBIZWFkaW5nUGl0Y2hSb2xsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkgewogICAgcmV0dXJuIEhlYWRpbmdQaXRjaFJvbGwuY2xvbmUodGhpcywgcmVzdWx0KTsKICB9OwogIEhlYWRpbmdQaXRjaFJvbGwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHJpZ2h0KSB7CiAgICByZXR1cm4gSGVhZGluZ1BpdGNoUm9sbC5lcXVhbHModGhpcywgcmlnaHQpOwogIH07CiAgSGVhZGluZ1BpdGNoUm9sbC5wcm90b3R5cGUuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uKHJpZ2h0LCByZWxhdGl2ZUVwc2lsb24sIGFic29sdXRlRXBzaWxvbikgewogICAgcmV0dXJuIEhlYWRpbmdQaXRjaFJvbGwuZXF1YWxzRXBzaWxvbigKICAgICAgdGhpcywKICAgICAgcmlnaHQsCiAgICAgIHJlbGF0aXZlRXBzaWxvbiwKICAgICAgYWJzb2x1dGVFcHNpbG9uCiAgICApOwogIH07CiAgSGVhZGluZ1BpdGNoUm9sbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiBgKCR7dGhpcy5oZWFkaW5nfSwgJHt0aGlzLnBpdGNofSwgJHt0aGlzLnJvbGx9KWA7CiAgfTsKICB2YXIgSGVhZGluZ1BpdGNoUm9sbF9kZWZhdWx0ID0gSGVhZGluZ1BpdGNoUm9sbDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2J1aWxkTW9kdWxlVXJsLmpzCiAgdmFyIGNlc2l1bVNjcmlwdFJlZ2V4ID0gLygoPzouKlwvKXxeKUNlc2l1bVwuanMoPzpcP3xcI3wkKS87CiAgZnVuY3Rpb24gZ2V0QmFzZVVybEZyb21DZXNpdW1TY3JpcHQoKSB7CiAgICBjb25zdCBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInNjcmlwdCIpOwogICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNjcmlwdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICAgICAgY29uc3Qgc3JjID0gc2NyaXB0c1tpXS5nZXRBdHRyaWJ1dGUoInNyYyIpOwogICAgICBjb25zdCByZXN1bHQgPSBjZXNpdW1TY3JpcHRSZWdleC5leGVjKHNyYyk7CiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHsKICAgICAgICByZXR1cm4gcmVzdWx0WzFdOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gdm9pZCAwOwogIH0KICB2YXIgYTI7CiAgZnVuY3Rpb24gdHJ5TWFrZUFic29sdXRlKHVybCkgewogICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gInVuZGVmaW5lZCIpIHsKICAgICAgcmV0dXJuIHVybDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGEyKSkgewogICAgICBhMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTsKICAgIH0KICAgIGEyLmhyZWYgPSB1cmw7CiAgICBhMi5ocmVmID0gYTIuaHJlZjsKICAgIHJldHVybiBhMi5ocmVmOwogIH0KICB2YXIgYmFzZVJlc291cmNlOwogIGZ1bmN0aW9uIGdldENlc2l1bUJhc2VVcmwoKSB7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KGJhc2VSZXNvdXJjZSkpIHsKICAgICAgcmV0dXJuIGJhc2VSZXNvdXJjZTsKICAgIH0KICAgIGxldCBiYXNlVXJsU3RyaW5nOwogICAgaWYgKHR5cGVvZiBDRVNJVU1fQkFTRV9VUkwgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgIGJhc2VVcmxTdHJpbmcgPSBDRVNJVU1fQkFTRV9VUkw7CiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICJvYmplY3QiICYmIGRlZmluZWRfZGVmYXVsdChkZWZpbmUuYW1kKSAmJiAhZGVmaW5lLmFtZC50b1VybFVuZGVmaW5lZCAmJiBkZWZpbmVkX2RlZmF1bHQoX19yZXF1aXJlLnRvVXJsKSkgewogICAgICBiYXNlVXJsU3RyaW5nID0gZ2V0QWJzb2x1dGVVcmlfZGVmYXVsdCgKICAgICAgICAiLi4iLAogICAgICAgIGJ1aWxkTW9kdWxlVXJsKCJDb3JlL2J1aWxkTW9kdWxlVXJsLmpzIikKICAgICAgKTsKICAgIH0gZWxzZSB7CiAgICAgIGJhc2VVcmxTdHJpbmcgPSBnZXRCYXNlVXJsRnJvbUNlc2l1bVNjcmlwdCgpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYmFzZVVybFN0cmluZykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgIlVuYWJsZSB0byBkZXRlcm1pbmUgQ2VzaXVtIGJhc2UgVVJMIGF1dG9tYXRpY2FsbHksIHRyeSBkZWZpbmluZyBhIGdsb2JhbCB2YXJpYWJsZSBjYWxsZWQgQ0VTSVVNX0JBU0VfVVJMLiIKICAgICAgKTsKICAgIH0KICAgIGJhc2VSZXNvdXJjZSA9IG5ldyBSZXNvdXJjZV9kZWZhdWx0KHsKICAgICAgdXJsOiB0cnlNYWtlQWJzb2x1dGUoYmFzZVVybFN0cmluZykKICAgIH0pOwogICAgYmFzZVJlc291cmNlLmFwcGVuZEZvcndhcmRTbGFzaCgpOwogICAgcmV0dXJuIGJhc2VSZXNvdXJjZTsKICB9CiAgZnVuY3Rpb24gYnVpbGRNb2R1bGVVcmxGcm9tUmVxdWlyZVRvVXJsKG1vZHVsZUlEKSB7CiAgICByZXR1cm4gdHJ5TWFrZUFic29sdXRlKF9fcmVxdWlyZS50b1VybChgLi4vJHttb2R1bGVJRH1gKSk7CiAgfQogIGZ1bmN0aW9uIGJ1aWxkTW9kdWxlVXJsRnJvbUJhc2VVcmwobW9kdWxlSUQpIHsKICAgIGNvbnN0IHJlc291cmNlID0gZ2V0Q2VzaXVtQmFzZVVybCgpLmdldERlcml2ZWRSZXNvdXJjZSh7CiAgICAgIHVybDogbW9kdWxlSUQKICAgIH0pOwogICAgcmV0dXJuIHJlc291cmNlLnVybDsKICB9CiAgdmFyIGltcGxlbWVudGF0aW9uOwogIGZ1bmN0aW9uIGJ1aWxkTW9kdWxlVXJsKHJlbGF0aXZlVXJsKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpbXBsZW1lbnRhdGlvbikpIHsKICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICJvYmplY3QiICYmIGRlZmluZWRfZGVmYXVsdChkZWZpbmUuYW1kKSAmJiAhZGVmaW5lLmFtZC50b1VybFVuZGVmaW5lZCAmJiBkZWZpbmVkX2RlZmF1bHQoX19yZXF1aXJlLnRvVXJsKSkgewogICAgICAgIGltcGxlbWVudGF0aW9uID0gYnVpbGRNb2R1bGVVcmxGcm9tUmVxdWlyZVRvVXJsOwogICAgICB9IGVsc2UgewogICAgICAgIGltcGxlbWVudGF0aW9uID0gYnVpbGRNb2R1bGVVcmxGcm9tQmFzZVVybDsKICAgICAgfQogICAgfQogICAgY29uc3QgdXJsID0gaW1wbGVtZW50YXRpb24ocmVsYXRpdmVVcmwpOwogICAgcmV0dXJuIHVybDsKICB9CiAgYnVpbGRNb2R1bGVVcmwuX2Nlc2l1bVNjcmlwdFJlZ2V4ID0gY2VzaXVtU2NyaXB0UmVnZXg7CiAgYnVpbGRNb2R1bGVVcmwuX2J1aWxkTW9kdWxlVXJsRnJvbUJhc2VVcmwgPSBidWlsZE1vZHVsZVVybEZyb21CYXNlVXJsOwogIGJ1aWxkTW9kdWxlVXJsLl9jbGVhckJhc2VSZXNvdXJjZSA9IGZ1bmN0aW9uKCkgewogICAgYmFzZVJlc291cmNlID0gdm9pZCAwOwogIH07CiAgYnVpbGRNb2R1bGVVcmwuc2V0QmFzZVVybCA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICBiYXNlUmVzb3VyY2UgPSBSZXNvdXJjZV9kZWZhdWx0LkRFRkFVTFQuZ2V0RGVyaXZlZFJlc291cmNlKHsKICAgICAgdXJsOiB2YWx1ZQogICAgfSk7CiAgfTsKICBidWlsZE1vZHVsZVVybC5nZXRDZXNpdW1CYXNlVXJsID0gZ2V0Q2VzaXVtQmFzZVVybDsKICB2YXIgYnVpbGRNb2R1bGVVcmxfZGVmYXVsdCA9IGJ1aWxkTW9kdWxlVXJsOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSWF1MjAwNlh5c1NhbXBsZS5qcwogIGZ1bmN0aW9uIElhdTIwMDZYeXNTYW1wbGUoeCwgeSwgcykgewogICAgdGhpcy54ID0geDsKICAgIHRoaXMueSA9IHk7CiAgICB0aGlzLnMgPSBzOwogIH0KICB2YXIgSWF1MjAwNlh5c1NhbXBsZV9kZWZhdWx0ID0gSWF1MjAwNlh5c1NhbXBsZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0lhdTIwMDZYeXNEYXRhLmpzCiAgZnVuY3Rpb24gSWF1MjAwNlh5c0RhdGEob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMsIGRlZmF1bHRWYWx1ZV9kZWZhdWx0LkVNUFRZX09CSkVDVCk7CiAgICB0aGlzLl94eXNGaWxlVXJsVGVtcGxhdGUgPSBSZXNvdXJjZV9kZWZhdWx0LmNyZWF0ZUlmTmVlZGVkKAogICAgICBvcHRpb25zLnh5c0ZpbGVVcmxUZW1wbGF0ZQogICAgKTsKICAgIHRoaXMuX2ludGVycG9sYXRpb25PcmRlciA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMuaW50ZXJwb2xhdGlvbk9yZGVyLCA5KTsKICAgIHRoaXMuX3NhbXBsZVplcm9KdWxpYW5FcGhlbWVyaXNEYXRlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIG9wdGlvbnMuc2FtcGxlWmVyb0p1bGlhbkVwaGVtZXJpc0RhdGUsCiAgICAgIDI0NDIzOTY1ZS0xCiAgICApOwogICAgdGhpcy5fc2FtcGxlWmVyb0RhdGVUVCA9IG5ldyBKdWxpYW5EYXRlX2RlZmF1bHQoCiAgICAgIHRoaXMuX3NhbXBsZVplcm9KdWxpYW5FcGhlbWVyaXNEYXRlLAogICAgICAwLAogICAgICBUaW1lU3RhbmRhcmRfZGVmYXVsdC5UQUkKICAgICk7CiAgICB0aGlzLl9zdGVwU2l6ZURheXMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLnN0ZXBTaXplRGF5cywgMSk7CiAgICB0aGlzLl9zYW1wbGVzUGVyWHlzRmlsZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMuc2FtcGxlc1Blclh5c0ZpbGUsIDFlMyk7CiAgICB0aGlzLl90b3RhbFNhbXBsZXMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLnRvdGFsU2FtcGxlcywgMjc0MjYpOwogICAgdGhpcy5fc2FtcGxlcyA9IG5ldyBBcnJheSh0aGlzLl90b3RhbFNhbXBsZXMgKiAzKTsKICAgIHRoaXMuX2NodW5rRG93bmxvYWRzSW5Qcm9ncmVzcyA9IFtdOwogICAgY29uc3Qgb3JkZXIgPSB0aGlzLl9pbnRlcnBvbGF0aW9uT3JkZXI7CiAgICBjb25zdCBkZW5vbSA9IHRoaXMuX2Rlbm9taW5hdG9ycyA9IG5ldyBBcnJheShvcmRlciArIDEpOwogICAgY29uc3QgeFRhYmxlID0gdGhpcy5feFRhYmxlID0gbmV3IEFycmF5KG9yZGVyICsgMSk7CiAgICBjb25zdCBzdGVwTiA9IE1hdGgucG93KHRoaXMuX3N0ZXBTaXplRGF5cywgb3JkZXIpOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gb3JkZXI7ICsraSkgewogICAgICBkZW5vbVtpXSA9IHN0ZXBOOwogICAgICB4VGFibGVbaV0gPSBpICogdGhpcy5fc3RlcFNpemVEYXlzOwogICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBvcmRlcjsgKytqKSB7CiAgICAgICAgaWYgKGogIT09IGkpIHsKICAgICAgICAgIGRlbm9tW2ldICo9IGkgLSBqOwogICAgICAgIH0KICAgICAgfQogICAgICBkZW5vbVtpXSA9IDEgLyBkZW5vbVtpXTsKICAgIH0KICAgIHRoaXMuX3dvcmsgPSBuZXcgQXJyYXkob3JkZXIgKyAxKTsKICAgIHRoaXMuX2NvZWYgPSBuZXcgQXJyYXkob3JkZXIgKyAxKTsKICB9CiAgdmFyIGp1bGlhbkRhdGVTY3JhdGNoID0gbmV3IEp1bGlhbkRhdGVfZGVmYXVsdCgwLCAwLCBUaW1lU3RhbmRhcmRfZGVmYXVsdC5UQUkpOwogIGZ1bmN0aW9uIGdldERheXNTaW5jZUVwb2NoKHh5cywgZGF5VFQsIHNlY29uZFRUKSB7CiAgICBjb25zdCBkYXRlVFQgPSBqdWxpYW5EYXRlU2NyYXRjaDsKICAgIGRhdGVUVC5kYXlOdW1iZXIgPSBkYXlUVDsKICAgIGRhdGVUVC5zZWNvbmRzT2ZEYXkgPSBzZWNvbmRUVDsKICAgIHJldHVybiBKdWxpYW5EYXRlX2RlZmF1bHQuZGF5c0RpZmZlcmVuY2UoZGF0ZVRULCB4eXMuX3NhbXBsZVplcm9EYXRlVFQpOwogIH0KICBJYXUyMDA2WHlzRGF0YS5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uKHN0YXJ0RGF5VFQsIHN0YXJ0U2Vjb25kVFQsIHN0b3BEYXlUVCwgc3RvcFNlY29uZFRUKSB7CiAgICBjb25zdCBzdGFydERheXNTaW5jZUVwb2NoID0gZ2V0RGF5c1NpbmNlRXBvY2goCiAgICAgIHRoaXMsCiAgICAgIHN0YXJ0RGF5VFQsCiAgICAgIHN0YXJ0U2Vjb25kVFQKICAgICk7CiAgICBjb25zdCBzdG9wRGF5c1NpbmNlRXBvY2ggPSBnZXREYXlzU2luY2VFcG9jaCh0aGlzLCBzdG9wRGF5VFQsIHN0b3BTZWNvbmRUVCk7CiAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0RGF5c1NpbmNlRXBvY2ggLyB0aGlzLl9zdGVwU2l6ZURheXMgLSB0aGlzLl9pbnRlcnBvbGF0aW9uT3JkZXIgLyAyIHwgMDsKICAgIGlmIChzdGFydEluZGV4IDwgMCkgewogICAgICBzdGFydEluZGV4ID0gMDsKICAgIH0KICAgIGxldCBzdG9wSW5kZXggPSBzdG9wRGF5c1NpbmNlRXBvY2ggLyB0aGlzLl9zdGVwU2l6ZURheXMgLSB0aGlzLl9pbnRlcnBvbGF0aW9uT3JkZXIgLyAyIHwgMCArIHRoaXMuX2ludGVycG9sYXRpb25PcmRlcjsKICAgIGlmIChzdG9wSW5kZXggPj0gdGhpcy5fdG90YWxTYW1wbGVzKSB7CiAgICAgIHN0b3BJbmRleCA9IHRoaXMuX3RvdGFsU2FtcGxlcyAtIDE7CiAgICB9CiAgICBjb25zdCBzdGFydENodW5rID0gc3RhcnRJbmRleCAvIHRoaXMuX3NhbXBsZXNQZXJYeXNGaWxlIHwgMDsKICAgIGNvbnN0IHN0b3BDaHVuayA9IHN0b3BJbmRleCAvIHRoaXMuX3NhbXBsZXNQZXJYeXNGaWxlIHwgMDsKICAgIGNvbnN0IHByb21pc2VzID0gW107CiAgICBmb3IgKGxldCBpID0gc3RhcnRDaHVuazsgaSA8PSBzdG9wQ2h1bms7ICsraSkgewogICAgICBwcm9taXNlcy5wdXNoKHJlcXVlc3RYeXNDaHVuayh0aGlzLCBpKSk7CiAgICB9CiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpOwogIH07CiAgSWF1MjAwNlh5c0RhdGEucHJvdG90eXBlLmNvbXB1dGVYeXNSYWRpYW5zID0gZnVuY3Rpb24oZGF5VFQsIHNlY29uZFRULCByZXN1bHQpIHsKICAgIGNvbnN0IGRheXNTaW5jZUVwb2NoID0gZ2V0RGF5c1NpbmNlRXBvY2godGhpcywgZGF5VFQsIHNlY29uZFRUKTsKICAgIGlmIChkYXlzU2luY2VFcG9jaCA8IDApIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGNvbnN0IGNlbnRlckluZGV4ID0gZGF5c1NpbmNlRXBvY2ggLyB0aGlzLl9zdGVwU2l6ZURheXMgfCAwOwogICAgaWYgKGNlbnRlckluZGV4ID49IHRoaXMuX3RvdGFsU2FtcGxlcykgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgY29uc3QgZGVncmVlID0gdGhpcy5faW50ZXJwb2xhdGlvbk9yZGVyOwogICAgbGV0IGZpcnN0SW5kZXggPSBjZW50ZXJJbmRleCAtIChkZWdyZWUgLyAyIHwgMCk7CiAgICBpZiAoZmlyc3RJbmRleCA8IDApIHsKICAgICAgZmlyc3RJbmRleCA9IDA7CiAgICB9CiAgICBsZXQgbGFzdEluZGV4ID0gZmlyc3RJbmRleCArIGRlZ3JlZTsKICAgIGlmIChsYXN0SW5kZXggPj0gdGhpcy5fdG90YWxTYW1wbGVzKSB7CiAgICAgIGxhc3RJbmRleCA9IHRoaXMuX3RvdGFsU2FtcGxlcyAtIDE7CiAgICAgIGZpcnN0SW5kZXggPSBsYXN0SW5kZXggLSBkZWdyZWU7CiAgICAgIGlmIChmaXJzdEluZGV4IDwgMCkgewogICAgICAgIGZpcnN0SW5kZXggPSAwOwogICAgICB9CiAgICB9CiAgICBsZXQgaXNEYXRhTWlzc2luZyA9IGZhbHNlOwogICAgY29uc3Qgc2FtcGxlcyA9IHRoaXMuX3NhbXBsZXM7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChzYW1wbGVzW2ZpcnN0SW5kZXggKiAzXSkpIHsKICAgICAgcmVxdWVzdFh5c0NodW5rKHRoaXMsIGZpcnN0SW5kZXggLyB0aGlzLl9zYW1wbGVzUGVyWHlzRmlsZSB8IDApOwogICAgICBpc0RhdGFNaXNzaW5nID0gdHJ1ZTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHNhbXBsZXNbbGFzdEluZGV4ICogM10pKSB7CiAgICAgIHJlcXVlc3RYeXNDaHVuayh0aGlzLCBsYXN0SW5kZXggLyB0aGlzLl9zYW1wbGVzUGVyWHlzRmlsZSB8IDApOwogICAgICBpc0RhdGFNaXNzaW5nID0gdHJ1ZTsKICAgIH0KICAgIGlmIChpc0RhdGFNaXNzaW5nKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBJYXUyMDA2WHlzU2FtcGxlX2RlZmF1bHQoMCwgMCwgMCk7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQueCA9IDA7CiAgICAgIHJlc3VsdC55ID0gMDsKICAgICAgcmVzdWx0LnMgPSAwOwogICAgfQogICAgY29uc3QgeCA9IGRheXNTaW5jZUVwb2NoIC0gZmlyc3RJbmRleCAqIHRoaXMuX3N0ZXBTaXplRGF5czsKICAgIGNvbnN0IHdvcmsgPSB0aGlzLl93b3JrOwogICAgY29uc3QgZGVub20gPSB0aGlzLl9kZW5vbWluYXRvcnM7CiAgICBjb25zdCBjb2VmID0gdGhpcy5fY29lZjsKICAgIGNvbnN0IHhUYWJsZSA9IHRoaXMuX3hUYWJsZTsKICAgIGxldCBpLCBqOwogICAgZm9yIChpID0gMDsgaSA8PSBkZWdyZWU7ICsraSkgewogICAgICB3b3JrW2ldID0geCAtIHhUYWJsZVtpXTsKICAgIH0KICAgIGZvciAoaSA9IDA7IGkgPD0gZGVncmVlOyArK2kpIHsKICAgICAgY29lZltpXSA9IDE7CiAgICAgIGZvciAoaiA9IDA7IGogPD0gZGVncmVlOyArK2opIHsKICAgICAgICBpZiAoaiAhPT0gaSkgewogICAgICAgICAgY29lZltpXSAqPSB3b3JrW2pdOwogICAgICAgIH0KICAgICAgfQogICAgICBjb2VmW2ldICo9IGRlbm9tW2ldOwogICAgICBsZXQgc2FtcGxlSW5kZXggPSAoZmlyc3RJbmRleCArIGkpICogMzsKICAgICAgcmVzdWx0LnggKz0gY29lZltpXSAqIHNhbXBsZXNbc2FtcGxlSW5kZXgrK107CiAgICAgIHJlc3VsdC55ICs9IGNvZWZbaV0gKiBzYW1wbGVzW3NhbXBsZUluZGV4KytdOwogICAgICByZXN1bHQucyArPSBjb2VmW2ldICogc2FtcGxlc1tzYW1wbGVJbmRleF07CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgZnVuY3Rpb24gcmVxdWVzdFh5c0NodW5rKHh5c0RhdGEsIGNodW5rSW5kZXgpIHsKICAgIGlmICh4eXNEYXRhLl9jaHVua0Rvd25sb2Fkc0luUHJvZ3Jlc3NbY2h1bmtJbmRleF0pIHsKICAgICAgcmV0dXJuIHh5c0RhdGEuX2NodW5rRG93bmxvYWRzSW5Qcm9ncmVzc1tjaHVua0luZGV4XTsKICAgIH0KICAgIGxldCBjaHVua1VybDsKICAgIGNvbnN0IHh5c0ZpbGVVcmxUZW1wbGF0ZSA9IHh5c0RhdGEuX3h5c0ZpbGVVcmxUZW1wbGF0ZTsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoeHlzRmlsZVVybFRlbXBsYXRlKSkgewogICAgICBjaHVua1VybCA9IHh5c0ZpbGVVcmxUZW1wbGF0ZS5nZXREZXJpdmVkUmVzb3VyY2UoewogICAgICAgIHRlbXBsYXRlVmFsdWVzOiB7CiAgICAgICAgICAwOiBjaHVua0luZGV4CiAgICAgICAgfQogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIGNodW5rVXJsID0gbmV3IFJlc291cmNlX2RlZmF1bHQoewogICAgICAgIHVybDogYnVpbGRNb2R1bGVVcmxfZGVmYXVsdChgQXNzZXRzL0lBVTIwMDZfWFlTL0lBVTIwMDZfWFlTXyR7Y2h1bmtJbmRleH0uanNvbmApCiAgICAgIH0pOwogICAgfQogICAgY29uc3QgcHJvbWlzZSA9IGNodW5rVXJsLmZldGNoSnNvbigpLnRoZW4oZnVuY3Rpb24oY2h1bmspIHsKICAgICAgeHlzRGF0YS5fY2h1bmtEb3dubG9hZHNJblByb2dyZXNzW2NodW5rSW5kZXhdID0gZmFsc2U7CiAgICAgIGNvbnN0IHNhbXBsZXMgPSB4eXNEYXRhLl9zYW1wbGVzOwogICAgICBjb25zdCBuZXdTYW1wbGVzID0gY2h1bmsuc2FtcGxlczsKICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGNodW5rSW5kZXggKiB4eXNEYXRhLl9zYW1wbGVzUGVyWHlzRmlsZSAqIDM7CiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBuZXdTYW1wbGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgc2FtcGxlc1tzdGFydEluZGV4ICsgaV0gPSBuZXdTYW1wbGVzW2ldOwogICAgICB9CiAgICB9KTsKICAgIHh5c0RhdGEuX2NodW5rRG93bmxvYWRzSW5Qcm9ncmVzc1tjaHVua0luZGV4XSA9IHByb21pc2U7CiAgICByZXR1cm4gcHJvbWlzZTsKICB9CiAgdmFyIElhdTIwMDZYeXNEYXRhX2RlZmF1bHQgPSBJYXUyMDA2WHlzRGF0YTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RyYW5zZm9ybXMuanMKICB2YXIgVHJhbnNmb3JtcyA9IHt9OwogIHZhciB2ZWN0b3JQcm9kdWN0TG9jYWxGcmFtZSA9IHsKICAgIHVwOiB7CiAgICAgIHNvdXRoOiAiZWFzdCIsCiAgICAgIG5vcnRoOiAid2VzdCIsCiAgICAgIHdlc3Q6ICJzb3V0aCIsCiAgICAgIGVhc3Q6ICJub3J0aCIKICAgIH0sCiAgICBkb3duOiB7CiAgICAgIHNvdXRoOiAid2VzdCIsCiAgICAgIG5vcnRoOiAiZWFzdCIsCiAgICAgIHdlc3Q6ICJub3J0aCIsCiAgICAgIGVhc3Q6ICJzb3V0aCIKICAgIH0sCiAgICBzb3V0aDogewogICAgICB1cDogIndlc3QiLAogICAgICBkb3duOiAiZWFzdCIsCiAgICAgIHdlc3Q6ICJkb3duIiwKICAgICAgZWFzdDogInVwIgogICAgfSwKICAgIG5vcnRoOiB7CiAgICAgIHVwOiAiZWFzdCIsCiAgICAgIGRvd246ICJ3ZXN0IiwKICAgICAgd2VzdDogInVwIiwKICAgICAgZWFzdDogImRvd24iCiAgICB9LAogICAgd2VzdDogewogICAgICB1cDogIm5vcnRoIiwKICAgICAgZG93bjogInNvdXRoIiwKICAgICAgbm9ydGg6ICJkb3duIiwKICAgICAgc291dGg6ICJ1cCIKICAgIH0sCiAgICBlYXN0OiB7CiAgICAgIHVwOiAic291dGgiLAogICAgICBkb3duOiAibm9ydGgiLAogICAgICBub3J0aDogInVwIiwKICAgICAgc291dGg6ICJkb3duIgogICAgfQogIH07CiAgdmFyIGRlZ2VuZXJhdGVQb3NpdGlvbkxvY2FsRnJhbWUgPSB7CiAgICBub3J0aDogWy0xLCAwLCAwXSwKICAgIGVhc3Q6IFswLCAxLCAwXSwKICAgIHVwOiBbMCwgMCwgMV0sCiAgICBzb3V0aDogWzEsIDAsIDBdLAogICAgd2VzdDogWzAsIC0xLCAwXSwKICAgIGRvd246IFswLCAwLCAtMV0KICB9OwogIHZhciBsb2NhbEZyYW1lVG9GaXhlZEZyYW1lQ2FjaGUgPSB7fTsKICB2YXIgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbiA9IHsKICAgIGVhc3Q6IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKSwKICAgIG5vcnRoOiBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCksCiAgICB1cDogbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpLAogICAgd2VzdDogbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpLAogICAgc291dGg6IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKSwKICAgIGRvd246IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKQogIH07CiAgdmFyIHNjcmF0Y2hGaXJzdENhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFNlY29uZENhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFRoaXJkQ2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIFRyYW5zZm9ybXMubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvciA9IGZ1bmN0aW9uKGZpcnN0QXhpcywgc2Vjb25kQXhpcykgewogICAgaWYgKCF2ZWN0b3JQcm9kdWN0TG9jYWxGcmFtZS5oYXNPd25Qcm9wZXJ0eShmaXJzdEF4aXMpIHx8ICF2ZWN0b3JQcm9kdWN0TG9jYWxGcmFtZVtmaXJzdEF4aXNdLmhhc093blByb3BlcnR5KHNlY29uZEF4aXMpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJmaXJzdEF4aXMgYW5kIHNlY29uZEF4aXMgbXVzdCBiZSBlYXN0LCBub3J0aCwgdXAsIHdlc3QsIHNvdXRoIG9yIGRvd24uIgogICAgICApOwogICAgfQogICAgY29uc3QgdGhpcmRBeGlzID0gdmVjdG9yUHJvZHVjdExvY2FsRnJhbWVbZmlyc3RBeGlzXVtzZWNvbmRBeGlzXTsKICAgIGxldCByZXN1bHRhdDsKICAgIGNvbnN0IGhhc2hBeGlzID0gZmlyc3RBeGlzICsgc2Vjb25kQXhpczsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQobG9jYWxGcmFtZVRvRml4ZWRGcmFtZUNhY2hlW2hhc2hBeGlzXSkpIHsKICAgICAgcmVzdWx0YXQgPSBsb2NhbEZyYW1lVG9GaXhlZEZyYW1lQ2FjaGVbaGFzaEF4aXNdOwogICAgfSBlbHNlIHsKICAgICAgcmVzdWx0YXQgPSBmdW5jdGlvbihvcmlnaW4sIGVsbGlwc29pZCwgcmVzdWx0KSB7CiAgICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3JpZ2luKSkgewogICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9yaWdpbiBpcyByZXF1aXJlZC4iKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICAgICAgcmVzdWx0ID0gbmV3IE1hdHJpeDRfZGVmYXVsdCgpOwogICAgICAgIH0KICAgICAgICBpZiAoQ2FydGVzaWFuM19kZWZhdWx0LmVxdWFsc0Vwc2lsb24ob3JpZ2luLCBDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTywgTWF0aF9kZWZhdWx0LkVQU0lMT04xNCkpIHsKICAgICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC51bnBhY2soCiAgICAgICAgICAgIGRlZ2VuZXJhdGVQb3NpdGlvbkxvY2FsRnJhbWVbZmlyc3RBeGlzXSwKICAgICAgICAgICAgMCwKICAgICAgICAgICAgc2NyYXRjaEZpcnN0Q2FydGVzaWFuCiAgICAgICAgICApOwogICAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnVucGFjaygKICAgICAgICAgICAgZGVnZW5lcmF0ZVBvc2l0aW9uTG9jYWxGcmFtZVtzZWNvbmRBeGlzXSwKICAgICAgICAgICAgMCwKICAgICAgICAgICAgc2NyYXRjaFNlY29uZENhcnRlc2lhbgogICAgICAgICAgKTsKICAgICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC51bnBhY2soCiAgICAgICAgICAgIGRlZ2VuZXJhdGVQb3NpdGlvbkxvY2FsRnJhbWVbdGhpcmRBeGlzXSwKICAgICAgICAgICAgMCwKICAgICAgICAgICAgc2NyYXRjaFRoaXJkQ2FydGVzaWFuCiAgICAgICAgICApOwogICAgICAgIH0gZWxzZSBpZiAoTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24ob3JpZ2luLngsIDAsIE1hdGhfZGVmYXVsdC5FUFNJTE9OMTQpICYmIE1hdGhfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKG9yaWdpbi55LCAwLCBNYXRoX2RlZmF1bHQuRVBTSUxPTjE0KSkgewogICAgICAgICAgY29uc3Qgc2lnbjIgPSBNYXRoX2RlZmF1bHQuc2lnbihvcmlnaW4ueik7CiAgICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQudW5wYWNrKAogICAgICAgICAgICBkZWdlbmVyYXRlUG9zaXRpb25Mb2NhbEZyYW1lW2ZpcnN0QXhpc10sCiAgICAgICAgICAgIDAsCiAgICAgICAgICAgIHNjcmF0Y2hGaXJzdENhcnRlc2lhbgogICAgICAgICAgKTsKICAgICAgICAgIGlmIChmaXJzdEF4aXMgIT09ICJlYXN0IiAmJiBmaXJzdEF4aXMgIT09ICJ3ZXN0IikgewogICAgICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgICAgICAgICBzY3JhdGNoRmlyc3RDYXJ0ZXNpYW4sCiAgICAgICAgICAgICAgc2lnbjIsCiAgICAgICAgICAgICAgc2NyYXRjaEZpcnN0Q2FydGVzaWFuCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQudW5wYWNrKAogICAgICAgICAgICBkZWdlbmVyYXRlUG9zaXRpb25Mb2NhbEZyYW1lW3NlY29uZEF4aXNdLAogICAgICAgICAgICAwLAogICAgICAgICAgICBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuCiAgICAgICAgICApOwogICAgICAgICAgaWYgKHNlY29uZEF4aXMgIT09ICJlYXN0IiAmJiBzZWNvbmRBeGlzICE9PSAid2VzdCIpIHsKICAgICAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0Lm11bHRpcGx5QnlTY2FsYXIoCiAgICAgICAgICAgICAgc2NyYXRjaFNlY29uZENhcnRlc2lhbiwKICAgICAgICAgICAgICBzaWduMiwKICAgICAgICAgICAgICBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQudW5wYWNrKAogICAgICAgICAgICBkZWdlbmVyYXRlUG9zaXRpb25Mb2NhbEZyYW1lW3RoaXJkQXhpc10sCiAgICAgICAgICAgIDAsCiAgICAgICAgICAgIHNjcmF0Y2hUaGlyZENhcnRlc2lhbgogICAgICAgICAgKTsKICAgICAgICAgIGlmICh0aGlyZEF4aXMgIT09ICJlYXN0IiAmJiB0aGlyZEF4aXMgIT09ICJ3ZXN0IikgewogICAgICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgICAgICAgICBzY3JhdGNoVGhpcmRDYXJ0ZXNpYW4sCiAgICAgICAgICAgICAgc2lnbjIsCiAgICAgICAgICAgICAgc2NyYXRjaFRoaXJkQ2FydGVzaWFuCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGVsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGVsbGlwc29pZCwgRWxsaXBzb2lkX2RlZmF1bHQuV0dTODQpOwogICAgICAgICAgZWxsaXBzb2lkLmdlb2RldGljU3VyZmFjZU5vcm1hbChvcmlnaW4sIHNjcmF0Y2hDYWxjdWxhdGVDYXJ0ZXNpYW4udXApOwogICAgICAgICAgY29uc3QgdXAgPSBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuLnVwOwogICAgICAgICAgY29uc3QgZWFzdCA9IHNjcmF0Y2hDYWxjdWxhdGVDYXJ0ZXNpYW4uZWFzdDsKICAgICAgICAgIGVhc3QueCA9IC1vcmlnaW4ueTsKICAgICAgICAgIGVhc3QueSA9IG9yaWdpbi54OwogICAgICAgICAgZWFzdC56ID0gMDsKICAgICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUoZWFzdCwgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi5lYXN0KTsKICAgICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyh1cCwgZWFzdCwgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi5ub3J0aCk7CiAgICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgICAgICAgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi51cCwKICAgICAgICAgICAgLTEsCiAgICAgICAgICAgIHNjcmF0Y2hDYWxjdWxhdGVDYXJ0ZXNpYW4uZG93bgogICAgICAgICAgKTsKICAgICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGFyKAogICAgICAgICAgICBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuLmVhc3QsCiAgICAgICAgICAgIC0xLAogICAgICAgICAgICBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuLndlc3QKICAgICAgICAgICk7CiAgICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgICAgICAgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi5ub3J0aCwKICAgICAgICAgICAgLTEsCiAgICAgICAgICAgIHNjcmF0Y2hDYWxjdWxhdGVDYXJ0ZXNpYW4uc291dGgKICAgICAgICAgICk7CiAgICAgICAgICBzY3JhdGNoRmlyc3RDYXJ0ZXNpYW4gPSBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuW2ZpcnN0QXhpc107CiAgICAgICAgICBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuID0gc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbltzZWNvbmRBeGlzXTsKICAgICAgICAgIHNjcmF0Y2hUaGlyZENhcnRlc2lhbiA9IHNjcmF0Y2hDYWxjdWxhdGVDYXJ0ZXNpYW5bdGhpcmRBeGlzXTsKICAgICAgICB9CiAgICAgICAgcmVzdWx0WzBdID0gc2NyYXRjaEZpcnN0Q2FydGVzaWFuLng7CiAgICAgICAgcmVzdWx0WzFdID0gc2NyYXRjaEZpcnN0Q2FydGVzaWFuLnk7CiAgICAgICAgcmVzdWx0WzJdID0gc2NyYXRjaEZpcnN0Q2FydGVzaWFuLno7CiAgICAgICAgcmVzdWx0WzNdID0gMDsKICAgICAgICByZXN1bHRbNF0gPSBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuLng7CiAgICAgICAgcmVzdWx0WzVdID0gc2NyYXRjaFNlY29uZENhcnRlc2lhbi55OwogICAgICAgIHJlc3VsdFs2XSA9IHNjcmF0Y2hTZWNvbmRDYXJ0ZXNpYW4uejsKICAgICAgICByZXN1bHRbN10gPSAwOwogICAgICAgIHJlc3VsdFs4XSA9IHNjcmF0Y2hUaGlyZENhcnRlc2lhbi54OwogICAgICAgIHJlc3VsdFs5XSA9IHNjcmF0Y2hUaGlyZENhcnRlc2lhbi55OwogICAgICAgIHJlc3VsdFsxMF0gPSBzY3JhdGNoVGhpcmRDYXJ0ZXNpYW4uejsKICAgICAgICByZXN1bHRbMTFdID0gMDsKICAgICAgICByZXN1bHRbMTJdID0gb3JpZ2luLng7CiAgICAgICAgcmVzdWx0WzEzXSA9IG9yaWdpbi55OwogICAgICAgIHJlc3VsdFsxNF0gPSBvcmlnaW4uejsKICAgICAgICByZXN1bHRbMTVdID0gMTsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9OwogICAgICBsb2NhbEZyYW1lVG9GaXhlZEZyYW1lQ2FjaGVbaGFzaEF4aXNdID0gcmVzdWx0YXQ7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0YXQ7CiAgfTsKICBUcmFuc2Zvcm1zLmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lID0gVHJhbnNmb3Jtcy5sb2NhbEZyYW1lVG9GaXhlZEZyYW1lR2VuZXJhdG9yKAogICAgImVhc3QiLAogICAgIm5vcnRoIgogICk7CiAgVHJhbnNmb3Jtcy5ub3J0aEVhc3REb3duVG9GaXhlZEZyYW1lID0gVHJhbnNmb3Jtcy5sb2NhbEZyYW1lVG9GaXhlZEZyYW1lR2VuZXJhdG9yKAogICAgIm5vcnRoIiwKICAgICJlYXN0IgogICk7CiAgVHJhbnNmb3Jtcy5ub3J0aFVwRWFzdFRvRml4ZWRGcmFtZSA9IFRyYW5zZm9ybXMubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvcigKICAgICJub3J0aCIsCiAgICAidXAiCiAgKTsKICBUcmFuc2Zvcm1zLm5vcnRoV2VzdFVwVG9GaXhlZEZyYW1lID0gVHJhbnNmb3Jtcy5sb2NhbEZyYW1lVG9GaXhlZEZyYW1lR2VuZXJhdG9yKAogICAgIm5vcnRoIiwKICAgICJ3ZXN0IgogICk7CiAgdmFyIHNjcmF0Y2hIUFJRdWF0ZXJuaW9uMiA9IG5ldyBRdWF0ZXJuaW9uX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFNjYWxlID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgxLCAxLCAxKTsKICB2YXIgc2NyYXRjaEhQUk1hdHJpeDQgPSBuZXcgTWF0cml4NF9kZWZhdWx0KCk7CiAgVHJhbnNmb3Jtcy5oZWFkaW5nUGl0Y2hSb2xsVG9GaXhlZEZyYW1lID0gZnVuY3Rpb24ob3JpZ2luLCBoZWFkaW5nUGl0Y2hSb2xsLCBlbGxpcHNvaWQsIGZpeGVkRnJhbWVUcmFuc2Zvcm0sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJIZWFkaW5nUGl0Y2hSb2xsIiwgaGVhZGluZ1BpdGNoUm9sbCk7CiAgICBmaXhlZEZyYW1lVHJhbnNmb3JtID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIGZpeGVkRnJhbWVUcmFuc2Zvcm0sCiAgICAgIFRyYW5zZm9ybXMuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWUKICAgICk7CiAgICBjb25zdCBocHJRdWF0ZXJuaW9uID0gUXVhdGVybmlvbl9kZWZhdWx0LmZyb21IZWFkaW5nUGl0Y2hSb2xsKAogICAgICBoZWFkaW5nUGl0Y2hSb2xsLAogICAgICBzY3JhdGNoSFBSUXVhdGVybmlvbjIKICAgICk7CiAgICBjb25zdCBocHJNYXRyaXggPSBNYXRyaXg0X2RlZmF1bHQuZnJvbVRyYW5zbGF0aW9uUXVhdGVybmlvblJvdGF0aW9uU2NhbGUoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLAogICAgICBocHJRdWF0ZXJuaW9uLAogICAgICBzY3JhdGNoU2NhbGUsCiAgICAgIHNjcmF0Y2hIUFJNYXRyaXg0CiAgICApOwogICAgcmVzdWx0ID0gZml4ZWRGcmFtZVRyYW5zZm9ybShvcmlnaW4sIGVsbGlwc29pZCwgcmVzdWx0KTsKICAgIHJldHVybiBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHkocmVzdWx0LCBocHJNYXRyaXgsIHJlc3VsdCk7CiAgfTsKICB2YXIgc2NyYXRjaEVOVU1hdHJpeDQgPSBuZXcgTWF0cml4NF9kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hIUFJNYXRyaXgzID0gbmV3IE1hdHJpeDNfZGVmYXVsdCgpOwogIFRyYW5zZm9ybXMuaGVhZGluZ1BpdGNoUm9sbFF1YXRlcm5pb24gPSBmdW5jdGlvbihvcmlnaW4sIGhlYWRpbmdQaXRjaFJvbGwsIGVsbGlwc29pZCwgZml4ZWRGcmFtZVRyYW5zZm9ybSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIkhlYWRpbmdQaXRjaFJvbGwiLCBoZWFkaW5nUGl0Y2hSb2xsKTsKICAgIGNvbnN0IHRyYW5zZm9ybSA9IFRyYW5zZm9ybXMuaGVhZGluZ1BpdGNoUm9sbFRvRml4ZWRGcmFtZSgKICAgICAgb3JpZ2luLAogICAgICBoZWFkaW5nUGl0Y2hSb2xsLAogICAgICBlbGxpcHNvaWQsCiAgICAgIGZpeGVkRnJhbWVUcmFuc2Zvcm0sCiAgICAgIHNjcmF0Y2hFTlVNYXRyaXg0CiAgICApOwogICAgY29uc3Qgcm90YXRpb24gPSBNYXRyaXg0X2RlZmF1bHQuZ2V0TWF0cml4Myh0cmFuc2Zvcm0sIHNjcmF0Y2hIUFJNYXRyaXgzKTsKICAgIHJldHVybiBRdWF0ZXJuaW9uX2RlZmF1bHQuZnJvbVJvdGF0aW9uTWF0cml4KHJvdGF0aW9uLCByZXN1bHQpOwogIH07CiAgdmFyIG5vU2NhbGUgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KDEsIDEsIDEpOwogIHZhciBocHJDZW50ZXJTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBmZlNjcmF0Y2ggPSBuZXcgTWF0cml4NF9kZWZhdWx0KCk7CiAgdmFyIGhwclRyYW5zZm9ybVNjcmF0Y2ggPSBuZXcgTWF0cml4NF9kZWZhdWx0KCk7CiAgdmFyIGhwclJvdGF0aW9uU2NyYXRjaCA9IG5ldyBNYXRyaXgzX2RlZmF1bHQoKTsKICB2YXIgaHByUXVhdGVybmlvblNjcmF0Y2ggPSBuZXcgUXVhdGVybmlvbl9kZWZhdWx0KCk7CiAgVHJhbnNmb3Jtcy5maXhlZEZyYW1lVG9IZWFkaW5nUGl0Y2hSb2xsID0gZnVuY3Rpb24odHJhbnNmb3JtLCBlbGxpcHNvaWQsIGZpeGVkRnJhbWVUcmFuc2Zvcm0sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ0cmFuc2Zvcm0iLCB0cmFuc2Zvcm0pOwogICAgZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZWxsaXBzb2lkLCBFbGxpcHNvaWRfZGVmYXVsdC5XR1M4NCk7CiAgICBmaXhlZEZyYW1lVHJhbnNmb3JtID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIGZpeGVkRnJhbWVUcmFuc2Zvcm0sCiAgICAgIFRyYW5zZm9ybXMuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWUKICAgICk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBIZWFkaW5nUGl0Y2hSb2xsX2RlZmF1bHQoKTsKICAgIH0KICAgIGNvbnN0IGNlbnRlciA9IE1hdHJpeDRfZGVmYXVsdC5nZXRUcmFuc2xhdGlvbih0cmFuc2Zvcm0sIGhwckNlbnRlclNjcmF0Y2gpOwogICAgaWYgKENhcnRlc2lhbjNfZGVmYXVsdC5lcXVhbHMoY2VudGVyLCBDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTykpIHsKICAgICAgcmVzdWx0LmhlYWRpbmcgPSAwOwogICAgICByZXN1bHQucGl0Y2ggPSAwOwogICAgICByZXN1bHQucm9sbCA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBsZXQgdG9GaXhlZEZyYW1lID0gTWF0cml4NF9kZWZhdWx0LmludmVyc2VUcmFuc2Zvcm1hdGlvbigKICAgICAgZml4ZWRGcmFtZVRyYW5zZm9ybShjZW50ZXIsIGVsbGlwc29pZCwgZmZTY3JhdGNoKSwKICAgICAgZmZTY3JhdGNoCiAgICApOwogICAgbGV0IHRyYW5zZm9ybUNvcHkgPSBNYXRyaXg0X2RlZmF1bHQuc2V0U2NhbGUodHJhbnNmb3JtLCBub1NjYWxlLCBocHJUcmFuc2Zvcm1TY3JhdGNoKTsKICAgIHRyYW5zZm9ybUNvcHkgPSBNYXRyaXg0X2RlZmF1bHQuc2V0VHJhbnNsYXRpb24oCiAgICAgIHRyYW5zZm9ybUNvcHksCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLAogICAgICB0cmFuc2Zvcm1Db3B5CiAgICApOwogICAgdG9GaXhlZEZyYW1lID0gTWF0cml4NF9kZWZhdWx0Lm11bHRpcGx5KHRvRml4ZWRGcmFtZSwgdHJhbnNmb3JtQ29weSwgdG9GaXhlZEZyYW1lKTsKICAgIGxldCBxdWF0ZXJuaW9uUm90YXRpb24gPSBRdWF0ZXJuaW9uX2RlZmF1bHQuZnJvbVJvdGF0aW9uTWF0cml4KAogICAgICBNYXRyaXg0X2RlZmF1bHQuZ2V0TWF0cml4Myh0b0ZpeGVkRnJhbWUsIGhwclJvdGF0aW9uU2NyYXRjaCksCiAgICAgIGhwclF1YXRlcm5pb25TY3JhdGNoCiAgICApOwogICAgcXVhdGVybmlvblJvdGF0aW9uID0gUXVhdGVybmlvbl9kZWZhdWx0Lm5vcm1hbGl6ZSgKICAgICAgcXVhdGVybmlvblJvdGF0aW9uLAogICAgICBxdWF0ZXJuaW9uUm90YXRpb24KICAgICk7CiAgICByZXR1cm4gSGVhZGluZ1BpdGNoUm9sbF9kZWZhdWx0LmZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb25Sb3RhdGlvbiwgcmVzdWx0KTsKICB9OwogIHZhciBnbXN0Q29uc3RhbnQwID0gNiAqIDM2MDAgKyA0MSAqIDYwICsgNTAuNTQ4NDE7CiAgdmFyIGdtc3RDb25zdGFudDEgPSA4NjQwMTg0ODEyODY2ZS02OwogIHZhciBnbXN0Q29uc3RhbnQyID0gMC4wOTMxMDQ7CiAgdmFyIGdtc3RDb25zdGFudDMgPSAtNjJlLTc7CiAgdmFyIHJhdGVDb2VmID0gMTE3NzI3NTgzODQ2NjhlLTMyOwogIHZhciB3Z3M4NFdSUHJlY2Vzc2luZyA9IDcyOTIxMTU4NTUzZS0xNTsKICB2YXIgdHdvUGlPdmVyU2Vjb25kc0luRGF5ID0gTWF0aF9kZWZhdWx0LlRXT19QSSAvIDg2NDAwOwogIHZhciBkYXRlSW5VdGMgPSBuZXcgSnVsaWFuRGF0ZV9kZWZhdWx0KCk7CiAgVHJhbnNmb3Jtcy5jb21wdXRlVGVtZVRvUHNldWRvRml4ZWRNYXRyaXggPSBmdW5jdGlvbihkYXRlLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGRhdGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkYXRlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgZGF0ZUluVXRjID0gSnVsaWFuRGF0ZV9kZWZhdWx0LmFkZFNlY29uZHMoCiAgICAgIGRhdGUsCiAgICAgIC1KdWxpYW5EYXRlX2RlZmF1bHQuY29tcHV0ZVRhaU1pbnVzVXRjKGRhdGUpLAogICAgICBkYXRlSW5VdGMKICAgICk7CiAgICBjb25zdCB1dGNEYXlOdW1iZXIgPSBkYXRlSW5VdGMuZGF5TnVtYmVyOwogICAgY29uc3QgdXRjU2Vjb25kc0ludG9EYXkgPSBkYXRlSW5VdGMuc2Vjb25kc09mRGF5OwogICAgbGV0IHQ7CiAgICBjb25zdCBkaWZmRGF5cyA9IHV0Y0RheU51bWJlciAtIDI0NTE1NDU7CiAgICBpZiAodXRjU2Vjb25kc0ludG9EYXkgPj0gNDMyMDApIHsKICAgICAgdCA9IChkaWZmRGF5cyArIDAuNSkgLyBUaW1lQ29uc3RhbnRzX2RlZmF1bHQuREFZU19QRVJfSlVMSUFOX0NFTlRVUlk7CiAgICB9IGVsc2UgewogICAgICB0ID0gKGRpZmZEYXlzIC0gMC41KSAvIFRpbWVDb25zdGFudHNfZGVmYXVsdC5EQVlTX1BFUl9KVUxJQU5fQ0VOVFVSWTsKICAgIH0KICAgIGNvbnN0IGdtc3QwID0gZ21zdENvbnN0YW50MCArIHQgKiAoZ21zdENvbnN0YW50MSArIHQgKiAoZ21zdENvbnN0YW50MiArIHQgKiBnbXN0Q29uc3RhbnQzKSk7CiAgICBjb25zdCBhbmdsZSA9IGdtc3QwICogdHdvUGlPdmVyU2Vjb25kc0luRGF5ICUgTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgIGNvbnN0IHJhdGlvID0gd2dzODRXUlByZWNlc3NpbmcgKyByYXRlQ29lZiAqICh1dGNEYXlOdW1iZXIgLSAyNDUxNTQ1NWUtMSk7CiAgICBjb25zdCBzZWNvbmRzU2luY2VNaWRuaWdodCA9ICh1dGNTZWNvbmRzSW50b0RheSArIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9EQVkgKiAwLjUpICUgVGltZUNvbnN0YW50c19kZWZhdWx0LlNFQ09ORFNfUEVSX0RBWTsKICAgIGNvbnN0IGdoYSA9IGFuZ2xlICsgcmF0aW8gKiBzZWNvbmRzU2luY2VNaWRuaWdodDsKICAgIGNvbnN0IGNvc0doYSA9IE1hdGguY29zKGdoYSk7CiAgICBjb25zdCBzaW5HaGEgPSBNYXRoLnNpbihnaGEpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IE1hdHJpeDNfZGVmYXVsdCgKICAgICAgICBjb3NHaGEsCiAgICAgICAgc2luR2hhLAogICAgICAgIDAsCiAgICAgICAgLXNpbkdoYSwKICAgICAgICBjb3NHaGEsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApOwogICAgfQogICAgcmVzdWx0WzBdID0gY29zR2hhOwogICAgcmVzdWx0WzFdID0gLXNpbkdoYTsKICAgIHJlc3VsdFsyXSA9IDA7CiAgICByZXN1bHRbM10gPSBzaW5HaGE7CiAgICByZXN1bHRbNF0gPSBjb3NHaGE7CiAgICByZXN1bHRbNV0gPSAwOwogICAgcmVzdWx0WzZdID0gMDsKICAgIHJlc3VsdFs3XSA9IDA7CiAgICByZXN1bHRbOF0gPSAxOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFRyYW5zZm9ybXMuaWF1MjAwNlh5c0RhdGEgPSBuZXcgSWF1MjAwNlh5c0RhdGFfZGVmYXVsdCgpOwogIFRyYW5zZm9ybXMuZWFydGhPcmllbnRhdGlvblBhcmFtZXRlcnMgPSBFYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVyc19kZWZhdWx0Lk5PTkU7CiAgdmFyIHR0TWludXNUYWkgPSAzMi4xODQ7CiAgdmFyIGoyMDAwdHREYXlzID0gMjQ1MTU0NTsKICBUcmFuc2Zvcm1zLnByZWxvYWRJY3JmRml4ZWQgPSBmdW5jdGlvbih0aW1lSW50ZXJ2YWwpIHsKICAgIGNvbnN0IHN0YXJ0RGF5VFQgPSB0aW1lSW50ZXJ2YWwuc3RhcnQuZGF5TnVtYmVyOwogICAgY29uc3Qgc3RhcnRTZWNvbmRUVCA9IHRpbWVJbnRlcnZhbC5zdGFydC5zZWNvbmRzT2ZEYXkgKyB0dE1pbnVzVGFpOwogICAgY29uc3Qgc3RvcERheVRUID0gdGltZUludGVydmFsLnN0b3AuZGF5TnVtYmVyOwogICAgY29uc3Qgc3RvcFNlY29uZFRUID0gdGltZUludGVydmFsLnN0b3Auc2Vjb25kc09mRGF5ICsgdHRNaW51c1RhaTsKICAgIGNvbnN0IHh5c1Byb21pc2UgPSBUcmFuc2Zvcm1zLmlhdTIwMDZYeXNEYXRhLnByZWxvYWQoCiAgICAgIHN0YXJ0RGF5VFQsCiAgICAgIHN0YXJ0U2Vjb25kVFQsCiAgICAgIHN0b3BEYXlUVCwKICAgICAgc3RvcFNlY29uZFRUCiAgICApOwogICAgY29uc3QgZW9wUHJvbWlzZSA9IFRyYW5zZm9ybXMuZWFydGhPcmllbnRhdGlvblBhcmFtZXRlcnMuZ2V0UHJvbWlzZVRvTG9hZCgpOwogICAgcmV0dXJuIFByb21pc2UuYWxsKFt4eXNQcm9taXNlLCBlb3BQcm9taXNlXSk7CiAgfTsKICBUcmFuc2Zvcm1zLmNvbXB1dGVJY3JmVG9GaXhlZE1hdHJpeCA9IGZ1bmN0aW9uKGRhdGUsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZGF0ZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImRhdGUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBNYXRyaXgzX2RlZmF1bHQoKTsKICAgIH0KICAgIGNvbnN0IGZpeGVkVG9JY3JmTXR4ID0gVHJhbnNmb3Jtcy5jb21wdXRlRml4ZWRUb0ljcmZNYXRyaXgoZGF0ZSwgcmVzdWx0KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGZpeGVkVG9JY3JmTXR4KSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgcmV0dXJuIE1hdHJpeDNfZGVmYXVsdC50cmFuc3Bvc2UoZml4ZWRUb0ljcmZNdHgsIHJlc3VsdCk7CiAgfTsKICB2YXIgeHlzU2NyYXRjaCA9IG5ldyBJYXUyMDA2WHlzU2FtcGxlX2RlZmF1bHQoMCwgMCwgMCk7CiAgdmFyIGVvcFNjcmF0Y2ggPSBuZXcgRWFydGhPcmllbnRhdGlvblBhcmFtZXRlcnNTYW1wbGVfZGVmYXVsdCgKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDAsCiAgICAwLAogICAgMAogICk7CiAgdmFyIHJvdGF0aW9uMVNjcmF0Y2ggPSBuZXcgTWF0cml4M19kZWZhdWx0KCk7CiAgdmFyIHJvdGF0aW9uMlNjcmF0Y2ggPSBuZXcgTWF0cml4M19kZWZhdWx0KCk7CiAgVHJhbnNmb3Jtcy5jb21wdXRlRml4ZWRUb0ljcmZNYXRyaXggPSBmdW5jdGlvbihkYXRlLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGRhdGUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkYXRlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgTWF0cml4M19kZWZhdWx0KCk7CiAgICB9CiAgICBjb25zdCBlb3AgPSBUcmFuc2Zvcm1zLmVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzLmNvbXB1dGUoZGF0ZSwgZW9wU2NyYXRjaCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChlb3ApKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCBkYXlUVCA9IGRhdGUuZGF5TnVtYmVyOwogICAgY29uc3Qgc2Vjb25kVFQgPSBkYXRlLnNlY29uZHNPZkRheSArIHR0TWludXNUYWk7CiAgICBjb25zdCB4eXMgPSBUcmFuc2Zvcm1zLmlhdTIwMDZYeXNEYXRhLmNvbXB1dGVYeXNSYWRpYW5zKAogICAgICBkYXlUVCwKICAgICAgc2Vjb25kVFQsCiAgICAgIHh5c1NjcmF0Y2gKICAgICk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh4eXMpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCB4ID0geHlzLnggKyBlb3AueFBvbGVPZmZzZXQ7CiAgICBjb25zdCB5ID0geHlzLnkgKyBlb3AueVBvbGVPZmZzZXQ7CiAgICBjb25zdCBhMyA9IDEgLyAoMSArIE1hdGguc3FydCgxIC0geCAqIHggLSB5ICogeSkpOwogICAgY29uc3Qgcm90YXRpb24xID0gcm90YXRpb24xU2NyYXRjaDsKICAgIHJvdGF0aW9uMVswXSA9IDEgLSBhMyAqIHggKiB4OwogICAgcm90YXRpb24xWzNdID0gLWEzICogeCAqIHk7CiAgICByb3RhdGlvbjFbNl0gPSB4OwogICAgcm90YXRpb24xWzFdID0gLWEzICogeCAqIHk7CiAgICByb3RhdGlvbjFbNF0gPSAxIC0gYTMgKiB5ICogeTsKICAgIHJvdGF0aW9uMVs3XSA9IHk7CiAgICByb3RhdGlvbjFbMl0gPSAteDsKICAgIHJvdGF0aW9uMVs1XSA9IC15OwogICAgcm90YXRpb24xWzhdID0gMSAtIGEzICogKHggKiB4ICsgeSAqIHkpOwogICAgY29uc3Qgcm90YXRpb24yID0gTWF0cml4M19kZWZhdWx0LmZyb21Sb3RhdGlvblooLXh5cy5zLCByb3RhdGlvbjJTY3JhdGNoKTsKICAgIGNvbnN0IG1hdHJpeFEgPSBNYXRyaXgzX2RlZmF1bHQubXVsdGlwbHkocm90YXRpb24xLCByb3RhdGlvbjIsIHJvdGF0aW9uMVNjcmF0Y2gpOwogICAgY29uc3QgZGF0ZVV0MWRheSA9IGRhdGUuZGF5TnVtYmVyOwogICAgY29uc3QgZGF0ZVV0MXNlYyA9IGRhdGUuc2Vjb25kc09mRGF5IC0gSnVsaWFuRGF0ZV9kZWZhdWx0LmNvbXB1dGVUYWlNaW51c1V0YyhkYXRlKSArIGVvcC51dDFNaW51c1V0YzsKICAgIGNvbnN0IGRheXNTaW5jZUoyMDAwID0gZGF0ZVV0MWRheSAtIDI0NTE1NDU7CiAgICBjb25zdCBmcmFjdGlvbk9mRGF5ID0gZGF0ZVV0MXNlYyAvIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9EQVk7CiAgICBsZXQgZXJhID0gMC43NzkwNTcyNzMyNjQgKyBmcmFjdGlvbk9mRGF5ICsgMC4wMDI3Mzc4MTE5MTEzNTQ0OCAqIChkYXlzU2luY2VKMjAwMCArIGZyYWN0aW9uT2ZEYXkpOwogICAgZXJhID0gZXJhICUgMSAqIE1hdGhfZGVmYXVsdC5UV09fUEk7CiAgICBjb25zdCBlYXJ0aFJvdGF0aW9uID0gTWF0cml4M19kZWZhdWx0LmZyb21Sb3RhdGlvblooZXJhLCByb3RhdGlvbjJTY3JhdGNoKTsKICAgIGNvbnN0IHBmVG9JY3JmID0gTWF0cml4M19kZWZhdWx0Lm11bHRpcGx5KG1hdHJpeFEsIGVhcnRoUm90YXRpb24sIHJvdGF0aW9uMVNjcmF0Y2gpOwogICAgY29uc3QgY29zeHAgPSBNYXRoLmNvcyhlb3AueFBvbGVXYW5kZXIpOwogICAgY29uc3QgY29zeXAgPSBNYXRoLmNvcyhlb3AueVBvbGVXYW5kZXIpOwogICAgY29uc3Qgc2lueHAgPSBNYXRoLnNpbihlb3AueFBvbGVXYW5kZXIpOwogICAgY29uc3Qgc2lueXAgPSBNYXRoLnNpbihlb3AueVBvbGVXYW5kZXIpOwogICAgbGV0IHR0dCA9IGRheVRUIC0gajIwMDB0dERheXMgKyBzZWNvbmRUVCAvIFRpbWVDb25zdGFudHNfZGVmYXVsdC5TRUNPTkRTX1BFUl9EQVk7CiAgICB0dHQgLz0gMzY1MjU7CiAgICBjb25zdCBzcCA9IC00N2UtNiAqIHR0dCAqIE1hdGhfZGVmYXVsdC5SQURJQU5TX1BFUl9ERUdSRUUgLyAzNjAwOwogICAgY29uc3QgY29zc3AgPSBNYXRoLmNvcyhzcCk7CiAgICBjb25zdCBzaW5zcCA9IE1hdGguc2luKHNwKTsKICAgIGNvbnN0IGZUb1BmTXR4ID0gcm90YXRpb24yU2NyYXRjaDsKICAgIGZUb1BmTXR4WzBdID0gY29zeHAgKiBjb3NzcDsKICAgIGZUb1BmTXR4WzFdID0gY29zeHAgKiBzaW5zcDsKICAgIGZUb1BmTXR4WzJdID0gc2lueHA7CiAgICBmVG9QZk10eFszXSA9IC1jb3N5cCAqIHNpbnNwICsgc2lueXAgKiBzaW54cCAqIGNvc3NwOwogICAgZlRvUGZNdHhbNF0gPSBjb3N5cCAqIGNvc3NwICsgc2lueXAgKiBzaW54cCAqIHNpbnNwOwogICAgZlRvUGZNdHhbNV0gPSAtc2lueXAgKiBjb3N4cDsKICAgIGZUb1BmTXR4WzZdID0gLXNpbnlwICogc2luc3AgLSBjb3N5cCAqIHNpbnhwICogY29zc3A7CiAgICBmVG9QZk10eFs3XSA9IHNpbnlwICogY29zc3AgLSBjb3N5cCAqIHNpbnhwICogc2luc3A7CiAgICBmVG9QZk10eFs4XSA9IGNvc3lwICogY29zeHA7CiAgICByZXR1cm4gTWF0cml4M19kZWZhdWx0Lm11bHRpcGx5KHBmVG9JY3JmLCBmVG9QZk10eCwgcmVzdWx0KTsKICB9OwogIHZhciBwb2ludFRvV2luZG93Q29vcmRpbmF0ZXNUZW1wID0gbmV3IENhcnRlc2lhbjRfZGVmYXVsdCgpOwogIFRyYW5zZm9ybXMucG9pbnRUb1dpbmRvd0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24obW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCwgdmlld3BvcnRUcmFuc2Zvcm1hdGlvbiwgcG9pbnQsIHJlc3VsdCkgewogICAgcmVzdWx0ID0gVHJhbnNmb3Jtcy5wb2ludFRvR0xXaW5kb3dDb29yZGluYXRlcygKICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCwKICAgICAgdmlld3BvcnRUcmFuc2Zvcm1hdGlvbiwKICAgICAgcG9pbnQsCiAgICAgIHJlc3VsdAogICAgKTsKICAgIHJlc3VsdC55ID0gMiAqIHZpZXdwb3J0VHJhbnNmb3JtYXRpb25bNV0gLSByZXN1bHQueTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBUcmFuc2Zvcm1zLnBvaW50VG9HTFdpbmRvd0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24obW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCwgdmlld3BvcnRUcmFuc2Zvcm1hdGlvbiwgcG9pbnQsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh2aWV3cG9ydFRyYW5zZm9ybWF0aW9uKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidmlld3BvcnRUcmFuc2Zvcm1hdGlvbiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBvaW50KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicG9pbnQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICAgIH0KICAgIGNvbnN0IHRtcDIgPSBwb2ludFRvV2luZG93Q29vcmRpbmF0ZXNUZW1wOwogICAgTWF0cml4NF9kZWZhdWx0Lm11bHRpcGx5QnlWZWN0b3IoCiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsCiAgICAgIENhcnRlc2lhbjRfZGVmYXVsdC5mcm9tRWxlbWVudHMocG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiwgMSwgdG1wMiksCiAgICAgIHRtcDIKICAgICk7CiAgICBDYXJ0ZXNpYW40X2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcih0bXAyLCAxIC8gdG1wMi53LCB0bXAyKTsKICAgIE1hdHJpeDRfZGVmYXVsdC5tdWx0aXBseUJ5VmVjdG9yKHZpZXdwb3J0VHJhbnNmb3JtYXRpb24sIHRtcDIsIHRtcDIpOwogICAgcmV0dXJuIENhcnRlc2lhbjJfZGVmYXVsdC5mcm9tQ2FydGVzaWFuNCh0bXAyLCByZXN1bHQpOwogIH07CiAgdmFyIG5vcm1hbFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHJpZ2h0U2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgdXBTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIFRyYW5zZm9ybXMucm90YXRpb25NYXRyaXhGcm9tUG9zaXRpb25WZWxvY2l0eSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB2ZWxvY2l0eSwgZWxsaXBzb2lkLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBvc2l0aW9uKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicG9zaXRpb24gaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh2ZWxvY2l0eSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInZlbG9jaXR5IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3Qgbm9ybWFsID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZWxsaXBzb2lkLCBFbGxpcHNvaWRfZGVmYXVsdC5XR1M4NCkuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKAogICAgICBwb3NpdGlvbiwKICAgICAgbm9ybWFsU2NyYXRjaAogICAgKTsKICAgIGxldCByaWdodCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyh2ZWxvY2l0eSwgbm9ybWFsLCByaWdodFNjcmF0Y2gpOwogICAgaWYgKENhcnRlc2lhbjNfZGVmYXVsdC5lcXVhbHNFcHNpbG9uKHJpZ2h0LCBDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTywgTWF0aF9kZWZhdWx0LkVQU0lMT042KSkgewogICAgICByaWdodCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShDYXJ0ZXNpYW4zX2RlZmF1bHQuVU5JVF9YLCByaWdodCk7CiAgICB9CiAgICBjb25zdCB1cCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyhyaWdodCwgdmVsb2NpdHksIHVwU2NyYXRjaCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKHVwLCB1cCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY3Jvc3ModmVsb2NpdHksIHVwLCByaWdodCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubmVnYXRlKHJpZ2h0LCByaWdodCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKHJpZ2h0LCByaWdodCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBNYXRyaXgzX2RlZmF1bHQoKTsKICAgIH0KICAgIHJlc3VsdFswXSA9IHZlbG9jaXR5Lng7CiAgICByZXN1bHRbMV0gPSB2ZWxvY2l0eS55OwogICAgcmVzdWx0WzJdID0gdmVsb2NpdHkuejsKICAgIHJlc3VsdFszXSA9IHJpZ2h0Lng7CiAgICByZXN1bHRbNF0gPSByaWdodC55OwogICAgcmVzdWx0WzVdID0gcmlnaHQuejsKICAgIHJlc3VsdFs2XSA9IHVwLng7CiAgICByZXN1bHRbN10gPSB1cC55OwogICAgcmVzdWx0WzhdID0gdXAuejsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc3dpenpsZU1hdHJpeCA9IG5ldyBNYXRyaXg0X2RlZmF1bHQoCiAgICAwLAogICAgMCwKICAgIDEsCiAgICAwLAogICAgMSwKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDAsCiAgICAxLAogICAgMCwKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDAsCiAgICAxCiAgKTsKICB2YXIgc2NyYXRjaENhcnRvZ3JhcGhpYyA9IG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoQ2FydGVzaWFuM1Byb2plY3Rpb24gPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hDZW50ZXIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hSb3RhdGlvbiA9IG5ldyBNYXRyaXgzX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaEZyb21FTlUgPSBuZXcgTWF0cml4NF9kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hUb0VOVSA9IG5ldyBNYXRyaXg0X2RlZmF1bHQoKTsKICBUcmFuc2Zvcm1zLmJhc2lzVG8yRCA9IGZ1bmN0aW9uKHByb2plY3Rpb24sIG1hdHJpeCwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwcm9qZWN0aW9uKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicHJvamVjdGlvbiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG1hdHJpeCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm1hdHJpeCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJlc3VsdCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IHJ0Y0NlbnRlciA9IE1hdHJpeDRfZGVmYXVsdC5nZXRUcmFuc2xhdGlvbihtYXRyaXgsIHNjcmF0Y2hDZW50ZXIpOwogICAgY29uc3QgZWxsaXBzb2lkID0gcHJvamVjdGlvbi5lbGxpcHNvaWQ7CiAgICBjb25zdCBjYXJ0b2dyYXBoaWMgPSBlbGxpcHNvaWQuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWMoCiAgICAgIHJ0Y0NlbnRlciwKICAgICAgc2NyYXRjaENhcnRvZ3JhcGhpYwogICAgKTsKICAgIGNvbnN0IHByb2plY3RlZFBvc2l0aW9uID0gcHJvamVjdGlvbi5wcm9qZWN0KAogICAgICBjYXJ0b2dyYXBoaWMsCiAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW4zUHJvamVjdGlvbgogICAgKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5mcm9tRWxlbWVudHMoCiAgICAgIHByb2plY3RlZFBvc2l0aW9uLnosCiAgICAgIHByb2plY3RlZFBvc2l0aW9uLngsCiAgICAgIHByb2plY3RlZFBvc2l0aW9uLnksCiAgICAgIHByb2plY3RlZFBvc2l0aW9uCiAgICApOwogICAgY29uc3QgZnJvbUVOVSA9IFRyYW5zZm9ybXMuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWUoCiAgICAgIHJ0Y0NlbnRlciwKICAgICAgZWxsaXBzb2lkLAogICAgICBzY3JhdGNoRnJvbUVOVQogICAgKTsKICAgIGNvbnN0IHRvRU5VID0gTWF0cml4NF9kZWZhdWx0LmludmVyc2VUcmFuc2Zvcm1hdGlvbihmcm9tRU5VLCBzY3JhdGNoVG9FTlUpOwogICAgY29uc3Qgcm90YXRpb24gPSBNYXRyaXg0X2RlZmF1bHQuZ2V0TWF0cml4MyhtYXRyaXgsIHNjcmF0Y2hSb3RhdGlvbik7CiAgICBjb25zdCBsb2NhbCA9IE1hdHJpeDRfZGVmYXVsdC5tdWx0aXBseUJ5TWF0cml4Myh0b0VOVSwgcm90YXRpb24sIHJlc3VsdCk7CiAgICBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHkoc3dpenpsZU1hdHJpeCwgbG9jYWwsIHJlc3VsdCk7CiAgICBNYXRyaXg0X2RlZmF1bHQuc2V0VHJhbnNsYXRpb24ocmVzdWx0LCBwcm9qZWN0ZWRQb3NpdGlvbiwgcmVzdWx0KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBUcmFuc2Zvcm1zLndnczg0VG8yRE1vZGVsTWF0cml4ID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgY2VudGVyLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHByb2plY3Rpb24pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJwcm9qZWN0aW9uIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY2VudGVyKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY2VudGVyIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicmVzdWx0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgZWxsaXBzb2lkID0gcHJvamVjdGlvbi5lbGxpcHNvaWQ7CiAgICBjb25zdCBmcm9tRU5VID0gVHJhbnNmb3Jtcy5lYXN0Tm9ydGhVcFRvRml4ZWRGcmFtZSgKICAgICAgY2VudGVyLAogICAgICBlbGxpcHNvaWQsCiAgICAgIHNjcmF0Y2hGcm9tRU5VCiAgICApOwogICAgY29uc3QgdG9FTlUgPSBNYXRyaXg0X2RlZmF1bHQuaW52ZXJzZVRyYW5zZm9ybWF0aW9uKGZyb21FTlUsIHNjcmF0Y2hUb0VOVSk7CiAgICBjb25zdCBjYXJ0b2dyYXBoaWMgPSBlbGxpcHNvaWQuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWMoCiAgICAgIGNlbnRlciwKICAgICAgc2NyYXRjaENhcnRvZ3JhcGhpYwogICAgKTsKICAgIGNvbnN0IHByb2plY3RlZFBvc2l0aW9uID0gcHJvamVjdGlvbi5wcm9qZWN0KAogICAgICBjYXJ0b2dyYXBoaWMsCiAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW4zUHJvamVjdGlvbgogICAgKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5mcm9tRWxlbWVudHMoCiAgICAgIHByb2plY3RlZFBvc2l0aW9uLnosCiAgICAgIHByb2plY3RlZFBvc2l0aW9uLngsCiAgICAgIHByb2plY3RlZFBvc2l0aW9uLnksCiAgICAgIHByb2plY3RlZFBvc2l0aW9uCiAgICApOwogICAgY29uc3QgdHJhbnNsYXRpb24gPSBNYXRyaXg0X2RlZmF1bHQuZnJvbVRyYW5zbGF0aW9uKAogICAgICBwcm9qZWN0ZWRQb3NpdGlvbiwKICAgICAgc2NyYXRjaEZyb21FTlUKICAgICk7CiAgICBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHkoc3dpenpsZU1hdHJpeCwgdG9FTlUsIHJlc3VsdCk7CiAgICBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHkodHJhbnNsYXRpb24sIHJlc3VsdCwgcmVzdWx0KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgVHJhbnNmb3Jtc19kZWZhdWx0ID0gVHJhbnNmb3JtczsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1Rhc2tQcm9jZXNzb3IuanMKICB2YXIgaW1wb3J0X3VyaWpzNyA9IF9fdG9FU00ocmVxdWlyZV9VUkkoKSwgMSk7CiAgZnVuY3Rpb24gY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcigpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KFRhc2tQcm9jZXNzb3IuX2NhblRyYW5zZmVyQXJyYXlCdWZmZXIpKSB7CiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoCiAgICAgICAgZ2V0V29ya2VyVXJsKCJXb3JrZXJzL3RyYW5zZmVyVHlwZWRBcnJheVRlc3QuanMiKQogICAgICApOwogICAgICB3b3JrZXIucG9zdE1lc3NhZ2UgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgICB3b3JrZXIud2Via2l0UG9zdE1lc3NhZ2UsCiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlCiAgICAgICk7CiAgICAgIGNvbnN0IHZhbHVlID0gOTk7CiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IEludDhBcnJheShbdmFsdWVdKTsKICAgICAgdHJ5IHsKICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoCiAgICAgICAgICB7CiAgICAgICAgICAgIGFycmF5CiAgICAgICAgICB9LAogICAgICAgICAgW2FycmF5LmJ1ZmZlcl0KICAgICAgICApOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgVGFza1Byb2Nlc3Nvci5fY2FuVHJhbnNmZXJBcnJheUJ1ZmZlciA9IGZhbHNlOwogICAgICAgIHJldHVybiBUYXNrUHJvY2Vzc29yLl9jYW5UcmFuc2ZlckFycmF5QnVmZmVyOwogICAgICB9CiAgICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXJfZGVmYXVsdCgpOwogICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHsKICAgICAgICBjb25zdCBhcnJheTIgPSBldmVudC5kYXRhLmFycmF5OwogICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZmluZWRfZGVmYXVsdChhcnJheTIpICYmIGFycmF5MlswXSA9PT0gdmFsdWU7CiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpOwogICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTsKICAgICAgICBUYXNrUHJvY2Vzc29yLl9jYW5UcmFuc2ZlckFycmF5QnVmZmVyID0gcmVzdWx0OwogICAgICB9OwogICAgICBUYXNrUHJvY2Vzc29yLl9jYW5UcmFuc2ZlckFycmF5QnVmZmVyID0gZGVmZXJyZWQucHJvbWlzZTsKICAgIH0KICAgIHJldHVybiBUYXNrUHJvY2Vzc29yLl9jYW5UcmFuc2ZlckFycmF5QnVmZmVyOwogIH0KICB2YXIgdGFza0NvbXBsZXRlZEV2ZW50ID0gbmV3IEV2ZW50X2RlZmF1bHQoKTsKICBmdW5jdGlvbiBjb21wbGV0ZVRhc2socHJvY2Vzc29yLCBkYXRhKSB7CiAgICAtLXByb2Nlc3Nvci5fYWN0aXZlVGFza3M7CiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpZCkpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgZGVmZXJyZWRzID0gcHJvY2Vzc29yLl9kZWZlcnJlZHM7CiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVycmVkc1tpZF07CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KGRhdGEuZXJyb3IpKSB7CiAgICAgIGxldCBlcnJvciA9IGRhdGEuZXJyb3I7CiAgICAgIGlmIChlcnJvci5uYW1lID09PSAiUnVudGltZUVycm9yIikgewogICAgICAgIGVycm9yID0gbmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KGRhdGEuZXJyb3IubWVzc2FnZSk7CiAgICAgICAgZXJyb3Iuc3RhY2sgPSBkYXRhLmVycm9yLnN0YWNrOwogICAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICJEZXZlbG9wZXJFcnJvciIpIHsKICAgICAgICBlcnJvciA9IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KGRhdGEuZXJyb3IubWVzc2FnZSk7CiAgICAgICAgZXJyb3Iuc3RhY2sgPSBkYXRhLmVycm9yLnN0YWNrOwogICAgICB9CiAgICAgIHRhc2tDb21wbGV0ZWRFdmVudC5yYWlzZUV2ZW50KGVycm9yKTsKICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTsKICAgIH0gZWxzZSB7CiAgICAgIHRhc2tDb21wbGV0ZWRFdmVudC5yYWlzZUV2ZW50KCk7CiAgICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YS5yZXN1bHQpOwogICAgfQogICAgZGVsZXRlIGRlZmVycmVkc1tpZF07CiAgfQogIGZ1bmN0aW9uIGdldFdvcmtlclVybChtb2R1bGVJRCkgewogICAgbGV0IHVybCA9IGJ1aWxkTW9kdWxlVXJsX2RlZmF1bHQobW9kdWxlSUQpOwogICAgaWYgKGlzQ3Jvc3NPcmlnaW5VcmxfZGVmYXVsdCh1cmwpKSB7CiAgICAgIGNvbnN0IHNjcmlwdCA9IGBpbXBvcnRTY3JpcHRzKCIke3VybH0iKTtgOwogICAgICBsZXQgYmxvYjsKICAgICAgdHJ5IHsKICAgICAgICBibG9iID0gbmV3IEJsb2IoW3NjcmlwdF0sIHsKICAgICAgICAgIHR5cGU6ICJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IgogICAgICAgIH0pOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY29uc3QgQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcjsKICAgICAgICBjb25zdCBibG9iQnVpbGRlciA9IG5ldyBCbG9iQnVpbGRlcigpOwogICAgICAgIGJsb2JCdWlsZGVyLmFwcGVuZChzY3JpcHQpOwogICAgICAgIGJsb2IgPSBibG9iQnVpbGRlci5nZXRCbG9iKCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Iik7CiAgICAgIH0KICAgICAgY29uc3QgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMOwogICAgICB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpOwogICAgfQogICAgcmV0dXJuIHVybDsKICB9CiAgdmFyIGJvb3RzdHJhcHBlclVybFJlc3VsdDsKICBmdW5jdGlvbiBnZXRCb290c3RyYXBwZXJVcmwoKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChib290c3RyYXBwZXJVcmxSZXN1bHQpKSB7CiAgICAgIGJvb3RzdHJhcHBlclVybFJlc3VsdCA9IGdldFdvcmtlclVybCgiV29ya2Vycy9jZXNpdW1Xb3JrZXJCb290c3RyYXBwZXIuanMiKTsKICAgIH0KICAgIHJldHVybiBib290c3RyYXBwZXJVcmxSZXN1bHQ7CiAgfQogIGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihwcm9jZXNzb3IpIHsKICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoZ2V0Qm9vdHN0cmFwcGVyVXJsKCkpOwogICAgd29ya2VyLnBvc3RNZXNzYWdlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIHdvcmtlci53ZWJraXRQb3N0TWVzc2FnZSwKICAgICAgd29ya2VyLnBvc3RNZXNzYWdlCiAgICApOwogICAgY29uc3QgYm9vdHN0cmFwTWVzc2FnZSA9IHsKICAgICAgbG9hZGVyQ29uZmlnOiB7CiAgICAgICAgcGF0aHM6IHsKICAgICAgICAgIFdvcmtlcnM6IGJ1aWxkTW9kdWxlVXJsX2RlZmF1bHQoIldvcmtlcnMiKQogICAgICAgIH0sCiAgICAgICAgYmFzZVVybDogYnVpbGRNb2R1bGVVcmxfZGVmYXVsdC5nZXRDZXNpdW1CYXNlVXJsKCkudXJsCiAgICAgIH0sCiAgICAgIHdvcmtlck1vZHVsZTogcHJvY2Vzc29yLl93b3JrZXJQYXRoCiAgICB9OwogICAgd29ya2VyLnBvc3RNZXNzYWdlKGJvb3RzdHJhcE1lc3NhZ2UpOwogICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7CiAgICAgIGNvbXBsZXRlVGFzayhwcm9jZXNzb3IsIGV2ZW50LmRhdGEpOwogICAgfTsKICAgIHJldHVybiB3b3JrZXI7CiAgfQogIGZ1bmN0aW9uIGdldFdlYkFzc2VtYmx5TG9hZGVyQ29uZmlnKHByb2Nlc3Nvciwgd2FzbU9wdGlvbnMpIHsKICAgIGNvbnN0IGNvbmZpZyA9IHsKICAgICAgbW9kdWxlUGF0aDogdm9pZCAwLAogICAgICB3YXNtQmluYXJ5RmlsZTogdm9pZCAwLAogICAgICB3YXNtQmluYXJ5OiB2b2lkIDAKICAgIH07CiAgICBpZiAoIUZlYXR1cmVEZXRlY3Rpb25fZGVmYXVsdC5zdXBwb3J0c1dlYkFzc2VtYmx5KCkpIHsKICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQod2FzbU9wdGlvbnMuZmFsbGJhY2tNb2R1bGVQYXRoKSkgewogICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3JfZGVmYXVsdCgKICAgICAgICAgIGBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWIgQXNzZW1ibHksIGFuZCBubyBiYWNrdXAgbW9kdWxlIHdhcyBwcm92aWRlZCBmb3IgJHtwcm9jZXNzb3IuX3dvcmtlclBhdGh9YAogICAgICAgICk7CiAgICAgIH0KICAgICAgY29uZmlnLm1vZHVsZVBhdGggPSBidWlsZE1vZHVsZVVybF9kZWZhdWx0KHdhc21PcHRpb25zLmZhbGxiYWNrTW9kdWxlUGF0aCk7CiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29uZmlnKTsKICAgIH0KICAgIGNvbmZpZy5tb2R1bGVQYXRoID0gYnVpbGRNb2R1bGVVcmxfZGVmYXVsdCh3YXNtT3B0aW9ucy5tb2R1bGVQYXRoKTsKICAgIGNvbmZpZy53YXNtQmluYXJ5RmlsZSA9IGJ1aWxkTW9kdWxlVXJsX2RlZmF1bHQod2FzbU9wdGlvbnMud2FzbUJpbmFyeUZpbGUpOwogICAgcmV0dXJuIFJlc291cmNlX2RlZmF1bHQuZmV0Y2hBcnJheUJ1ZmZlcih7CiAgICAgIHVybDogY29uZmlnLndhc21CaW5hcnlGaWxlCiAgICB9KS50aGVuKGZ1bmN0aW9uKGFycmF5QnVmZmVyKSB7CiAgICAgIGNvbmZpZy53YXNtQmluYXJ5ID0gYXJyYXlCdWZmZXI7CiAgICAgIHJldHVybiBjb25maWc7CiAgICB9KTsKICB9CiAgZnVuY3Rpb24gVGFza1Byb2Nlc3Nvcih3b3JrZXJQYXRoLCBtYXhpbXVtQWN0aXZlVGFza3MpIHsKICAgIGNvbnN0IHVyaSA9IG5ldyBpbXBvcnRfdXJpanM3LmRlZmF1bHQod29ya2VyUGF0aCk7CiAgICB0aGlzLl93b3JrZXJQYXRoID0gdXJpLnNjaGVtZSgpLmxlbmd0aCAhPT0gMCAmJiB1cmkuZnJhZ21lbnQoKS5sZW5ndGggPT09IDAgPyB3b3JrZXJQYXRoIDogVGFza1Byb2Nlc3Nvci5fd29ya2VyTW9kdWxlUHJlZml4ICsgd29ya2VyUGF0aDsKICAgIHRoaXMuX21heGltdW1BY3RpdmVUYXNrcyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBtYXhpbXVtQWN0aXZlVGFza3MsCiAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWQogICAgKTsKICAgIHRoaXMuX2FjdGl2ZVRhc2tzID0gMDsKICAgIHRoaXMuX2RlZmVycmVkcyA9IHt9OwogICAgdGhpcy5fbmV4dElEID0gMDsKICB9CiAgdmFyIGVtcHR5VHJhbnNmZXJhYmxlT2JqZWN0QXJyYXkgPSBbXTsKICBUYXNrUHJvY2Vzc29yLnByb3RvdHlwZS5zY2hlZHVsZVRhc2sgPSBmdW5jdGlvbihwYXJhbWV0ZXJzLCB0cmFuc2ZlcmFibGVPYmplY3RzKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh0aGlzLl93b3JrZXIpKSB7CiAgICAgIHRoaXMuX3dvcmtlciA9IGNyZWF0ZVdvcmtlcih0aGlzKTsKICAgIH0KICAgIGlmICh0aGlzLl9hY3RpdmVUYXNrcyA+PSB0aGlzLl9tYXhpbXVtQWN0aXZlVGFza3MpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgICsrdGhpcy5fYWN0aXZlVGFza3M7CiAgICBjb25zdCBwcm9jZXNzb3IgPSB0aGlzOwogICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYW5UcmFuc2ZlckFycmF5QnVmZmVyKCkpLnRoZW4oZnVuY3Rpb24oY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcjIpIHsKICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodHJhbnNmZXJhYmxlT2JqZWN0cykpIHsKICAgICAgICB0cmFuc2ZlcmFibGVPYmplY3RzID0gZW1wdHlUcmFuc2ZlcmFibGVPYmplY3RBcnJheTsKICAgICAgfSBlbHNlIGlmICghY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcjIpIHsKICAgICAgICB0cmFuc2ZlcmFibGVPYmplY3RzLmxlbmd0aCA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaWQgPSBwcm9jZXNzb3IuX25leHRJRCsrOwogICAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyX2RlZmF1bHQoKTsKICAgICAgcHJvY2Vzc29yLl9kZWZlcnJlZHNbaWRdID0gZGVmZXJyZWQ7CiAgICAgIHByb2Nlc3Nvci5fd29ya2VyLnBvc3RNZXNzYWdlKAogICAgICAgIHsKICAgICAgICAgIGlkLAogICAgICAgICAgcGFyYW1ldGVycywKICAgICAgICAgIGNhblRyYW5zZmVyQXJyYXlCdWZmZXI6IGNhblRyYW5zZmVyQXJyYXlCdWZmZXIyCiAgICAgICAgfSwKICAgICAgICB0cmFuc2ZlcmFibGVPYmplY3RzCiAgICAgICk7CiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlOwogICAgfSk7CiAgfTsKICBUYXNrUHJvY2Vzc29yLnByb3RvdHlwZS5pbml0V2ViQXNzZW1ibHlNb2R1bGUgPSBmdW5jdGlvbih3ZWJBc3NlbWJseU9wdGlvbnMpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRoaXMuX3dvcmtlcikpIHsKICAgICAgdGhpcy5fd29ya2VyID0gY3JlYXRlV29ya2VyKHRoaXMpOwogICAgfQogICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcl9kZWZhdWx0KCk7CiAgICBjb25zdCBwcm9jZXNzb3IgPSB0aGlzOwogICAgY29uc3Qgd29ya2VyID0gdGhpcy5fd29ya2VyOwogICAgZ2V0V2ViQXNzZW1ibHlMb2FkZXJDb25maWcodGhpcywgd2ViQXNzZW1ibHlPcHRpb25zKS50aGVuKGZ1bmN0aW9uKHdhc21Db25maWcpIHsKICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYW5UcmFuc2ZlckFycmF5QnVmZmVyKCkpLnRoZW4oZnVuY3Rpb24oY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcjIpIHsKICAgICAgICBsZXQgdHJhbnNmZXJhYmxlT2JqZWN0czsKICAgICAgICBjb25zdCBiaW5hcnkgPSB3YXNtQ29uZmlnLndhc21CaW5hcnk7CiAgICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChiaW5hcnkpICYmIGNhblRyYW5zZmVyQXJyYXlCdWZmZXIyKSB7CiAgICAgICAgICB0cmFuc2ZlcmFibGVPYmplY3RzID0gW2JpbmFyeV07CiAgICAgICAgfQogICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkgewogICAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50MikgewogICAgICAgICAgICBjb21wbGV0ZVRhc2socHJvY2Vzc29yLCBldmVudDIuZGF0YSk7CiAgICAgICAgICB9OwogICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShldmVudC5kYXRhKTsKICAgICAgICB9OwogICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSgKICAgICAgICAgIHsgd2ViQXNzZW1ibHlDb25maWc6IHdhc21Db25maWcgfSwKICAgICAgICAgIHRyYW5zZmVyYWJsZU9iamVjdHMKICAgICAgICApOwogICAgICB9KTsKICAgIH0pOwogICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7CiAgfTsKICBUYXNrUHJvY2Vzc29yLnByb3RvdHlwZS5pc0Rlc3Ryb3llZCA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIGZhbHNlOwogIH07CiAgVGFza1Byb2Nlc3Nvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkgewogICAgaWYgKGRlZmluZWRfZGVmYXVsdCh0aGlzLl93b3JrZXIpKSB7CiAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTsKICAgIH0KICAgIHJldHVybiBkZXN0cm95T2JqZWN0X2RlZmF1bHQodGhpcyk7CiAgfTsKICBUYXNrUHJvY2Vzc29yLnRhc2tDb21wbGV0ZWRFdmVudCA9IHRhc2tDb21wbGV0ZWRFdmVudDsKICBUYXNrUHJvY2Vzc29yLl9kZWZhdWx0V29ya2VyTW9kdWxlUHJlZml4ID0gIldvcmtlcnMvIjsKICBUYXNrUHJvY2Vzc29yLl93b3JrZXJNb2R1bGVQcmVmaXggPSBUYXNrUHJvY2Vzc29yLl9kZWZhdWx0V29ya2VyTW9kdWxlUHJlZml4OwogIFRhc2tQcm9jZXNzb3IuX2NhblRyYW5zZmVyQXJyYXlCdWZmZXIgPSB2b2lkIDA7CiAgdmFyIFRhc2tQcm9jZXNzb3JfZGVmYXVsdCA9IFRhc2tQcm9jZXNzb3I7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9QbGFuZS5qcwogIGZ1bmN0aW9uIFBsYW5lKG5vcm1hbCwgZGlzdGFuY2UpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibm9ybWFsIiwgbm9ybWFsKTsKICAgIGlmICghTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUobm9ybWFsKSwKICAgICAgMSwKICAgICAgTWF0aF9kZWZhdWx0LkVQU0lMT042CiAgICApKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJub3JtYWwgbXVzdCBiZSBub3JtYWxpemVkLiIpOwogICAgfQogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJkaXN0YW5jZSIsIGRpc3RhbmNlKTsKICAgIHRoaXMubm9ybWFsID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKG5vcm1hbCk7CiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7CiAgfQogIFBsYW5lLmZyb21Qb2ludE5vcm1hbCA9IGZ1bmN0aW9uKHBvaW50LCBub3JtYWwsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJwb2ludCIsIHBvaW50KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibm9ybWFsIiwgbm9ybWFsKTsKICAgIGlmICghTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUobm9ybWFsKSwKICAgICAgMSwKICAgICAgTWF0aF9kZWZhdWx0LkVQU0lMT042CiAgICApKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJub3JtYWwgbXVzdCBiZSBub3JtYWxpemVkLiIpOwogICAgfQogICAgY29uc3QgZGlzdGFuY2UgPSAtQ2FydGVzaWFuM19kZWZhdWx0LmRvdChub3JtYWwsIHBvaW50KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBQbGFuZShub3JtYWwsIGRpc3RhbmNlKTsKICAgIH0KICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShub3JtYWwsIHJlc3VsdC5ub3JtYWwpOwogICAgcmVzdWx0LmRpc3RhbmNlID0gZGlzdGFuY2U7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjcmF0Y2hOb3JtYWwgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgUGxhbmUuZnJvbUNhcnRlc2lhbjQgPSBmdW5jdGlvbihjb2VmZmljaWVudHMsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjb2VmZmljaWVudHMiLCBjb2VmZmljaWVudHMpOwogICAgY29uc3Qgbm9ybWFsID0gQ2FydGVzaWFuM19kZWZhdWx0LmZyb21DYXJ0ZXNpYW40KGNvZWZmaWNpZW50cywgc2NyYXRjaE5vcm1hbCk7CiAgICBjb25zdCBkaXN0YW5jZSA9IGNvZWZmaWNpZW50cy53OwogICAgaWYgKCFNYXRoX2RlZmF1bHQuZXF1YWxzRXBzaWxvbigKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZShub3JtYWwpLAogICAgICAxLAogICAgICBNYXRoX2RlZmF1bHQuRVBTSUxPTjYKICAgICkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm5vcm1hbCBtdXN0IGJlIG5vcm1hbGl6ZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgUGxhbmUobm9ybWFsLCBkaXN0YW5jZSk7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUobm9ybWFsLCByZXN1bHQubm9ybWFsKTsKICAgIHJlc3VsdC5kaXN0YW5jZSA9IGRpc3RhbmNlOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFBsYW5lLmdldFBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbihwbGFuZSwgcG9pbnQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicGxhbmUiLCBwbGFuZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInBvaW50IiwgcG9pbnQpOwogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5kb3QocGxhbmUubm9ybWFsLCBwb2ludCkgKyBwbGFuZS5kaXN0YW5jZTsKICB9OwogIHZhciBzY3JhdGNoQ2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIFBsYW5lLnByb2plY3RQb2ludE9udG9QbGFuZSA9IGZ1bmN0aW9uKHBsYW5lLCBwb2ludCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInBsYW5lIiwgcGxhbmUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJwb2ludCIsIHBvaW50KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogICAgfQogICAgY29uc3QgcG9pbnREaXN0YW5jZSA9IFBsYW5lLmdldFBvaW50RGlzdGFuY2UocGxhbmUsIHBvaW50KTsKICAgIGNvbnN0IHNjYWxlZE5vcm1hbCA9IENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGFyKAogICAgICBwbGFuZS5ub3JtYWwsCiAgICAgIHBvaW50RGlzdGFuY2UsCiAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW4KICAgICk7CiAgICByZXR1cm4gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHBvaW50LCBzY2FsZWROb3JtYWwsIHJlc3VsdCk7CiAgfTsKICB2YXIgc2NyYXRjaEludmVyc2VUcmFuc3Bvc2UgPSBuZXcgTWF0cml4NF9kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQbGFuZUNhcnRlc2lhbjQgPSBuZXcgQ2FydGVzaWFuNF9kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hUcmFuc2Zvcm1Ob3JtYWwgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgUGxhbmUudHJhbnNmb3JtID0gZnVuY3Rpb24ocGxhbmUsIHRyYW5zZm9ybSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInBsYW5lIiwgcGxhbmUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2Zvcm0iLCB0cmFuc2Zvcm0pOwogICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsOwogICAgY29uc3QgZGlzdGFuY2UgPSBwbGFuZS5kaXN0YW5jZTsKICAgIGNvbnN0IGludmVyc2VUcmFuc3Bvc2UgPSBNYXRyaXg0X2RlZmF1bHQuaW52ZXJzZVRyYW5zcG9zZSgKICAgICAgdHJhbnNmb3JtLAogICAgICBzY3JhdGNoSW52ZXJzZVRyYW5zcG9zZQogICAgKTsKICAgIGxldCBwbGFuZUFzQ2FydGVzaWFuNCA9IENhcnRlc2lhbjRfZGVmYXVsdC5mcm9tRWxlbWVudHMoCiAgICAgIG5vcm1hbC54LAogICAgICBub3JtYWwueSwKICAgICAgbm9ybWFsLnosCiAgICAgIGRpc3RhbmNlLAogICAgICBzY3JhdGNoUGxhbmVDYXJ0ZXNpYW40CiAgICApOwogICAgcGxhbmVBc0NhcnRlc2lhbjQgPSBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHlCeVZlY3RvcigKICAgICAgaW52ZXJzZVRyYW5zcG9zZSwKICAgICAgcGxhbmVBc0NhcnRlc2lhbjQsCiAgICAgIHBsYW5lQXNDYXJ0ZXNpYW40CiAgICApOwogICAgY29uc3QgdHJhbnNmb3JtZWROb3JtYWwgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbUNhcnRlc2lhbjQoCiAgICAgIHBsYW5lQXNDYXJ0ZXNpYW40LAogICAgICBzY3JhdGNoVHJhbnNmb3JtTm9ybWFsCiAgICApOwogICAgcGxhbmVBc0NhcnRlc2lhbjQgPSBDYXJ0ZXNpYW40X2RlZmF1bHQuZGl2aWRlQnlTY2FsYXIoCiAgICAgIHBsYW5lQXNDYXJ0ZXNpYW40LAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKHRyYW5zZm9ybWVkTm9ybWFsKSwKICAgICAgcGxhbmVBc0NhcnRlc2lhbjQKICAgICk7CiAgICByZXR1cm4gUGxhbmUuZnJvbUNhcnRlc2lhbjQocGxhbmVBc0NhcnRlc2lhbjQsIHJlc3VsdCk7CiAgfTsKICBQbGFuZS5jbG9uZSA9IGZ1bmN0aW9uKHBsYW5lLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicGxhbmUiLCBwbGFuZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgUGxhbmUocGxhbmUubm9ybWFsLCBwbGFuZS5kaXN0YW5jZSk7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUocGxhbmUubm9ybWFsLCByZXN1bHQubm9ybWFsKTsKICAgIHJlc3VsdC5kaXN0YW5jZSA9IHBsYW5lLmRpc3RhbmNlOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFBsYW5lLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImxlZnQiLCBsZWZ0KTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicmlnaHQiLCByaWdodCk7CiAgICByZXR1cm4gbGVmdC5kaXN0YW5jZSA9PT0gcmlnaHQuZGlzdGFuY2UgJiYgQ2FydGVzaWFuM19kZWZhdWx0LmVxdWFscyhsZWZ0Lm5vcm1hbCwgcmlnaHQubm9ybWFsKTsKICB9OwogIFBsYW5lLk9SSUdJTl9YWV9QTEFORSA9IE9iamVjdC5mcmVlemUobmV3IFBsYW5lKENhcnRlc2lhbjNfZGVmYXVsdC5VTklUX1osIDApKTsKICBQbGFuZS5PUklHSU5fWVpfUExBTkUgPSBPYmplY3QuZnJlZXplKG5ldyBQbGFuZShDYXJ0ZXNpYW4zX2RlZmF1bHQuVU5JVF9YLCAwKSk7CiAgUGxhbmUuT1JJR0lOX1pYX1BMQU5FID0gT2JqZWN0LmZyZWV6ZShuZXcgUGxhbmUoQ2FydGVzaWFuM19kZWZhdWx0LlVOSVRfWSwgMCkpOwogIHZhciBQbGFuZV9kZWZhdWx0ID0gUGxhbmU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9JbnRlcnZhbC5qcwogIGZ1bmN0aW9uIEludGVydmFsKHN0YXJ0LCBzdG9wKSB7CiAgICB0aGlzLnN0YXJ0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RhcnQsIDApOwogICAgdGhpcy5zdG9wID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RvcCwgMCk7CiAgfQogIHZhciBJbnRlcnZhbF9kZWZhdWx0ID0gSW50ZXJ2YWw7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9Cb3VuZGluZ1NwaGVyZS5qcwogIGZ1bmN0aW9uIEJvdW5kaW5nU3BoZXJlKGNlbnRlciwgcmFkaXVzKSB7CiAgICB0aGlzLmNlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShkZWZhdWx0VmFsdWVfZGVmYXVsdChjZW50ZXIsIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPKSk7CiAgICB0aGlzLnJhZGl1cyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHJhZGl1cywgMCk7CiAgfQogIHZhciBmcm9tUG9pbnRzWE1pbiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZnJvbVBvaW50c1lNaW4gPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIGZyb21Qb2ludHNaTWluID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBmcm9tUG9pbnRzWE1heCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZnJvbVBvaW50c1lNYXggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIGZyb21Qb2ludHNaTWF4ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBmcm9tUG9pbnRzQ3VycmVudFBvcyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZnJvbVBvaW50c1NjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIGZyb21Qb2ludHNSaXR0ZXJDZW50ZXIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIGZyb21Qb2ludHNNaW5Cb3hQdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZnJvbVBvaW50c01heEJveFB0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBmcm9tUG9pbnRzTmFpdmVDZW50ZXJTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciB2b2x1bWVDb25zdGFudCA9IDQgLyAzICogTWF0aF9kZWZhdWx0LlBJOwogIEJvdW5kaW5nU3BoZXJlLmZyb21Qb2ludHMgPSBmdW5jdGlvbihwb3NpdGlvbnMsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBvc2l0aW9ucykgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkgewogICAgICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCByZXN1bHQuY2VudGVyKTsKICAgICAgcmVzdWx0LnJhZGl1cyA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBjb25zdCBjdXJyZW50UG9zID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKHBvc2l0aW9uc1swXSwgZnJvbVBvaW50c0N1cnJlbnRQb3MpOwogICAgY29uc3QgeE1pbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCBmcm9tUG9pbnRzWE1pbik7CiAgICBjb25zdCB5TWluID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIGZyb21Qb2ludHNZTWluKTsKICAgIGNvbnN0IHpNaW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgZnJvbVBvaW50c1pNaW4pOwogICAgY29uc3QgeE1heCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCBmcm9tUG9pbnRzWE1heCk7CiAgICBjb25zdCB5TWF4ID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIGZyb21Qb2ludHNZTWF4KTsKICAgIGNvbnN0IHpNYXggPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgZnJvbVBvaW50c1pNYXgpOwogICAgY29uc3QgbnVtUG9zaXRpb25zID0gcG9zaXRpb25zLmxlbmd0aDsKICAgIGxldCBpOwogICAgZm9yIChpID0gMTsgaSA8IG51bVBvc2l0aW9uczsgaSsrKSB7CiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShwb3NpdGlvbnNbaV0sIGN1cnJlbnRQb3MpOwogICAgICBjb25zdCB4ID0gY3VycmVudFBvcy54OwogICAgICBjb25zdCB5ID0gY3VycmVudFBvcy55OwogICAgICBjb25zdCB6ID0gY3VycmVudFBvcy56OwogICAgICBpZiAoeCA8IHhNaW4ueCkgewogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCB4TWluKTsKICAgICAgfQogICAgICBpZiAoeCA+IHhNYXgueCkgewogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCB4TWF4KTsKICAgICAgfQogICAgICBpZiAoeSA8IHlNaW4ueSkgewogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCB5TWluKTsKICAgICAgfQogICAgICBpZiAoeSA+IHlNYXgueSkgewogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCB5TWF4KTsKICAgICAgfQogICAgICBpZiAoeiA8IHpNaW4ueikgewogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCB6TWluKTsKICAgICAgfQogICAgICBpZiAoeiA+IHpNYXgueikgewogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCB6TWF4KTsKICAgICAgfQogICAgfQogICAgY29uc3QgeFNwYW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlU3F1YXJlZCgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHhNYXgsIHhNaW4sIGZyb21Qb2ludHNTY3JhdGNoKQogICAgKTsKICAgIGNvbnN0IHlTcGFuID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdCh5TWF4LCB5TWluLCBmcm9tUG9pbnRzU2NyYXRjaCkKICAgICk7CiAgICBjb25zdCB6U3BhbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3Qoek1heCwgek1pbiwgZnJvbVBvaW50c1NjcmF0Y2gpCiAgICApOwogICAgbGV0IGRpYW1ldGVyMSA9IHhNaW47CiAgICBsZXQgZGlhbWV0ZXIyID0geE1heDsKICAgIGxldCBtYXhTcGFuID0geFNwYW47CiAgICBpZiAoeVNwYW4gPiBtYXhTcGFuKSB7CiAgICAgIG1heFNwYW4gPSB5U3BhbjsKICAgICAgZGlhbWV0ZXIxID0geU1pbjsKICAgICAgZGlhbWV0ZXIyID0geU1heDsKICAgIH0KICAgIGlmICh6U3BhbiA+IG1heFNwYW4pIHsKICAgICAgbWF4U3BhbiA9IHpTcGFuOwogICAgICBkaWFtZXRlcjEgPSB6TWluOwogICAgICBkaWFtZXRlcjIgPSB6TWF4OwogICAgfQogICAgY29uc3Qgcml0dGVyQ2VudGVyID0gZnJvbVBvaW50c1JpdHRlckNlbnRlcjsKICAgIHJpdHRlckNlbnRlci54ID0gKGRpYW1ldGVyMS54ICsgZGlhbWV0ZXIyLngpICogMC41OwogICAgcml0dGVyQ2VudGVyLnkgPSAoZGlhbWV0ZXIxLnkgKyBkaWFtZXRlcjIueSkgKiAwLjU7CiAgICByaXR0ZXJDZW50ZXIueiA9IChkaWFtZXRlcjEueiArIGRpYW1ldGVyMi56KSAqIDAuNTsKICAgIGxldCByYWRpdXNTcXVhcmVkID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChkaWFtZXRlcjIsIHJpdHRlckNlbnRlciwgZnJvbVBvaW50c1NjcmF0Y2gpCiAgICApOwogICAgbGV0IHJpdHRlclJhZGl1cyA9IE1hdGguc3FydChyYWRpdXNTcXVhcmVkKTsKICAgIGNvbnN0IG1pbkJveFB0ID0gZnJvbVBvaW50c01pbkJveFB0OwogICAgbWluQm94UHQueCA9IHhNaW4ueDsKICAgIG1pbkJveFB0LnkgPSB5TWluLnk7CiAgICBtaW5Cb3hQdC56ID0gek1pbi56OwogICAgY29uc3QgbWF4Qm94UHQgPSBmcm9tUG9pbnRzTWF4Qm94UHQ7CiAgICBtYXhCb3hQdC54ID0geE1heC54OwogICAgbWF4Qm94UHQueSA9IHlNYXgueTsKICAgIG1heEJveFB0LnogPSB6TWF4Lno7CiAgICBjb25zdCBuYWl2ZUNlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5taWRwb2ludCgKICAgICAgbWluQm94UHQsCiAgICAgIG1heEJveFB0LAogICAgICBmcm9tUG9pbnRzTmFpdmVDZW50ZXJTY3JhdGNoCiAgICApOwogICAgbGV0IG5haXZlUmFkaXVzID0gMDsKICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb3NpdGlvbnM7IGkrKykgewogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUocG9zaXRpb25zW2ldLCBjdXJyZW50UG9zKTsKICAgICAgY29uc3QgciA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUoCiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGN1cnJlbnRQb3MsIG5haXZlQ2VudGVyLCBmcm9tUG9pbnRzU2NyYXRjaCkKICAgICAgKTsKICAgICAgaWYgKHIgPiBuYWl2ZVJhZGl1cykgewogICAgICAgIG5haXZlUmFkaXVzID0gcjsKICAgICAgfQogICAgICBjb25zdCBvbGRDZW50ZXJUb1BvaW50U3F1YXJlZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKAogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjdXJyZW50UG9zLCByaXR0ZXJDZW50ZXIsIGZyb21Qb2ludHNTY3JhdGNoKQogICAgICApOwogICAgICBpZiAob2xkQ2VudGVyVG9Qb2ludFNxdWFyZWQgPiByYWRpdXNTcXVhcmVkKSB7CiAgICAgICAgY29uc3Qgb2xkQ2VudGVyVG9Qb2ludCA9IE1hdGguc3FydChvbGRDZW50ZXJUb1BvaW50U3F1YXJlZCk7CiAgICAgICAgcml0dGVyUmFkaXVzID0gKHJpdHRlclJhZGl1cyArIG9sZENlbnRlclRvUG9pbnQpICogMC41OwogICAgICAgIHJhZGl1c1NxdWFyZWQgPSByaXR0ZXJSYWRpdXMgKiByaXR0ZXJSYWRpdXM7CiAgICAgICAgY29uc3Qgb2xkVG9OZXcgPSBvbGRDZW50ZXJUb1BvaW50IC0gcml0dGVyUmFkaXVzOwogICAgICAgIHJpdHRlckNlbnRlci54ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci54ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLngpIC8gb2xkQ2VudGVyVG9Qb2ludDsKICAgICAgICByaXR0ZXJDZW50ZXIueSA9IChyaXR0ZXJSYWRpdXMgKiByaXR0ZXJDZW50ZXIueSArIG9sZFRvTmV3ICogY3VycmVudFBvcy55KSAvIG9sZENlbnRlclRvUG9pbnQ7CiAgICAgICAgcml0dGVyQ2VudGVyLnogPSAocml0dGVyUmFkaXVzICogcml0dGVyQ2VudGVyLnogKyBvbGRUb05ldyAqIGN1cnJlbnRQb3MueikgLyBvbGRDZW50ZXJUb1BvaW50OwogICAgICB9CiAgICB9CiAgICBpZiAocml0dGVyUmFkaXVzIDwgbmFpdmVSYWRpdXMpIHsKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKHJpdHRlckNlbnRlciwgcmVzdWx0LmNlbnRlcik7CiAgICAgIHJlc3VsdC5yYWRpdXMgPSByaXR0ZXJSYWRpdXM7CiAgICB9IGVsc2UgewogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUobmFpdmVDZW50ZXIsIHJlc3VsdC5jZW50ZXIpOwogICAgICByZXN1bHQucmFkaXVzID0gbmFpdmVSYWRpdXM7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIGRlZmF1bHRQcm9qZWN0aW9uID0gbmV3IEdlb2dyYXBoaWNQcm9qZWN0aW9uX2RlZmF1bHQoKTsKICB2YXIgZnJvbVJlY3RhbmdsZTJETG93ZXJMZWZ0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBmcm9tUmVjdGFuZ2xlMkRVcHBlclJpZ2h0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBmcm9tUmVjdGFuZ2xlMkRTb3V0aHdlc3QgPSBuZXcgQ2FydG9ncmFwaGljX2RlZmF1bHQoKTsKICB2YXIgZnJvbVJlY3RhbmdsZTJETm9ydGhlYXN0ID0gbmV3IENhcnRvZ3JhcGhpY19kZWZhdWx0KCk7CiAgQm91bmRpbmdTcGhlcmUuZnJvbVJlY3RhbmdsZTJEID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCBwcm9qZWN0aW9uLCByZXN1bHQpIHsKICAgIHJldHVybiBCb3VuZGluZ1NwaGVyZS5mcm9tUmVjdGFuZ2xlV2l0aEhlaWdodHMyRCgKICAgICAgcmVjdGFuZ2xlLAogICAgICBwcm9qZWN0aW9uLAogICAgICAwLAogICAgICAwLAogICAgICByZXN1bHQKICAgICk7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS5mcm9tUmVjdGFuZ2xlV2l0aEhlaWdodHMyRCA9IGZ1bmN0aW9uKHJlY3RhbmdsZSwgcHJvamVjdGlvbiwgbWluaW11bUhlaWdodCwgbWF4aW11bUhlaWdodCwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBCb3VuZGluZ1NwaGVyZSgpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVjdGFuZ2xlKSkgewogICAgICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCByZXN1bHQuY2VudGVyKTsKICAgICAgcmVzdWx0LnJhZGl1cyA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBwcm9qZWN0aW9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQocHJvamVjdGlvbiwgZGVmYXVsdFByb2plY3Rpb24pOwogICAgUmVjdGFuZ2xlX2RlZmF1bHQuc291dGh3ZXN0KHJlY3RhbmdsZSwgZnJvbVJlY3RhbmdsZTJEU291dGh3ZXN0KTsKICAgIGZyb21SZWN0YW5nbGUyRFNvdXRod2VzdC5oZWlnaHQgPSBtaW5pbXVtSGVpZ2h0OwogICAgUmVjdGFuZ2xlX2RlZmF1bHQubm9ydGhlYXN0KHJlY3RhbmdsZSwgZnJvbVJlY3RhbmdsZTJETm9ydGhlYXN0KTsKICAgIGZyb21SZWN0YW5nbGUyRE5vcnRoZWFzdC5oZWlnaHQgPSBtYXhpbXVtSGVpZ2h0OwogICAgY29uc3QgbG93ZXJMZWZ0ID0gcHJvamVjdGlvbi5wcm9qZWN0KAogICAgICBmcm9tUmVjdGFuZ2xlMkRTb3V0aHdlc3QsCiAgICAgIGZyb21SZWN0YW5nbGUyRExvd2VyTGVmdAogICAgKTsKICAgIGNvbnN0IHVwcGVyUmlnaHQgPSBwcm9qZWN0aW9uLnByb2plY3QoCiAgICAgIGZyb21SZWN0YW5nbGUyRE5vcnRoZWFzdCwKICAgICAgZnJvbVJlY3RhbmdsZTJEVXBwZXJSaWdodAogICAgKTsKICAgIGNvbnN0IHdpZHRoID0gdXBwZXJSaWdodC54IC0gbG93ZXJMZWZ0Lng7CiAgICBjb25zdCBoZWlnaHQgPSB1cHBlclJpZ2h0LnkgLSBsb3dlckxlZnQueTsKICAgIGNvbnN0IGVsZXZhdGlvbiA9IHVwcGVyUmlnaHQueiAtIGxvd2VyTGVmdC56OwogICAgcmVzdWx0LnJhZGl1cyA9IE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0ICsgZWxldmF0aW9uICogZWxldmF0aW9uKSAqIDAuNTsKICAgIGNvbnN0IGNlbnRlciA9IHJlc3VsdC5jZW50ZXI7CiAgICBjZW50ZXIueCA9IGxvd2VyTGVmdC54ICsgd2lkdGggKiAwLjU7CiAgICBjZW50ZXIueSA9IGxvd2VyTGVmdC55ICsgaGVpZ2h0ICogMC41OwogICAgY2VudGVyLnogPSBsb3dlckxlZnQueiArIGVsZXZhdGlvbiAqIDAuNTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgZnJvbVJlY3RhbmdsZTNEU2NyYXRjaCA9IFtdOwogIEJvdW5kaW5nU3BoZXJlLmZyb21SZWN0YW5nbGUzRCA9IGZ1bmN0aW9uKHJlY3RhbmdsZSwgZWxsaXBzb2lkLCBzdXJmYWNlSGVpZ2h0LCByZXN1bHQpIHsKICAgIGVsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGVsbGlwc29pZCwgRWxsaXBzb2lkX2RlZmF1bHQuV0dTODQpOwogICAgc3VyZmFjZUhlaWdodCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN1cmZhY2VIZWlnaHQsIDApOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlY3RhbmdsZSkpIHsKICAgICAgcmVzdWx0LmNlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTywgcmVzdWx0LmNlbnRlcik7CiAgICAgIHJlc3VsdC5yYWRpdXMgPSAwOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgY29uc3QgcG9zaXRpb25zID0gUmVjdGFuZ2xlX2RlZmF1bHQuc3Vic2FtcGxlKAogICAgICByZWN0YW5nbGUsCiAgICAgIGVsbGlwc29pZCwKICAgICAgc3VyZmFjZUhlaWdodCwKICAgICAgZnJvbVJlY3RhbmdsZTNEU2NyYXRjaAogICAgKTsKICAgIHJldHVybiBCb3VuZGluZ1NwaGVyZS5mcm9tUG9pbnRzKHBvc2l0aW9ucywgcmVzdWx0KTsKICB9OwogIEJvdW5kaW5nU3BoZXJlLmZyb21WZXJ0aWNlcyA9IGZ1bmN0aW9uKHBvc2l0aW9ucywgY2VudGVyLCBzdHJpZGUsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBvc2l0aW9ucykgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkgewogICAgICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCByZXN1bHQuY2VudGVyKTsKICAgICAgcmVzdWx0LnJhZGl1cyA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBjZW50ZXIgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjZW50ZXIsIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPKTsKICAgIHN0cmlkZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0cmlkZSwgMyk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscygic3RyaWRlIiwgc3RyaWRlLCAzKTsKICAgIGNvbnN0IGN1cnJlbnRQb3MgPSBmcm9tUG9pbnRzQ3VycmVudFBvczsKICAgIGN1cnJlbnRQb3MueCA9IHBvc2l0aW9uc1swXSArIGNlbnRlci54OwogICAgY3VycmVudFBvcy55ID0gcG9zaXRpb25zWzFdICsgY2VudGVyLnk7CiAgICBjdXJyZW50UG9zLnogPSBwb3NpdGlvbnNbMl0gKyBjZW50ZXIuejsKICAgIGNvbnN0IHhNaW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgZnJvbVBvaW50c1hNaW4pOwogICAgY29uc3QgeU1pbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCBmcm9tUG9pbnRzWU1pbik7CiAgICBjb25zdCB6TWluID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIGZyb21Qb2ludHNaTWluKTsKICAgIGNvbnN0IHhNYXggPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgZnJvbVBvaW50c1hNYXgpOwogICAgY29uc3QgeU1heCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCBmcm9tUG9pbnRzWU1heCk7CiAgICBjb25zdCB6TWF4ID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIGZyb21Qb2ludHNaTWF4KTsKICAgIGNvbnN0IG51bUVsZW1lbnRzID0gcG9zaXRpb25zLmxlbmd0aDsKICAgIGxldCBpOwogICAgZm9yIChpID0gMDsgaSA8IG51bUVsZW1lbnRzOyBpICs9IHN0cmlkZSkgewogICAgICBjb25zdCB4ID0gcG9zaXRpb25zW2ldICsgY2VudGVyLng7CiAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSArIDFdICsgY2VudGVyLnk7CiAgICAgIGNvbnN0IHogPSBwb3NpdGlvbnNbaSArIDJdICsgY2VudGVyLno7CiAgICAgIGN1cnJlbnRQb3MueCA9IHg7CiAgICAgIGN1cnJlbnRQb3MueSA9IHk7CiAgICAgIGN1cnJlbnRQb3MueiA9IHo7CiAgICAgIGlmICh4IDwgeE1pbi54KSB7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIHhNaW4pOwogICAgICB9CiAgICAgIGlmICh4ID4geE1heC54KSB7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIHhNYXgpOwogICAgICB9CiAgICAgIGlmICh5IDwgeU1pbi55KSB7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIHlNaW4pOwogICAgICB9CiAgICAgIGlmICh5ID4geU1heC55KSB7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIHlNYXgpOwogICAgICB9CiAgICAgIGlmICh6IDwgek1pbi56KSB7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIHpNaW4pOwogICAgICB9CiAgICAgIGlmICh6ID4gek1heC56KSB7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIHpNYXgpOwogICAgICB9CiAgICB9CiAgICBjb25zdCB4U3BhbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoeE1heCwgeE1pbiwgZnJvbVBvaW50c1NjcmF0Y2gpCiAgICApOwogICAgY29uc3QgeVNwYW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlU3F1YXJlZCgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHlNYXgsIHlNaW4sIGZyb21Qb2ludHNTY3JhdGNoKQogICAgKTsKICAgIGNvbnN0IHpTcGFuID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdCh6TWF4LCB6TWluLCBmcm9tUG9pbnRzU2NyYXRjaCkKICAgICk7CiAgICBsZXQgZGlhbWV0ZXIxID0geE1pbjsKICAgIGxldCBkaWFtZXRlcjIgPSB4TWF4OwogICAgbGV0IG1heFNwYW4gPSB4U3BhbjsKICAgIGlmICh5U3BhbiA+IG1heFNwYW4pIHsKICAgICAgbWF4U3BhbiA9IHlTcGFuOwogICAgICBkaWFtZXRlcjEgPSB5TWluOwogICAgICBkaWFtZXRlcjIgPSB5TWF4OwogICAgfQogICAgaWYgKHpTcGFuID4gbWF4U3BhbikgewogICAgICBtYXhTcGFuID0gelNwYW47CiAgICAgIGRpYW1ldGVyMSA9IHpNaW47CiAgICAgIGRpYW1ldGVyMiA9IHpNYXg7CiAgICB9CiAgICBjb25zdCByaXR0ZXJDZW50ZXIgPSBmcm9tUG9pbnRzUml0dGVyQ2VudGVyOwogICAgcml0dGVyQ2VudGVyLnggPSAoZGlhbWV0ZXIxLnggKyBkaWFtZXRlcjIueCkgKiAwLjU7CiAgICByaXR0ZXJDZW50ZXIueSA9IChkaWFtZXRlcjEueSArIGRpYW1ldGVyMi55KSAqIDAuNTsKICAgIHJpdHRlckNlbnRlci56ID0gKGRpYW1ldGVyMS56ICsgZGlhbWV0ZXIyLnopICogMC41OwogICAgbGV0IHJhZGl1c1NxdWFyZWQgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlU3F1YXJlZCgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGRpYW1ldGVyMiwgcml0dGVyQ2VudGVyLCBmcm9tUG9pbnRzU2NyYXRjaCkKICAgICk7CiAgICBsZXQgcml0dGVyUmFkaXVzID0gTWF0aC5zcXJ0KHJhZGl1c1NxdWFyZWQpOwogICAgY29uc3QgbWluQm94UHQgPSBmcm9tUG9pbnRzTWluQm94UHQ7CiAgICBtaW5Cb3hQdC54ID0geE1pbi54OwogICAgbWluQm94UHQueSA9IHlNaW4ueTsKICAgIG1pbkJveFB0LnogPSB6TWluLno7CiAgICBjb25zdCBtYXhCb3hQdCA9IGZyb21Qb2ludHNNYXhCb3hQdDsKICAgIG1heEJveFB0LnggPSB4TWF4Lng7CiAgICBtYXhCb3hQdC55ID0geU1heC55OwogICAgbWF4Qm94UHQueiA9IHpNYXguejsKICAgIGNvbnN0IG5haXZlQ2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1pZHBvaW50KAogICAgICBtaW5Cb3hQdCwKICAgICAgbWF4Qm94UHQsCiAgICAgIGZyb21Qb2ludHNOYWl2ZUNlbnRlclNjcmF0Y2gKICAgICk7CiAgICBsZXQgbmFpdmVSYWRpdXMgPSAwOwogICAgZm9yIChpID0gMDsgaSA8IG51bUVsZW1lbnRzOyBpICs9IHN0cmlkZSkgewogICAgICBjdXJyZW50UG9zLnggPSBwb3NpdGlvbnNbaV0gKyBjZW50ZXIueDsKICAgICAgY3VycmVudFBvcy55ID0gcG9zaXRpb25zW2kgKyAxXSArIGNlbnRlci55OwogICAgICBjdXJyZW50UG9zLnogPSBwb3NpdGlvbnNbaSArIDJdICsgY2VudGVyLno7CiAgICAgIGNvbnN0IHIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKAogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjdXJyZW50UG9zLCBuYWl2ZUNlbnRlciwgZnJvbVBvaW50c1NjcmF0Y2gpCiAgICAgICk7CiAgICAgIGlmIChyID4gbmFpdmVSYWRpdXMpIHsKICAgICAgICBuYWl2ZVJhZGl1cyA9IHI7CiAgICAgIH0KICAgICAgY29uc3Qgb2xkQ2VudGVyVG9Qb2ludFNxdWFyZWQgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlU3F1YXJlZCgKICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY3VycmVudFBvcywgcml0dGVyQ2VudGVyLCBmcm9tUG9pbnRzU2NyYXRjaCkKICAgICAgKTsKICAgICAgaWYgKG9sZENlbnRlclRvUG9pbnRTcXVhcmVkID4gcmFkaXVzU3F1YXJlZCkgewogICAgICAgIGNvbnN0IG9sZENlbnRlclRvUG9pbnQgPSBNYXRoLnNxcnQob2xkQ2VudGVyVG9Qb2ludFNxdWFyZWQpOwogICAgICAgIHJpdHRlclJhZGl1cyA9IChyaXR0ZXJSYWRpdXMgKyBvbGRDZW50ZXJUb1BvaW50KSAqIDAuNTsKICAgICAgICByYWRpdXNTcXVhcmVkID0gcml0dGVyUmFkaXVzICogcml0dGVyUmFkaXVzOwogICAgICAgIGNvbnN0IG9sZFRvTmV3ID0gb2xkQ2VudGVyVG9Qb2ludCAtIHJpdHRlclJhZGl1czsKICAgICAgICByaXR0ZXJDZW50ZXIueCA9IChyaXR0ZXJSYWRpdXMgKiByaXR0ZXJDZW50ZXIueCArIG9sZFRvTmV3ICogY3VycmVudFBvcy54KSAvIG9sZENlbnRlclRvUG9pbnQ7CiAgICAgICAgcml0dGVyQ2VudGVyLnkgPSAocml0dGVyUmFkaXVzICogcml0dGVyQ2VudGVyLnkgKyBvbGRUb05ldyAqIGN1cnJlbnRQb3MueSkgLyBvbGRDZW50ZXJUb1BvaW50OwogICAgICAgIHJpdHRlckNlbnRlci56ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci56ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLnopIC8gb2xkQ2VudGVyVG9Qb2ludDsKICAgICAgfQogICAgfQogICAgaWYgKHJpdHRlclJhZGl1cyA8IG5haXZlUmFkaXVzKSB7CiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShyaXR0ZXJDZW50ZXIsIHJlc3VsdC5jZW50ZXIpOwogICAgICByZXN1bHQucmFkaXVzID0gcml0dGVyUmFkaXVzOwogICAgfSBlbHNlIHsKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKG5haXZlQ2VudGVyLCByZXN1bHQuY2VudGVyKTsKICAgICAgcmVzdWx0LnJhZGl1cyA9IG5haXZlUmFkaXVzOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEJvdW5kaW5nU3BoZXJlLmZyb21FbmNvZGVkQ2FydGVzaWFuVmVydGljZXMgPSBmdW5jdGlvbihwb3NpdGlvbnNIaWdoLCBwb3NpdGlvbnNMb3csIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBvc2l0aW9uc0hpZ2gpIHx8ICFkZWZpbmVkX2RlZmF1bHQocG9zaXRpb25zTG93KSB8fCBwb3NpdGlvbnNIaWdoLmxlbmd0aCAhPT0gcG9zaXRpb25zTG93Lmxlbmd0aCB8fCBwb3NpdGlvbnNIaWdoLmxlbmd0aCA9PT0gMCkgewogICAgICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCByZXN1bHQuY2VudGVyKTsKICAgICAgcmVzdWx0LnJhZGl1cyA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBjb25zdCBjdXJyZW50UG9zID0gZnJvbVBvaW50c0N1cnJlbnRQb3M7CiAgICBjdXJyZW50UG9zLnggPSBwb3NpdGlvbnNIaWdoWzBdICsgcG9zaXRpb25zTG93WzBdOwogICAgY3VycmVudFBvcy55ID0gcG9zaXRpb25zSGlnaFsxXSArIHBvc2l0aW9uc0xvd1sxXTsKICAgIGN1cnJlbnRQb3MueiA9IHBvc2l0aW9uc0hpZ2hbMl0gKyBwb3NpdGlvbnNMb3dbMl07CiAgICBjb25zdCB4TWluID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIGZyb21Qb2ludHNYTWluKTsKICAgIGNvbnN0IHlNaW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgZnJvbVBvaW50c1lNaW4pOwogICAgY29uc3Qgek1pbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCBmcm9tUG9pbnRzWk1pbik7CiAgICBjb25zdCB4TWF4ID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGN1cnJlbnRQb3MsIGZyb21Qb2ludHNYTWF4KTsKICAgIGNvbnN0IHlNYXggPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgZnJvbVBvaW50c1lNYXgpOwogICAgY29uc3Qgek1heCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjdXJyZW50UG9zLCBmcm9tUG9pbnRzWk1heCk7CiAgICBjb25zdCBudW1FbGVtZW50cyA9IHBvc2l0aW9uc0hpZ2gubGVuZ3RoOwogICAgbGV0IGk7CiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7IGkgKz0gMykgewogICAgICBjb25zdCB4ID0gcG9zaXRpb25zSGlnaFtpXSArIHBvc2l0aW9uc0xvd1tpXTsKICAgICAgY29uc3QgeSA9IHBvc2l0aW9uc0hpZ2hbaSArIDFdICsgcG9zaXRpb25zTG93W2kgKyAxXTsKICAgICAgY29uc3QgeiA9IHBvc2l0aW9uc0hpZ2hbaSArIDJdICsgcG9zaXRpb25zTG93W2kgKyAyXTsKICAgICAgY3VycmVudFBvcy54ID0geDsKICAgICAgY3VycmVudFBvcy55ID0geTsKICAgICAgY3VycmVudFBvcy56ID0gejsKICAgICAgaWYgKHggPCB4TWluLngpIHsKICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgeE1pbik7CiAgICAgIH0KICAgICAgaWYgKHggPiB4TWF4LngpIHsKICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgeE1heCk7CiAgICAgIH0KICAgICAgaWYgKHkgPCB5TWluLnkpIHsKICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgeU1pbik7CiAgICAgIH0KICAgICAgaWYgKHkgPiB5TWF4LnkpIHsKICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgeU1heCk7CiAgICAgIH0KICAgICAgaWYgKHogPCB6TWluLnopIHsKICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgek1pbik7CiAgICAgIH0KICAgICAgaWYgKHogPiB6TWF4LnopIHsKICAgICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY3VycmVudFBvcywgek1heCk7CiAgICAgIH0KICAgIH0KICAgIGNvbnN0IHhTcGFuID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdCh4TWF4LCB4TWluLCBmcm9tUG9pbnRzU2NyYXRjaCkKICAgICk7CiAgICBjb25zdCB5U3BhbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoeU1heCwgeU1pbiwgZnJvbVBvaW50c1NjcmF0Y2gpCiAgICApOwogICAgY29uc3QgelNwYW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlU3F1YXJlZCgKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHpNYXgsIHpNaW4sIGZyb21Qb2ludHNTY3JhdGNoKQogICAgKTsKICAgIGxldCBkaWFtZXRlcjEgPSB4TWluOwogICAgbGV0IGRpYW1ldGVyMiA9IHhNYXg7CiAgICBsZXQgbWF4U3BhbiA9IHhTcGFuOwogICAgaWYgKHlTcGFuID4gbWF4U3BhbikgewogICAgICBtYXhTcGFuID0geVNwYW47CiAgICAgIGRpYW1ldGVyMSA9IHlNaW47CiAgICAgIGRpYW1ldGVyMiA9IHlNYXg7CiAgICB9CiAgICBpZiAoelNwYW4gPiBtYXhTcGFuKSB7CiAgICAgIG1heFNwYW4gPSB6U3BhbjsKICAgICAgZGlhbWV0ZXIxID0gek1pbjsKICAgICAgZGlhbWV0ZXIyID0gek1heDsKICAgIH0KICAgIGNvbnN0IHJpdHRlckNlbnRlciA9IGZyb21Qb2ludHNSaXR0ZXJDZW50ZXI7CiAgICByaXR0ZXJDZW50ZXIueCA9IChkaWFtZXRlcjEueCArIGRpYW1ldGVyMi54KSAqIDAuNTsKICAgIHJpdHRlckNlbnRlci55ID0gKGRpYW1ldGVyMS55ICsgZGlhbWV0ZXIyLnkpICogMC41OwogICAgcml0dGVyQ2VudGVyLnogPSAoZGlhbWV0ZXIxLnogKyBkaWFtZXRlcjIueikgKiAwLjU7CiAgICBsZXQgcmFkaXVzU3F1YXJlZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoZGlhbWV0ZXIyLCByaXR0ZXJDZW50ZXIsIGZyb21Qb2ludHNTY3JhdGNoKQogICAgKTsKICAgIGxldCByaXR0ZXJSYWRpdXMgPSBNYXRoLnNxcnQocmFkaXVzU3F1YXJlZCk7CiAgICBjb25zdCBtaW5Cb3hQdCA9IGZyb21Qb2ludHNNaW5Cb3hQdDsKICAgIG1pbkJveFB0LnggPSB4TWluLng7CiAgICBtaW5Cb3hQdC55ID0geU1pbi55OwogICAgbWluQm94UHQueiA9IHpNaW4uejsKICAgIGNvbnN0IG1heEJveFB0ID0gZnJvbVBvaW50c01heEJveFB0OwogICAgbWF4Qm94UHQueCA9IHhNYXgueDsKICAgIG1heEJveFB0LnkgPSB5TWF4Lnk7CiAgICBtYXhCb3hQdC56ID0gek1heC56OwogICAgY29uc3QgbmFpdmVDZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWlkcG9pbnQoCiAgICAgIG1pbkJveFB0LAogICAgICBtYXhCb3hQdCwKICAgICAgZnJvbVBvaW50c05haXZlQ2VudGVyU2NyYXRjaAogICAgKTsKICAgIGxldCBuYWl2ZVJhZGl1cyA9IDA7CiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7IGkgKz0gMykgewogICAgICBjdXJyZW50UG9zLnggPSBwb3NpdGlvbnNIaWdoW2ldICsgcG9zaXRpb25zTG93W2ldOwogICAgICBjdXJyZW50UG9zLnkgPSBwb3NpdGlvbnNIaWdoW2kgKyAxXSArIHBvc2l0aW9uc0xvd1tpICsgMV07CiAgICAgIGN1cnJlbnRQb3MueiA9IHBvc2l0aW9uc0hpZ2hbaSArIDJdICsgcG9zaXRpb25zTG93W2kgKyAyXTsKICAgICAgY29uc3QgciA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUoCiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGN1cnJlbnRQb3MsIG5haXZlQ2VudGVyLCBmcm9tUG9pbnRzU2NyYXRjaCkKICAgICAgKTsKICAgICAgaWYgKHIgPiBuYWl2ZVJhZGl1cykgewogICAgICAgIG5haXZlUmFkaXVzID0gcjsKICAgICAgfQogICAgICBjb25zdCBvbGRDZW50ZXJUb1BvaW50U3F1YXJlZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKAogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjdXJyZW50UG9zLCByaXR0ZXJDZW50ZXIsIGZyb21Qb2ludHNTY3JhdGNoKQogICAgICApOwogICAgICBpZiAob2xkQ2VudGVyVG9Qb2ludFNxdWFyZWQgPiByYWRpdXNTcXVhcmVkKSB7CiAgICAgICAgY29uc3Qgb2xkQ2VudGVyVG9Qb2ludCA9IE1hdGguc3FydChvbGRDZW50ZXJUb1BvaW50U3F1YXJlZCk7CiAgICAgICAgcml0dGVyUmFkaXVzID0gKHJpdHRlclJhZGl1cyArIG9sZENlbnRlclRvUG9pbnQpICogMC41OwogICAgICAgIHJhZGl1c1NxdWFyZWQgPSByaXR0ZXJSYWRpdXMgKiByaXR0ZXJSYWRpdXM7CiAgICAgICAgY29uc3Qgb2xkVG9OZXcgPSBvbGRDZW50ZXJUb1BvaW50IC0gcml0dGVyUmFkaXVzOwogICAgICAgIHJpdHRlckNlbnRlci54ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci54ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLngpIC8gb2xkQ2VudGVyVG9Qb2ludDsKICAgICAgICByaXR0ZXJDZW50ZXIueSA9IChyaXR0ZXJSYWRpdXMgKiByaXR0ZXJDZW50ZXIueSArIG9sZFRvTmV3ICogY3VycmVudFBvcy55KSAvIG9sZENlbnRlclRvUG9pbnQ7CiAgICAgICAgcml0dGVyQ2VudGVyLnogPSAocml0dGVyUmFkaXVzICogcml0dGVyQ2VudGVyLnogKyBvbGRUb05ldyAqIGN1cnJlbnRQb3MueikgLyBvbGRDZW50ZXJUb1BvaW50OwogICAgICB9CiAgICB9CiAgICBpZiAocml0dGVyUmFkaXVzIDwgbmFpdmVSYWRpdXMpIHsKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKHJpdHRlckNlbnRlciwgcmVzdWx0LmNlbnRlcik7CiAgICAgIHJlc3VsdC5yYWRpdXMgPSByaXR0ZXJSYWRpdXM7CiAgICB9IGVsc2UgewogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUobmFpdmVDZW50ZXIsIHJlc3VsdC5jZW50ZXIpOwogICAgICByZXN1bHQucmFkaXVzID0gbmFpdmVSYWRpdXM7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQm91bmRpbmdTcGhlcmUuZnJvbUNvcm5lclBvaW50cyA9IGZ1bmN0aW9uKGNvcm5lciwgb3Bwb3NpdGVDb3JuZXIsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJjb3JuZXIiLCBjb3JuZXIpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJvcHBvc2l0ZUNvcm5lciIsIG9wcG9zaXRlQ29ybmVyKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEJvdW5kaW5nU3BoZXJlKCk7CiAgICB9CiAgICBjb25zdCBjZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWlkcG9pbnQoY29ybmVyLCBvcHBvc2l0ZUNvcm5lciwgcmVzdWx0LmNlbnRlcik7CiAgICByZXN1bHQucmFkaXVzID0gQ2FydGVzaWFuM19kZWZhdWx0LmRpc3RhbmNlKGNlbnRlciwgb3Bwb3NpdGVDb3JuZXIpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEJvdW5kaW5nU3BoZXJlLmZyb21FbGxpcHNvaWQgPSBmdW5jdGlvbihlbGxpcHNvaWQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJlbGxpcHNvaWQiLCBlbGxpcHNvaWQpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTywgcmVzdWx0LmNlbnRlcik7CiAgICByZXN1bHQucmFkaXVzID0gZWxsaXBzb2lkLm1heGltdW1SYWRpdXM7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIGZyb21Cb3VuZGluZ1NwaGVyZXNTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIEJvdW5kaW5nU3BoZXJlLmZyb21Cb3VuZGluZ1NwaGVyZXMgPSBmdW5jdGlvbihib3VuZGluZ1NwaGVyZXMsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJvdW5kaW5nU3BoZXJlcykgfHwgYm91bmRpbmdTcGhlcmVzLmxlbmd0aCA9PT0gMCkgewogICAgICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCByZXN1bHQuY2VudGVyKTsKICAgICAgcmVzdWx0LnJhZGl1cyA9IDA7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBjb25zdCBsZW5ndGggPSBib3VuZGluZ1NwaGVyZXMubGVuZ3RoOwogICAgaWYgKGxlbmd0aCA9PT0gMSkgewogICAgICByZXR1cm4gQm91bmRpbmdTcGhlcmUuY2xvbmUoYm91bmRpbmdTcGhlcmVzWzBdLCByZXN1bHQpOwogICAgfQogICAgaWYgKGxlbmd0aCA9PT0gMikgewogICAgICByZXR1cm4gQm91bmRpbmdTcGhlcmUudW5pb24oYm91bmRpbmdTcGhlcmVzWzBdLCBib3VuZGluZ1NwaGVyZXNbMV0sIHJlc3VsdCk7CiAgICB9CiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTsKICAgIGxldCBpOwogICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgIHBvc2l0aW9ucy5wdXNoKGJvdW5kaW5nU3BoZXJlc1tpXS5jZW50ZXIpOwogICAgfQogICAgcmVzdWx0ID0gQm91bmRpbmdTcGhlcmUuZnJvbVBvaW50cyhwb3NpdGlvbnMsIHJlc3VsdCk7CiAgICBjb25zdCBjZW50ZXIgPSByZXN1bHQuY2VudGVyOwogICAgbGV0IHJhZGl1cyA9IHJlc3VsdC5yYWRpdXM7CiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgdG1wMiA9IGJvdW5kaW5nU3BoZXJlc1tpXTsKICAgICAgcmFkaXVzID0gTWF0aC5tYXgoCiAgICAgICAgcmFkaXVzLAogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5kaXN0YW5jZShjZW50ZXIsIHRtcDIuY2VudGVyLCBmcm9tQm91bmRpbmdTcGhlcmVzU2NyYXRjaCkgKyB0bXAyLnJhZGl1cwogICAgICApOwogICAgfQogICAgcmVzdWx0LnJhZGl1cyA9IHJhZGl1czsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgZnJvbU9yaWVudGVkQm91bmRpbmdCb3hTY3JhdGNoVSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZnJvbU9yaWVudGVkQm91bmRpbmdCb3hTY3JhdGNoViA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZnJvbU9yaWVudGVkQm91bmRpbmdCb3hTY3JhdGNoVyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBCb3VuZGluZ1NwaGVyZS5mcm9tT3JpZW50ZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKG9yaWVudGVkQm91bmRpbmdCb3gsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJvcmllbnRlZEJvdW5kaW5nQm94Iiwgb3JpZW50ZWRCb3VuZGluZ0JveCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBCb3VuZGluZ1NwaGVyZSgpOwogICAgfQogICAgY29uc3QgaGFsZkF4ZXMgPSBvcmllbnRlZEJvdW5kaW5nQm94LmhhbGZBeGVzOwogICAgY29uc3QgdTIgPSBNYXRyaXgzX2RlZmF1bHQuZ2V0Q29sdW1uKGhhbGZBeGVzLCAwLCBmcm9tT3JpZW50ZWRCb3VuZGluZ0JveFNjcmF0Y2hVKTsKICAgIGNvbnN0IHYyID0gTWF0cml4M19kZWZhdWx0LmdldENvbHVtbihoYWxmQXhlcywgMSwgZnJvbU9yaWVudGVkQm91bmRpbmdCb3hTY3JhdGNoVik7CiAgICBjb25zdCB3ID0gTWF0cml4M19kZWZhdWx0LmdldENvbHVtbihoYWxmQXhlcywgMiwgZnJvbU9yaWVudGVkQm91bmRpbmdCb3hTY3JhdGNoVyk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHUyLCB2MiwgdTIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZCh1MiwgdywgdTIpOwogICAgcmVzdWx0LmNlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShvcmllbnRlZEJvdW5kaW5nQm94LmNlbnRlciwgcmVzdWx0LmNlbnRlcik7CiAgICByZXN1bHQucmFkaXVzID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZSh1Mik7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjcmF0Y2hGcm9tVHJhbnNmb3JtYXRpb25DZW50ZXIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hGcm9tVHJhbnNmb3JtYXRpb25TY2FsZSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBCb3VuZGluZ1NwaGVyZS5mcm9tVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbih0cmFuc2Zvcm1hdGlvbiwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInRyYW5zZm9ybWF0aW9uIiwgdHJhbnNmb3JtYXRpb24pOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIGNvbnN0IGNlbnRlciA9IE1hdHJpeDRfZGVmYXVsdC5nZXRUcmFuc2xhdGlvbigKICAgICAgdHJhbnNmb3JtYXRpb24sCiAgICAgIHNjcmF0Y2hGcm9tVHJhbnNmb3JtYXRpb25DZW50ZXIKICAgICk7CiAgICBjb25zdCBzY2FsZSA9IE1hdHJpeDRfZGVmYXVsdC5nZXRTY2FsZSgKICAgICAgdHJhbnNmb3JtYXRpb24sCiAgICAgIHNjcmF0Y2hGcm9tVHJhbnNmb3JtYXRpb25TY2FsZQogICAgKTsKICAgIGNvbnN0IHJhZGl1cyA9IDAuNSAqIENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUoc2NhbGUpOwogICAgcmVzdWx0LmNlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjZW50ZXIsIHJlc3VsdC5jZW50ZXIpOwogICAgcmVzdWx0LnJhZGl1cyA9IHJhZGl1czsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS5jbG9uZSA9IGZ1bmN0aW9uKHNwaGVyZSwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChzcGhlcmUpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQm91bmRpbmdTcGhlcmUoc3BoZXJlLmNlbnRlciwgc3BoZXJlLnJhZGl1cyk7CiAgICB9CiAgICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKHNwaGVyZS5jZW50ZXIsIHJlc3VsdC5jZW50ZXIpOwogICAgcmVzdWx0LnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQm91bmRpbmdTcGhlcmUucGFja2VkTGVuZ3RoID0gNDsKICBCb3VuZGluZ1NwaGVyZS5wYWNrID0gZnVuY3Rpb24odmFsdWUsIGFycmF5LCBzdGFydGluZ0luZGV4KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInZhbHVlIiwgdmFsdWUpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIGNvbnN0IGNlbnRlciA9IHZhbHVlLmNlbnRlcjsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSBjZW50ZXIueDsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSBjZW50ZXIueTsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSBjZW50ZXIuejsKICAgIGFycmF5W3N0YXJ0aW5nSW5kZXhdID0gdmFsdWUucmFkaXVzOwogICAgcmV0dXJuIGFycmF5OwogIH07CiAgQm91bmRpbmdTcGhlcmUudW5wYWNrID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEJvdW5kaW5nU3BoZXJlKCk7CiAgICB9CiAgICBjb25zdCBjZW50ZXIgPSByZXN1bHQuY2VudGVyOwogICAgY2VudGVyLnggPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgY2VudGVyLnkgPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgY2VudGVyLnogPSBhcnJheVtzdGFydGluZ0luZGV4KytdOwogICAgcmVzdWx0LnJhZGl1cyA9IGFycmF5W3N0YXJ0aW5nSW5kZXhdOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciB1bmlvblNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHVuaW9uU2NyYXRjaENlbnRlciA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBCb3VuZGluZ1NwaGVyZS51bmlvbiA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgibGVmdCIsIGxlZnQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyaWdodCIsIHJpZ2h0KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEJvdW5kaW5nU3BoZXJlKCk7CiAgICB9CiAgICBjb25zdCBsZWZ0Q2VudGVyID0gbGVmdC5jZW50ZXI7CiAgICBjb25zdCBsZWZ0UmFkaXVzID0gbGVmdC5yYWRpdXM7CiAgICBjb25zdCByaWdodENlbnRlciA9IHJpZ2h0LmNlbnRlcjsKICAgIGNvbnN0IHJpZ2h0UmFkaXVzID0gcmlnaHQucmFkaXVzOwogICAgY29uc3QgdG9SaWdodENlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdCgKICAgICAgcmlnaHRDZW50ZXIsCiAgICAgIGxlZnRDZW50ZXIsCiAgICAgIHVuaW9uU2NyYXRjaAogICAgKTsKICAgIGNvbnN0IGNlbnRlclNlcGFyYXRpb24gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKHRvUmlnaHRDZW50ZXIpOwogICAgaWYgKGxlZnRSYWRpdXMgPj0gY2VudGVyU2VwYXJhdGlvbiArIHJpZ2h0UmFkaXVzKSB7CiAgICAgIGxlZnQuY2xvbmUocmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIGlmIChyaWdodFJhZGl1cyA+PSBjZW50ZXJTZXBhcmF0aW9uICsgbGVmdFJhZGl1cykgewogICAgICByaWdodC5jbG9uZShyZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgY29uc3QgaGFsZkRpc3RhbmNlQmV0d2VlblRhbmdlbnRQb2ludHMgPSAobGVmdFJhZGl1cyArIGNlbnRlclNlcGFyYXRpb24gKyByaWdodFJhZGl1cykgKiAwLjU7CiAgICBjb25zdCBjZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgdG9SaWdodENlbnRlciwKICAgICAgKC1sZWZ0UmFkaXVzICsgaGFsZkRpc3RhbmNlQmV0d2VlblRhbmdlbnRQb2ludHMpIC8gY2VudGVyU2VwYXJhdGlvbiwKICAgICAgdW5pb25TY3JhdGNoQ2VudGVyCiAgICApOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjZW50ZXIsIGxlZnRDZW50ZXIsIGNlbnRlcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY2VudGVyLCByZXN1bHQuY2VudGVyKTsKICAgIHJlc3VsdC5yYWRpdXMgPSBoYWxmRGlzdGFuY2VCZXR3ZWVuVGFuZ2VudFBvaW50czsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgZXhwYW5kU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBCb3VuZGluZ1NwaGVyZS5leHBhbmQgPSBmdW5jdGlvbihzcGhlcmUsIHBvaW50LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic3BoZXJlIiwgc3BoZXJlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicG9pbnQiLCBwb2ludCk7CiAgICByZXN1bHQgPSBCb3VuZGluZ1NwaGVyZS5jbG9uZShzcGhlcmUsIHJlc3VsdCk7CiAgICBjb25zdCByYWRpdXMgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKAogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QocG9pbnQsIHJlc3VsdC5jZW50ZXIsIGV4cGFuZFNjcmF0Y2gpCiAgICApOwogICAgaWYgKHJhZGl1cyA+IHJlc3VsdC5yYWRpdXMpIHsKICAgICAgcmVzdWx0LnJhZGl1cyA9IHJhZGl1czsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS5pbnRlcnNlY3RQbGFuZSA9IGZ1bmN0aW9uKHNwaGVyZSwgcGxhbmUpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic3BoZXJlIiwgc3BoZXJlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgicGxhbmUiLCBwbGFuZSk7CiAgICBjb25zdCBjZW50ZXIgPSBzcGhlcmUuY2VudGVyOwogICAgY29uc3QgcmFkaXVzID0gc3BoZXJlLnJhZGl1czsKICAgIGNvbnN0IG5vcm1hbCA9IHBsYW5lLm5vcm1hbDsKICAgIGNvbnN0IGRpc3RhbmNlVG9QbGFuZSA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3Qobm9ybWFsLCBjZW50ZXIpICsgcGxhbmUuZGlzdGFuY2U7CiAgICBpZiAoZGlzdGFuY2VUb1BsYW5lIDwgLXJhZGl1cykgewogICAgICByZXR1cm4gSW50ZXJzZWN0X2RlZmF1bHQuT1VUU0lERTsKICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VUb1BsYW5lIDwgcmFkaXVzKSB7CiAgICAgIHJldHVybiBJbnRlcnNlY3RfZGVmYXVsdC5JTlRFUlNFQ1RJTkc7CiAgICB9CiAgICByZXR1cm4gSW50ZXJzZWN0X2RlZmF1bHQuSU5TSURFOwogIH07CiAgQm91bmRpbmdTcGhlcmUudHJhbnNmb3JtID0gZnVuY3Rpb24oc3BoZXJlLCB0cmFuc2Zvcm0sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzcGhlcmUiLCBzcGhlcmUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2Zvcm0iLCB0cmFuc2Zvcm0pOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTsKICAgIH0KICAgIHJlc3VsdC5jZW50ZXIgPSBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHlCeVBvaW50KAogICAgICB0cmFuc2Zvcm0sCiAgICAgIHNwaGVyZS5jZW50ZXIsCiAgICAgIHJlc3VsdC5jZW50ZXIKICAgICk7CiAgICByZXN1bHQucmFkaXVzID0gTWF0cml4NF9kZWZhdWx0LmdldE1heGltdW1TY2FsZSh0cmFuc2Zvcm0pICogc3BoZXJlLnJhZGl1czsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgZGlzdGFuY2VTcXVhcmVkVG9TY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIEJvdW5kaW5nU3BoZXJlLmRpc3RhbmNlU3F1YXJlZFRvID0gZnVuY3Rpb24oc3BoZXJlLCBjYXJ0ZXNpYW4pIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgic3BoZXJlIiwgc3BoZXJlKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIGNvbnN0IGRpZmYgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoCiAgICAgIHNwaGVyZS5jZW50ZXIsCiAgICAgIGNhcnRlc2lhbiwKICAgICAgZGlzdGFuY2VTcXVhcmVkVG9TY3JhdGNoCiAgICApOwogICAgY29uc3QgZGlzdGFuY2UgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKGRpZmYpIC0gc3BoZXJlLnJhZGl1czsKICAgIGlmIChkaXN0YW5jZSA8PSAwKSB7CiAgICAgIHJldHVybiAwOwogICAgfQogICAgcmV0dXJuIGRpc3RhbmNlICogZGlzdGFuY2U7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS50cmFuc2Zvcm1XaXRob3V0U2NhbGUgPSBmdW5jdGlvbihzcGhlcmUsIHRyYW5zZm9ybSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInNwaGVyZSIsIHNwaGVyZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInRyYW5zZm9ybSIsIHRyYW5zZm9ybSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBCb3VuZGluZ1NwaGVyZSgpOwogICAgfQogICAgcmVzdWx0LmNlbnRlciA9IE1hdHJpeDRfZGVmYXVsdC5tdWx0aXBseUJ5UG9pbnQoCiAgICAgIHRyYW5zZm9ybSwKICAgICAgc3BoZXJlLmNlbnRlciwKICAgICAgcmVzdWx0LmNlbnRlcgogICAgKTsKICAgIHJlc3VsdC5yYWRpdXMgPSBzcGhlcmUucmFkaXVzOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY3JhdGNoQ2FydGVzaWFuMyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBCb3VuZGluZ1NwaGVyZS5jb21wdXRlUGxhbmVEaXN0YW5jZXMgPSBmdW5jdGlvbihzcGhlcmUsIHBvc2l0aW9uLCBkaXJlY3Rpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzcGhlcmUiLCBzcGhlcmUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJwb3NpdGlvbiIsIHBvc2l0aW9uKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZGlyZWN0aW9uIiwgZGlyZWN0aW9uKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEludGVydmFsX2RlZmF1bHQoKTsKICAgIH0KICAgIGNvbnN0IHRvQ2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KAogICAgICBzcGhlcmUuY2VudGVyLAogICAgICBwb3NpdGlvbiwKICAgICAgc2NyYXRjaENhcnRlc2lhbjMKICAgICk7CiAgICBjb25zdCBtYWcgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KGRpcmVjdGlvbiwgdG9DZW50ZXIpOwogICAgcmVzdWx0LnN0YXJ0ID0gbWFnIC0gc3BoZXJlLnJhZGl1czsKICAgIHJlc3VsdC5zdG9wID0gbWFnICsgc3BoZXJlLnJhZGl1czsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgcHJvamVjdFRvMkROb3JtYWxTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBwcm9qZWN0VG8yREVhc3RTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBwcm9qZWN0VG8yRE5vcnRoU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgcHJvamVjdFRvMkRXZXN0U2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgcHJvamVjdFRvMkRTb3V0aFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHByb2plY3RUbzJEQ2FydG9ncmFwaGljU2NyYXRjaCA9IG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdCgpOwogIHZhciBwcm9qZWN0VG8yRFBvc2l0aW9uc1NjcmF0Y2ggPSBuZXcgQXJyYXkoOCk7CiAgZm9yIChsZXQgbiA9IDA7IG4gPCA4OyArK24pIHsKICAgIHByb2plY3RUbzJEUG9zaXRpb25zU2NyYXRjaFtuXSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB9CiAgdmFyIHByb2plY3RUbzJEUHJvamVjdGlvbiA9IG5ldyBHZW9ncmFwaGljUHJvamVjdGlvbl9kZWZhdWx0KCk7CiAgQm91bmRpbmdTcGhlcmUucHJvamVjdFRvMkQgPSBmdW5jdGlvbihzcGhlcmUsIHByb2plY3Rpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJzcGhlcmUiLCBzcGhlcmUpOwogICAgcHJvamVjdGlvbiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHByb2plY3Rpb24sIHByb2plY3RUbzJEUHJvamVjdGlvbik7CiAgICBjb25zdCBlbGxpcHNvaWQgPSBwcm9qZWN0aW9uLmVsbGlwc29pZDsKICAgIGxldCBjZW50ZXIgPSBzcGhlcmUuY2VudGVyOwogICAgY29uc3QgcmFkaXVzID0gc3BoZXJlLnJhZGl1czsKICAgIGxldCBub3JtYWw7CiAgICBpZiAoQ2FydGVzaWFuM19kZWZhdWx0LmVxdWFscyhjZW50ZXIsIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPKSkgewogICAgICBub3JtYWwgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoQ2FydGVzaWFuM19kZWZhdWx0LlVOSVRfWCwgcHJvamVjdFRvMkROb3JtYWxTY3JhdGNoKTsKICAgIH0gZWxzZSB7CiAgICAgIG5vcm1hbCA9IGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwoY2VudGVyLCBwcm9qZWN0VG8yRE5vcm1hbFNjcmF0Y2gpOwogICAgfQogICAgY29uc3QgZWFzdCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcygKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LlVOSVRfWiwKICAgICAgbm9ybWFsLAogICAgICBwcm9qZWN0VG8yREVhc3RTY3JhdGNoCiAgICApOwogICAgQ2FydGVzaWFuM19kZWZhdWx0Lm5vcm1hbGl6ZShlYXN0LCBlYXN0KTsKICAgIGNvbnN0IG5vcnRoID0gQ2FydGVzaWFuM19kZWZhdWx0LmNyb3NzKG5vcm1hbCwgZWFzdCwgcHJvamVjdFRvMkROb3J0aFNjcmF0Y2gpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0Lm5vcm1hbGl6ZShub3J0aCwgbm9ydGgpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0Lm11bHRpcGx5QnlTY2FsYXIobm9ybWFsLCByYWRpdXMsIG5vcm1hbCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihub3J0aCwgcmFkaXVzLCBub3J0aCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihlYXN0LCByYWRpdXMsIGVhc3QpOwogICAgY29uc3Qgc291dGggPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubmVnYXRlKG5vcnRoLCBwcm9qZWN0VG8yRFNvdXRoU2NyYXRjaCk7CiAgICBjb25zdCB3ZXN0ID0gQ2FydGVzaWFuM19kZWZhdWx0Lm5lZ2F0ZShlYXN0LCBwcm9qZWN0VG8yRFdlc3RTY3JhdGNoKTsKICAgIGNvbnN0IHBvc2l0aW9ucyA9IHByb2plY3RUbzJEUG9zaXRpb25zU2NyYXRjaDsKICAgIGxldCBjb3JuZXIgPSBwb3NpdGlvbnNbMF07CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKG5vcm1hbCwgbm9ydGgsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNvcm5lciwgZWFzdCwgY29ybmVyKTsKICAgIGNvcm5lciA9IHBvc2l0aW9uc1sxXTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQobm9ybWFsLCBub3J0aCwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoY29ybmVyLCB3ZXN0LCBjb3JuZXIpOwogICAgY29ybmVyID0gcG9zaXRpb25zWzJdOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChub3JtYWwsIHNvdXRoLCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjb3JuZXIsIHdlc3QsIGNvcm5lcik7CiAgICBjb3JuZXIgPSBwb3NpdGlvbnNbM107CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKG5vcm1hbCwgc291dGgsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNvcm5lciwgZWFzdCwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5uZWdhdGUobm9ybWFsLCBub3JtYWwpOwogICAgY29ybmVyID0gcG9zaXRpb25zWzRdOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChub3JtYWwsIG5vcnRoLCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjb3JuZXIsIGVhc3QsIGNvcm5lcik7CiAgICBjb3JuZXIgPSBwb3NpdGlvbnNbNV07CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKG5vcm1hbCwgbm9ydGgsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNvcm5lciwgd2VzdCwgY29ybmVyKTsKICAgIGNvcm5lciA9IHBvc2l0aW9uc1s2XTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQobm9ybWFsLCBzb3V0aCwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoY29ybmVyLCB3ZXN0LCBjb3JuZXIpOwogICAgY29ybmVyID0gcG9zaXRpb25zWzddOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChub3JtYWwsIHNvdXRoLCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjb3JuZXIsIGVhc3QsIGNvcm5lcik7CiAgICBjb25zdCBsZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpXTsKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjZW50ZXIsIHBvc2l0aW9uLCBwb3NpdGlvbik7CiAgICAgIGNvbnN0IGNhcnRvZ3JhcGhpYyA9IGVsbGlwc29pZC5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpYygKICAgICAgICBwb3NpdGlvbiwKICAgICAgICBwcm9qZWN0VG8yRENhcnRvZ3JhcGhpY1NjcmF0Y2gKICAgICAgKTsKICAgICAgcHJvamVjdGlvbi5wcm9qZWN0KGNhcnRvZ3JhcGhpYywgcG9zaXRpb24pOwogICAgfQogICAgcmVzdWx0ID0gQm91bmRpbmdTcGhlcmUuZnJvbVBvaW50cyhwb3NpdGlvbnMsIHJlc3VsdCk7CiAgICBjZW50ZXIgPSByZXN1bHQuY2VudGVyOwogICAgY29uc3QgeCA9IGNlbnRlci54OwogICAgY29uc3QgeSA9IGNlbnRlci55OwogICAgY29uc3QgeiA9IGNlbnRlci56OwogICAgY2VudGVyLnggPSB6OwogICAgY2VudGVyLnkgPSB4OwogICAgY2VudGVyLnogPSB5OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEJvdW5kaW5nU3BoZXJlLmlzT2NjbHVkZWQgPSBmdW5jdGlvbihzcGhlcmUsIG9jY2x1ZGVyKSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInNwaGVyZSIsIHNwaGVyZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm9jY2x1ZGVyIiwgb2NjbHVkZXIpOwogICAgcmV0dXJuICFvY2NsdWRlci5pc0JvdW5kaW5nU3BoZXJlVmlzaWJsZShzcGhlcmUpOwogIH07CiAgQm91bmRpbmdTcGhlcmUuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBDYXJ0ZXNpYW4zX2RlZmF1bHQuZXF1YWxzKGxlZnQuY2VudGVyLCByaWdodC5jZW50ZXIpICYmIGxlZnQucmFkaXVzID09PSByaWdodC5yYWRpdXM7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihwbGFuZSkgewogICAgcmV0dXJuIEJvdW5kaW5nU3BoZXJlLmludGVyc2VjdFBsYW5lKHRoaXMsIHBsYW5lKTsKICB9OwogIEJvdW5kaW5nU3BoZXJlLnByb3RvdHlwZS5kaXN0YW5jZVNxdWFyZWRUbyA9IGZ1bmN0aW9uKGNhcnRlc2lhbikgewogICAgcmV0dXJuIEJvdW5kaW5nU3BoZXJlLmRpc3RhbmNlU3F1YXJlZFRvKHRoaXMsIGNhcnRlc2lhbik7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS5wcm90b3R5cGUuY29tcHV0ZVBsYW5lRGlzdGFuY2VzID0gZnVuY3Rpb24ocG9zaXRpb24sIGRpcmVjdGlvbiwgcmVzdWx0KSB7CiAgICByZXR1cm4gQm91bmRpbmdTcGhlcmUuY29tcHV0ZVBsYW5lRGlzdGFuY2VzKAogICAgICB0aGlzLAogICAgICBwb3NpdGlvbiwKICAgICAgZGlyZWN0aW9uLAogICAgICByZXN1bHQKICAgICk7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS5wcm90b3R5cGUuaXNPY2NsdWRlZCA9IGZ1bmN0aW9uKG9jY2x1ZGVyKSB7CiAgICByZXR1cm4gQm91bmRpbmdTcGhlcmUuaXNPY2NsdWRlZCh0aGlzLCBvY2NsdWRlcik7CiAgfTsKICBCb3VuZGluZ1NwaGVyZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocmlnaHQpIHsKICAgIHJldHVybiBCb3VuZGluZ1NwaGVyZS5lcXVhbHModGhpcywgcmlnaHQpOwogIH07CiAgQm91bmRpbmdTcGhlcmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gQm91bmRpbmdTcGhlcmUuY2xvbmUodGhpcywgcmVzdWx0KTsKICB9OwogIEJvdW5kaW5nU3BoZXJlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpIHsKICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMucmFkaXVzOwogICAgcmV0dXJuIHZvbHVtZUNvbnN0YW50ICogcmFkaXVzICogcmFkaXVzICogcmFkaXVzOwogIH07CiAgdmFyIEJvdW5kaW5nU3BoZXJlX2RlZmF1bHQgPSBCb3VuZGluZ1NwaGVyZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0dlb2dyYXBoaWNUaWxpbmdTY2hlbWUuanMKICBmdW5jdGlvbiBHZW9ncmFwaGljVGlsaW5nU2NoZW1lKG9wdGlvbnMpIHsKICAgIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLCBkZWZhdWx0VmFsdWVfZGVmYXVsdC5FTVBUWV9PQkpFQ1QpOwogICAgdGhpcy5fZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5lbGxpcHNvaWQsIEVsbGlwc29pZF9kZWZhdWx0LldHUzg0KTsKICAgIHRoaXMuX3JlY3RhbmdsZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMucmVjdGFuZ2xlLCBSZWN0YW5nbGVfZGVmYXVsdC5NQVhfVkFMVUUpOwogICAgdGhpcy5fcHJvamVjdGlvbiA9IG5ldyBHZW9ncmFwaGljUHJvamVjdGlvbl9kZWZhdWx0KHRoaXMuX2VsbGlwc29pZCk7CiAgICB0aGlzLl9udW1iZXJPZkxldmVsWmVyb1RpbGVzWCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBvcHRpb25zLm51bWJlck9mTGV2ZWxaZXJvVGlsZXNYLAogICAgICAyCiAgICApOwogICAgdGhpcy5fbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1kgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgb3B0aW9ucy5udW1iZXJPZkxldmVsWmVyb1RpbGVzWSwKICAgICAgMQogICAgKTsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZS5wcm90b3R5cGUsIHsKICAgIGVsbGlwc29pZDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9lbGxpcHNvaWQ7CiAgICAgIH0KICAgIH0sCiAgICByZWN0YW5nbGU6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcmVjdGFuZ2xlOwogICAgICB9CiAgICB9LAogICAgcHJvamVjdGlvbjogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0aW9uOwogICAgICB9CiAgICB9CiAgfSk7CiAgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZS5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsID0gZnVuY3Rpb24obGV2ZWwpIHsKICAgIHJldHVybiB0aGlzLl9udW1iZXJPZkxldmVsWmVyb1RpbGVzWCA8PCBsZXZlbDsKICB9OwogIEdlb2dyYXBoaWNUaWxpbmdTY2hlbWUucHJvdG90eXBlLmdldE51bWJlck9mWVRpbGVzQXRMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7CiAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1kgPDwgbGV2ZWw7CiAgfTsKICBHZW9ncmFwaGljVGlsaW5nU2NoZW1lLnByb3RvdHlwZS5yZWN0YW5nbGVUb05hdGl2ZVJlY3RhbmdsZSA9IGZ1bmN0aW9uKHJlY3RhbmdsZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInJlY3RhbmdsZSIsIHJlY3RhbmdsZSk7CiAgICBjb25zdCB3ZXN0ID0gTWF0aF9kZWZhdWx0LnRvRGVncmVlcyhyZWN0YW5nbGUud2VzdCk7CiAgICBjb25zdCBzb3V0aCA9IE1hdGhfZGVmYXVsdC50b0RlZ3JlZXMocmVjdGFuZ2xlLnNvdXRoKTsKICAgIGNvbnN0IGVhc3QgPSBNYXRoX2RlZmF1bHQudG9EZWdyZWVzKHJlY3RhbmdsZS5lYXN0KTsKICAgIGNvbnN0IG5vcnRoID0gTWF0aF9kZWZhdWx0LnRvRGVncmVlcyhyZWN0YW5nbGUubm9ydGgpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZV9kZWZhdWx0KHdlc3QsIHNvdXRoLCBlYXN0LCBub3J0aCk7CiAgICB9CiAgICByZXN1bHQud2VzdCA9IHdlc3Q7CiAgICByZXN1bHQuc291dGggPSBzb3V0aDsKICAgIHJlc3VsdC5lYXN0ID0gZWFzdDsKICAgIHJlc3VsdC5ub3J0aCA9IG5vcnRoOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEdlb2dyYXBoaWNUaWxpbmdTY2hlbWUucHJvdG90eXBlLnRpbGVYWVRvTmF0aXZlUmVjdGFuZ2xlID0gZnVuY3Rpb24oeCwgeSwgbGV2ZWwsIHJlc3VsdCkgewogICAgY29uc3QgcmVjdGFuZ2xlUmFkaWFucyA9IHRoaXMudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwsIHJlc3VsdCk7CiAgICByZWN0YW5nbGVSYWRpYW5zLndlc3QgPSBNYXRoX2RlZmF1bHQudG9EZWdyZWVzKHJlY3RhbmdsZVJhZGlhbnMud2VzdCk7CiAgICByZWN0YW5nbGVSYWRpYW5zLnNvdXRoID0gTWF0aF9kZWZhdWx0LnRvRGVncmVlcyhyZWN0YW5nbGVSYWRpYW5zLnNvdXRoKTsKICAgIHJlY3RhbmdsZVJhZGlhbnMuZWFzdCA9IE1hdGhfZGVmYXVsdC50b0RlZ3JlZXMocmVjdGFuZ2xlUmFkaWFucy5lYXN0KTsKICAgIHJlY3RhbmdsZVJhZGlhbnMubm9ydGggPSBNYXRoX2RlZmF1bHQudG9EZWdyZWVzKHJlY3RhbmdsZVJhZGlhbnMubm9ydGgpOwogICAgcmV0dXJuIHJlY3RhbmdsZVJhZGlhbnM7CiAgfTsKICBHZW9ncmFwaGljVGlsaW5nU2NoZW1lLnByb3RvdHlwZS50aWxlWFlUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uKHgsIHksIGxldmVsLCByZXN1bHQpIHsKICAgIGNvbnN0IHJlY3RhbmdsZSA9IHRoaXMuX3JlY3RhbmdsZTsKICAgIGNvbnN0IHhUaWxlcyA9IHRoaXMuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsKGxldmVsKTsKICAgIGNvbnN0IHlUaWxlcyA9IHRoaXMuZ2V0TnVtYmVyT2ZZVGlsZXNBdExldmVsKGxldmVsKTsKICAgIGNvbnN0IHhUaWxlV2lkdGggPSByZWN0YW5nbGUud2lkdGggLyB4VGlsZXM7CiAgICBjb25zdCB3ZXN0ID0geCAqIHhUaWxlV2lkdGggKyByZWN0YW5nbGUud2VzdDsKICAgIGNvbnN0IGVhc3QgPSAoeCArIDEpICogeFRpbGVXaWR0aCArIHJlY3RhbmdsZS53ZXN0OwogICAgY29uc3QgeVRpbGVIZWlnaHQgPSByZWN0YW5nbGUuaGVpZ2h0IC8geVRpbGVzOwogICAgY29uc3Qgbm9ydGggPSByZWN0YW5nbGUubm9ydGggLSB5ICogeVRpbGVIZWlnaHQ7CiAgICBjb25zdCBzb3V0aCA9IHJlY3RhbmdsZS5ub3J0aCAtICh5ICsgMSkgKiB5VGlsZUhlaWdodDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZV9kZWZhdWx0KHdlc3QsIHNvdXRoLCBlYXN0LCBub3J0aCk7CiAgICB9CiAgICByZXN1bHQud2VzdCA9IHdlc3Q7CiAgICByZXN1bHQuc291dGggPSBzb3V0aDsKICAgIHJlc3VsdC5lYXN0ID0gZWFzdDsKICAgIHJlc3VsdC5ub3J0aCA9IG5vcnRoOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEdlb2dyYXBoaWNUaWxpbmdTY2hlbWUucHJvdG90eXBlLnBvc2l0aW9uVG9UaWxlWFkgPSBmdW5jdGlvbihwb3NpdGlvbiwgbGV2ZWwsIHJlc3VsdCkgewogICAgY29uc3QgcmVjdGFuZ2xlID0gdGhpcy5fcmVjdGFuZ2xlOwogICAgaWYgKCFSZWN0YW5nbGVfZGVmYXVsdC5jb250YWlucyhyZWN0YW5nbGUsIHBvc2l0aW9uKSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgY29uc3QgeFRpbGVzID0gdGhpcy5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwobGV2ZWwpOwogICAgY29uc3QgeVRpbGVzID0gdGhpcy5nZXROdW1iZXJPZllUaWxlc0F0TGV2ZWwobGV2ZWwpOwogICAgY29uc3QgeFRpbGVXaWR0aCA9IHJlY3RhbmdsZS53aWR0aCAvIHhUaWxlczsKICAgIGNvbnN0IHlUaWxlSGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodCAvIHlUaWxlczsKICAgIGxldCBsb25naXR1ZGUgPSBwb3NpdGlvbi5sb25naXR1ZGU7CiAgICBpZiAocmVjdGFuZ2xlLmVhc3QgPCByZWN0YW5nbGUud2VzdCkgewogICAgICBsb25naXR1ZGUgKz0gTWF0aF9kZWZhdWx0LlRXT19QSTsKICAgIH0KICAgIGxldCB4VGlsZUNvb3JkaW5hdGUgPSAobG9uZ2l0dWRlIC0gcmVjdGFuZ2xlLndlc3QpIC8geFRpbGVXaWR0aCB8IDA7CiAgICBpZiAoeFRpbGVDb29yZGluYXRlID49IHhUaWxlcykgewogICAgICB4VGlsZUNvb3JkaW5hdGUgPSB4VGlsZXMgLSAxOwogICAgfQogICAgbGV0IHlUaWxlQ29vcmRpbmF0ZSA9IChyZWN0YW5nbGUubm9ydGggLSBwb3NpdGlvbi5sYXRpdHVkZSkgLyB5VGlsZUhlaWdodCB8IDA7CiAgICBpZiAoeVRpbGVDb29yZGluYXRlID49IHlUaWxlcykgewogICAgICB5VGlsZUNvb3JkaW5hdGUgPSB5VGlsZXMgLSAxOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IENhcnRlc2lhbjJfZGVmYXVsdCh4VGlsZUNvb3JkaW5hdGUsIHlUaWxlQ29vcmRpbmF0ZSk7CiAgICB9CiAgICByZXN1bHQueCA9IHhUaWxlQ29vcmRpbmF0ZTsKICAgIHJlc3VsdC55ID0geVRpbGVDb29yZGluYXRlOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBHZW9ncmFwaGljVGlsaW5nU2NoZW1lX2RlZmF1bHQgPSBHZW9ncmFwaGljVGlsaW5nU2NoZW1lOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQXhpc0FsaWduZWRCb3VuZGluZ0JveC5qcwogIGZ1bmN0aW9uIEF4aXNBbGlnbmVkQm91bmRpbmdCb3gobWluaW11bSwgbWF4aW11bSwgY2VudGVyKSB7CiAgICB0aGlzLm1pbmltdW0gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoZGVmYXVsdFZhbHVlX2RlZmF1bHQobWluaW11bSwgQ2FydGVzaWFuM19kZWZhdWx0LlpFUk8pKTsKICAgIHRoaXMubWF4aW11bSA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShkZWZhdWx0VmFsdWVfZGVmYXVsdChtYXhpbXVtLCBDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTykpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY2VudGVyKSkgewogICAgICBjZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWlkcG9pbnQodGhpcy5taW5pbXVtLCB0aGlzLm1heGltdW0sIG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKSk7CiAgICB9IGVsc2UgewogICAgICBjZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY2VudGVyKTsKICAgIH0KICAgIHRoaXMuY2VudGVyID0gY2VudGVyOwogIH0KICBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LmZyb21Db3JuZXJzID0gZnVuY3Rpb24obWluaW11bSwgbWF4aW11bSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoIm1pbmltdW0iLCBtaW5pbXVtKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgibWF4aW11bSIsIG1heGltdW0pOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXhpc0FsaWduZWRCb3VuZGluZ0JveCgpOwogICAgfQogICAgcmVzdWx0Lm1pbmltdW0gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUobWluaW11bSwgcmVzdWx0Lm1pbmltdW0pOwogICAgcmVzdWx0Lm1heGltdW0gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUobWF4aW11bSwgcmVzdWx0Lm1heGltdW0pOwogICAgcmVzdWx0LmNlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5taWRwb2ludChtaW5pbXVtLCBtYXhpbXVtLCByZXN1bHQuY2VudGVyKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LmZyb21Qb2ludHMgPSBmdW5jdGlvbihwb3NpdGlvbnMsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXhpc0FsaWduZWRCb3VuZGluZ0JveCgpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocG9zaXRpb25zKSB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7CiAgICAgIHJlc3VsdC5taW5pbXVtID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCByZXN1bHQubWluaW11bSk7CiAgICAgIHJlc3VsdC5tYXhpbXVtID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPLCByZXN1bHQubWF4aW11bSk7CiAgICAgIHJlc3VsdC5jZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoQ2FydGVzaWFuM19kZWZhdWx0LlpFUk8sIHJlc3VsdC5jZW50ZXIpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgbGV0IG1pbmltdW1YID0gcG9zaXRpb25zWzBdLng7CiAgICBsZXQgbWluaW11bVkgPSBwb3NpdGlvbnNbMF0ueTsKICAgIGxldCBtaW5pbXVtWiA9IHBvc2l0aW9uc1swXS56OwogICAgbGV0IG1heGltdW1YID0gcG9zaXRpb25zWzBdLng7CiAgICBsZXQgbWF4aW11bVkgPSBwb3NpdGlvbnNbMF0ueTsKICAgIGxldCBtYXhpbXVtWiA9IHBvc2l0aW9uc1swXS56OwogICAgY29uc3QgbGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aDsKICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgcCA9IHBvc2l0aW9uc1tpXTsKICAgICAgY29uc3QgeCA9IHAueDsKICAgICAgY29uc3QgeSA9IHAueTsKICAgICAgY29uc3QgeiA9IHAuejsKICAgICAgbWluaW11bVggPSBNYXRoLm1pbih4LCBtaW5pbXVtWCk7CiAgICAgIG1heGltdW1YID0gTWF0aC5tYXgoeCwgbWF4aW11bVgpOwogICAgICBtaW5pbXVtWSA9IE1hdGgubWluKHksIG1pbmltdW1ZKTsKICAgICAgbWF4aW11bVkgPSBNYXRoLm1heCh5LCBtYXhpbXVtWSk7CiAgICAgIG1pbmltdW1aID0gTWF0aC5taW4oeiwgbWluaW11bVopOwogICAgICBtYXhpbXVtWiA9IE1hdGgubWF4KHosIG1heGltdW1aKTsKICAgIH0KICAgIGNvbnN0IG1pbmltdW0gPSByZXN1bHQubWluaW11bTsKICAgIG1pbmltdW0ueCA9IG1pbmltdW1YOwogICAgbWluaW11bS55ID0gbWluaW11bVk7CiAgICBtaW5pbXVtLnogPSBtaW5pbXVtWjsKICAgIGNvbnN0IG1heGltdW0gPSByZXN1bHQubWF4aW11bTsKICAgIG1heGltdW0ueCA9IG1heGltdW1YOwogICAgbWF4aW11bS55ID0gbWF4aW11bVk7CiAgICBtYXhpbXVtLnogPSBtYXhpbXVtWjsKICAgIHJlc3VsdC5jZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWlkcG9pbnQobWluaW11bSwgbWF4aW11bSwgcmVzdWx0LmNlbnRlcik7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgQXhpc0FsaWduZWRCb3VuZGluZ0JveC5jbG9uZSA9IGZ1bmN0aW9uKGJveCwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChib3gpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQXhpc0FsaWduZWRCb3VuZGluZ0JveChib3gubWluaW11bSwgYm94Lm1heGltdW0sIGJveC5jZW50ZXIpOwogICAgfQogICAgcmVzdWx0Lm1pbmltdW0gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoYm94Lm1pbmltdW0sIHJlc3VsdC5taW5pbXVtKTsKICAgIHJlc3VsdC5tYXhpbXVtID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGJveC5tYXhpbXVtLCByZXN1bHQubWF4aW11bSk7CiAgICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGJveC5jZW50ZXIsIHJlc3VsdC5jZW50ZXIpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEF4aXNBbGlnbmVkQm91bmRpbmdCb3guZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBDYXJ0ZXNpYW4zX2RlZmF1bHQuZXF1YWxzKGxlZnQuY2VudGVyLCByaWdodC5jZW50ZXIpICYmIENhcnRlc2lhbjNfZGVmYXVsdC5lcXVhbHMobGVmdC5taW5pbXVtLCByaWdodC5taW5pbXVtKSAmJiBDYXJ0ZXNpYW4zX2RlZmF1bHQuZXF1YWxzKGxlZnQubWF4aW11bSwgcmlnaHQubWF4aW11bSk7CiAgfTsKICB2YXIgaW50ZXJzZWN0U2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LmludGVyc2VjdFBsYW5lID0gZnVuY3Rpb24oYm94LCBwbGFuZSkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJib3giLCBib3gpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJwbGFuZSIsIHBsYW5lKTsKICAgIGludGVyc2VjdFNjcmF0Y2ggPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoCiAgICAgIGJveC5tYXhpbXVtLAogICAgICBib3gubWluaW11bSwKICAgICAgaW50ZXJzZWN0U2NyYXRjaAogICAgKTsKICAgIGNvbnN0IGggPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgaW50ZXJzZWN0U2NyYXRjaCwKICAgICAgMC41LAogICAgICBpbnRlcnNlY3RTY3JhdGNoCiAgICApOwogICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsOwogICAgY29uc3QgZSA9IGgueCAqIE1hdGguYWJzKG5vcm1hbC54KSArIGgueSAqIE1hdGguYWJzKG5vcm1hbC55KSArIGgueiAqIE1hdGguYWJzKG5vcm1hbC56KTsKICAgIGNvbnN0IHMgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KGJveC5jZW50ZXIsIG5vcm1hbCkgKyBwbGFuZS5kaXN0YW5jZTsKICAgIGlmIChzIC0gZSA+IDApIHsKICAgICAgcmV0dXJuIEludGVyc2VjdF9kZWZhdWx0LklOU0lERTsKICAgIH0KICAgIGlmIChzICsgZSA8IDApIHsKICAgICAgcmV0dXJuIEludGVyc2VjdF9kZWZhdWx0Lk9VVFNJREU7CiAgICB9CiAgICByZXR1cm4gSW50ZXJzZWN0X2RlZmF1bHQuSU5URVJTRUNUSU5HOwogIH07CiAgQXhpc0FsaWduZWRCb3VuZGluZ0JveC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHsKICAgIHJldHVybiBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LmNsb25lKHRoaXMsIHJlc3VsdCk7CiAgfTsKICBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZSA9IGZ1bmN0aW9uKHBsYW5lKSB7CiAgICByZXR1cm4gQXhpc0FsaWduZWRCb3VuZGluZ0JveC5pbnRlcnNlY3RQbGFuZSh0aGlzLCBwbGFuZSk7CiAgfTsKICBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihyaWdodCkgewogICAgcmV0dXJuIEF4aXNBbGlnbmVkQm91bmRpbmdCb3guZXF1YWxzKHRoaXMsIHJpZ2h0KTsKICB9OwogIHZhciBBeGlzQWxpZ25lZEJvdW5kaW5nQm94X2RlZmF1bHQgPSBBeGlzQWxpZ25lZEJvdW5kaW5nQm94OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvUXVhZHJhdGljUmVhbFBvbHlub21pYWwuanMKICB2YXIgUXVhZHJhdGljUmVhbFBvbHlub21pYWwgPSB7fTsKICBRdWFkcmF0aWNSZWFsUG9seW5vbWlhbC5jb21wdXRlRGlzY3JpbWluYW50ID0gZnVuY3Rpb24oYTMsIGIsIGMpIHsKICAgIGlmICh0eXBlb2YgYTMgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgaWYgKHR5cGVvZiBiICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYiBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGlmICh0eXBlb2YgYyAhPT0gIm51bWJlciIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImMgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgICB9CiAgICBjb25zdCBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhMyAqIGM7CiAgICByZXR1cm4gZGlzY3JpbWluYW50OwogIH07CiAgZnVuY3Rpb24gYWRkV2l0aENhbmNlbGxhdGlvbkNoZWNrKGxlZnQsIHJpZ2h0LCB0b2xlcmFuY2UpIHsKICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBsZWZ0ICsgcmlnaHQ7CiAgICBpZiAoTWF0aF9kZWZhdWx0LnNpZ24obGVmdCkgIT09IE1hdGhfZGVmYXVsdC5zaWduKHJpZ2h0KSAmJiBNYXRoLmFicyhkaWZmZXJlbmNlIC8gTWF0aC5tYXgoTWF0aC5hYnMobGVmdCksIE1hdGguYWJzKHJpZ2h0KSkpIDwgdG9sZXJhbmNlKSB7CiAgICAgIHJldHVybiAwOwogICAgfQogICAgcmV0dXJuIGRpZmZlcmVuY2U7CiAgfQogIFF1YWRyYXRpY1JlYWxQb2x5bm9taWFsLmNvbXB1dGVSZWFsUm9vdHMgPSBmdW5jdGlvbihhMywgYiwgYykgewogICAgaWYgKHR5cGVvZiBhMyAhPT0gIm51bWJlciIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImEgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgICB9CiAgICBpZiAodHlwZW9mIGIgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJiIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgaWYgKHR5cGVvZiBjICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYyBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGxldCByYXRpbzsKICAgIGlmIChhMyA9PT0gMCkgewogICAgICBpZiAoYiA9PT0gMCkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICByZXR1cm4gWy1jIC8gYl07CiAgICB9IGVsc2UgaWYgKGIgPT09IDApIHsKICAgICAgaWYgKGMgPT09IDApIHsKICAgICAgICByZXR1cm4gWzAsIDBdOwogICAgICB9CiAgICAgIGNvbnN0IGNNYWduaXR1ZGUgPSBNYXRoLmFicyhjKTsKICAgICAgY29uc3QgYU1hZ25pdHVkZSA9IE1hdGguYWJzKGEzKTsKICAgICAgaWYgKGNNYWduaXR1ZGUgPCBhTWFnbml0dWRlICYmIGNNYWduaXR1ZGUgLyBhTWFnbml0dWRlIDwgTWF0aF9kZWZhdWx0LkVQU0lMT04xNCkgewogICAgICAgIHJldHVybiBbMCwgMF07CiAgICAgIH0gZWxzZSBpZiAoY01hZ25pdHVkZSA+IGFNYWduaXR1ZGUgJiYgYU1hZ25pdHVkZSAvIGNNYWduaXR1ZGUgPCBNYXRoX2RlZmF1bHQuRVBTSUxPTjE0KSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIHJhdGlvID0gLWMgLyBhMzsKICAgICAgaWYgKHJhdGlvIDwgMCkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCByb290ID0gTWF0aC5zcXJ0KHJhdGlvKTsKICAgICAgcmV0dXJuIFstcm9vdCwgcm9vdF07CiAgICB9IGVsc2UgaWYgKGMgPT09IDApIHsKICAgICAgcmF0aW8gPSAtYiAvIGEzOwogICAgICBpZiAocmF0aW8gPCAwKSB7CiAgICAgICAgcmV0dXJuIFtyYXRpbywgMF07CiAgICAgIH0KICAgICAgcmV0dXJuIFswLCByYXRpb107CiAgICB9CiAgICBjb25zdCBiMiA9IGIgKiBiOwogICAgY29uc3QgZm91cl9hYyA9IDQgKiBhMyAqIGM7CiAgICBjb25zdCByYWRpY2FuZCA9IGFkZFdpdGhDYW5jZWxsYXRpb25DaGVjayhiMiwgLWZvdXJfYWMsIE1hdGhfZGVmYXVsdC5FUFNJTE9OMTQpOwogICAgaWYgKHJhZGljYW5kIDwgMCkgewogICAgICByZXR1cm4gW107CiAgICB9CiAgICBjb25zdCBxID0gLTAuNSAqIGFkZFdpdGhDYW5jZWxsYXRpb25DaGVjaygKICAgICAgYiwKICAgICAgTWF0aF9kZWZhdWx0LnNpZ24oYikgKiBNYXRoLnNxcnQocmFkaWNhbmQpLAogICAgICBNYXRoX2RlZmF1bHQuRVBTSUxPTjE0CiAgICApOwogICAgaWYgKGIgPiAwKSB7CiAgICAgIHJldHVybiBbcSAvIGEzLCBjIC8gcV07CiAgICB9CiAgICByZXR1cm4gW2MgLyBxLCBxIC8gYTNdOwogIH07CiAgdmFyIFF1YWRyYXRpY1JlYWxQb2x5bm9taWFsX2RlZmF1bHQgPSBRdWFkcmF0aWNSZWFsUG9seW5vbWlhbDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0N1YmljUmVhbFBvbHlub21pYWwuanMKICB2YXIgQ3ViaWNSZWFsUG9seW5vbWlhbCA9IHt9OwogIEN1YmljUmVhbFBvbHlub21pYWwuY29tcHV0ZURpc2NyaW1pbmFudCA9IGZ1bmN0aW9uKGEzLCBiLCBjLCBkKSB7CiAgICBpZiAodHlwZW9mIGEzICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYSBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGlmICh0eXBlb2YgYiAhPT0gIm51bWJlciIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImIgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgICB9CiAgICBpZiAodHlwZW9mIGMgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJjIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgaWYgKHR5cGVvZiBkICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZCBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGNvbnN0IGEyMiA9IGEzICogYTM7CiAgICBjb25zdCBiMiA9IGIgKiBiOwogICAgY29uc3QgYzIgPSBjICogYzsKICAgIGNvbnN0IGQyID0gZCAqIGQ7CiAgICBjb25zdCBkaXNjcmltaW5hbnQgPSAxOCAqIGEzICogYiAqIGMgKiBkICsgYjIgKiBjMiAtIDI3ICogYTIyICogZDIgLSA0ICogKGEzICogYzIgKiBjICsgYjIgKiBiICogZCk7CiAgICByZXR1cm4gZGlzY3JpbWluYW50OwogIH07CiAgZnVuY3Rpb24gY29tcHV0ZVJlYWxSb290cyhhMywgYiwgYywgZCkgewogICAgY29uc3QgQSA9IGEzOwogICAgY29uc3QgQiA9IGIgLyAzOwogICAgY29uc3QgQyA9IGMgLyAzOwogICAgY29uc3QgRCA9IGQ7CiAgICBjb25zdCBBQyA9IEEgKiBDOwogICAgY29uc3QgQkQgPSBCICogRDsKICAgIGNvbnN0IEIyID0gQiAqIEI7CiAgICBjb25zdCBDMiA9IEMgKiBDOwogICAgY29uc3QgZGVsdGExID0gQSAqIEMgLSBCMjsKICAgIGNvbnN0IGRlbHRhMiA9IEEgKiBEIC0gQiAqIEM7CiAgICBjb25zdCBkZWx0YTMgPSBCICogRCAtIEMyOwogICAgY29uc3QgZGlzY3JpbWluYW50ID0gNCAqIGRlbHRhMSAqIGRlbHRhMyAtIGRlbHRhMiAqIGRlbHRhMjsKICAgIGxldCB0ZW1wOwogICAgbGV0IHRlbXAxOwogICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHsKICAgICAgbGV0IEFCYXI7CiAgICAgIGxldCBDQmFyOwogICAgICBsZXQgREJhcjsKICAgICAgaWYgKEIyICogQkQgPj0gQUMgKiBDMikgewogICAgICAgIEFCYXIgPSBBOwogICAgICAgIENCYXIgPSBkZWx0YTE7CiAgICAgICAgREJhciA9IC0yICogQiAqIGRlbHRhMSArIEEgKiBkZWx0YTI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgQUJhciA9IEQ7CiAgICAgICAgQ0JhciA9IGRlbHRhMzsKICAgICAgICBEQmFyID0gLUQgKiBkZWx0YTIgKyAyICogQyAqIGRlbHRhMzsKICAgICAgfQogICAgICBjb25zdCBzID0gREJhciA8IDAgPyAtMSA6IDE7CiAgICAgIGNvbnN0IHRlbXAwID0gLXMgKiBNYXRoLmFicyhBQmFyKSAqIE1hdGguc3FydCgtZGlzY3JpbWluYW50KTsKICAgICAgdGVtcDEgPSAtREJhciArIHRlbXAwOwogICAgICBjb25zdCB4ID0gdGVtcDEgLyAyOwogICAgICBjb25zdCBwID0geCA8IDAgPyAtTWF0aC5wb3coLXgsIDEgLyAzKSA6IE1hdGgucG93KHgsIDEgLyAzKTsKICAgICAgY29uc3QgcSA9IHRlbXAxID09PSB0ZW1wMCA/IC1wIDogLUNCYXIgLyBwOwogICAgICB0ZW1wID0gQ0JhciA8PSAwID8gcCArIHEgOiAtREJhciAvIChwICogcCArIHEgKiBxICsgQ0Jhcik7CiAgICAgIGlmIChCMiAqIEJEID49IEFDICogQzIpIHsKICAgICAgICByZXR1cm4gWyh0ZW1wIC0gQikgLyBBXTsKICAgICAgfQogICAgICByZXR1cm4gWy1EIC8gKHRlbXAgKyBDKV07CiAgICB9CiAgICBjb25zdCBDQmFyQSA9IGRlbHRhMTsKICAgIGNvbnN0IERCYXJBID0gLTIgKiBCICogZGVsdGExICsgQSAqIGRlbHRhMjsKICAgIGNvbnN0IENCYXJEID0gZGVsdGEzOwogICAgY29uc3QgREJhckQgPSAtRCAqIGRlbHRhMiArIDIgKiBDICogZGVsdGEzOwogICAgY29uc3Qgc3F1YXJlUm9vdE9mRGlzY3JpbWluYW50ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7CiAgICBjb25zdCBoYWxmU3F1YXJlUm9vdE9mMyA9IE1hdGguc3FydCgzKSAvIDI7CiAgICBsZXQgdGhldGEgPSBNYXRoLmFicyhNYXRoLmF0YW4yKEEgKiBzcXVhcmVSb290T2ZEaXNjcmltaW5hbnQsIC1EQmFyQSkgLyAzKTsKICAgIHRlbXAgPSAyICogTWF0aC5zcXJ0KC1DQmFyQSk7CiAgICBsZXQgY29zaW5lID0gTWF0aC5jb3ModGhldGEpOwogICAgdGVtcDEgPSB0ZW1wICogY29zaW5lOwogICAgbGV0IHRlbXAzID0gdGVtcCAqICgtY29zaW5lIC8gMiAtIGhhbGZTcXVhcmVSb290T2YzICogTWF0aC5zaW4odGhldGEpKTsKICAgIGNvbnN0IG51bWVyYXRvckxhcmdlID0gdGVtcDEgKyB0ZW1wMyA+IDIgKiBCID8gdGVtcDEgLSBCIDogdGVtcDMgLSBCOwogICAgY29uc3QgZGVub21pbmF0b3JMYXJnZSA9IEE7CiAgICBjb25zdCByb290MSA9IG51bWVyYXRvckxhcmdlIC8gZGVub21pbmF0b3JMYXJnZTsKICAgIHRoZXRhID0gTWF0aC5hYnMoTWF0aC5hdGFuMihEICogc3F1YXJlUm9vdE9mRGlzY3JpbWluYW50LCAtREJhckQpIC8gMyk7CiAgICB0ZW1wID0gMiAqIE1hdGguc3FydCgtQ0JhckQpOwogICAgY29zaW5lID0gTWF0aC5jb3ModGhldGEpOwogICAgdGVtcDEgPSB0ZW1wICogY29zaW5lOwogICAgdGVtcDMgPSB0ZW1wICogKC1jb3NpbmUgLyAyIC0gaGFsZlNxdWFyZVJvb3RPZjMgKiBNYXRoLnNpbih0aGV0YSkpOwogICAgY29uc3QgbnVtZXJhdG9yU21hbGwgPSAtRDsKICAgIGNvbnN0IGRlbm9taW5hdG9yU21hbGwgPSB0ZW1wMSArIHRlbXAzIDwgMiAqIEMgPyB0ZW1wMSArIEMgOiB0ZW1wMyArIEM7CiAgICBjb25zdCByb290MyA9IG51bWVyYXRvclNtYWxsIC8gZGVub21pbmF0b3JTbWFsbDsKICAgIGNvbnN0IEUgPSBkZW5vbWluYXRvckxhcmdlICogZGVub21pbmF0b3JTbWFsbDsKICAgIGNvbnN0IEYgPSAtbnVtZXJhdG9yTGFyZ2UgKiBkZW5vbWluYXRvclNtYWxsIC0gZGVub21pbmF0b3JMYXJnZSAqIG51bWVyYXRvclNtYWxsOwogICAgY29uc3QgRyA9IG51bWVyYXRvckxhcmdlICogbnVtZXJhdG9yU21hbGw7CiAgICBjb25zdCByb290MiA9IChDICogRiAtIEIgKiBHKSAvICgtQiAqIEYgKyBDICogRSk7CiAgICBpZiAocm9vdDEgPD0gcm9vdDIpIHsKICAgICAgaWYgKHJvb3QxIDw9IHJvb3QzKSB7CiAgICAgICAgaWYgKHJvb3QyIDw9IHJvb3QzKSB7CiAgICAgICAgICByZXR1cm4gW3Jvb3QxLCByb290Miwgcm9vdDNdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gW3Jvb3QxLCByb290Mywgcm9vdDJdOwogICAgICB9CiAgICAgIHJldHVybiBbcm9vdDMsIHJvb3QxLCByb290Ml07CiAgICB9CiAgICBpZiAocm9vdDEgPD0gcm9vdDMpIHsKICAgICAgcmV0dXJuIFtyb290Miwgcm9vdDEsIHJvb3QzXTsKICAgIH0KICAgIGlmIChyb290MiA8PSByb290MykgewogICAgICByZXR1cm4gW3Jvb3QyLCByb290Mywgcm9vdDFdOwogICAgfQogICAgcmV0dXJuIFtyb290Mywgcm9vdDIsIHJvb3QxXTsKICB9CiAgQ3ViaWNSZWFsUG9seW5vbWlhbC5jb21wdXRlUmVhbFJvb3RzID0gZnVuY3Rpb24oYTMsIGIsIGMsIGQpIHsKICAgIGlmICh0eXBlb2YgYTMgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgaWYgKHR5cGVvZiBiICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYiBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGlmICh0eXBlb2YgYyAhPT0gIm51bWJlciIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImMgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgICB9CiAgICBpZiAodHlwZW9mIGQgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgbGV0IHJvb3RzOwogICAgbGV0IHJhdGlvOwogICAgaWYgKGEzID09PSAwKSB7CiAgICAgIHJldHVybiBRdWFkcmF0aWNSZWFsUG9seW5vbWlhbF9kZWZhdWx0LmNvbXB1dGVSZWFsUm9vdHMoYiwgYywgZCk7CiAgICB9IGVsc2UgaWYgKGIgPT09IDApIHsKICAgICAgaWYgKGMgPT09IDApIHsKICAgICAgICBpZiAoZCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIFswLCAwLCAwXTsKICAgICAgICB9CiAgICAgICAgcmF0aW8gPSAtZCAvIGEzOwogICAgICAgIGNvbnN0IHJvb3QgPSByYXRpbyA8IDAgPyAtTWF0aC5wb3coLXJhdGlvLCAxIC8gMykgOiBNYXRoLnBvdyhyYXRpbywgMSAvIDMpOwogICAgICAgIHJldHVybiBbcm9vdCwgcm9vdCwgcm9vdF07CiAgICAgIH0gZWxzZSBpZiAoZCA9PT0gMCkgewogICAgICAgIHJvb3RzID0gUXVhZHJhdGljUmVhbFBvbHlub21pYWxfZGVmYXVsdC5jb21wdXRlUmVhbFJvb3RzKGEzLCAwLCBjKTsKICAgICAgICBpZiAocm9vdHMuTGVuZ3RoID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gWzBdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gW3Jvb3RzWzBdLCAwLCByb290c1sxXV07CiAgICAgIH0KICAgICAgcmV0dXJuIGNvbXB1dGVSZWFsUm9vdHMoYTMsIDAsIGMsIGQpOwogICAgfSBlbHNlIGlmIChjID09PSAwKSB7CiAgICAgIGlmIChkID09PSAwKSB7CiAgICAgICAgcmF0aW8gPSAtYiAvIGEzOwogICAgICAgIGlmIChyYXRpbyA8IDApIHsKICAgICAgICAgIHJldHVybiBbcmF0aW8sIDAsIDBdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gWzAsIDAsIHJhdGlvXTsKICAgICAgfQogICAgICByZXR1cm4gY29tcHV0ZVJlYWxSb290cyhhMywgYiwgMCwgZCk7CiAgICB9IGVsc2UgaWYgKGQgPT09IDApIHsKICAgICAgcm9vdHMgPSBRdWFkcmF0aWNSZWFsUG9seW5vbWlhbF9kZWZhdWx0LmNvbXB1dGVSZWFsUm9vdHMoYTMsIGIsIGMpOwogICAgICBpZiAocm9vdHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgcmV0dXJuIFswXTsKICAgICAgfSBlbHNlIGlmIChyb290c1sxXSA8PSAwKSB7CiAgICAgICAgcmV0dXJuIFtyb290c1swXSwgcm9vdHNbMV0sIDBdOwogICAgICB9IGVsc2UgaWYgKHJvb3RzWzBdID49IDApIHsKICAgICAgICByZXR1cm4gWzAsIHJvb3RzWzBdLCByb290c1sxXV07CiAgICAgIH0KICAgICAgcmV0dXJuIFtyb290c1swXSwgMCwgcm9vdHNbMV1dOwogICAgfQogICAgcmV0dXJuIGNvbXB1dGVSZWFsUm9vdHMoYTMsIGIsIGMsIGQpOwogIH07CiAgdmFyIEN1YmljUmVhbFBvbHlub21pYWxfZGVmYXVsdCA9IEN1YmljUmVhbFBvbHlub21pYWw7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9RdWFydGljUmVhbFBvbHlub21pYWwuanMKICB2YXIgUXVhcnRpY1JlYWxQb2x5bm9taWFsID0ge307CiAgUXVhcnRpY1JlYWxQb2x5bm9taWFsLmNvbXB1dGVEaXNjcmltaW5hbnQgPSBmdW5jdGlvbihhMywgYiwgYywgZCwgZSkgewogICAgaWYgKHR5cGVvZiBhMyAhPT0gIm51bWJlciIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImEgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgICB9CiAgICBpZiAodHlwZW9mIGIgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJiIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgaWYgKHR5cGVvZiBjICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYyBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGlmICh0eXBlb2YgZCAhPT0gIm51bWJlciIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImQgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgICB9CiAgICBpZiAodHlwZW9mIGUgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJlIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgY29uc3QgYTIyID0gYTMgKiBhMzsKICAgIGNvbnN0IGEzMiA9IGEyMiAqIGEzOwogICAgY29uc3QgYjIgPSBiICogYjsKICAgIGNvbnN0IGIzID0gYjIgKiBiOwogICAgY29uc3QgYzIgPSBjICogYzsKICAgIGNvbnN0IGMzID0gYzIgKiBjOwogICAgY29uc3QgZDIgPSBkICogZDsKICAgIGNvbnN0IGQzID0gZDIgKiBkOwogICAgY29uc3QgZTIgPSBlICogZTsKICAgIGNvbnN0IGUzID0gZTIgKiBlOwogICAgY29uc3QgZGlzY3JpbWluYW50ID0gYjIgKiBjMiAqIGQyIC0gNCAqIGIzICogZDMgLSA0ICogYTMgKiBjMyAqIGQyICsgMTggKiBhMyAqIGIgKiBjICogZDMgLSAyNyAqIGEyMiAqIGQyICogZDIgKyAyNTYgKiBhMzIgKiBlMyArIGUgKiAoMTggKiBiMyAqIGMgKiBkIC0gNCAqIGIyICogYzMgKyAxNiAqIGEzICogYzIgKiBjMiAtIDgwICogYTMgKiBiICogYzIgKiBkIC0gNiAqIGEzICogYjIgKiBkMiArIDE0NCAqIGEyMiAqIGMgKiBkMikgKyBlMiAqICgxNDQgKiBhMyAqIGIyICogYyAtIDI3ICogYjIgKiBiMiAtIDEyOCAqIGEyMiAqIGMyIC0gMTkyICogYTIyICogYiAqIGQpOwogICAgcmV0dXJuIGRpc2NyaW1pbmFudDsKICB9OwogIGZ1bmN0aW9uIG9yaWdpbmFsKGEzLCBhMjIsIGExLCBhMCkgewogICAgY29uc3QgYTNTcXVhcmVkID0gYTMgKiBhMzsKICAgIGNvbnN0IHAgPSBhMjIgLSAzICogYTNTcXVhcmVkIC8gODsKICAgIGNvbnN0IHEgPSBhMSAtIGEyMiAqIGEzIC8gMiArIGEzU3F1YXJlZCAqIGEzIC8gODsKICAgIGNvbnN0IHIgPSBhMCAtIGExICogYTMgLyA0ICsgYTIyICogYTNTcXVhcmVkIC8gMTYgLSAzICogYTNTcXVhcmVkICogYTNTcXVhcmVkIC8gMjU2OwogICAgY29uc3QgY3ViaWNSb290cyA9IEN1YmljUmVhbFBvbHlub21pYWxfZGVmYXVsdC5jb21wdXRlUmVhbFJvb3RzKAogICAgICAxLAogICAgICAyICogcCwKICAgICAgcCAqIHAgLSA0ICogciwKICAgICAgLXEgKiBxCiAgICApOwogICAgaWYgKGN1YmljUm9vdHMubGVuZ3RoID4gMCkgewogICAgICBjb25zdCB0ZW1wID0gLWEzIC8gNDsKICAgICAgY29uc3QgaFNxdWFyZWQgPSBjdWJpY1Jvb3RzW2N1YmljUm9vdHMubGVuZ3RoIC0gMV07CiAgICAgIGlmIChNYXRoLmFicyhoU3F1YXJlZCkgPCBNYXRoX2RlZmF1bHQuRVBTSUxPTjE0KSB7CiAgICAgICAgY29uc3Qgcm9vdHMgPSBRdWFkcmF0aWNSZWFsUG9seW5vbWlhbF9kZWZhdWx0LmNvbXB1dGVSZWFsUm9vdHMoMSwgcCwgcik7CiAgICAgICAgaWYgKHJvb3RzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgY29uc3Qgcm9vdDAgPSByb290c1swXTsKICAgICAgICAgIGNvbnN0IHJvb3QxID0gcm9vdHNbMV07CiAgICAgICAgICBsZXQgeTsKICAgICAgICAgIGlmIChyb290MCA+PSAwICYmIHJvb3QxID49IDApIHsKICAgICAgICAgICAgY29uc3QgeTAgPSBNYXRoLnNxcnQocm9vdDApOwogICAgICAgICAgICBjb25zdCB5MSA9IE1hdGguc3FydChyb290MSk7CiAgICAgICAgICAgIHJldHVybiBbdGVtcCAtIHkxLCB0ZW1wIC0geTAsIHRlbXAgKyB5MCwgdGVtcCArIHkxXTsKICAgICAgICAgIH0gZWxzZSBpZiAocm9vdDAgPj0gMCAmJiByb290MSA8IDApIHsKICAgICAgICAgICAgeSA9IE1hdGguc3FydChyb290MCk7CiAgICAgICAgICAgIHJldHVybiBbdGVtcCAtIHksIHRlbXAgKyB5XTsKICAgICAgICAgIH0gZWxzZSBpZiAocm9vdDAgPCAwICYmIHJvb3QxID49IDApIHsKICAgICAgICAgICAgeSA9IE1hdGguc3FydChyb290MSk7CiAgICAgICAgICAgIHJldHVybiBbdGVtcCAtIHksIHRlbXAgKyB5XTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9IGVsc2UgaWYgKGhTcXVhcmVkID4gMCkgewogICAgICAgIGNvbnN0IGggPSBNYXRoLnNxcnQoaFNxdWFyZWQpOwogICAgICAgIGNvbnN0IG0gPSAocCArIGhTcXVhcmVkIC0gcSAvIGgpIC8gMjsKICAgICAgICBjb25zdCBuID0gKHAgKyBoU3F1YXJlZCArIHEgLyBoKSAvIDI7CiAgICAgICAgY29uc3Qgcm9vdHMxID0gUXVhZHJhdGljUmVhbFBvbHlub21pYWxfZGVmYXVsdC5jb21wdXRlUmVhbFJvb3RzKDEsIGgsIG0pOwogICAgICAgIGNvbnN0IHJvb3RzMiA9IFF1YWRyYXRpY1JlYWxQb2x5bm9taWFsX2RlZmF1bHQuY29tcHV0ZVJlYWxSb290cygxLCAtaCwgbik7CiAgICAgICAgaWYgKHJvb3RzMS5sZW5ndGggIT09IDApIHsKICAgICAgICAgIHJvb3RzMVswXSArPSB0ZW1wOwogICAgICAgICAgcm9vdHMxWzFdICs9IHRlbXA7CiAgICAgICAgICBpZiAocm9vdHMyLmxlbmd0aCAhPT0gMCkgewogICAgICAgICAgICByb290czJbMF0gKz0gdGVtcDsKICAgICAgICAgICAgcm9vdHMyWzFdICs9IHRlbXA7CiAgICAgICAgICAgIGlmIChyb290czFbMV0gPD0gcm9vdHMyWzBdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtyb290czFbMF0sIHJvb3RzMVsxXSwgcm9vdHMyWzBdLCByb290czJbMV1dOwogICAgICAgICAgICB9IGVsc2UgaWYgKHJvb3RzMlsxXSA8PSByb290czFbMF0pIHsKICAgICAgICAgICAgICByZXR1cm4gW3Jvb3RzMlswXSwgcm9vdHMyWzFdLCByb290czFbMF0sIHJvb3RzMVsxXV07CiAgICAgICAgICAgIH0gZWxzZSBpZiAocm9vdHMxWzBdID49IHJvb3RzMlswXSAmJiByb290czFbMV0gPD0gcm9vdHMyWzFdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtyb290czJbMF0sIHJvb3RzMVswXSwgcm9vdHMxWzFdLCByb290czJbMV1dOwogICAgICAgICAgICB9IGVsc2UgaWYgKHJvb3RzMlswXSA+PSByb290czFbMF0gJiYgcm9vdHMyWzFdIDw9IHJvb3RzMVsxXSkgewogICAgICAgICAgICAgIHJldHVybiBbcm9vdHMxWzBdLCByb290czJbMF0sIHJvb3RzMlsxXSwgcm9vdHMxWzFdXTsKICAgICAgICAgICAgfSBlbHNlIGlmIChyb290czFbMF0gPiByb290czJbMF0gJiYgcm9vdHMxWzBdIDwgcm9vdHMyWzFdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtyb290czJbMF0sIHJvb3RzMVswXSwgcm9vdHMyWzFdLCByb290czFbMV1dOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBbcm9vdHMxWzBdLCByb290czJbMF0sIHJvb3RzMVsxXSwgcm9vdHMyWzFdXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByb290czE7CiAgICAgICAgfQogICAgICAgIGlmIChyb290czIubGVuZ3RoICE9PSAwKSB7CiAgICAgICAgICByb290czJbMF0gKz0gdGVtcDsKICAgICAgICAgIHJvb3RzMlsxXSArPSB0ZW1wOwogICAgICAgICAgcmV0dXJuIHJvb3RzMjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gW107CiAgfQogIGZ1bmN0aW9uIG5ldW1hcmsoYTMsIGEyMiwgYTEsIGEwKSB7CiAgICBjb25zdCBhMVNxdWFyZWQgPSBhMSAqIGExOwogICAgY29uc3QgYTJTcXVhcmVkID0gYTIyICogYTIyOwogICAgY29uc3QgYTNTcXVhcmVkID0gYTMgKiBhMzsKICAgIGNvbnN0IHAgPSAtMiAqIGEyMjsKICAgIGNvbnN0IHEgPSBhMSAqIGEzICsgYTJTcXVhcmVkIC0gNCAqIGEwOwogICAgY29uc3QgciA9IGEzU3F1YXJlZCAqIGEwIC0gYTEgKiBhMjIgKiBhMyArIGExU3F1YXJlZDsKICAgIGNvbnN0IGN1YmljUm9vdHMgPSBDdWJpY1JlYWxQb2x5bm9taWFsX2RlZmF1bHQuY29tcHV0ZVJlYWxSb290cygxLCBwLCBxLCByKTsKICAgIGlmIChjdWJpY1Jvb3RzLmxlbmd0aCA+IDApIHsKICAgICAgY29uc3QgeSA9IGN1YmljUm9vdHNbMF07CiAgICAgIGNvbnN0IHRlbXAgPSBhMjIgLSB5OwogICAgICBjb25zdCB0ZW1wU3F1YXJlZCA9IHRlbXAgKiB0ZW1wOwogICAgICBjb25zdCBnMSA9IGEzIC8gMjsKICAgICAgY29uc3QgaDEgPSB0ZW1wIC8gMjsKICAgICAgY29uc3QgbSA9IHRlbXBTcXVhcmVkIC0gNCAqIGEwOwogICAgICBjb25zdCBtRXJyb3IgPSB0ZW1wU3F1YXJlZCArIDQgKiBNYXRoLmFicyhhMCk7CiAgICAgIGNvbnN0IG4gPSBhM1NxdWFyZWQgLSA0ICogeTsKICAgICAgY29uc3QgbkVycm9yID0gYTNTcXVhcmVkICsgNCAqIE1hdGguYWJzKHkpOwogICAgICBsZXQgZzI7CiAgICAgIGxldCBoMjsKICAgICAgaWYgKHkgPCAwIHx8IG0gKiBuRXJyb3IgPCBuICogbUVycm9yKSB7CiAgICAgICAgY29uc3Qgc3F1YXJlUm9vdE9mTiA9IE1hdGguc3FydChuKTsKICAgICAgICBnMiA9IHNxdWFyZVJvb3RPZk4gLyAyOwogICAgICAgIGgyID0gc3F1YXJlUm9vdE9mTiA9PT0gMCA/IDAgOiAoYTMgKiBoMSAtIGExKSAvIHNxdWFyZVJvb3RPZk47CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3Qgc3F1YXJlUm9vdE9mTSA9IE1hdGguc3FydChtKTsKICAgICAgICBnMiA9IHNxdWFyZVJvb3RPZk0gPT09IDAgPyAwIDogKGEzICogaDEgLSBhMSkgLyBzcXVhcmVSb290T2ZNOwogICAgICAgIGgyID0gc3F1YXJlUm9vdE9mTSAvIDI7CiAgICAgIH0KICAgICAgbGV0IEc7CiAgICAgIGxldCBnOwogICAgICBpZiAoZzEgPT09IDAgJiYgZzIgPT09IDApIHsKICAgICAgICBHID0gMDsKICAgICAgICBnID0gMDsKICAgICAgfSBlbHNlIGlmIChNYXRoX2RlZmF1bHQuc2lnbihnMSkgPT09IE1hdGhfZGVmYXVsdC5zaWduKGcyKSkgewogICAgICAgIEcgPSBnMSArIGcyOwogICAgICAgIGcgPSB5IC8gRzsKICAgICAgfSBlbHNlIHsKICAgICAgICBnID0gZzEgLSBnMjsKICAgICAgICBHID0geSAvIGc7CiAgICAgIH0KICAgICAgbGV0IEg7CiAgICAgIGxldCBoOwogICAgICBpZiAoaDEgPT09IDAgJiYgaDIgPT09IDApIHsKICAgICAgICBIID0gMDsKICAgICAgICBoID0gMDsKICAgICAgfSBlbHNlIGlmIChNYXRoX2RlZmF1bHQuc2lnbihoMSkgPT09IE1hdGhfZGVmYXVsdC5zaWduKGgyKSkgewogICAgICAgIEggPSBoMSArIGgyOwogICAgICAgIGggPSBhMCAvIEg7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaCA9IGgxIC0gaDI7CiAgICAgICAgSCA9IGEwIC8gaDsKICAgICAgfQogICAgICBjb25zdCByb290czEgPSBRdWFkcmF0aWNSZWFsUG9seW5vbWlhbF9kZWZhdWx0LmNvbXB1dGVSZWFsUm9vdHMoMSwgRywgSCk7CiAgICAgIGNvbnN0IHJvb3RzMiA9IFF1YWRyYXRpY1JlYWxQb2x5bm9taWFsX2RlZmF1bHQuY29tcHV0ZVJlYWxSb290cygxLCBnLCBoKTsKICAgICAgaWYgKHJvb3RzMS5sZW5ndGggIT09IDApIHsKICAgICAgICBpZiAocm9vdHMyLmxlbmd0aCAhPT0gMCkgewogICAgICAgICAgaWYgKHJvb3RzMVsxXSA8PSByb290czJbMF0pIHsKICAgICAgICAgICAgcmV0dXJuIFtyb290czFbMF0sIHJvb3RzMVsxXSwgcm9vdHMyWzBdLCByb290czJbMV1dOwogICAgICAgICAgfSBlbHNlIGlmIChyb290czJbMV0gPD0gcm9vdHMxWzBdKSB7CiAgICAgICAgICAgIHJldHVybiBbcm9vdHMyWzBdLCByb290czJbMV0sIHJvb3RzMVswXSwgcm9vdHMxWzFdXTsKICAgICAgICAgIH0gZWxzZSBpZiAocm9vdHMxWzBdID49IHJvb3RzMlswXSAmJiByb290czFbMV0gPD0gcm9vdHMyWzFdKSB7CiAgICAgICAgICAgIHJldHVybiBbcm9vdHMyWzBdLCByb290czFbMF0sIHJvb3RzMVsxXSwgcm9vdHMyWzFdXTsKICAgICAgICAgIH0gZWxzZSBpZiAocm9vdHMyWzBdID49IHJvb3RzMVswXSAmJiByb290czJbMV0gPD0gcm9vdHMxWzFdKSB7CiAgICAgICAgICAgIHJldHVybiBbcm9vdHMxWzBdLCByb290czJbMF0sIHJvb3RzMlsxXSwgcm9vdHMxWzFdXTsKICAgICAgICAgIH0gZWxzZSBpZiAocm9vdHMxWzBdID4gcm9vdHMyWzBdICYmIHJvb3RzMVswXSA8IHJvb3RzMlsxXSkgewogICAgICAgICAgICByZXR1cm4gW3Jvb3RzMlswXSwgcm9vdHMxWzBdLCByb290czJbMV0sIHJvb3RzMVsxXV07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gW3Jvb3RzMVswXSwgcm9vdHMyWzBdLCByb290czFbMV0sIHJvb3RzMlsxXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiByb290czE7CiAgICAgIH0KICAgICAgaWYgKHJvb3RzMi5sZW5ndGggIT09IDApIHsKICAgICAgICByZXR1cm4gcm9vdHMyOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gW107CiAgfQogIFF1YXJ0aWNSZWFsUG9seW5vbWlhbC5jb21wdXRlUmVhbFJvb3RzID0gZnVuY3Rpb24oYTMsIGIsIGMsIGQsIGUpIHsKICAgIGlmICh0eXBlb2YgYTMgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgaWYgKHR5cGVvZiBiICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYiBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGlmICh0eXBlb2YgYyAhPT0gIm51bWJlciIpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImMgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgICB9CiAgICBpZiAodHlwZW9mIGQgIT09ICJudW1iZXIiKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogICAgfQogICAgaWYgKHR5cGVvZiBlICE9PSAibnVtYmVyIikgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZSBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICAgIH0KICAgIGlmIChNYXRoLmFicyhhMykgPCBNYXRoX2RlZmF1bHQuRVBTSUxPTjE1KSB7CiAgICAgIHJldHVybiBDdWJpY1JlYWxQb2x5bm9taWFsX2RlZmF1bHQuY29tcHV0ZVJlYWxSb290cyhiLCBjLCBkLCBlKTsKICAgIH0KICAgIGNvbnN0IGEzMiA9IGIgLyBhMzsKICAgIGNvbnN0IGEyMiA9IGMgLyBhMzsKICAgIGNvbnN0IGExID0gZCAvIGEzOwogICAgY29uc3QgYTAgPSBlIC8gYTM7CiAgICBsZXQgayA9IGEzMiA8IDAgPyAxIDogMDsKICAgIGsgKz0gYTIyIDwgMCA/IGsgKyAxIDogazsKICAgIGsgKz0gYTEgPCAwID8gayArIDEgOiBrOwogICAgayArPSBhMCA8IDAgPyBrICsgMSA6IGs7CiAgICBzd2l0Y2ggKGspIHsKICAgICAgY2FzZSAwOgogICAgICAgIHJldHVybiBvcmlnaW5hbChhMzIsIGEyMiwgYTEsIGEwKTsKICAgICAgY2FzZSAxOgogICAgICAgIHJldHVybiBuZXVtYXJrKGEzMiwgYTIyLCBhMSwgYTApOwogICAgICBjYXNlIDI6CiAgICAgICAgcmV0dXJuIG5ldW1hcmsoYTMyLCBhMjIsIGExLCBhMCk7CiAgICAgIGNhc2UgMzoKICAgICAgICByZXR1cm4gb3JpZ2luYWwoYTMyLCBhMjIsIGExLCBhMCk7CiAgICAgIGNhc2UgNDoKICAgICAgICByZXR1cm4gb3JpZ2luYWwoYTMyLCBhMjIsIGExLCBhMCk7CiAgICAgIGNhc2UgNToKICAgICAgICByZXR1cm4gbmV1bWFyayhhMzIsIGEyMiwgYTEsIGEwKTsKICAgICAgY2FzZSA2OgogICAgICAgIHJldHVybiBvcmlnaW5hbChhMzIsIGEyMiwgYTEsIGEwKTsKICAgICAgY2FzZSA3OgogICAgICAgIHJldHVybiBvcmlnaW5hbChhMzIsIGEyMiwgYTEsIGEwKTsKICAgICAgY2FzZSA4OgogICAgICAgIHJldHVybiBuZXVtYXJrKGEzMiwgYTIyLCBhMSwgYTApOwogICAgICBjYXNlIDk6CiAgICAgICAgcmV0dXJuIG9yaWdpbmFsKGEzMiwgYTIyLCBhMSwgYTApOwogICAgICBjYXNlIDEwOgogICAgICAgIHJldHVybiBvcmlnaW5hbChhMzIsIGEyMiwgYTEsIGEwKTsKICAgICAgY2FzZSAxMToKICAgICAgICByZXR1cm4gbmV1bWFyayhhMzIsIGEyMiwgYTEsIGEwKTsKICAgICAgY2FzZSAxMjoKICAgICAgICByZXR1cm4gb3JpZ2luYWwoYTMyLCBhMjIsIGExLCBhMCk7CiAgICAgIGNhc2UgMTM6CiAgICAgICAgcmV0dXJuIG9yaWdpbmFsKGEzMiwgYTIyLCBhMSwgYTApOwogICAgICBjYXNlIDE0OgogICAgICAgIHJldHVybiBvcmlnaW5hbChhMzIsIGEyMiwgYTEsIGEwKTsKICAgICAgY2FzZSAxNToKICAgICAgICByZXR1cm4gb3JpZ2luYWwoYTMyLCBhMjIsIGExLCBhMCk7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICB9OwogIHZhciBRdWFydGljUmVhbFBvbHlub21pYWxfZGVmYXVsdCA9IFF1YXJ0aWNSZWFsUG9seW5vbWlhbDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1JheS5qcwogIGZ1bmN0aW9uIFJheShvcmlnaW4sIGRpcmVjdGlvbikgewogICAgZGlyZWN0aW9uID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGRpcmVjdGlvbiwgQ2FydGVzaWFuM19kZWZhdWx0LlpFUk8pKTsKICAgIGlmICghQ2FydGVzaWFuM19kZWZhdWx0LmVxdWFscyhkaXJlY3Rpb24sIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPKSkgewogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKGRpcmVjdGlvbiwgZGlyZWN0aW9uKTsKICAgIH0KICAgIHRoaXMub3JpZ2luID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9yaWdpbiwgQ2FydGVzaWFuM19kZWZhdWx0LlpFUk8pKTsKICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uOwogIH0KICBSYXkuY2xvbmUgPSBmdW5jdGlvbihyYXksIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmF5KSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXR1cm4gbmV3IFJheShyYXkub3JpZ2luLCByYXkuZGlyZWN0aW9uKTsKICAgIH0KICAgIHJlc3VsdC5vcmlnaW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUocmF5Lm9yaWdpbik7CiAgICByZXN1bHQuZGlyZWN0aW9uID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKHJheS5kaXJlY3Rpb24pOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFJheS5nZXRQb2ludCA9IGZ1bmN0aW9uKHJheSwgdCwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInJheSIsIHJheSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInQiLCB0KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogICAgfQogICAgcmVzdWx0ID0gQ2FydGVzaWFuM19kZWZhdWx0Lm11bHRpcGx5QnlTY2FsYXIocmF5LmRpcmVjdGlvbiwgdCwgcmVzdWx0KTsKICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJheS5vcmlnaW4sIHJlc3VsdCwgcmVzdWx0KTsKICB9OwogIHZhciBSYXlfZGVmYXVsdCA9IFJheTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0ludGVyc2VjdGlvblRlc3RzLmpzCiAgdmFyIEludGVyc2VjdGlvblRlc3RzID0ge307CiAgSW50ZXJzZWN0aW9uVGVzdHMucmF5UGxhbmUgPSBmdW5jdGlvbihyYXksIHBsYW5lLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJheSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJheSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBsYW5lKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicGxhbmUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIGNvbnN0IG9yaWdpbiA9IHJheS5vcmlnaW47CiAgICBjb25zdCBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uOwogICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsOwogICAgY29uc3QgZGVub21pbmF0b3IgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KG5vcm1hbCwgZGlyZWN0aW9uKTsKICAgIGlmIChNYXRoLmFicyhkZW5vbWluYXRvcikgPCBNYXRoX2RlZmF1bHQuRVBTSUxPTjE1KSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCB0ID0gKC1wbGFuZS5kaXN0YW5jZSAtIENhcnRlc2lhbjNfZGVmYXVsdC5kb3Qobm9ybWFsLCBvcmlnaW4pKSAvIGRlbm9taW5hdG9yOwogICAgaWYgKHQgPCAwKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICByZXN1bHQgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihkaXJlY3Rpb24sIHQsIHJlc3VsdCk7CiAgICByZXR1cm4gQ2FydGVzaWFuM19kZWZhdWx0LmFkZChvcmlnaW4sIHJlc3VsdCwgcmVzdWx0KTsKICB9OwogIHZhciBzY3JhdGNoRWRnZTAgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hFZGdlMSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFBWZWMgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hUVmVjID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUVZlYyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBJbnRlcnNlY3Rpb25UZXN0cy5yYXlUcmlhbmdsZVBhcmFtZXRyaWMgPSBmdW5jdGlvbihyYXksIHAwLCBwMSwgcDIsIGN1bGxCYWNrRmFjZXMpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJheSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJheSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHAwKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicDAgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwMSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInAxIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocDIpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJwMiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGN1bGxCYWNrRmFjZXMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjdWxsQmFja0ZhY2VzLCBmYWxzZSk7CiAgICBjb25zdCBvcmlnaW4gPSByYXkub3JpZ2luOwogICAgY29uc3QgZGlyZWN0aW9uID0gcmF5LmRpcmVjdGlvbjsKICAgIGNvbnN0IGVkZ2UwID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHAxLCBwMCwgc2NyYXRjaEVkZ2UwKTsKICAgIGNvbnN0IGVkZ2UxID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHAyLCBwMCwgc2NyYXRjaEVkZ2UxKTsKICAgIGNvbnN0IHAgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY3Jvc3MoZGlyZWN0aW9uLCBlZGdlMSwgc2NyYXRjaFBWZWMpOwogICAgY29uc3QgZGV0ID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChlZGdlMCwgcCk7CiAgICBsZXQgdHZlYzsKICAgIGxldCBxOwogICAgbGV0IHUyOwogICAgbGV0IHYyOwogICAgbGV0IHQ7CiAgICBpZiAoY3VsbEJhY2tGYWNlcykgewogICAgICBpZiAoZGV0IDwgTWF0aF9kZWZhdWx0LkVQU0lMT042KSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICB0dmVjID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KG9yaWdpbiwgcDAsIHNjcmF0Y2hUVmVjKTsKICAgICAgdTIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KHR2ZWMsIHApOwogICAgICBpZiAodTIgPCAwIHx8IHUyID4gZGV0KSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICBxID0gQ2FydGVzaWFuM19kZWZhdWx0LmNyb3NzKHR2ZWMsIGVkZ2UwLCBzY3JhdGNoUVZlYyk7CiAgICAgIHYyID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChkaXJlY3Rpb24sIHEpOwogICAgICBpZiAodjIgPCAwIHx8IHUyICsgdjIgPiBkZXQpIHsKICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICB9CiAgICAgIHQgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KGVkZ2UxLCBxKSAvIGRldDsKICAgIH0gZWxzZSB7CiAgICAgIGlmIChNYXRoLmFicyhkZXQpIDwgTWF0aF9kZWZhdWx0LkVQU0lMT042KSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICBjb25zdCBpbnZEZXQgPSAxIC8gZGV0OwogICAgICB0dmVjID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KG9yaWdpbiwgcDAsIHNjcmF0Y2hUVmVjKTsKICAgICAgdTIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KHR2ZWMsIHApICogaW52RGV0OwogICAgICBpZiAodTIgPCAwIHx8IHUyID4gMSkgewogICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgIH0KICAgICAgcSA9IENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyh0dmVjLCBlZGdlMCwgc2NyYXRjaFFWZWMpOwogICAgICB2MiA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZGlyZWN0aW9uLCBxKSAqIGludkRldDsKICAgICAgaWYgKHYyIDwgMCB8fCB1MiArIHYyID4gMSkgewogICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgIH0KICAgICAgdCA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZWRnZTEsIHEpICogaW52RGV0OwogICAgfQogICAgcmV0dXJuIHQ7CiAgfTsKICBJbnRlcnNlY3Rpb25UZXN0cy5yYXlUcmlhbmdsZSA9IGZ1bmN0aW9uKHJheSwgcDAsIHAxLCBwMiwgY3VsbEJhY2tGYWNlcywgcmVzdWx0KSB7CiAgICBjb25zdCB0ID0gSW50ZXJzZWN0aW9uVGVzdHMucmF5VHJpYW5nbGVQYXJhbWV0cmljKAogICAgICByYXksCiAgICAgIHAwLAogICAgICBwMSwKICAgICAgcDIsCiAgICAgIGN1bGxCYWNrRmFjZXMKICAgICk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh0KSB8fCB0IDwgMCkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihyYXkuZGlyZWN0aW9uLCB0LCByZXN1bHQpOwogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQocmF5Lm9yaWdpbiwgcmVzdWx0LCByZXN1bHQpOwogIH07CiAgdmFyIHNjcmF0Y2hMaW5lU2VnbWVudFRyaWFuZ2xlUmF5ID0gbmV3IFJheV9kZWZhdWx0KCk7CiAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRUcmlhbmdsZSA9IGZ1bmN0aW9uKHYwLCB2MSwgcDAsIHAxLCBwMiwgY3VsbEJhY2tGYWNlcywgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh2MCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInYwIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodjEpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ2MSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHAwKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicDAgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwMSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInAxIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocDIpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJwMiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IHJheSA9IHNjcmF0Y2hMaW5lU2VnbWVudFRyaWFuZ2xlUmF5OwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKHYwLCByYXkub3JpZ2luKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdCh2MSwgdjAsIHJheS5kaXJlY3Rpb24pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0Lm5vcm1hbGl6ZShyYXkuZGlyZWN0aW9uLCByYXkuZGlyZWN0aW9uKTsKICAgIGNvbnN0IHQgPSBJbnRlcnNlY3Rpb25UZXN0cy5yYXlUcmlhbmdsZVBhcmFtZXRyaWMoCiAgICAgIHJheSwKICAgICAgcDAsCiAgICAgIHAxLAogICAgICBwMiwKICAgICAgY3VsbEJhY2tGYWNlcwogICAgKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHQpIHx8IHQgPCAwIHx8IHQgPiBDYXJ0ZXNpYW4zX2RlZmF1bHQuZGlzdGFuY2UodjAsIHYxKSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihyYXkuZGlyZWN0aW9uLCB0LCByZXN1bHQpOwogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQocmF5Lm9yaWdpbiwgcmVzdWx0LCByZXN1bHQpOwogIH07CiAgZnVuY3Rpb24gc29sdmVRdWFkcmF0aWMoYTMsIGIsIGMsIHJlc3VsdCkgewogICAgY29uc3QgZGV0ID0gYiAqIGIgLSA0ICogYTMgKiBjOwogICAgaWYgKGRldCA8IDApIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0gZWxzZSBpZiAoZGV0ID4gMCkgewogICAgICBjb25zdCBkZW5vbSA9IDEgLyAoMiAqIGEzKTsKICAgICAgY29uc3QgZGlzYyA9IE1hdGguc3FydChkZXQpOwogICAgICBjb25zdCByb290MCA9ICgtYiArIGRpc2MpICogZGVub207CiAgICAgIGNvbnN0IHJvb3QxID0gKC1iIC0gZGlzYykgKiBkZW5vbTsKICAgICAgaWYgKHJvb3QwIDwgcm9vdDEpIHsKICAgICAgICByZXN1bHQucm9vdDAgPSByb290MDsKICAgICAgICByZXN1bHQucm9vdDEgPSByb290MTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQucm9vdDAgPSByb290MTsKICAgICAgICByZXN1bHQucm9vdDEgPSByb290MDsKICAgICAgfQogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgY29uc3Qgcm9vdCA9IC1iIC8gKDIgKiBhMyk7CiAgICBpZiAocm9vdCA9PT0gMCkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgcmVzdWx0LnJvb3QwID0gcmVzdWx0LnJvb3QxID0gcm9vdDsKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciByYXlTcGhlcmVSb290cyA9IHsKICAgIHJvb3QwOiAwLAogICAgcm9vdDE6IDAKICB9OwogIGZ1bmN0aW9uIHJheVNwaGVyZShyYXksIHNwaGVyZSwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnZhbF9kZWZhdWx0KCk7CiAgICB9CiAgICBjb25zdCBvcmlnaW4gPSByYXkub3JpZ2luOwogICAgY29uc3QgZGlyZWN0aW9uID0gcmF5LmRpcmVjdGlvbjsKICAgIGNvbnN0IGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7CiAgICBjb25zdCByYWRpdXNTcXVhcmVkID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7CiAgICBjb25zdCBkaWZmID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KG9yaWdpbiwgY2VudGVyLCBzY3JhdGNoUFZlYyk7CiAgICBjb25zdCBhMyA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZGlyZWN0aW9uLCBkaXJlY3Rpb24pOwogICAgY29uc3QgYiA9IDIgKiBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KGRpcmVjdGlvbiwgZGlmZik7CiAgICBjb25zdCBjID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQoZGlmZikgLSByYWRpdXNTcXVhcmVkOwogICAgY29uc3Qgcm9vdHMgPSBzb2x2ZVF1YWRyYXRpYyhhMywgYiwgYywgcmF5U3BoZXJlUm9vdHMpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocm9vdHMpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICByZXN1bHQuc3RhcnQgPSByb290cy5yb290MDsKICAgIHJlc3VsdC5zdG9wID0gcm9vdHMucm9vdDE7CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICBJbnRlcnNlY3Rpb25UZXN0cy5yYXlTcGhlcmUgPSBmdW5jdGlvbihyYXksIHNwaGVyZSwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyYXkpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJyYXkgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChzcGhlcmUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJzcGhlcmUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICByZXN1bHQgPSByYXlTcGhlcmUocmF5LCBzcGhlcmUsIHJlc3VsdCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpIHx8IHJlc3VsdC5zdG9wIDwgMCkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgcmVzdWx0LnN0YXJ0ID0gTWF0aC5tYXgocmVzdWx0LnN0YXJ0LCAwKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NyYXRjaExpbmVTZWdtZW50UmF5ID0gbmV3IFJheV9kZWZhdWx0KCk7CiAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRTcGhlcmUgPSBmdW5jdGlvbihwMCwgcDEsIHNwaGVyZSwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwMCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInAwIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocDEpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJwMSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHNwaGVyZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInNwaGVyZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IHJheSA9IHNjcmF0Y2hMaW5lU2VnbWVudFJheTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShwMCwgcmF5Lm9yaWdpbik7CiAgICBjb25zdCBkaXJlY3Rpb24gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QocDEsIHAwLCByYXkuZGlyZWN0aW9uKTsKICAgIGNvbnN0IG1heFQgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKGRpcmVjdGlvbik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKGRpcmVjdGlvbiwgZGlyZWN0aW9uKTsKICAgIHJlc3VsdCA9IHJheVNwaGVyZShyYXksIHNwaGVyZSwgcmVzdWx0KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkgfHwgcmVzdWx0LnN0b3AgPCAwIHx8IHJlc3VsdC5zdGFydCA+IG1heFQpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIHJlc3VsdC5zdGFydCA9IE1hdGgubWF4KHJlc3VsdC5zdGFydCwgMCk7CiAgICByZXN1bHQuc3RvcCA9IE1hdGgubWluKHJlc3VsdC5zdG9wLCBtYXhUKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NyYXRjaFEgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hXID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIEludGVyc2VjdGlvblRlc3RzLnJheUVsbGlwc29pZCA9IGZ1bmN0aW9uKHJheSwgZWxsaXBzb2lkKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyYXkpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJyYXkgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChlbGxpcHNvaWQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJlbGxpcHNvaWQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBpbnZlcnNlUmFkaWkgPSBlbGxpcHNvaWQub25lT3ZlclJhZGlpOwogICAgY29uc3QgcSA9IENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUNvbXBvbmVudHMoaW52ZXJzZVJhZGlpLCByYXkub3JpZ2luLCBzY3JhdGNoUSk7CiAgICBjb25zdCB3ID0gQ2FydGVzaWFuM19kZWZhdWx0Lm11bHRpcGx5Q29tcG9uZW50cygKICAgICAgaW52ZXJzZVJhZGlpLAogICAgICByYXkuZGlyZWN0aW9uLAogICAgICBzY3JhdGNoVwogICAgKTsKICAgIGNvbnN0IHEyID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQocSk7CiAgICBjb25zdCBxdyA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QocSwgdyk7CiAgICBsZXQgZGlmZmVyZW5jZSwgdzIsIHByb2R1Y3QsIGRpc2NyaW1pbmFudCwgdGVtcDsKICAgIGlmIChxMiA+IDEpIHsKICAgICAgaWYgKHF3ID49IDApIHsKICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICB9CiAgICAgIGNvbnN0IHF3MiA9IHF3ICogcXc7CiAgICAgIGRpZmZlcmVuY2UgPSBxMiAtIDE7CiAgICAgIHcyID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQodyk7CiAgICAgIHByb2R1Y3QgPSB3MiAqIGRpZmZlcmVuY2U7CiAgICAgIGlmIChxdzIgPCBwcm9kdWN0KSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfSBlbHNlIGlmIChxdzIgPiBwcm9kdWN0KSB7CiAgICAgICAgZGlzY3JpbWluYW50ID0gcXcgKiBxdyAtIHByb2R1Y3Q7CiAgICAgICAgdGVtcCA9IC1xdyArIE1hdGguc3FydChkaXNjcmltaW5hbnQpOwogICAgICAgIGNvbnN0IHJvb3QwID0gdGVtcCAvIHcyOwogICAgICAgIGNvbnN0IHJvb3QxID0gZGlmZmVyZW5jZSAvIHRlbXA7CiAgICAgICAgaWYgKHJvb3QwIDwgcm9vdDEpIHsKICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWxfZGVmYXVsdChyb290MCwgcm9vdDEpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gewogICAgICAgICAgc3RhcnQ6IHJvb3QxLAogICAgICAgICAgc3RvcDogcm9vdDAKICAgICAgICB9OwogICAgICB9CiAgICAgIGNvbnN0IHJvb3QgPSBNYXRoLnNxcnQoZGlmZmVyZW5jZSAvIHcyKTsKICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbF9kZWZhdWx0KHJvb3QsIHJvb3QpOwogICAgfSBlbHNlIGlmIChxMiA8IDEpIHsKICAgICAgZGlmZmVyZW5jZSA9IHEyIC0gMTsKICAgICAgdzIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlU3F1YXJlZCh3KTsKICAgICAgcHJvZHVjdCA9IHcyICogZGlmZmVyZW5jZTsKICAgICAgZGlzY3JpbWluYW50ID0gcXcgKiBxdyAtIHByb2R1Y3Q7CiAgICAgIHRlbXAgPSAtcXcgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTsKICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbF9kZWZhdWx0KDAsIHRlbXAgLyB3Mik7CiAgICB9CiAgICBpZiAocXcgPCAwKSB7CiAgICAgIHcyID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZVNxdWFyZWQodyk7CiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWxfZGVmYXVsdCgwLCAtcXcgLyB3Mik7CiAgICB9CiAgICByZXR1cm4gdm9pZCAwOwogIH07CiAgZnVuY3Rpb24gYWRkV2l0aENhbmNlbGxhdGlvbkNoZWNrMihsZWZ0LCByaWdodCwgdG9sZXJhbmNlKSB7CiAgICBjb25zdCBkaWZmZXJlbmNlID0gbGVmdCArIHJpZ2h0OwogICAgaWYgKE1hdGhfZGVmYXVsdC5zaWduKGxlZnQpICE9PSBNYXRoX2RlZmF1bHQuc2lnbihyaWdodCkgJiYgTWF0aC5hYnMoZGlmZmVyZW5jZSAvIE1hdGgubWF4KE1hdGguYWJzKGxlZnQpLCBNYXRoLmFicyhyaWdodCkpKSA8IHRvbGVyYW5jZSkgewogICAgICByZXR1cm4gMDsKICAgIH0KICAgIHJldHVybiBkaWZmZXJlbmNlOwogIH0KICBmdW5jdGlvbiBxdWFkcmF0aWNWZWN0b3JFeHByZXNzaW9uKEEsIGIsIGMsIHgsIHcpIHsKICAgIGNvbnN0IHhTcXVhcmVkID0geCAqIHg7CiAgICBjb25zdCB3U3F1YXJlZCA9IHcgKiB3OwogICAgY29uc3QgbDIgPSAoQVtNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMVJPVzFdIC0gQVtNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMlJPVzJdKSAqIHdTcXVhcmVkOwogICAgY29uc3QgbDEgPSB3ICogKHggKiBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2syKAogICAgICBBW01hdHJpeDNfZGVmYXVsdC5DT0xVTU4xUk9XMF0sCiAgICAgIEFbTWF0cml4M19kZWZhdWx0LkNPTFVNTjBST1cxXSwKICAgICAgTWF0aF9kZWZhdWx0LkVQU0lMT04xNQogICAgKSArIGIueSk7CiAgICBjb25zdCBsMCA9IEFbTWF0cml4M19kZWZhdWx0LkNPTFVNTjBST1cwXSAqIHhTcXVhcmVkICsgQVtNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMlJPVzJdICogd1NxdWFyZWQgKyB4ICogYi54ICsgYzsKICAgIGNvbnN0IHIxID0gd1NxdWFyZWQgKiBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2syKAogICAgICBBW01hdHJpeDNfZGVmYXVsdC5DT0xVTU4yUk9XMV0sCiAgICAgIEFbTWF0cml4M19kZWZhdWx0LkNPTFVNTjFST1cyXSwKICAgICAgTWF0aF9kZWZhdWx0LkVQU0lMT04xNQogICAgKTsKICAgIGNvbnN0IHIwID0gdyAqICh4ICogYWRkV2l0aENhbmNlbGxhdGlvbkNoZWNrMihBW01hdHJpeDNfZGVmYXVsdC5DT0xVTU4yUk9XMF0sIEFbTWF0cml4M19kZWZhdWx0LkNPTFVNTjBST1cyXSkgKyBiLnopOwogICAgbGV0IGNvc2luZXM7CiAgICBjb25zdCBzb2x1dGlvbnMgPSBbXTsKICAgIGlmIChyMCA9PT0gMCAmJiByMSA9PT0gMCkgewogICAgICBjb3NpbmVzID0gUXVhZHJhdGljUmVhbFBvbHlub21pYWxfZGVmYXVsdC5jb21wdXRlUmVhbFJvb3RzKGwyLCBsMSwgbDApOwogICAgICBpZiAoY29zaW5lcy5sZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4gc29sdXRpb25zOwogICAgICB9CiAgICAgIGNvbnN0IGNvc2luZTAgPSBjb3NpbmVzWzBdOwogICAgICBjb25zdCBzaW5lMCA9IE1hdGguc3FydChNYXRoLm1heCgxIC0gY29zaW5lMCAqIGNvc2luZTAsIDApKTsKICAgICAgc29sdXRpb25zLnB1c2gobmV3IENhcnRlc2lhbjNfZGVmYXVsdCh4LCB3ICogY29zaW5lMCwgdyAqIC1zaW5lMCkpOwogICAgICBzb2x1dGlvbnMucHVzaChuZXcgQ2FydGVzaWFuM19kZWZhdWx0KHgsIHcgKiBjb3NpbmUwLCB3ICogc2luZTApKTsKICAgICAgaWYgKGNvc2luZXMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgY29uc3QgY29zaW5lMSA9IGNvc2luZXNbMV07CiAgICAgICAgY29uc3Qgc2luZTEgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMSAtIGNvc2luZTEgKiBjb3NpbmUxLCAwKSk7CiAgICAgICAgc29sdXRpb25zLnB1c2gobmV3IENhcnRlc2lhbjNfZGVmYXVsdCh4LCB3ICogY29zaW5lMSwgdyAqIC1zaW5lMSkpOwogICAgICAgIHNvbHV0aW9ucy5wdXNoKG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoeCwgdyAqIGNvc2luZTEsIHcgKiBzaW5lMSkpOwogICAgICB9CiAgICAgIHJldHVybiBzb2x1dGlvbnM7CiAgICB9CiAgICBjb25zdCByMFNxdWFyZWQgPSByMCAqIHIwOwogICAgY29uc3QgcjFTcXVhcmVkID0gcjEgKiByMTsKICAgIGNvbnN0IGwyU3F1YXJlZCA9IGwyICogbDI7CiAgICBjb25zdCByMHIxID0gcjAgKiByMTsKICAgIGNvbnN0IGM0ID0gbDJTcXVhcmVkICsgcjFTcXVhcmVkOwogICAgY29uc3QgYzMgPSAyICogKGwxICogbDIgKyByMHIxKTsKICAgIGNvbnN0IGMyID0gMiAqIGwwICogbDIgKyBsMSAqIGwxIC0gcjFTcXVhcmVkICsgcjBTcXVhcmVkOwogICAgY29uc3QgYzEgPSAyICogKGwwICogbDEgLSByMHIxKTsKICAgIGNvbnN0IGMwID0gbDAgKiBsMCAtIHIwU3F1YXJlZDsKICAgIGlmIChjNCA9PT0gMCAmJiBjMyA9PT0gMCAmJiBjMiA9PT0gMCAmJiBjMSA9PT0gMCkgewogICAgICByZXR1cm4gc29sdXRpb25zOwogICAgfQogICAgY29zaW5lcyA9IFF1YXJ0aWNSZWFsUG9seW5vbWlhbF9kZWZhdWx0LmNvbXB1dGVSZWFsUm9vdHMoYzQsIGMzLCBjMiwgYzEsIGMwKTsKICAgIGNvbnN0IGxlbmd0aCA9IGNvc2luZXMubGVuZ3RoOwogICAgaWYgKGxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gc29sdXRpb25zOwogICAgfQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICBjb25zdCBjb3NpbmUgPSBjb3NpbmVzW2ldOwogICAgICBjb25zdCBjb3NpbmVTcXVhcmVkID0gY29zaW5lICogY29zaW5lOwogICAgICBjb25zdCBzaW5lU3F1YXJlZCA9IE1hdGgubWF4KDEgLSBjb3NpbmVTcXVhcmVkLCAwKTsKICAgICAgY29uc3Qgc2luZSA9IE1hdGguc3FydChzaW5lU3F1YXJlZCk7CiAgICAgIGxldCBsZWZ0OwogICAgICBpZiAoTWF0aF9kZWZhdWx0LnNpZ24obDIpID09PSBNYXRoX2RlZmF1bHQuc2lnbihsMCkpIHsKICAgICAgICBsZWZ0ID0gYWRkV2l0aENhbmNlbGxhdGlvbkNoZWNrMigKICAgICAgICAgIGwyICogY29zaW5lU3F1YXJlZCArIGwwLAogICAgICAgICAgbDEgKiBjb3NpbmUsCiAgICAgICAgICBNYXRoX2RlZmF1bHQuRVBTSUxPTjEyCiAgICAgICAgKTsKICAgICAgfSBlbHNlIGlmIChNYXRoX2RlZmF1bHQuc2lnbihsMCkgPT09IE1hdGhfZGVmYXVsdC5zaWduKGwxICogY29zaW5lKSkgewogICAgICAgIGxlZnQgPSBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2syKAogICAgICAgICAgbDIgKiBjb3NpbmVTcXVhcmVkLAogICAgICAgICAgbDEgKiBjb3NpbmUgKyBsMCwKICAgICAgICAgIE1hdGhfZGVmYXVsdC5FUFNJTE9OMTIKICAgICAgICApOwogICAgICB9IGVsc2UgewogICAgICAgIGxlZnQgPSBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2syKAogICAgICAgICAgbDIgKiBjb3NpbmVTcXVhcmVkICsgbDEgKiBjb3NpbmUsCiAgICAgICAgICBsMCwKICAgICAgICAgIE1hdGhfZGVmYXVsdC5FUFNJTE9OMTIKICAgICAgICApOwogICAgICB9CiAgICAgIGNvbnN0IHJpZ2h0ID0gYWRkV2l0aENhbmNlbGxhdGlvbkNoZWNrMigKICAgICAgICByMSAqIGNvc2luZSwKICAgICAgICByMCwKICAgICAgICBNYXRoX2RlZmF1bHQuRVBTSUxPTjE1CiAgICAgICk7CiAgICAgIGNvbnN0IHByb2R1Y3QgPSBsZWZ0ICogcmlnaHQ7CiAgICAgIGlmIChwcm9kdWN0IDwgMCkgewogICAgICAgIHNvbHV0aW9ucy5wdXNoKG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoeCwgdyAqIGNvc2luZSwgdyAqIHNpbmUpKTsKICAgICAgfSBlbHNlIGlmIChwcm9kdWN0ID4gMCkgewogICAgICAgIHNvbHV0aW9ucy5wdXNoKG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoeCwgdyAqIGNvc2luZSwgdyAqIC1zaW5lKSk7CiAgICAgIH0gZWxzZSBpZiAoc2luZSAhPT0gMCkgewogICAgICAgIHNvbHV0aW9ucy5wdXNoKG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoeCwgdyAqIGNvc2luZSwgdyAqIC1zaW5lKSk7CiAgICAgICAgc29sdXRpb25zLnB1c2gobmV3IENhcnRlc2lhbjNfZGVmYXVsdCh4LCB3ICogY29zaW5lLCB3ICogc2luZSkpOwogICAgICAgICsraTsKICAgICAgfSBlbHNlIHsKICAgICAgICBzb2x1dGlvbnMucHVzaChuZXcgQ2FydGVzaWFuM19kZWZhdWx0KHgsIHcgKiBjb3NpbmUsIHcgKiBzaW5lKSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBzb2x1dGlvbnM7CiAgfQogIHZhciBmaXJzdEF4aXNTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzZWNvbmRBeGlzU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgdGhpcmRBeGlzU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgcmVmZXJlbmNlU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgYkNhcnQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIGJTY3JhdGNoID0gbmV3IE1hdHJpeDNfZGVmYXVsdCgpOwogIHZhciBidFNjcmF0Y2ggPSBuZXcgTWF0cml4M19kZWZhdWx0KCk7CiAgdmFyIGRpU2NyYXRjaCA9IG5ldyBNYXRyaXgzX2RlZmF1bHQoKTsKICB2YXIgZFNjcmF0Y2ggPSBuZXcgTWF0cml4M19kZWZhdWx0KCk7CiAgdmFyIGNTY3JhdGNoID0gbmV3IE1hdHJpeDNfZGVmYXVsdCgpOwogIHZhciB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeDNfZGVmYXVsdCgpOwogIHZhciBhU2NyYXRjaCA9IG5ldyBNYXRyaXgzX2RlZmF1bHQoKTsKICB2YXIgc1NjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIGNsb3Nlc3RTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzdXJmUG9pbnRTY3JhdGNoID0gbmV3IENhcnRvZ3JhcGhpY19kZWZhdWx0KCk7CiAgSW50ZXJzZWN0aW9uVGVzdHMuZ3JhemluZ0FsdGl0dWRlTG9jYXRpb24gPSBmdW5jdGlvbihyYXksIGVsbGlwc29pZCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmF5KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicmF5IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZWxsaXBzb2lkKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZWxsaXBzb2lkIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgcG9zaXRpb24gPSByYXkub3JpZ2luOwogICAgY29uc3QgZGlyZWN0aW9uID0gcmF5LmRpcmVjdGlvbjsKICAgIGlmICghQ2FydGVzaWFuM19kZWZhdWx0LmVxdWFscyhwb3NpdGlvbiwgQ2FydGVzaWFuM19kZWZhdWx0LlpFUk8pKSB7CiAgICAgIGNvbnN0IG5vcm1hbCA9IGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwocG9zaXRpb24sIGZpcnN0QXhpc1NjcmF0Y2gpOwogICAgICBpZiAoQ2FydGVzaWFuM19kZWZhdWx0LmRvdChkaXJlY3Rpb24sIG5vcm1hbCkgPj0gMCkgewogICAgICAgIHJldHVybiBwb3NpdGlvbjsKICAgICAgfQogICAgfQogICAgY29uc3QgaW50ZXJzZWN0cyA9IGRlZmluZWRfZGVmYXVsdCh0aGlzLnJheUVsbGlwc29pZChyYXksIGVsbGlwc29pZCkpOwogICAgY29uc3QgZiA9IGVsbGlwc29pZC50cmFuc2Zvcm1Qb3NpdGlvblRvU2NhbGVkU3BhY2UoCiAgICAgIGRpcmVjdGlvbiwKICAgICAgZmlyc3RBeGlzU2NyYXRjaAogICAgKTsKICAgIGNvbnN0IGZpcnN0QXhpcyA9IENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUoZiwgZik7CiAgICBjb25zdCByZWZlcmVuY2UgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubW9zdE9ydGhvZ29uYWxBeGlzKGYsIHJlZmVyZW5jZVNjcmF0Y2gpOwogICAgY29uc3Qgc2Vjb25kQXhpcyA9IENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyhyZWZlcmVuY2UsIGZpcnN0QXhpcywgc2Vjb25kQXhpc1NjcmF0Y2gpLAogICAgICBzZWNvbmRBeGlzU2NyYXRjaAogICAgKTsKICAgIGNvbnN0IHRoaXJkQXhpcyA9IENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyhmaXJzdEF4aXMsIHNlY29uZEF4aXMsIHRoaXJkQXhpc1NjcmF0Y2gpLAogICAgICB0aGlyZEF4aXNTY3JhdGNoCiAgICApOwogICAgY29uc3QgQiA9IGJTY3JhdGNoOwogICAgQlswXSA9IGZpcnN0QXhpcy54OwogICAgQlsxXSA9IGZpcnN0QXhpcy55OwogICAgQlsyXSA9IGZpcnN0QXhpcy56OwogICAgQlszXSA9IHNlY29uZEF4aXMueDsKICAgIEJbNF0gPSBzZWNvbmRBeGlzLnk7CiAgICBCWzVdID0gc2Vjb25kQXhpcy56OwogICAgQls2XSA9IHRoaXJkQXhpcy54OwogICAgQls3XSA9IHRoaXJkQXhpcy55OwogICAgQls4XSA9IHRoaXJkQXhpcy56OwogICAgY29uc3QgQl9UID0gTWF0cml4M19kZWZhdWx0LnRyYW5zcG9zZShCLCBidFNjcmF0Y2gpOwogICAgY29uc3QgRF9JID0gTWF0cml4M19kZWZhdWx0LmZyb21TY2FsZShlbGxpcHNvaWQucmFkaWksIGRpU2NyYXRjaCk7CiAgICBjb25zdCBEID0gTWF0cml4M19kZWZhdWx0LmZyb21TY2FsZShlbGxpcHNvaWQub25lT3ZlclJhZGlpLCBkU2NyYXRjaCk7CiAgICBjb25zdCBDID0gY1NjcmF0Y2g7CiAgICBDWzBdID0gMDsKICAgIENbMV0gPSAtZGlyZWN0aW9uLno7CiAgICBDWzJdID0gZGlyZWN0aW9uLnk7CiAgICBDWzNdID0gZGlyZWN0aW9uLno7CiAgICBDWzRdID0gMDsKICAgIENbNV0gPSAtZGlyZWN0aW9uLng7CiAgICBDWzZdID0gLWRpcmVjdGlvbi55OwogICAgQ1s3XSA9IGRpcmVjdGlvbi54OwogICAgQ1s4XSA9IDA7CiAgICBjb25zdCB0ZW1wID0gTWF0cml4M19kZWZhdWx0Lm11bHRpcGx5KAogICAgICBNYXRyaXgzX2RlZmF1bHQubXVsdGlwbHkoQl9ULCBELCB0ZW1wTWF0cml4KSwKICAgICAgQywKICAgICAgdGVtcE1hdHJpeAogICAgKTsKICAgIGNvbnN0IEEgPSBNYXRyaXgzX2RlZmF1bHQubXVsdGlwbHkoCiAgICAgIE1hdHJpeDNfZGVmYXVsdC5tdWx0aXBseSh0ZW1wLCBEX0ksIGFTY3JhdGNoKSwKICAgICAgQiwKICAgICAgYVNjcmF0Y2gKICAgICk7CiAgICBjb25zdCBiID0gTWF0cml4M19kZWZhdWx0Lm11bHRpcGx5QnlWZWN0b3IodGVtcCwgcG9zaXRpb24sIGJDYXJ0KTsKICAgIGNvbnN0IHNvbHV0aW9ucyA9IHF1YWRyYXRpY1ZlY3RvckV4cHJlc3Npb24oCiAgICAgIEEsCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5uZWdhdGUoYiwgZmlyc3RBeGlzU2NyYXRjaCksCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICk7CiAgICBsZXQgczsKICAgIGxldCBhbHRpdHVkZTsKICAgIGNvbnN0IGxlbmd0aCA9IHNvbHV0aW9ucy5sZW5ndGg7CiAgICBpZiAobGVuZ3RoID4gMCkgewogICAgICBsZXQgY2xvc2VzdCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTywgY2xvc2VzdFNjcmF0Y2gpOwogICAgICBsZXQgbWF4aW11bVZhbHVlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgcyA9IE1hdHJpeDNfZGVmYXVsdC5tdWx0aXBseUJ5VmVjdG9yKAogICAgICAgICAgRF9JLAogICAgICAgICAgTWF0cml4M19kZWZhdWx0Lm11bHRpcGx5QnlWZWN0b3IoQiwgc29sdXRpb25zW2ldLCBzU2NyYXRjaCksCiAgICAgICAgICBzU2NyYXRjaAogICAgICAgICk7CiAgICAgICAgY29uc3QgdjIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKAogICAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHMsIHBvc2l0aW9uLCByZWZlcmVuY2VTY3JhdGNoKSwKICAgICAgICAgIHJlZmVyZW5jZVNjcmF0Y2gKICAgICAgICApOwogICAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KHYyLCBkaXJlY3Rpb24pOwogICAgICAgIGlmIChkb3RQcm9kdWN0ID4gbWF4aW11bVZhbHVlKSB7CiAgICAgICAgICBtYXhpbXVtVmFsdWUgPSBkb3RQcm9kdWN0OwogICAgICAgICAgY2xvc2VzdCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShzLCBjbG9zZXN0KTsKICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3Qgc3VyZmFjZVBvaW50ID0gZWxsaXBzb2lkLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKAogICAgICAgIGNsb3Nlc3QsCiAgICAgICAgc3VyZlBvaW50U2NyYXRjaAogICAgICApOwogICAgICBtYXhpbXVtVmFsdWUgPSBNYXRoX2RlZmF1bHQuY2xhbXAobWF4aW11bVZhbHVlLCAwLCAxKTsKICAgICAgYWx0aXR1ZGUgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKAogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjbG9zZXN0LCBwb3NpdGlvbiwgcmVmZXJlbmNlU2NyYXRjaCkKICAgICAgKSAqIE1hdGguc3FydCgxIC0gbWF4aW11bVZhbHVlICogbWF4aW11bVZhbHVlKTsKICAgICAgYWx0aXR1ZGUgPSBpbnRlcnNlY3RzID8gLWFsdGl0dWRlIDogYWx0aXR1ZGU7CiAgICAgIHN1cmZhY2VQb2ludC5oZWlnaHQgPSBhbHRpdHVkZTsKICAgICAgcmV0dXJuIGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihzdXJmYWNlUG9pbnQsIG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKSk7CiAgICB9CiAgICByZXR1cm4gdm9pZCAwOwogIH07CiAgdmFyIGxpbmVTZWdtZW50UGxhbmVEaWZmZXJlbmNlID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUgPSBmdW5jdGlvbihlbmRQb2ludDAsIGVuZFBvaW50MSwgcGxhbmUsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZW5kUG9pbnQwKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZW5kUG9pbnQwIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZW5kUG9pbnQxKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZW5kUG9pbnQxIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocGxhbmUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJwbGFuZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogICAgfQogICAgY29uc3QgZGlmZmVyZW5jZSA9IENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdCgKICAgICAgZW5kUG9pbnQxLAogICAgICBlbmRQb2ludDAsCiAgICAgIGxpbmVTZWdtZW50UGxhbmVEaWZmZXJlbmNlCiAgICApOwogICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsOwogICAgY29uc3QgbkRvdERpZmYgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KG5vcm1hbCwgZGlmZmVyZW5jZSk7CiAgICBpZiAoTWF0aC5hYnMobkRvdERpZmYpIDwgTWF0aF9kZWZhdWx0LkVQU0lMT042KSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCBuRG90UDAgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KG5vcm1hbCwgZW5kUG9pbnQwKTsKICAgIGNvbnN0IHQgPSAtKHBsYW5lLmRpc3RhbmNlICsgbkRvdFAwKSAvIG5Eb3REaWZmOwogICAgaWYgKHQgPCAwIHx8IHQgPiAxKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcihkaWZmZXJlbmNlLCB0LCByZXN1bHQpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChlbmRQb2ludDAsIHJlc3VsdCwgcmVzdWx0KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBJbnRlcnNlY3Rpb25UZXN0cy50cmlhbmdsZVBsYW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgcGxhbmUpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHAwKSB8fCAhZGVmaW5lZF9kZWZhdWx0KHAxKSB8fCAhZGVmaW5lZF9kZWZhdWx0KHAyKSB8fCAhZGVmaW5lZF9kZWZhdWx0KHBsYW5lKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicDAsIHAxLCBwMiwgYW5kIHBsYW5lIGFyZSByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IHBsYW5lTm9ybWFsID0gcGxhbmUubm9ybWFsOwogICAgY29uc3QgcGxhbmVEID0gcGxhbmUuZGlzdGFuY2U7CiAgICBjb25zdCBwMEJlaGluZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QocGxhbmVOb3JtYWwsIHAwKSArIHBsYW5lRCA8IDA7CiAgICBjb25zdCBwMUJlaGluZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QocGxhbmVOb3JtYWwsIHAxKSArIHBsYW5lRCA8IDA7CiAgICBjb25zdCBwMkJlaGluZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QocGxhbmVOb3JtYWwsIHAyKSArIHBsYW5lRCA8IDA7CiAgICBsZXQgbnVtQmVoaW5kID0gMDsKICAgIG51bUJlaGluZCArPSBwMEJlaGluZCA/IDEgOiAwOwogICAgbnVtQmVoaW5kICs9IHAxQmVoaW5kID8gMSA6IDA7CiAgICBudW1CZWhpbmQgKz0gcDJCZWhpbmQgPyAxIDogMDsKICAgIGxldCB1MSwgdTI7CiAgICBpZiAobnVtQmVoaW5kID09PSAxIHx8IG51bUJlaGluZCA9PT0gMikgewogICAgICB1MSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgICAgdTIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgICB9CiAgICBpZiAobnVtQmVoaW5kID09PSAxKSB7CiAgICAgIGlmIChwMEJlaGluZCkgewogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDAsIHAxLCBwbGFuZSwgdTEpOwogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDAsIHAyLCBwbGFuZSwgdTIpOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwb3NpdGlvbnM6IFtwMCwgcDEsIHAyLCB1MSwgdTJdLAogICAgICAgICAgaW5kaWNlczogWwogICAgICAgICAgICAwLAogICAgICAgICAgICAzLAogICAgICAgICAgICA0LAogICAgICAgICAgICAxLAogICAgICAgICAgICAyLAogICAgICAgICAgICA0LAogICAgICAgICAgICAxLAogICAgICAgICAgICA0LAogICAgICAgICAgICAzCiAgICAgICAgICBdCiAgICAgICAgfTsKICAgICAgfSBlbHNlIGlmIChwMUJlaGluZCkgewogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDEsIHAyLCBwbGFuZSwgdTEpOwogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDEsIHAwLCBwbGFuZSwgdTIpOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwb3NpdGlvbnM6IFtwMCwgcDEsIHAyLCB1MSwgdTJdLAogICAgICAgICAgaW5kaWNlczogWwogICAgICAgICAgICAxLAogICAgICAgICAgICAzLAogICAgICAgICAgICA0LAogICAgICAgICAgICAyLAogICAgICAgICAgICAwLAogICAgICAgICAgICA0LAogICAgICAgICAgICAyLAogICAgICAgICAgICA0LAogICAgICAgICAgICAzCiAgICAgICAgICBdCiAgICAgICAgfTsKICAgICAgfSBlbHNlIGlmIChwMkJlaGluZCkgewogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDIsIHAwLCBwbGFuZSwgdTEpOwogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDIsIHAxLCBwbGFuZSwgdTIpOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwb3NpdGlvbnM6IFtwMCwgcDEsIHAyLCB1MSwgdTJdLAogICAgICAgICAgaW5kaWNlczogWwogICAgICAgICAgICAyLAogICAgICAgICAgICAzLAogICAgICAgICAgICA0LAogICAgICAgICAgICAwLAogICAgICAgICAgICAxLAogICAgICAgICAgICA0LAogICAgICAgICAgICAwLAogICAgICAgICAgICA0LAogICAgICAgICAgICAzCiAgICAgICAgICBdCiAgICAgICAgfTsKICAgICAgfQogICAgfSBlbHNlIGlmIChudW1CZWhpbmQgPT09IDIpIHsKICAgICAgaWYgKCFwMEJlaGluZCkgewogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDEsIHAwLCBwbGFuZSwgdTEpOwogICAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDIsIHAwLCBwbGFuZSwgdTIpOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwb3NpdGlvbnM6IFtwMCwgcDEsIHAyLCB1MSwgdTJdLAogICAgICAgICAgaW5kaWNlczogWwogICAgICAgICAgICAxLAogICAgICAgICAgICAyLAogICAgICAgICAgICA0LAogICAgICAgICAgICAxLAogICAgICAgICAgICA0LAogICAgICAgICAgICAzLAogICAgICAgICAgICAwLAogICAgICAgICAgICAzLAogICAgICAgICAgICA0CiAgICAgICAgICBdCiAgICAgICAgfTsKICAgICAgfSBlbHNlIGlmICghcDFCZWhpbmQpIHsKICAgICAgICBJbnRlcnNlY3Rpb25UZXN0cy5saW5lU2VnbWVudFBsYW5lKHAyLCBwMSwgcGxhbmUsIHUxKTsKICAgICAgICBJbnRlcnNlY3Rpb25UZXN0cy5saW5lU2VnbWVudFBsYW5lKHAwLCBwMSwgcGxhbmUsIHUyKTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgcG9zaXRpb25zOiBbcDAsIHAxLCBwMiwgdTEsIHUyXSwKICAgICAgICAgIGluZGljZXM6IFsKICAgICAgICAgICAgMiwKICAgICAgICAgICAgMCwKICAgICAgICAgICAgNCwKICAgICAgICAgICAgMiwKICAgICAgICAgICAgNCwKICAgICAgICAgICAgMywKICAgICAgICAgICAgMSwKICAgICAgICAgICAgMywKICAgICAgICAgICAgNAogICAgICAgICAgXQogICAgICAgIH07CiAgICAgIH0gZWxzZSBpZiAoIXAyQmVoaW5kKSB7CiAgICAgICAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRQbGFuZShwMCwgcDIsIHBsYW5lLCB1MSk7CiAgICAgICAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRQbGFuZShwMSwgcDIsIHBsYW5lLCB1Mik7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHBvc2l0aW9uczogW3AwLCBwMSwgcDIsIHUxLCB1Ml0sCiAgICAgICAgICBpbmRpY2VzOiBbCiAgICAgICAgICAgIDAsCiAgICAgICAgICAgIDEsCiAgICAgICAgICAgIDQsCiAgICAgICAgICAgIDAsCiAgICAgICAgICAgIDQsCiAgICAgICAgICAgIDMsCiAgICAgICAgICAgIDIsCiAgICAgICAgICAgIDMsCiAgICAgICAgICAgIDQKICAgICAgICAgIF0KICAgICAgICB9OwogICAgICB9CiAgICB9CiAgICByZXR1cm4gdm9pZCAwOwogIH07CiAgdmFyIEludGVyc2VjdGlvblRlc3RzX2RlZmF1bHQgPSBJbnRlcnNlY3Rpb25UZXN0czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0VsbGlwc29pZFRhbmdlbnRQbGFuZS5qcwogIHZhciBzY3JhdGNoQ2FydDQgPSBuZXcgQ2FydGVzaWFuNF9kZWZhdWx0KCk7CiAgZnVuY3Rpb24gRWxsaXBzb2lkVGFuZ2VudFBsYW5lKG9yaWdpbiwgZWxsaXBzb2lkKSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoIm9yaWdpbiIsIG9yaWdpbik7CiAgICBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChlbGxpcHNvaWQsIEVsbGlwc29pZF9kZWZhdWx0LldHUzg0KTsKICAgIG9yaWdpbiA9IGVsbGlwc29pZC5zY2FsZVRvR2VvZGV0aWNTdXJmYWNlKG9yaWdpbik7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcmlnaW4pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJvcmlnaW4gbXVzdCBub3QgYmUgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkLiIKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IGVhc3ROb3J0aFVwID0gVHJhbnNmb3Jtc19kZWZhdWx0LmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lKG9yaWdpbiwgZWxsaXBzb2lkKTsKICAgIHRoaXMuX2VsbGlwc29pZCA9IGVsbGlwc29pZDsKICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbjsKICAgIHRoaXMuX3hBeGlzID0gQ2FydGVzaWFuM19kZWZhdWx0LmZyb21DYXJ0ZXNpYW40KAogICAgICBNYXRyaXg0X2RlZmF1bHQuZ2V0Q29sdW1uKGVhc3ROb3J0aFVwLCAwLCBzY3JhdGNoQ2FydDQpCiAgICApOwogICAgdGhpcy5feUF4aXMgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbUNhcnRlc2lhbjQoCiAgICAgIE1hdHJpeDRfZGVmYXVsdC5nZXRDb2x1bW4oZWFzdE5vcnRoVXAsIDEsIHNjcmF0Y2hDYXJ0NCkKICAgICk7CiAgICBjb25zdCBub3JtYWwgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbUNhcnRlc2lhbjQoCiAgICAgIE1hdHJpeDRfZGVmYXVsdC5nZXRDb2x1bW4oZWFzdE5vcnRoVXAsIDIsIHNjcmF0Y2hDYXJ0NCkKICAgICk7CiAgICB0aGlzLl9wbGFuZSA9IFBsYW5lX2RlZmF1bHQuZnJvbVBvaW50Tm9ybWFsKG9yaWdpbiwgbm9ybWFsKTsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxsaXBzb2lkVGFuZ2VudFBsYW5lLnByb3RvdHlwZSwgewogICAgZWxsaXBzb2lkOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2VsbGlwc29pZDsKICAgICAgfQogICAgfSwKICAgIG9yaWdpbjogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW47CiAgICAgIH0KICAgIH0sCiAgICBwbGFuZTogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9wbGFuZTsKICAgICAgfQogICAgfSwKICAgIHhBeGlzOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3hBeGlzOwogICAgICB9CiAgICB9LAogICAgeUF4aXM6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5feUF4aXM7CiAgICAgIH0KICAgIH0sCiAgICB6QXhpczogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9wbGFuZS5ub3JtYWw7CiAgICAgIH0KICAgIH0KICB9KTsKICB2YXIgdG1wID0gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3hfZGVmYXVsdCgpOwogIEVsbGlwc29pZFRhbmdlbnRQbGFuZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24oY2FydGVzaWFucywgZWxsaXBzb2lkKSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImNhcnRlc2lhbnMiLCBjYXJ0ZXNpYW5zKTsKICAgIGNvbnN0IGJveCA9IEF4aXNBbGlnbmVkQm91bmRpbmdCb3hfZGVmYXVsdC5mcm9tUG9pbnRzKGNhcnRlc2lhbnMsIHRtcCk7CiAgICByZXR1cm4gbmV3IEVsbGlwc29pZFRhbmdlbnRQbGFuZShib3guY2VudGVyLCBlbGxpcHNvaWQpOwogIH07CiAgdmFyIHNjcmF0Y2hQcm9qZWN0UG9pbnRPbnRvUGxhbmVSYXkgPSBuZXcgUmF5X2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZUNhcnRlc2lhbjMgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgRWxsaXBzb2lkVGFuZ2VudFBsYW5lLnByb3RvdHlwZS5wcm9qZWN0UG9pbnRPbnRvUGxhbmUgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgY29uc3QgcmF5ID0gc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZVJheTsKICAgIHJheS5vcmlnaW4gPSBjYXJ0ZXNpYW47CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKGNhcnRlc2lhbiwgcmF5LmRpcmVjdGlvbik7CiAgICBsZXQgaW50ZXJzZWN0aW9uUG9pbnQgPSBJbnRlcnNlY3Rpb25UZXN0c19kZWZhdWx0LnJheVBsYW5lKAogICAgICByYXksCiAgICAgIHRoaXMuX3BsYW5lLAogICAgICBzY3JhdGNoUHJvamVjdFBvaW50T250b1BsYW5lQ2FydGVzaWFuMwogICAgKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGludGVyc2VjdGlvblBvaW50KSkgewogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubmVnYXRlKHJheS5kaXJlY3Rpb24sIHJheS5kaXJlY3Rpb24pOwogICAgICBpbnRlcnNlY3Rpb25Qb2ludCA9IEludGVyc2VjdGlvblRlc3RzX2RlZmF1bHQucmF5UGxhbmUoCiAgICAgICAgcmF5LAogICAgICAgIHRoaXMuX3BsYW5lLAogICAgICAgIHNjcmF0Y2hQcm9qZWN0UG9pbnRPbnRvUGxhbmVDYXJ0ZXNpYW4zCiAgICAgICk7CiAgICB9CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KGludGVyc2VjdGlvblBvaW50KSkgewogICAgICBjb25zdCB2MiA9IENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdCgKICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludCwKICAgICAgICB0aGlzLl9vcmlnaW4sCiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQKICAgICAgKTsKICAgICAgY29uc3QgeCA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QodGhpcy5feEF4aXMsIHYyKTsKICAgICAgY29uc3QgeSA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QodGhpcy5feUF4aXMsIHYyKTsKICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KHgsIHkpOwogICAgICB9CiAgICAgIHJlc3VsdC54ID0geDsKICAgICAgcmVzdWx0LnkgPSB5OwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgcmV0dXJuIHZvaWQgMDsKICB9OwogIEVsbGlwc29pZFRhbmdlbnRQbGFuZS5wcm90b3R5cGUucHJvamVjdFBvaW50c09udG9QbGFuZSA9IGZ1bmN0aW9uKGNhcnRlc2lhbnMsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjYXJ0ZXNpYW5zIiwgY2FydGVzaWFucyk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IFtdOwogICAgfQogICAgbGV0IGNvdW50ID0gMDsKICAgIGNvbnN0IGxlbmd0aCA9IGNhcnRlc2lhbnMubGVuZ3RoOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICBjb25zdCBwID0gdGhpcy5wcm9qZWN0UG9pbnRPbnRvUGxhbmUoY2FydGVzaWFuc1tpXSwgcmVzdWx0W2NvdW50XSk7CiAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQocCkpIHsKICAgICAgICByZXN1bHRbY291bnRdID0gcDsKICAgICAgICBjb3VudCsrOwogICAgICB9CiAgICB9CiAgICByZXN1bHQubGVuZ3RoID0gY291bnQ7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgRWxsaXBzb2lkVGFuZ2VudFBsYW5lLnByb3RvdHlwZS5wcm9qZWN0UG9pbnRUb05lYXJlc3RPblBsYW5lID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiY2FydGVzaWFuIiwgY2FydGVzaWFuKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjJfZGVmYXVsdCgpOwogICAgfQogICAgY29uc3QgcmF5ID0gc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZVJheTsKICAgIHJheS5vcmlnaW4gPSBjYXJ0ZXNpYW47CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUodGhpcy5fcGxhbmUubm9ybWFsLCByYXkuZGlyZWN0aW9uKTsKICAgIGxldCBpbnRlcnNlY3Rpb25Qb2ludCA9IEludGVyc2VjdGlvblRlc3RzX2RlZmF1bHQucmF5UGxhbmUoCiAgICAgIHJheSwKICAgICAgdGhpcy5fcGxhbmUsCiAgICAgIHNjcmF0Y2hQcm9qZWN0UG9pbnRPbnRvUGxhbmVDYXJ0ZXNpYW4zCiAgICApOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaW50ZXJzZWN0aW9uUG9pbnQpKSB7CiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5uZWdhdGUocmF5LmRpcmVjdGlvbiwgcmF5LmRpcmVjdGlvbik7CiAgICAgIGludGVyc2VjdGlvblBvaW50ID0gSW50ZXJzZWN0aW9uVGVzdHNfZGVmYXVsdC5yYXlQbGFuZSgKICAgICAgICByYXksCiAgICAgICAgdGhpcy5fcGxhbmUsCiAgICAgICAgc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZUNhcnRlc2lhbjMKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IHYyID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KAogICAgICBpbnRlcnNlY3Rpb25Qb2ludCwKICAgICAgdGhpcy5fb3JpZ2luLAogICAgICBpbnRlcnNlY3Rpb25Qb2ludAogICAgKTsKICAgIGNvbnN0IHggPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KHRoaXMuX3hBeGlzLCB2Mik7CiAgICBjb25zdCB5ID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdCh0aGlzLl95QXhpcywgdjIpOwogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEVsbGlwc29pZFRhbmdlbnRQbGFuZS5wcm90b3R5cGUucHJvamVjdFBvaW50c1RvTmVhcmVzdE9uUGxhbmUgPSBmdW5jdGlvbihjYXJ0ZXNpYW5zLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiY2FydGVzaWFucyIsIGNhcnRlc2lhbnMpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBbXTsKICAgIH0KICAgIGNvbnN0IGxlbmd0aCA9IGNhcnRlc2lhbnMubGVuZ3RoOwogICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgcmVzdWx0W2ldID0gdGhpcy5wcm9qZWN0UG9pbnRUb05lYXJlc3RPblBsYW5lKGNhcnRlc2lhbnNbaV0sIHJlc3VsdFtpXSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHByb2plY3RQb2ludHNPbnRvRWxsaXBzb2lkU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlLnByb2plY3RQb2ludE9udG9FbGxpcHNvaWQgPSBmdW5jdGlvbihjYXJ0ZXNpYW4sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjYXJ0ZXNpYW4iLCBjYXJ0ZXNpYW4pOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgICB9CiAgICBjb25zdCBlbGxpcHNvaWQgPSB0aGlzLl9lbGxpcHNvaWQ7CiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLl9vcmlnaW47CiAgICBjb25zdCB4QXhpcyA9IHRoaXMuX3hBeGlzOwogICAgY29uc3QgeUF4aXMgPSB0aGlzLl95QXhpczsKICAgIGNvbnN0IHRtcDIgPSBwcm9qZWN0UG9pbnRzT250b0VsbGlwc29pZFNjcmF0Y2g7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcih4QXhpcywgY2FydGVzaWFuLngsIHRtcDIpOwogICAgcmVzdWx0ID0gQ2FydGVzaWFuM19kZWZhdWx0LmFkZChvcmlnaW4sIHRtcDIsIHJlc3VsdCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcih5QXhpcywgY2FydGVzaWFuLnksIHRtcDIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChyZXN1bHQsIHRtcDIsIHJlc3VsdCk7CiAgICBlbGxpcHNvaWQuc2NhbGVUb0dlb2NlbnRyaWNTdXJmYWNlKHJlc3VsdCwgcmVzdWx0KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlLnByb2plY3RQb2ludHNPbnRvRWxsaXBzb2lkID0gZnVuY3Rpb24oY2FydGVzaWFucywgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImNhcnRlc2lhbnMiLCBjYXJ0ZXNpYW5zKTsKICAgIGNvbnN0IGxlbmd0aCA9IGNhcnRlc2lhbnMubGVuZ3RoOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgIHJlc3VsdFtpXSA9IHRoaXMucHJvamVjdFBvaW50T250b0VsbGlwc29pZChjYXJ0ZXNpYW5zW2ldLCByZXN1bHRbaV0pOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBFbGxpcHNvaWRUYW5nZW50UGxhbmVfZGVmYXVsdCA9IEVsbGlwc29pZFRhbmdlbnRQbGFuZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL09yaWVudGVkQm91bmRpbmdCb3guanMKICBmdW5jdGlvbiBPcmllbnRlZEJvdW5kaW5nQm94KGNlbnRlciwgaGFsZkF4ZXMpIHsKICAgIHRoaXMuY2VudGVyID0gQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGNlbnRlciwgQ2FydGVzaWFuM19kZWZhdWx0LlpFUk8pKTsKICAgIHRoaXMuaGFsZkF4ZXMgPSBNYXRyaXgzX2RlZmF1bHQuY2xvbmUoZGVmYXVsdFZhbHVlX2RlZmF1bHQoaGFsZkF4ZXMsIE1hdHJpeDNfZGVmYXVsdC5aRVJPKSk7CiAgfQogIE9yaWVudGVkQm91bmRpbmdCb3gucGFja2VkTGVuZ3RoID0gQ2FydGVzaWFuM19kZWZhdWx0LnBhY2tlZExlbmd0aCArIE1hdHJpeDNfZGVmYXVsdC5wYWNrZWRMZW5ndGg7CiAgT3JpZW50ZWRCb3VuZGluZ0JveC5wYWNrID0gZnVuY3Rpb24odmFsdWUsIGFycmF5LCBzdGFydGluZ0luZGV4KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoInZhbHVlIiwgdmFsdWUpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJhcnJheSIsIGFycmF5KTsKICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzdGFydGluZ0luZGV4LCAwKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5wYWNrKHZhbHVlLmNlbnRlciwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpOwogICAgTWF0cml4M19kZWZhdWx0LnBhY2sodmFsdWUuaGFsZkF4ZXMsIGFycmF5LCBzdGFydGluZ0luZGV4ICsgQ2FydGVzaWFuM19kZWZhdWx0LnBhY2tlZExlbmd0aCk7CiAgICByZXR1cm4gYXJyYXk7CiAgfTsKICBPcmllbnRlZEJvdW5kaW5nQm94LnVucGFjayA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydGluZ0luZGV4LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgiYXJyYXkiLCBhcnJheSk7CiAgICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoc3RhcnRpbmdJbmRleCwgMCk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBPcmllbnRlZEJvdW5kaW5nQm94KCk7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQudW5wYWNrKGFycmF5LCBzdGFydGluZ0luZGV4LCByZXN1bHQuY2VudGVyKTsKICAgIE1hdHJpeDNfZGVmYXVsdC51bnBhY2soCiAgICAgIGFycmF5LAogICAgICBzdGFydGluZ0luZGV4ICsgQ2FydGVzaWFuM19kZWZhdWx0LnBhY2tlZExlbmd0aCwKICAgICAgcmVzdWx0LmhhbGZBeGVzCiAgICApOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY3JhdGNoQ2FydGVzaWFuMSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaENhcnRlc2lhbjIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hDYXJ0ZXNpYW4zMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaENhcnRlc2lhbjQgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hDYXJ0ZXNpYW41ID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoQ2FydGVzaWFuNiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaENvdmFyaWFuY2VSZXN1bHQgPSBuZXcgTWF0cml4M19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hFaWdlblJlc3VsdCA9IHsKICAgIHVuaXRhcnk6IG5ldyBNYXRyaXgzX2RlZmF1bHQoKSwKICAgIGRpYWdvbmFsOiBuZXcgTWF0cml4M19kZWZhdWx0KCkKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3guZnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvc2l0aW9ucywgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBPcmllbnRlZEJvdW5kaW5nQm94KCk7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwb3NpdGlvbnMpIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDApIHsKICAgICAgcmVzdWx0LmhhbGZBeGVzID0gTWF0cml4M19kZWZhdWx0LlpFUk87CiAgICAgIHJlc3VsdC5jZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuWkVSTzsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIGxldCBpOwogICAgY29uc3QgbGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aDsKICAgIGNvbnN0IG1lYW5Qb2ludCA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShwb3NpdGlvbnNbMF0sIHNjcmF0Y2hDYXJ0ZXNpYW4xKTsKICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKG1lYW5Qb2ludCwgcG9zaXRpb25zW2ldLCBtZWFuUG9pbnQpOwogICAgfQogICAgY29uc3QgaW52TGVuZ3RoID0gMSAvIGxlbmd0aDsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGFyKG1lYW5Qb2ludCwgaW52TGVuZ3RoLCBtZWFuUG9pbnQpOwogICAgbGV0IGV4eCA9IDA7CiAgICBsZXQgZXh5ID0gMDsKICAgIGxldCBleHogPSAwOwogICAgbGV0IGV5eSA9IDA7CiAgICBsZXQgZXl6ID0gMDsKICAgIGxldCBlenogPSAwOwogICAgbGV0IHA7CiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgcCA9IENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChwb3NpdGlvbnNbaV0sIG1lYW5Qb2ludCwgc2NyYXRjaENhcnRlc2lhbjIpOwogICAgICBleHggKz0gcC54ICogcC54OwogICAgICBleHkgKz0gcC54ICogcC55OwogICAgICBleHogKz0gcC54ICogcC56OwogICAgICBleXkgKz0gcC55ICogcC55OwogICAgICBleXogKz0gcC55ICogcC56OwogICAgICBlenogKz0gcC56ICogcC56OwogICAgfQogICAgZXh4ICo9IGludkxlbmd0aDsKICAgIGV4eSAqPSBpbnZMZW5ndGg7CiAgICBleHogKj0gaW52TGVuZ3RoOwogICAgZXl5ICo9IGludkxlbmd0aDsKICAgIGV5eiAqPSBpbnZMZW5ndGg7CiAgICBlenogKj0gaW52TGVuZ3RoOwogICAgY29uc3QgY292YXJpYW5jZU1hdHJpeCA9IHNjcmF0Y2hDb3ZhcmlhbmNlUmVzdWx0OwogICAgY292YXJpYW5jZU1hdHJpeFswXSA9IGV4eDsKICAgIGNvdmFyaWFuY2VNYXRyaXhbMV0gPSBleHk7CiAgICBjb3ZhcmlhbmNlTWF0cml4WzJdID0gZXh6OwogICAgY292YXJpYW5jZU1hdHJpeFszXSA9IGV4eTsKICAgIGNvdmFyaWFuY2VNYXRyaXhbNF0gPSBleXk7CiAgICBjb3ZhcmlhbmNlTWF0cml4WzVdID0gZXl6OwogICAgY292YXJpYW5jZU1hdHJpeFs2XSA9IGV4ejsKICAgIGNvdmFyaWFuY2VNYXRyaXhbN10gPSBleXo7CiAgICBjb3ZhcmlhbmNlTWF0cml4WzhdID0gZXp6OwogICAgY29uc3QgZWlnZW5EZWNvbXBvc2l0aW9uID0gTWF0cml4M19kZWZhdWx0LmNvbXB1dGVFaWdlbkRlY29tcG9zaXRpb24oCiAgICAgIGNvdmFyaWFuY2VNYXRyaXgsCiAgICAgIHNjcmF0Y2hFaWdlblJlc3VsdAogICAgKTsKICAgIGNvbnN0IHJvdGF0aW9uID0gTWF0cml4M19kZWZhdWx0LmNsb25lKGVpZ2VuRGVjb21wb3NpdGlvbi51bml0YXJ5LCByZXN1bHQuaGFsZkF4ZXMpOwogICAgbGV0IHYxID0gTWF0cml4M19kZWZhdWx0LmdldENvbHVtbihyb3RhdGlvbiwgMCwgc2NyYXRjaENhcnRlc2lhbjQpOwogICAgbGV0IHYyID0gTWF0cml4M19kZWZhdWx0LmdldENvbHVtbihyb3RhdGlvbiwgMSwgc2NyYXRjaENhcnRlc2lhbjUpOwogICAgbGV0IHYzID0gTWF0cml4M19kZWZhdWx0LmdldENvbHVtbihyb3RhdGlvbiwgMiwgc2NyYXRjaENhcnRlc2lhbjYpOwogICAgbGV0IHUxID0gLU51bWJlci5NQVhfVkFMVUU7CiAgICBsZXQgdTIgPSAtTnVtYmVyLk1BWF9WQUxVRTsKICAgIGxldCB1MyA9IC1OdW1iZXIuTUFYX1ZBTFVFOwogICAgbGV0IGwxID0gTnVtYmVyLk1BWF9WQUxVRTsKICAgIGxldCBsMiA9IE51bWJlci5NQVhfVkFMVUU7CiAgICBsZXQgbDMgPSBOdW1iZXIuTUFYX1ZBTFVFOwogICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgIHAgPSBwb3NpdGlvbnNbaV07CiAgICAgIHUxID0gTWF0aC5tYXgoQ2FydGVzaWFuM19kZWZhdWx0LmRvdCh2MSwgcCksIHUxKTsKICAgICAgdTIgPSBNYXRoLm1heChDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KHYyLCBwKSwgdTIpOwogICAgICB1MyA9IE1hdGgubWF4KENhcnRlc2lhbjNfZGVmYXVsdC5kb3QodjMsIHApLCB1Myk7CiAgICAgIGwxID0gTWF0aC5taW4oQ2FydGVzaWFuM19kZWZhdWx0LmRvdCh2MSwgcCksIGwxKTsKICAgICAgbDIgPSBNYXRoLm1pbihDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KHYyLCBwKSwgbDIpOwogICAgICBsMyA9IE1hdGgubWluKENhcnRlc2lhbjNfZGVmYXVsdC5kb3QodjMsIHApLCBsMyk7CiAgICB9CiAgICB2MSA9IENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGFyKHYxLCAwLjUgKiAobDEgKyB1MSksIHYxKTsKICAgIHYyID0gQ2FydGVzaWFuM19kZWZhdWx0Lm11bHRpcGx5QnlTY2FsYXIodjIsIDAuNSAqIChsMiArIHUyKSwgdjIpOwogICAgdjMgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcih2MywgMC41ICogKGwzICsgdTMpLCB2Myk7CiAgICBjb25zdCBjZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHYxLCB2MiwgcmVzdWx0LmNlbnRlcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNlbnRlciwgdjMsIGNlbnRlcik7CiAgICBjb25zdCBzY2FsZSA9IHNjcmF0Y2hDYXJ0ZXNpYW4zMjsKICAgIHNjYWxlLnggPSB1MSAtIGwxOwogICAgc2NhbGUueSA9IHUyIC0gbDI7CiAgICBzY2FsZS56ID0gdTMgLSBsMzsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGFyKHNjYWxlLCAwLjUsIHNjYWxlKTsKICAgIE1hdHJpeDNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGUocmVzdWx0LmhhbGZBeGVzLCBzY2FsZSwgcmVzdWx0LmhhbGZBeGVzKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgc2NyYXRjaE9mZnNldCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFNjYWxlMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBmdW5jdGlvbiBmcm9tUGxhbmVFeHRlbnRzKHBsYW5lT3JpZ2luLCBwbGFuZVhBeGlzLCBwbGFuZVlBeGlzLCBwbGFuZVpBeGlzLCBtaW5pbXVtWCwgbWF4aW11bVgsIG1pbmltdW1ZLCBtYXhpbXVtWSwgbWluaW11bVosIG1heGltdW1aLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG1pbmltdW1YKSB8fCAhZGVmaW5lZF9kZWZhdWx0KG1heGltdW1YKSB8fCAhZGVmaW5lZF9kZWZhdWx0KG1pbmltdW1ZKSB8fCAhZGVmaW5lZF9kZWZhdWx0KG1heGltdW1ZKSB8fCAhZGVmaW5lZF9kZWZhdWx0KG1pbmltdW1aKSB8fCAhZGVmaW5lZF9kZWZhdWx0KG1heGltdW1aKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAiYWxsIGV4dGVudHMgKG1pbmltdW0vbWF4aW11bSBYL1kvWikgYXJlIHJlcXVpcmVkLiIKICAgICAgKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IE9yaWVudGVkQm91bmRpbmdCb3goKTsKICAgIH0KICAgIGNvbnN0IGhhbGZBeGVzID0gcmVzdWx0LmhhbGZBeGVzOwogICAgTWF0cml4M19kZWZhdWx0LnNldENvbHVtbihoYWxmQXhlcywgMCwgcGxhbmVYQXhpcywgaGFsZkF4ZXMpOwogICAgTWF0cml4M19kZWZhdWx0LnNldENvbHVtbihoYWxmQXhlcywgMSwgcGxhbmVZQXhpcywgaGFsZkF4ZXMpOwogICAgTWF0cml4M19kZWZhdWx0LnNldENvbHVtbihoYWxmQXhlcywgMiwgcGxhbmVaQXhpcywgaGFsZkF4ZXMpOwogICAgbGV0IGNlbnRlck9mZnNldCA9IHNjcmF0Y2hPZmZzZXQ7CiAgICBjZW50ZXJPZmZzZXQueCA9IChtaW5pbXVtWCArIG1heGltdW1YKSAvIDI7CiAgICBjZW50ZXJPZmZzZXQueSA9IChtaW5pbXVtWSArIG1heGltdW1ZKSAvIDI7CiAgICBjZW50ZXJPZmZzZXQueiA9IChtaW5pbXVtWiArIG1heGltdW1aKSAvIDI7CiAgICBjb25zdCBzY2FsZSA9IHNjcmF0Y2hTY2FsZTI7CiAgICBzY2FsZS54ID0gKG1heGltdW1YIC0gbWluaW11bVgpIC8gMjsKICAgIHNjYWxlLnkgPSAobWF4aW11bVkgLSBtaW5pbXVtWSkgLyAyOwogICAgc2NhbGUueiA9IChtYXhpbXVtWiAtIG1pbmltdW1aKSAvIDI7CiAgICBjb25zdCBjZW50ZXIgPSByZXN1bHQuY2VudGVyOwogICAgY2VudGVyT2Zmc2V0ID0gTWF0cml4M19kZWZhdWx0Lm11bHRpcGx5QnlWZWN0b3IoaGFsZkF4ZXMsIGNlbnRlck9mZnNldCwgY2VudGVyT2Zmc2V0KTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQocGxhbmVPcmlnaW4sIGNlbnRlck9mZnNldCwgY2VudGVyKTsKICAgIE1hdHJpeDNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGUoaGFsZkF4ZXMsIHNjYWxlLCBoYWxmQXhlcyk7CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgc2NyYXRjaFJlY3RhbmdsZUNlbnRlckNhcnRvZ3JhcGhpYyA9IG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUmVjdGFuZ2xlQ2VudGVyID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUGVyaW1ldGVyQ2FydG9ncmFwaGljTkMgPSBuZXcgQ2FydG9ncmFwaGljX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFBlcmltZXRlckNhcnRvZ3JhcGhpY05XID0gbmV3IENhcnRvZ3JhcGhpY19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQZXJpbWV0ZXJDYXJ0b2dyYXBoaWNDVyA9IG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUGVyaW1ldGVyQ2FydG9ncmFwaGljU1cgPSBuZXcgQ2FydG9ncmFwaGljX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFBlcmltZXRlckNhcnRvZ3JhcGhpY1NDID0gbmV3IENhcnRvZ3JhcGhpY19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQZXJpbWV0ZXJDYXJ0ZXNpYW5OQyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFBlcmltZXRlckNhcnRlc2lhbk5XID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUGVyaW1ldGVyQ2FydGVzaWFuQ1cgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQZXJpbWV0ZXJDYXJ0ZXNpYW5TVyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFBlcmltZXRlckNhcnRlc2lhblNDID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUGVyaW1ldGVyUHJvamVjdGVkTkMgPSBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQZXJpbWV0ZXJQcm9qZWN0ZWROVyA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFBlcmltZXRlclByb2plY3RlZENXID0gbmV3IENhcnRlc2lhbjJfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUGVyaW1ldGVyUHJvamVjdGVkU1cgPSBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQZXJpbWV0ZXJQcm9qZWN0ZWRTQyA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFBsYW5lT3JpZ2luID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUGxhbmVOb3JtYWwgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQbGFuZVhBeGlzID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoSG9yaXpvbkNhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaEhvcml6b25Qcm9qZWN0ZWQgPSBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hNYXhZID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoTWluWSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFogPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hQbGFuZSA9IG5ldyBQbGFuZV9kZWZhdWx0KENhcnRlc2lhbjNfZGVmYXVsdC5VTklUX1gsIDApOwogIE9yaWVudGVkQm91bmRpbmdCb3guZnJvbVJlY3RhbmdsZSA9IGZ1bmN0aW9uKHJlY3RhbmdsZSwgbWluaW11bUhlaWdodCwgbWF4aW11bUhlaWdodCwgZWxsaXBzb2lkLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlY3RhbmdsZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInJlY3RhbmdsZSBpcyByZXF1aXJlZCIpOwogICAgfQogICAgaWYgKHJlY3RhbmdsZS53aWR0aCA8IDAgfHwgcmVjdGFuZ2xlLndpZHRoID4gTWF0aF9kZWZhdWx0LlRXT19QSSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiUmVjdGFuZ2xlIHdpZHRoIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyKnBpIik7CiAgICB9CiAgICBpZiAocmVjdGFuZ2xlLmhlaWdodCA8IDAgfHwgcmVjdGFuZ2xlLmhlaWdodCA+IE1hdGhfZGVmYXVsdC5QSSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiUmVjdGFuZ2xlIGhlaWdodCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgcGkiKTsKICAgIH0KICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoZWxsaXBzb2lkKSAmJiAhTWF0aF9kZWZhdWx0LmVxdWFsc0Vwc2lsb24oCiAgICAgIGVsbGlwc29pZC5yYWRpaS54LAogICAgICBlbGxpcHNvaWQucmFkaWkueSwKICAgICAgTWF0aF9kZWZhdWx0LkVQU0lMT04xNQogICAgKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAiRWxsaXBzb2lkIG11c3QgYmUgYW4gZWxsaXBzb2lkIG9mIHJldm9sdXRpb24gKHJhZGlpLnggPT0gcmFkaWkueSkiCiAgICAgICk7CiAgICB9CiAgICBtaW5pbXVtSGVpZ2h0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQobWluaW11bUhlaWdodCwgMCk7CiAgICBtYXhpbXVtSGVpZ2h0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQobWF4aW11bUhlaWdodCwgMCk7CiAgICBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChlbGxpcHNvaWQsIEVsbGlwc29pZF9kZWZhdWx0LldHUzg0KTsKICAgIGxldCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCBtaW5aLCBtYXhaLCBwbGFuZTsKICAgIGlmIChyZWN0YW5nbGUud2lkdGggPD0gTWF0aF9kZWZhdWx0LlBJKSB7CiAgICAgIGNvbnN0IHRhbmdlbnRQb2ludENhcnRvZ3JhcGhpYyA9IFJlY3RhbmdsZV9kZWZhdWx0LmNlbnRlcigKICAgICAgICByZWN0YW5nbGUsCiAgICAgICAgc2NyYXRjaFJlY3RhbmdsZUNlbnRlckNhcnRvZ3JhcGhpYwogICAgICApOwogICAgICBjb25zdCB0YW5nZW50UG9pbnQgPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgICAgdGFuZ2VudFBvaW50Q2FydG9ncmFwaGljLAogICAgICAgIHNjcmF0Y2hSZWN0YW5nbGVDZW50ZXIKICAgICAgKTsKICAgICAgY29uc3QgdGFuZ2VudFBsYW5lID0gbmV3IEVsbGlwc29pZFRhbmdlbnRQbGFuZV9kZWZhdWx0KHRhbmdlbnRQb2ludCwgZWxsaXBzb2lkKTsKICAgICAgcGxhbmUgPSB0YW5nZW50UGxhbmUucGxhbmU7CiAgICAgIGNvbnN0IGxvbkNlbnRlciA9IHRhbmdlbnRQb2ludENhcnRvZ3JhcGhpYy5sb25naXR1ZGU7CiAgICAgIGNvbnN0IGxhdENlbnRlciA9IHJlY3RhbmdsZS5zb3V0aCA8IDAgJiYgcmVjdGFuZ2xlLm5vcnRoID4gMCA/IDAgOiB0YW5nZW50UG9pbnRDYXJ0b2dyYXBoaWMubGF0aXR1ZGU7CiAgICAgIGNvbnN0IHBlcmltZXRlckNhcnRvZ3JhcGhpY05DID0gQ2FydG9ncmFwaGljX2RlZmF1bHQuZnJvbVJhZGlhbnMoCiAgICAgICAgbG9uQ2VudGVyLAogICAgICAgIHJlY3RhbmdsZS5ub3J0aCwKICAgICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICAgIHNjcmF0Y2hQZXJpbWV0ZXJDYXJ0b2dyYXBoaWNOQwogICAgICApOwogICAgICBjb25zdCBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNOVyA9IENhcnRvZ3JhcGhpY19kZWZhdWx0LmZyb21SYWRpYW5zKAogICAgICAgIHJlY3RhbmdsZS53ZXN0LAogICAgICAgIHJlY3RhbmdsZS5ub3J0aCwKICAgICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICAgIHNjcmF0Y2hQZXJpbWV0ZXJDYXJ0b2dyYXBoaWNOVwogICAgICApOwogICAgICBjb25zdCBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNDVyA9IENhcnRvZ3JhcGhpY19kZWZhdWx0LmZyb21SYWRpYW5zKAogICAgICAgIHJlY3RhbmdsZS53ZXN0LAogICAgICAgIGxhdENlbnRlciwKICAgICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICAgIHNjcmF0Y2hQZXJpbWV0ZXJDYXJ0b2dyYXBoaWNDVwogICAgICApOwogICAgICBjb25zdCBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNTVyA9IENhcnRvZ3JhcGhpY19kZWZhdWx0LmZyb21SYWRpYW5zKAogICAgICAgIHJlY3RhbmdsZS53ZXN0LAogICAgICAgIHJlY3RhbmdsZS5zb3V0aCwKICAgICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICAgIHNjcmF0Y2hQZXJpbWV0ZXJDYXJ0b2dyYXBoaWNTVwogICAgICApOwogICAgICBjb25zdCBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNTQyA9IENhcnRvZ3JhcGhpY19kZWZhdWx0LmZyb21SYWRpYW5zKAogICAgICAgIGxvbkNlbnRlciwKICAgICAgICByZWN0YW5nbGUuc291dGgsCiAgICAgICAgbWF4aW11bUhlaWdodCwKICAgICAgICBzY3JhdGNoUGVyaW1ldGVyQ2FydG9ncmFwaGljU0MKICAgICAgKTsKICAgICAgY29uc3QgcGVyaW1ldGVyQ2FydGVzaWFuTkMgPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgICAgcGVyaW1ldGVyQ2FydG9ncmFwaGljTkMsCiAgICAgICAgc2NyYXRjaFBlcmltZXRlckNhcnRlc2lhbk5DCiAgICAgICk7CiAgICAgIGxldCBwZXJpbWV0ZXJDYXJ0ZXNpYW5OVyA9IGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbigKICAgICAgICBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNOVywKICAgICAgICBzY3JhdGNoUGVyaW1ldGVyQ2FydGVzaWFuTlcKICAgICAgKTsKICAgICAgY29uc3QgcGVyaW1ldGVyQ2FydGVzaWFuQ1cgPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgICAgcGVyaW1ldGVyQ2FydG9ncmFwaGljQ1csCiAgICAgICAgc2NyYXRjaFBlcmltZXRlckNhcnRlc2lhbkNXCiAgICAgICk7CiAgICAgIGxldCBwZXJpbWV0ZXJDYXJ0ZXNpYW5TVyA9IGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbigKICAgICAgICBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNTVywKICAgICAgICBzY3JhdGNoUGVyaW1ldGVyQ2FydGVzaWFuU1cKICAgICAgKTsKICAgICAgY29uc3QgcGVyaW1ldGVyQ2FydGVzaWFuU0MgPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgICAgcGVyaW1ldGVyQ2FydG9ncmFwaGljU0MsCiAgICAgICAgc2NyYXRjaFBlcmltZXRlckNhcnRlc2lhblNDCiAgICAgICk7CiAgICAgIGNvbnN0IHBlcmltZXRlclByb2plY3RlZE5DID0gdGFuZ2VudFBsYW5lLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmUoCiAgICAgICAgcGVyaW1ldGVyQ2FydGVzaWFuTkMsCiAgICAgICAgc2NyYXRjaFBlcmltZXRlclByb2plY3RlZE5DCiAgICAgICk7CiAgICAgIGNvbnN0IHBlcmltZXRlclByb2plY3RlZE5XID0gdGFuZ2VudFBsYW5lLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmUoCiAgICAgICAgcGVyaW1ldGVyQ2FydGVzaWFuTlcsCiAgICAgICAgc2NyYXRjaFBlcmltZXRlclByb2plY3RlZE5XCiAgICAgICk7CiAgICAgIGNvbnN0IHBlcmltZXRlclByb2plY3RlZENXID0gdGFuZ2VudFBsYW5lLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmUoCiAgICAgICAgcGVyaW1ldGVyQ2FydGVzaWFuQ1csCiAgICAgICAgc2NyYXRjaFBlcmltZXRlclByb2plY3RlZENXCiAgICAgICk7CiAgICAgIGNvbnN0IHBlcmltZXRlclByb2plY3RlZFNXID0gdGFuZ2VudFBsYW5lLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmUoCiAgICAgICAgcGVyaW1ldGVyQ2FydGVzaWFuU1csCiAgICAgICAgc2NyYXRjaFBlcmltZXRlclByb2plY3RlZFNXCiAgICAgICk7CiAgICAgIGNvbnN0IHBlcmltZXRlclByb2plY3RlZFNDID0gdGFuZ2VudFBsYW5lLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmUoCiAgICAgICAgcGVyaW1ldGVyQ2FydGVzaWFuU0MsCiAgICAgICAgc2NyYXRjaFBlcmltZXRlclByb2plY3RlZFNDCiAgICAgICk7CiAgICAgIG1pblggPSBNYXRoLm1pbigKICAgICAgICBwZXJpbWV0ZXJQcm9qZWN0ZWROVy54LAogICAgICAgIHBlcmltZXRlclByb2plY3RlZENXLngsCiAgICAgICAgcGVyaW1ldGVyUHJvamVjdGVkU1cueAogICAgICApOwogICAgICBtYXhYID0gLW1pblg7CiAgICAgIG1heFkgPSBNYXRoLm1heChwZXJpbWV0ZXJQcm9qZWN0ZWROVy55LCBwZXJpbWV0ZXJQcm9qZWN0ZWROQy55KTsKICAgICAgbWluWSA9IE1hdGgubWluKHBlcmltZXRlclByb2plY3RlZFNXLnksIHBlcmltZXRlclByb2plY3RlZFNDLnkpOwogICAgICBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNOVy5oZWlnaHQgPSBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNTVy5oZWlnaHQgPSBtaW5pbXVtSGVpZ2h0OwogICAgICBwZXJpbWV0ZXJDYXJ0ZXNpYW5OVyA9IGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbigKICAgICAgICBwZXJpbWV0ZXJDYXJ0b2dyYXBoaWNOVywKICAgICAgICBzY3JhdGNoUGVyaW1ldGVyQ2FydGVzaWFuTlcKICAgICAgKTsKICAgICAgcGVyaW1ldGVyQ2FydGVzaWFuU1cgPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgICAgcGVyaW1ldGVyQ2FydG9ncmFwaGljU1csCiAgICAgICAgc2NyYXRjaFBlcmltZXRlckNhcnRlc2lhblNXCiAgICAgICk7CiAgICAgIG1pblogPSBNYXRoLm1pbigKICAgICAgICBQbGFuZV9kZWZhdWx0LmdldFBvaW50RGlzdGFuY2UocGxhbmUsIHBlcmltZXRlckNhcnRlc2lhbk5XKSwKICAgICAgICBQbGFuZV9kZWZhdWx0LmdldFBvaW50RGlzdGFuY2UocGxhbmUsIHBlcmltZXRlckNhcnRlc2lhblNXKQogICAgICApOwogICAgICBtYXhaID0gbWF4aW11bUhlaWdodDsKICAgICAgcmV0dXJuIGZyb21QbGFuZUV4dGVudHMoCiAgICAgICAgdGFuZ2VudFBsYW5lLm9yaWdpbiwKICAgICAgICB0YW5nZW50UGxhbmUueEF4aXMsCiAgICAgICAgdGFuZ2VudFBsYW5lLnlBeGlzLAogICAgICAgIHRhbmdlbnRQbGFuZS56QXhpcywKICAgICAgICBtaW5YLAogICAgICAgIG1heFgsCiAgICAgICAgbWluWSwKICAgICAgICBtYXhZLAogICAgICAgIG1pblosCiAgICAgICAgbWF4WiwKICAgICAgICByZXN1bHQKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IGZ1bGx5QWJvdmVFcXVhdG9yID0gcmVjdGFuZ2xlLnNvdXRoID4gMDsKICAgIGNvbnN0IGZ1bGx5QmVsb3dFcXVhdG9yID0gcmVjdGFuZ2xlLm5vcnRoIDwgMDsKICAgIGNvbnN0IGxhdGl0dWRlTmVhcmVzdFRvRXF1YXRvciA9IGZ1bGx5QWJvdmVFcXVhdG9yID8gcmVjdGFuZ2xlLnNvdXRoIDogZnVsbHlCZWxvd0VxdWF0b3IgPyByZWN0YW5nbGUubm9ydGggOiAwOwogICAgY29uc3QgY2VudGVyTG9uZ2l0dWRlID0gUmVjdGFuZ2xlX2RlZmF1bHQuY2VudGVyKAogICAgICByZWN0YW5nbGUsCiAgICAgIHNjcmF0Y2hSZWN0YW5nbGVDZW50ZXJDYXJ0b2dyYXBoaWMKICAgICkubG9uZ2l0dWRlOwogICAgY29uc3QgcGxhbmVPcmlnaW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbVJhZGlhbnMoCiAgICAgIGNlbnRlckxvbmdpdHVkZSwKICAgICAgbGF0aXR1ZGVOZWFyZXN0VG9FcXVhdG9yLAogICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICBlbGxpcHNvaWQsCiAgICAgIHNjcmF0Y2hQbGFuZU9yaWdpbgogICAgKTsKICAgIHBsYW5lT3JpZ2luLnogPSAwOwogICAgY29uc3QgaXNQb2xlID0gTWF0aC5hYnMocGxhbmVPcmlnaW4ueCkgPCBNYXRoX2RlZmF1bHQuRVBTSUxPTjEwICYmIE1hdGguYWJzKHBsYW5lT3JpZ2luLnkpIDwgTWF0aF9kZWZhdWx0LkVQU0lMT04xMDsKICAgIGNvbnN0IHBsYW5lTm9ybWFsID0gIWlzUG9sZSA/IENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUocGxhbmVPcmlnaW4sIHNjcmF0Y2hQbGFuZU5vcm1hbCkgOiBDYXJ0ZXNpYW4zX2RlZmF1bHQuVU5JVF9YOwogICAgY29uc3QgcGxhbmVZQXhpcyA9IENhcnRlc2lhbjNfZGVmYXVsdC5VTklUX1o7CiAgICBjb25zdCBwbGFuZVhBeGlzID0gQ2FydGVzaWFuM19kZWZhdWx0LmNyb3NzKAogICAgICBwbGFuZU5vcm1hbCwKICAgICAgcGxhbmVZQXhpcywKICAgICAgc2NyYXRjaFBsYW5lWEF4aXMKICAgICk7CiAgICBwbGFuZSA9IFBsYW5lX2RlZmF1bHQuZnJvbVBvaW50Tm9ybWFsKHBsYW5lT3JpZ2luLCBwbGFuZU5vcm1hbCwgc2NyYXRjaFBsYW5lKTsKICAgIGNvbnN0IGhvcml6b25DYXJ0ZXNpYW4gPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbVJhZGlhbnMoCiAgICAgIGNlbnRlckxvbmdpdHVkZSArIE1hdGhfZGVmYXVsdC5QSV9PVkVSX1RXTywKICAgICAgbGF0aXR1ZGVOZWFyZXN0VG9FcXVhdG9yLAogICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICBlbGxpcHNvaWQsCiAgICAgIHNjcmF0Y2hIb3Jpem9uQ2FydGVzaWFuCiAgICApOwogICAgbWF4WCA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoCiAgICAgIFBsYW5lX2RlZmF1bHQucHJvamVjdFBvaW50T250b1BsYW5lKAogICAgICAgIHBsYW5lLAogICAgICAgIGhvcml6b25DYXJ0ZXNpYW4sCiAgICAgICAgc2NyYXRjaEhvcml6b25Qcm9qZWN0ZWQKICAgICAgKSwKICAgICAgcGxhbmVYQXhpcwogICAgKTsKICAgIG1pblggPSAtbWF4WDsKICAgIG1heFkgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbVJhZGlhbnMoCiAgICAgIDAsCiAgICAgIHJlY3RhbmdsZS5ub3J0aCwKICAgICAgZnVsbHlCZWxvd0VxdWF0b3IgPyBtaW5pbXVtSGVpZ2h0IDogbWF4aW11bUhlaWdodCwKICAgICAgZWxsaXBzb2lkLAogICAgICBzY3JhdGNoTWF4WQogICAgKS56OwogICAgbWluWSA9IENhcnRlc2lhbjNfZGVmYXVsdC5mcm9tUmFkaWFucygKICAgICAgMCwKICAgICAgcmVjdGFuZ2xlLnNvdXRoLAogICAgICBmdWxseUFib3ZlRXF1YXRvciA/IG1pbmltdW1IZWlnaHQgOiBtYXhpbXVtSGVpZ2h0LAogICAgICBlbGxpcHNvaWQsCiAgICAgIHNjcmF0Y2hNaW5ZCiAgICApLno7CiAgICBjb25zdCBmYXJaID0gQ2FydGVzaWFuM19kZWZhdWx0LmZyb21SYWRpYW5zKAogICAgICByZWN0YW5nbGUuZWFzdCwKICAgICAgbGF0aXR1ZGVOZWFyZXN0VG9FcXVhdG9yLAogICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICBlbGxpcHNvaWQsCiAgICAgIHNjcmF0Y2haCiAgICApOwogICAgbWluWiA9IFBsYW5lX2RlZmF1bHQuZ2V0UG9pbnREaXN0YW5jZShwbGFuZSwgZmFyWik7CiAgICBtYXhaID0gMDsKICAgIHJldHVybiBmcm9tUGxhbmVFeHRlbnRzKAogICAgICBwbGFuZU9yaWdpbiwKICAgICAgcGxhbmVYQXhpcywKICAgICAgcGxhbmVZQXhpcywKICAgICAgcGxhbmVOb3JtYWwsCiAgICAgIG1pblgsCiAgICAgIG1heFgsCiAgICAgIG1pblksCiAgICAgIG1heFksCiAgICAgIG1pblosCiAgICAgIG1heFosCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3guZnJvbVRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24odHJhbnNmb3JtYXRpb24sIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJ0cmFuc2Zvcm1hdGlvbiIsIHRyYW5zZm9ybWF0aW9uKTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IE9yaWVudGVkQm91bmRpbmdCb3goKTsKICAgIH0KICAgIHJlc3VsdC5jZW50ZXIgPSBNYXRyaXg0X2RlZmF1bHQuZ2V0VHJhbnNsYXRpb24odHJhbnNmb3JtYXRpb24sIHJlc3VsdC5jZW50ZXIpOwogICAgcmVzdWx0LmhhbGZBeGVzID0gTWF0cml4NF9kZWZhdWx0LmdldE1hdHJpeDModHJhbnNmb3JtYXRpb24sIHJlc3VsdC5oYWxmQXhlcyk7CiAgICByZXN1bHQuaGFsZkF4ZXMgPSBNYXRyaXgzX2RlZmF1bHQubXVsdGlwbHlCeVNjYWxhcigKICAgICAgcmVzdWx0LmhhbGZBeGVzLAogICAgICAwLjUsCiAgICAgIHJlc3VsdC5oYWxmQXhlcwogICAgKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBPcmllbnRlZEJvdW5kaW5nQm94LmNsb25lID0gZnVuY3Rpb24oYm94LCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJveCkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmV0dXJuIG5ldyBPcmllbnRlZEJvdW5kaW5nQm94KGJveC5jZW50ZXIsIGJveC5oYWxmQXhlcyk7CiAgICB9CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoYm94LmNlbnRlciwgcmVzdWx0LmNlbnRlcik7CiAgICBNYXRyaXgzX2RlZmF1bHQuY2xvbmUoYm94LmhhbGZBeGVzLCByZXN1bHQuaGFsZkF4ZXMpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3guaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihib3gsIHBsYW5lKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChib3gpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJib3ggaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChwbGFuZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInBsYW5lIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgY2VudGVyID0gYm94LmNlbnRlcjsKICAgIGNvbnN0IG5vcm1hbCA9IHBsYW5lLm5vcm1hbDsKICAgIGNvbnN0IGhhbGZBeGVzID0gYm94LmhhbGZBeGVzOwogICAgY29uc3Qgbm9ybWFsWCA9IG5vcm1hbC54LCBub3JtYWxZID0gbm9ybWFsLnksIG5vcm1hbFogPSBub3JtYWwuejsKICAgIGNvbnN0IHJhZEVmZmVjdGl2ZSA9IE1hdGguYWJzKAogICAgICBub3JtYWxYICogaGFsZkF4ZXNbTWF0cml4M19kZWZhdWx0LkNPTFVNTjBST1cwXSArIG5vcm1hbFkgKiBoYWxmQXhlc1tNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMFJPVzFdICsgbm9ybWFsWiAqIGhhbGZBeGVzW01hdHJpeDNfZGVmYXVsdC5DT0xVTU4wUk9XMl0KICAgICkgKyBNYXRoLmFicygKICAgICAgbm9ybWFsWCAqIGhhbGZBeGVzW01hdHJpeDNfZGVmYXVsdC5DT0xVTU4xUk9XMF0gKyBub3JtYWxZICogaGFsZkF4ZXNbTWF0cml4M19kZWZhdWx0LkNPTFVNTjFST1cxXSArIG5vcm1hbFogKiBoYWxmQXhlc1tNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMVJPVzJdCiAgICApICsgTWF0aC5hYnMoCiAgICAgIG5vcm1hbFggKiBoYWxmQXhlc1tNYXRyaXgzX2RlZmF1bHQuQ09MVU1OMlJPVzBdICsgbm9ybWFsWSAqIGhhbGZBeGVzW01hdHJpeDNfZGVmYXVsdC5DT0xVTU4yUk9XMV0gKyBub3JtYWxaICogaGFsZkF4ZXNbTWF0cml4M19kZWZhdWx0LkNPTFVNTjJST1cyXQogICAgKTsKICAgIGNvbnN0IGRpc3RhbmNlVG9QbGFuZSA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3Qobm9ybWFsLCBjZW50ZXIpICsgcGxhbmUuZGlzdGFuY2U7CiAgICBpZiAoZGlzdGFuY2VUb1BsYW5lIDw9IC1yYWRFZmZlY3RpdmUpIHsKICAgICAgcmV0dXJuIEludGVyc2VjdF9kZWZhdWx0Lk9VVFNJREU7CiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVG9QbGFuZSA+PSByYWRFZmZlY3RpdmUpIHsKICAgICAgcmV0dXJuIEludGVyc2VjdF9kZWZhdWx0LklOU0lERTsKICAgIH0KICAgIHJldHVybiBJbnRlcnNlY3RfZGVmYXVsdC5JTlRFUlNFQ1RJTkc7CiAgfTsKICB2YXIgc2NyYXRjaENhcnRlc2lhblUgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hDYXJ0ZXNpYW5WID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoQ2FydGVzaWFuVyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFZhbGlkQXhpczIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hWYWxpZEF4aXMzID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBzY3JhdGNoUFByaW1lID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIE9yaWVudGVkQm91bmRpbmdCb3guZGlzdGFuY2VTcXVhcmVkVG8gPSBmdW5jdGlvbihib3gsIGNhcnRlc2lhbikgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYm94KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYm94IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY2FydGVzaWFuKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY2FydGVzaWFuIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3Qgb2Zmc2V0ID0gQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNhcnRlc2lhbiwgYm94LmNlbnRlciwgc2NyYXRjaE9mZnNldCk7CiAgICBjb25zdCBoYWxmQXhlcyA9IGJveC5oYWxmQXhlczsKICAgIGxldCB1MiA9IE1hdHJpeDNfZGVmYXVsdC5nZXRDb2x1bW4oaGFsZkF4ZXMsIDAsIHNjcmF0Y2hDYXJ0ZXNpYW5VKTsKICAgIGxldCB2MiA9IE1hdHJpeDNfZGVmYXVsdC5nZXRDb2x1bW4oaGFsZkF4ZXMsIDEsIHNjcmF0Y2hDYXJ0ZXNpYW5WKTsKICAgIGxldCB3ID0gTWF0cml4M19kZWZhdWx0LmdldENvbHVtbihoYWxmQXhlcywgMiwgc2NyYXRjaENhcnRlc2lhblcpOwogICAgY29uc3QgdUhhbGYgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQubWFnbml0dWRlKHUyKTsKICAgIGNvbnN0IHZIYWxmID0gQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZSh2Mik7CiAgICBjb25zdCB3SGFsZiA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUodyk7CiAgICBsZXQgdVZhbGlkID0gdHJ1ZTsKICAgIGxldCB2VmFsaWQgPSB0cnVlOwogICAgbGV0IHdWYWxpZCA9IHRydWU7CiAgICBpZiAodUhhbGYgPiAwKSB7CiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5kaXZpZGVCeVNjYWxhcih1MiwgdUhhbGYsIHUyKTsKICAgIH0gZWxzZSB7CiAgICAgIHVWYWxpZCA9IGZhbHNlOwogICAgfQogICAgaWYgKHZIYWxmID4gMCkgewogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuZGl2aWRlQnlTY2FsYXIodjIsIHZIYWxmLCB2Mik7CiAgICB9IGVsc2UgewogICAgICB2VmFsaWQgPSBmYWxzZTsKICAgIH0KICAgIGlmICh3SGFsZiA+IDApIHsKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmRpdmlkZUJ5U2NhbGFyKHcsIHdIYWxmLCB3KTsKICAgIH0gZWxzZSB7CiAgICAgIHdWYWxpZCA9IGZhbHNlOwogICAgfQogICAgY29uc3QgbnVtYmVyT2ZEZWdlbmVyYXRlQXhlcyA9ICF1VmFsaWQgKyAhdlZhbGlkICsgIXdWYWxpZDsKICAgIGxldCB2YWxpZEF4aXMxOwogICAgbGV0IHZhbGlkQXhpczI7CiAgICBsZXQgdmFsaWRBeGlzMzsKICAgIGlmIChudW1iZXJPZkRlZ2VuZXJhdGVBeGVzID09PSAxKSB7CiAgICAgIGxldCBkZWdlbmVyYXRlQXhpcyA9IHUyOwogICAgICB2YWxpZEF4aXMxID0gdjI7CiAgICAgIHZhbGlkQXhpczIgPSB3OwogICAgICBpZiAoIXZWYWxpZCkgewogICAgICAgIGRlZ2VuZXJhdGVBeGlzID0gdjI7CiAgICAgICAgdmFsaWRBeGlzMSA9IHUyOwogICAgICB9IGVsc2UgaWYgKCF3VmFsaWQpIHsKICAgICAgICBkZWdlbmVyYXRlQXhpcyA9IHc7CiAgICAgICAgdmFsaWRBeGlzMiA9IHUyOwogICAgICB9CiAgICAgIHZhbGlkQXhpczMgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY3Jvc3ModmFsaWRBeGlzMSwgdmFsaWRBeGlzMiwgc2NyYXRjaFZhbGlkQXhpczMpOwogICAgICBpZiAoZGVnZW5lcmF0ZUF4aXMgPT09IHUyKSB7CiAgICAgICAgdTIgPSB2YWxpZEF4aXMzOwogICAgICB9IGVsc2UgaWYgKGRlZ2VuZXJhdGVBeGlzID09PSB2MikgewogICAgICAgIHYyID0gdmFsaWRBeGlzMzsKICAgICAgfSBlbHNlIGlmIChkZWdlbmVyYXRlQXhpcyA9PT0gdykgewogICAgICAgIHcgPSB2YWxpZEF4aXMzOwogICAgICB9CiAgICB9IGVsc2UgaWYgKG51bWJlck9mRGVnZW5lcmF0ZUF4ZXMgPT09IDIpIHsKICAgICAgdmFsaWRBeGlzMSA9IHUyOwogICAgICBpZiAodlZhbGlkKSB7CiAgICAgICAgdmFsaWRBeGlzMSA9IHYyOwogICAgICB9IGVsc2UgaWYgKHdWYWxpZCkgewogICAgICAgIHZhbGlkQXhpczEgPSB3OwogICAgICB9CiAgICAgIGxldCBjcm9zc1ZlY3RvciA9IENhcnRlc2lhbjNfZGVmYXVsdC5VTklUX1k7CiAgICAgIGlmIChjcm9zc1ZlY3Rvci5lcXVhbHNFcHNpbG9uKHZhbGlkQXhpczEsIE1hdGhfZGVmYXVsdC5FUFNJTE9OMykpIHsKICAgICAgICBjcm9zc1ZlY3RvciA9IENhcnRlc2lhbjNfZGVmYXVsdC5VTklUX1g7CiAgICAgIH0KICAgICAgdmFsaWRBeGlzMiA9IENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyh2YWxpZEF4aXMxLCBjcm9zc1ZlY3Rvciwgc2NyYXRjaFZhbGlkQXhpczIpOwogICAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKHZhbGlkQXhpczIsIHZhbGlkQXhpczIpOwogICAgICB2YWxpZEF4aXMzID0gQ2FydGVzaWFuM19kZWZhdWx0LmNyb3NzKHZhbGlkQXhpczEsIHZhbGlkQXhpczIsIHNjcmF0Y2hWYWxpZEF4aXMzKTsKICAgICAgQ2FydGVzaWFuM19kZWZhdWx0Lm5vcm1hbGl6ZSh2YWxpZEF4aXMzLCB2YWxpZEF4aXMzKTsKICAgICAgaWYgKHZhbGlkQXhpczEgPT09IHUyKSB7CiAgICAgICAgdjIgPSB2YWxpZEF4aXMyOwogICAgICAgIHcgPSB2YWxpZEF4aXMzOwogICAgICB9IGVsc2UgaWYgKHZhbGlkQXhpczEgPT09IHYyKSB7CiAgICAgICAgdyA9IHZhbGlkQXhpczI7CiAgICAgICAgdTIgPSB2YWxpZEF4aXMzOwogICAgICB9IGVsc2UgaWYgKHZhbGlkQXhpczEgPT09IHcpIHsKICAgICAgICB1MiA9IHZhbGlkQXhpczI7CiAgICAgICAgdjIgPSB2YWxpZEF4aXMzOwogICAgICB9CiAgICB9IGVsc2UgaWYgKG51bWJlck9mRGVnZW5lcmF0ZUF4ZXMgPT09IDMpIHsKICAgICAgdTIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuVU5JVF9YOwogICAgICB2MiA9IENhcnRlc2lhbjNfZGVmYXVsdC5VTklUX1k7CiAgICAgIHcgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuVU5JVF9aOwogICAgfQogICAgY29uc3QgcFByaW1lID0gc2NyYXRjaFBQcmltZTsKICAgIHBQcmltZS54ID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChvZmZzZXQsIHUyKTsKICAgIHBQcmltZS55ID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChvZmZzZXQsIHYyKTsKICAgIHBQcmltZS56ID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChvZmZzZXQsIHcpOwogICAgbGV0IGRpc3RhbmNlU3F1YXJlZCA9IDA7CiAgICBsZXQgZDsKICAgIGlmIChwUHJpbWUueCA8IC11SGFsZikgewogICAgICBkID0gcFByaW1lLnggKyB1SGFsZjsKICAgICAgZGlzdGFuY2VTcXVhcmVkICs9IGQgKiBkOwogICAgfSBlbHNlIGlmIChwUHJpbWUueCA+IHVIYWxmKSB7CiAgICAgIGQgPSBwUHJpbWUueCAtIHVIYWxmOwogICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7CiAgICB9CiAgICBpZiAocFByaW1lLnkgPCAtdkhhbGYpIHsKICAgICAgZCA9IHBQcmltZS55ICsgdkhhbGY7CiAgICAgIGRpc3RhbmNlU3F1YXJlZCArPSBkICogZDsKICAgIH0gZWxzZSBpZiAocFByaW1lLnkgPiB2SGFsZikgewogICAgICBkID0gcFByaW1lLnkgLSB2SGFsZjsKICAgICAgZGlzdGFuY2VTcXVhcmVkICs9IGQgKiBkOwogICAgfQogICAgaWYgKHBQcmltZS56IDwgLXdIYWxmKSB7CiAgICAgIGQgPSBwUHJpbWUueiArIHdIYWxmOwogICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7CiAgICB9IGVsc2UgaWYgKHBQcmltZS56ID4gd0hhbGYpIHsKICAgICAgZCA9IHBQcmltZS56IC0gd0hhbGY7CiAgICAgIGRpc3RhbmNlU3F1YXJlZCArPSBkICogZDsKICAgIH0KICAgIHJldHVybiBkaXN0YW5jZVNxdWFyZWQ7CiAgfTsKICB2YXIgc2NyYXRjaENvcm5lciA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFRvQ2VudGVyID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIE9yaWVudGVkQm91bmRpbmdCb3guY29tcHV0ZVBsYW5lRGlzdGFuY2VzID0gZnVuY3Rpb24oYm94LCBwb3NpdGlvbiwgZGlyZWN0aW9uLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJveCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImJveCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHBvc2l0aW9uKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgicG9zaXRpb24gaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChkaXJlY3Rpb24pKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkaXJlY3Rpb24gaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnZhbF9kZWZhdWx0KCk7CiAgICB9CiAgICBsZXQgbWluRGlzdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsKICAgIGxldCBtYXhEaXN0ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOwogICAgY29uc3QgY2VudGVyID0gYm94LmNlbnRlcjsKICAgIGNvbnN0IGhhbGZBeGVzID0gYm94LmhhbGZBeGVzOwogICAgY29uc3QgdTIgPSBNYXRyaXgzX2RlZmF1bHQuZ2V0Q29sdW1uKGhhbGZBeGVzLCAwLCBzY3JhdGNoQ2FydGVzaWFuVSk7CiAgICBjb25zdCB2MiA9IE1hdHJpeDNfZGVmYXVsdC5nZXRDb2x1bW4oaGFsZkF4ZXMsIDEsIHNjcmF0Y2hDYXJ0ZXNpYW5WKTsKICAgIGNvbnN0IHcgPSBNYXRyaXgzX2RlZmF1bHQuZ2V0Q29sdW1uKGhhbGZBeGVzLCAyLCBzY3JhdGNoQ2FydGVzaWFuVyk7CiAgICBjb25zdCBjb3JuZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHUyLCB2Miwgc2NyYXRjaENvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNvcm5lciwgdywgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoY29ybmVyLCBjZW50ZXIsIGNvcm5lcik7CiAgICBjb25zdCB0b0NlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjb3JuZXIsIHBvc2l0aW9uLCBzY3JhdGNoVG9DZW50ZXIpOwogICAgbGV0IG1hZyA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZGlyZWN0aW9uLCB0b0NlbnRlcik7CiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTsKICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjZW50ZXIsIHUyLCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjb3JuZXIsIHYyLCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNvcm5lciwgdywgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjb3JuZXIsIHBvc2l0aW9uLCB0b0NlbnRlcik7CiAgICBtYWcgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KGRpcmVjdGlvbiwgdG9DZW50ZXIpOwogICAgbWluRGlzdCA9IE1hdGgubWluKG1hZywgbWluRGlzdCk7CiAgICBtYXhEaXN0ID0gTWF0aC5tYXgobWFnLCBtYXhEaXN0KTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoY2VudGVyLCB1MiwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjb3JuZXIsIHYyLCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChjb3JuZXIsIHcsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY29ybmVyLCBwb3NpdGlvbiwgdG9DZW50ZXIpOwogICAgbWFnID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChkaXJlY3Rpb24sIHRvQ2VudGVyKTsKICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpOwogICAgbWF4RGlzdCA9IE1hdGgubWF4KG1hZywgbWF4RGlzdCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNlbnRlciwgdTIsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY29ybmVyLCB2MiwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjb3JuZXIsIHcsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY29ybmVyLCBwb3NpdGlvbiwgdG9DZW50ZXIpOwogICAgbWFnID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChkaXJlY3Rpb24sIHRvQ2VudGVyKTsKICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpOwogICAgbWF4RGlzdCA9IE1hdGgubWF4KG1hZywgbWF4RGlzdCk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY2VudGVyLCB1MiwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoY29ybmVyLCB2MiwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoY29ybmVyLCB3LCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNvcm5lciwgcG9zaXRpb24sIHRvQ2VudGVyKTsKICAgIG1hZyA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZGlyZWN0aW9uLCB0b0NlbnRlcik7CiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTsKICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNlbnRlciwgdTIsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKGNvcm5lciwgdjIsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY29ybmVyLCB3LCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNvcm5lciwgcG9zaXRpb24sIHRvQ2VudGVyKTsKICAgIG1hZyA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZGlyZWN0aW9uLCB0b0NlbnRlcik7CiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTsKICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNlbnRlciwgdTIsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY29ybmVyLCB2MiwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQoY29ybmVyLCB3LCBjb3JuZXIpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNvcm5lciwgcG9zaXRpb24sIHRvQ2VudGVyKTsKICAgIG1hZyA9IENhcnRlc2lhbjNfZGVmYXVsdC5kb3QoZGlyZWN0aW9uLCB0b0NlbnRlcik7CiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTsKICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KGNlbnRlciwgdTIsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY29ybmVyLCB2MiwgY29ybmVyKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChjb3JuZXIsIHcsIGNvcm5lcik7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoY29ybmVyLCBwb3NpdGlvbiwgdG9DZW50ZXIpOwogICAgbWFnID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChkaXJlY3Rpb24sIHRvQ2VudGVyKTsKICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpOwogICAgbWF4RGlzdCA9IE1hdGgubWF4KG1hZywgbWF4RGlzdCk7CiAgICByZXN1bHQuc3RhcnQgPSBtaW5EaXN0OwogICAgcmVzdWx0LnN0b3AgPSBtYXhEaXN0OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIHZhciBzY3JhdGNoWEF4aXMgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hZQXhpcyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgc2NyYXRjaFpBeGlzID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIE9yaWVudGVkQm91bmRpbmdCb3guY29tcHV0ZUNvcm5lcnMgPSBmdW5jdGlvbihib3gsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJib3giLCBib3gpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBbCiAgICAgICAgbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpLAogICAgICAgIG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKSwKICAgICAgICBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCksCiAgICAgICAgbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpLAogICAgICAgIG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKSwKICAgICAgICBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCksCiAgICAgICAgbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpLAogICAgICAgIG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKQogICAgICBdOwogICAgfQogICAgY29uc3QgY2VudGVyID0gYm94LmNlbnRlcjsKICAgIGNvbnN0IGhhbGZBeGVzID0gYm94LmhhbGZBeGVzOwogICAgY29uc3QgeEF4aXMgPSBNYXRyaXgzX2RlZmF1bHQuZ2V0Q29sdW1uKGhhbGZBeGVzLCAwLCBzY3JhdGNoWEF4aXMpOwogICAgY29uc3QgeUF4aXMgPSBNYXRyaXgzX2RlZmF1bHQuZ2V0Q29sdW1uKGhhbGZBeGVzLCAxLCBzY3JhdGNoWUF4aXMpOwogICAgY29uc3QgekF4aXMgPSBNYXRyaXgzX2RlZmF1bHQuZ2V0Q29sdW1uKGhhbGZBeGVzLCAyLCBzY3JhdGNoWkF4aXMpOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGNlbnRlciwgcmVzdWx0WzBdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChyZXN1bHRbMF0sIHhBeGlzLCByZXN1bHRbMF0pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHJlc3VsdFswXSwgeUF4aXMsIHJlc3VsdFswXSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QocmVzdWx0WzBdLCB6QXhpcywgcmVzdWx0WzBdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjZW50ZXIsIHJlc3VsdFsxXSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QocmVzdWx0WzFdLCB4QXhpcywgcmVzdWx0WzFdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChyZXN1bHRbMV0sIHlBeGlzLCByZXN1bHRbMV0pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChyZXN1bHRbMV0sIHpBeGlzLCByZXN1bHRbMV0pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGNlbnRlciwgcmVzdWx0WzJdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChyZXN1bHRbMl0sIHhBeGlzLCByZXN1bHRbMl0pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChyZXN1bHRbMl0sIHlBeGlzLCByZXN1bHRbMl0pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHJlc3VsdFsyXSwgekF4aXMsIHJlc3VsdFsyXSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY2VudGVyLCByZXN1bHRbM10pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHJlc3VsdFszXSwgeEF4aXMsIHJlc3VsdFszXSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFszXSwgeUF4aXMsIHJlc3VsdFszXSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFszXSwgekF4aXMsIHJlc3VsdFszXSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoY2VudGVyLCByZXN1bHRbNF0pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LmFkZChyZXN1bHRbNF0sIHhBeGlzLCByZXN1bHRbNF0pOwogICAgQ2FydGVzaWFuM19kZWZhdWx0LnN1YnRyYWN0KHJlc3VsdFs0XSwgeUF4aXMsIHJlc3VsdFs0XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QocmVzdWx0WzRdLCB6QXhpcywgcmVzdWx0WzRdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjZW50ZXIsIHJlc3VsdFs1XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFs1XSwgeEF4aXMsIHJlc3VsdFs1XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QocmVzdWx0WzVdLCB5QXhpcywgcmVzdWx0WzVdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5hZGQocmVzdWx0WzVdLCB6QXhpcywgcmVzdWx0WzVdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjZW50ZXIsIHJlc3VsdFs2XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFs2XSwgeEF4aXMsIHJlc3VsdFs2XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFs2XSwgeUF4aXMsIHJlc3VsdFs2XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QocmVzdWx0WzZdLCB6QXhpcywgcmVzdWx0WzZdKTsKICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjZW50ZXIsIHJlc3VsdFs3XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFs3XSwgeEF4aXMsIHJlc3VsdFs3XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFs3XSwgeUF4aXMsIHJlc3VsdFs3XSk7CiAgICBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdFs3XSwgekF4aXMsIHJlc3VsdFs3XSk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIHNjcmF0Y2hSb3RhdGlvblNjYWxlID0gbmV3IE1hdHJpeDNfZGVmYXVsdCgpOwogIE9yaWVudGVkQm91bmRpbmdCb3guY29tcHV0ZVRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24oYm94LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiYm94IiwgYm94KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IE1hdHJpeDRfZGVmYXVsdCgpOwogICAgfQogICAgY29uc3QgdHJhbnNsYXRpb24gPSBib3guY2VudGVyOwogICAgY29uc3Qgcm90YXRpb25TY2FsZSA9IE1hdHJpeDNfZGVmYXVsdC5tdWx0aXBseUJ5VW5pZm9ybVNjYWxlKAogICAgICBib3guaGFsZkF4ZXMsCiAgICAgIDIsCiAgICAgIHNjcmF0Y2hSb3RhdGlvblNjYWxlCiAgICApOwogICAgcmV0dXJuIE1hdHJpeDRfZGVmYXVsdC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbihyb3RhdGlvblNjYWxlLCB0cmFuc2xhdGlvbiwgcmVzdWx0KTsKICB9OwogIHZhciBzY3JhdGNoQm91bmRpbmdTcGhlcmUgPSBuZXcgQm91bmRpbmdTcGhlcmVfZGVmYXVsdCgpOwogIE9yaWVudGVkQm91bmRpbmdCb3guaXNPY2NsdWRlZCA9IGZ1bmN0aW9uKGJveCwgb2NjbHVkZXIpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJveCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImJveCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9jY2x1ZGVyKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib2NjbHVkZXIgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBzcGhlcmUgPSBCb3VuZGluZ1NwaGVyZV9kZWZhdWx0LmZyb21PcmllbnRlZEJvdW5kaW5nQm94KAogICAgICBib3gsCiAgICAgIHNjcmF0Y2hCb3VuZGluZ1NwaGVyZQogICAgKTsKICAgIHJldHVybiAhb2NjbHVkZXIuaXNCb3VuZGluZ1NwaGVyZVZpc2libGUoc3BoZXJlKTsKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3gucHJvdG90eXBlLmludGVyc2VjdFBsYW5lID0gZnVuY3Rpb24ocGxhbmUpIHsKICAgIHJldHVybiBPcmllbnRlZEJvdW5kaW5nQm94LmludGVyc2VjdFBsYW5lKHRoaXMsIHBsYW5lKTsKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3gucHJvdG90eXBlLmRpc3RhbmNlU3F1YXJlZFRvID0gZnVuY3Rpb24oY2FydGVzaWFuKSB7CiAgICByZXR1cm4gT3JpZW50ZWRCb3VuZGluZ0JveC5kaXN0YW5jZVNxdWFyZWRUbyh0aGlzLCBjYXJ0ZXNpYW4pOwogIH07CiAgT3JpZW50ZWRCb3VuZGluZ0JveC5wcm90b3R5cGUuY29tcHV0ZVBsYW5lRGlzdGFuY2VzID0gZnVuY3Rpb24ocG9zaXRpb24sIGRpcmVjdGlvbiwgcmVzdWx0KSB7CiAgICByZXR1cm4gT3JpZW50ZWRCb3VuZGluZ0JveC5jb21wdXRlUGxhbmVEaXN0YW5jZXMoCiAgICAgIHRoaXMsCiAgICAgIHBvc2l0aW9uLAogICAgICBkaXJlY3Rpb24sCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbXB1dGVDb3JuZXJzID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gT3JpZW50ZWRCb3VuZGluZ0JveC5jb21wdXRlQ29ybmVycyh0aGlzLCByZXN1bHQpOwogIH07CiAgT3JpZW50ZWRCb3VuZGluZ0JveC5wcm90b3R5cGUuY29tcHV0ZVRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gT3JpZW50ZWRCb3VuZGluZ0JveC5jb21wdXRlVHJhbnNmb3JtYXRpb24odGhpcywgcmVzdWx0KTsKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3gucHJvdG90eXBlLmlzT2NjbHVkZWQgPSBmdW5jdGlvbihvY2NsdWRlcikgewogICAgcmV0dXJuIE9yaWVudGVkQm91bmRpbmdCb3guaXNPY2NsdWRlZCh0aGlzLCBvY2NsdWRlcik7CiAgfTsKICBPcmllbnRlZEJvdW5kaW5nQm94LmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgZGVmaW5lZF9kZWZhdWx0KGxlZnQpICYmIGRlZmluZWRfZGVmYXVsdChyaWdodCkgJiYgQ2FydGVzaWFuM19kZWZhdWx0LmVxdWFscyhsZWZ0LmNlbnRlciwgcmlnaHQuY2VudGVyKSAmJiBNYXRyaXgzX2RlZmF1bHQuZXF1YWxzKGxlZnQuaGFsZkF4ZXMsIHJpZ2h0LmhhbGZBeGVzKTsKICB9OwogIE9yaWVudGVkQm91bmRpbmdCb3gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICByZXR1cm4gT3JpZW50ZWRCb3VuZGluZ0JveC5jbG9uZSh0aGlzLCByZXN1bHQpOwogIH07CiAgT3JpZW50ZWRCb3VuZGluZ0JveC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocmlnaHQpIHsKICAgIHJldHVybiBPcmllbnRlZEJvdW5kaW5nQm94LmVxdWFscyh0aGlzLCByaWdodCk7CiAgfTsKICB2YXIgT3JpZW50ZWRCb3VuZGluZ0JveF9kZWZhdWx0ID0gT3JpZW50ZWRCb3VuZGluZ0JveDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RlcnJhaW5FeGFnZ2VyYXRpb24uanMKICB2YXIgVGVycmFpbkV4YWdnZXJhdGlvbiA9IHt9OwogIFRlcnJhaW5FeGFnZ2VyYXRpb24uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBzY2FsZSwgcmVsYXRpdmVIZWlnaHQpIHsKICAgIHJldHVybiAoaGVpZ2h0IC0gcmVsYXRpdmVIZWlnaHQpICogc2NhbGUgKyByZWxhdGl2ZUhlaWdodDsKICB9OwogIHZhciBzY3JhdGNoQ2FydG9ncmFwaGljMiA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBUZXJyYWluRXhhZ2dlcmF0aW9uLmdldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24sIGVsbGlwc29pZCwgdGVycmFpbkV4YWdnZXJhdGlvbiwgdGVycmFpbkV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0LCByZXN1bHQpIHsKICAgIGNvbnN0IGNhcnRvZ3JhcGhpYyA9IGVsbGlwc29pZC5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpYygKICAgICAgcG9zaXRpb24sCiAgICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWMyCiAgICApOwogICAgY29uc3QgbmV3SGVpZ2h0ID0gVGVycmFpbkV4YWdnZXJhdGlvbi5nZXRIZWlnaHQoCiAgICAgIGNhcnRvZ3JhcGhpYy5oZWlnaHQsCiAgICAgIHRlcnJhaW5FeGFnZ2VyYXRpb24sCiAgICAgIHRlcnJhaW5FeGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodAogICAgKTsKICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQuZnJvbVJhZGlhbnMoCiAgICAgIGNhcnRvZ3JhcGhpYy5sb25naXR1ZGUsCiAgICAgIGNhcnRvZ3JhcGhpYy5sYXRpdHVkZSwKICAgICAgbmV3SGVpZ2h0LAogICAgICBlbGxpcHNvaWQsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIHZhciBUZXJyYWluRXhhZ2dlcmF0aW9uX2RlZmF1bHQgPSBUZXJyYWluRXhhZ2dlcmF0aW9uOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NjZW5lL0F0dHJpYnV0ZVR5cGUuanMKICB2YXIgQXR0cmlidXRlVHlwZSA9IHsKICAgIFNDQUxBUjogIlNDQUxBUiIsCiAgICBWRUMyOiAiVkVDMiIsCiAgICBWRUMzOiAiVkVDMyIsCiAgICBWRUM0OiAiVkVDNCIsCiAgICBNQVQyOiAiTUFUMiIsCiAgICBNQVQzOiAiTUFUMyIsCiAgICBNQVQ0OiAiTUFUNCIKICB9OwogIEF0dHJpYnV0ZVR5cGUuZ2V0TWF0aFR5cGUgPSBmdW5jdGlvbihhdHRyaWJ1dGVUeXBlKSB7CiAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUpIHsKICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLlNDQUxBUjoKICAgICAgICByZXR1cm4gTnVtYmVyOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDMjoKICAgICAgICByZXR1cm4gQ2FydGVzaWFuMl9kZWZhdWx0OwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDMzoKICAgICAgICByZXR1cm4gQ2FydGVzaWFuM19kZWZhdWx0OwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDNDoKICAgICAgICByZXR1cm4gQ2FydGVzaWFuNF9kZWZhdWx0OwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUMjoKICAgICAgICByZXR1cm4gTWF0cml4Ml9kZWZhdWx0OwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUMzoKICAgICAgICByZXR1cm4gTWF0cml4M19kZWZhdWx0OwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUNDoKICAgICAgICByZXR1cm4gTWF0cml4NF9kZWZhdWx0OwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhdHRyaWJ1dGVUeXBlIGlzIG5vdCBhIHZhbGlkIHZhbHVlLiIpOwogICAgfQogIH07CiAgQXR0cmlidXRlVHlwZS5nZXROdW1iZXJPZkNvbXBvbmVudHMgPSBmdW5jdGlvbihhdHRyaWJ1dGVUeXBlKSB7CiAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUpIHsKICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLlNDQUxBUjoKICAgICAgICByZXR1cm4gMTsKICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLlZFQzI6CiAgICAgICAgcmV0dXJuIDI7CiAgICAgIGNhc2UgQXR0cmlidXRlVHlwZS5WRUMzOgogICAgICAgIHJldHVybiAzOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDNDoKICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLk1BVDI6CiAgICAgICAgcmV0dXJuIDQ7CiAgICAgIGNhc2UgQXR0cmlidXRlVHlwZS5NQVQzOgogICAgICAgIHJldHVybiA5OwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUNDoKICAgICAgICByZXR1cm4gMTY7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImF0dHJpYnV0ZVR5cGUgaXMgbm90IGEgdmFsaWQgdmFsdWUuIik7CiAgICB9CiAgfTsKICBBdHRyaWJ1dGVUeXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uQ291bnQgPSBmdW5jdGlvbihhdHRyaWJ1dGVUeXBlKSB7CiAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUpIHsKICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLlNDQUxBUjoKICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLlZFQzI6CiAgICAgIGNhc2UgQXR0cmlidXRlVHlwZS5WRUMzOgogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDNDoKICAgICAgICByZXR1cm4gMTsKICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLk1BVDI6CiAgICAgICAgcmV0dXJuIDI7CiAgICAgIGNhc2UgQXR0cmlidXRlVHlwZS5NQVQzOgogICAgICAgIHJldHVybiAzOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUNDoKICAgICAgICByZXR1cm4gNDsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYXR0cmlidXRlVHlwZSBpcyBub3QgYSB2YWxpZCB2YWx1ZS4iKTsKICAgIH0KICB9OwogIEF0dHJpYnV0ZVR5cGUuZ2V0R2xzbFR5cGUgPSBmdW5jdGlvbihhdHRyaWJ1dGVUeXBlKSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5zdHJpbmcoImF0dHJpYnV0ZVR5cGUiLCBhdHRyaWJ1dGVUeXBlKTsKICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkgewogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuU0NBTEFSOgogICAgICAgIHJldHVybiAiZmxvYXQiOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDMjoKICAgICAgICByZXR1cm4gInZlYzIiOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDMzoKICAgICAgICByZXR1cm4gInZlYzMiOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDNDoKICAgICAgICByZXR1cm4gInZlYzQiOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUMjoKICAgICAgICByZXR1cm4gIm1hdDIiOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUMzoKICAgICAgICByZXR1cm4gIm1hdDMiOwogICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuTUFUNDoKICAgICAgICByZXR1cm4gIm1hdDQiOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJhdHRyaWJ1dGVUeXBlIGlzIG5vdCBhIHZhbGlkIHZhbHVlLiIpOwogICAgfQogIH07CiAgdmFyIEF0dHJpYnV0ZVR5cGVfZGVmYXVsdCA9IE9iamVjdC5mcmVlemUoQXR0cmlidXRlVHlwZSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9BdHRyaWJ1dGVDb21wcmVzc2lvbi5qcwogIHZhciBSSUdIVF9TSElGVCA9IDEgLyAyNTY7CiAgdmFyIExFRlRfU0hJRlQgPSAyNTY7CiAgdmFyIEF0dHJpYnV0ZUNvbXByZXNzaW9uID0ge307CiAgQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RW5jb2RlSW5SYW5nZSA9IGZ1bmN0aW9uKHZlY3RvciwgcmFuZ2VNYXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ2ZWN0b3IiLCB2ZWN0b3IpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgbWFnU3F1YXJlZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKHZlY3Rvcik7CiAgICBpZiAoTWF0aC5hYnMobWFnU3F1YXJlZCAtIDEpID4gTWF0aF9kZWZhdWx0LkVQU0lMT042KSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ2ZWN0b3IgbXVzdCBiZSBub3JtYWxpemVkLiIpOwogICAgfQogICAgcmVzdWx0LnggPSB2ZWN0b3IueCAvIChNYXRoLmFicyh2ZWN0b3IueCkgKyBNYXRoLmFicyh2ZWN0b3IueSkgKyBNYXRoLmFicyh2ZWN0b3IueikpOwogICAgcmVzdWx0LnkgPSB2ZWN0b3IueSAvIChNYXRoLmFicyh2ZWN0b3IueCkgKyBNYXRoLmFicyh2ZWN0b3IueSkgKyBNYXRoLmFicyh2ZWN0b3IueikpOwogICAgaWYgKHZlY3Rvci56IDwgMCkgewogICAgICBjb25zdCB4ID0gcmVzdWx0Lng7CiAgICAgIGNvbnN0IHkgPSByZXN1bHQueTsKICAgICAgcmVzdWx0LnggPSAoMSAtIE1hdGguYWJzKHkpKSAqIE1hdGhfZGVmYXVsdC5zaWduTm90WmVybyh4KTsKICAgICAgcmVzdWx0LnkgPSAoMSAtIE1hdGguYWJzKHgpKSAqIE1hdGhfZGVmYXVsdC5zaWduTm90WmVybyh5KTsKICAgIH0KICAgIHJlc3VsdC54ID0gTWF0aF9kZWZhdWx0LnRvU05vcm0ocmVzdWx0LngsIHJhbmdlTWF4KTsKICAgIHJlc3VsdC55ID0gTWF0aF9kZWZhdWx0LnRvU05vcm0ocmVzdWx0LnksIHJhbmdlTWF4KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGUgPSBmdW5jdGlvbih2ZWN0b3IsIHJlc3VsdCkgewogICAgcmV0dXJuIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZUluUmFuZ2UodmVjdG9yLCAyNTUsIHJlc3VsdCk7CiAgfTsKICB2YXIgb2N0RW5jb2RlU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICB2YXIgdWludDhGb3JjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgZnVuY3Rpb24gZm9yY2VVaW50OCh2YWx1ZSkgewogICAgdWludDhGb3JjZUFycmF5WzBdID0gdmFsdWU7CiAgICByZXR1cm4gdWludDhGb3JjZUFycmF5WzBdOwogIH0KICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGVUb0NhcnRlc2lhbjQgPSBmdW5jdGlvbih2ZWN0b3IsIHJlc3VsdCkgewogICAgQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RW5jb2RlSW5SYW5nZSh2ZWN0b3IsIDY1NTM1LCBvY3RFbmNvZGVTY3JhdGNoKTsKICAgIHJlc3VsdC54ID0gZm9yY2VVaW50OChvY3RFbmNvZGVTY3JhdGNoLnggKiBSSUdIVF9TSElGVCk7CiAgICByZXN1bHQueSA9IGZvcmNlVWludDgob2N0RW5jb2RlU2NyYXRjaC54KTsKICAgIHJlc3VsdC56ID0gZm9yY2VVaW50OChvY3RFbmNvZGVTY3JhdGNoLnkgKiBSSUdIVF9TSElGVCk7CiAgICByZXN1bHQudyA9IGZvcmNlVWludDgob2N0RW5jb2RlU2NyYXRjaC55KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGVJblJhbmdlID0gZnVuY3Rpb24oeCwgeSwgcmFuZ2VNYXgsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJyZXN1bHQiLCByZXN1bHQpOwogICAgaWYgKHggPCAwIHx8IHggPiByYW5nZU1heCB8fCB5IDwgMCB8fCB5ID4gcmFuZ2VNYXgpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgYHggYW5kIHkgbXVzdCBiZSB1bnNpZ25lZCBub3JtYWxpemVkIGludGVnZXJzIGJldHdlZW4gMCBhbmQgJHtyYW5nZU1heH1gCiAgICAgICk7CiAgICB9CiAgICByZXN1bHQueCA9IE1hdGhfZGVmYXVsdC5mcm9tU05vcm0oeCwgcmFuZ2VNYXgpOwogICAgcmVzdWx0LnkgPSBNYXRoX2RlZmF1bHQuZnJvbVNOb3JtKHksIHJhbmdlTWF4KTsKICAgIHJlc3VsdC56ID0gMSAtIChNYXRoLmFicyhyZXN1bHQueCkgKyBNYXRoLmFicyhyZXN1bHQueSkpOwogICAgaWYgKHJlc3VsdC56IDwgMCkgewogICAgICBjb25zdCBvbGRWWCA9IHJlc3VsdC54OwogICAgICByZXN1bHQueCA9ICgxIC0gTWF0aC5hYnMocmVzdWx0LnkpKSAqIE1hdGhfZGVmYXVsdC5zaWduTm90WmVybyhvbGRWWCk7CiAgICAgIHJlc3VsdC55ID0gKDEgLSBNYXRoLmFicyhvbGRWWCkpICogTWF0aF9kZWZhdWx0LnNpZ25Ob3RaZXJvKHJlc3VsdC55KTsKICAgIH0KICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQubm9ybWFsaXplKHJlc3VsdCwgcmVzdWx0KTsKICB9OwogIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdERlY29kZSA9IGZ1bmN0aW9uKHgsIHksIHJlc3VsdCkgewogICAgcmV0dXJuIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdERlY29kZUluUmFuZ2UoeCwgeSwgMjU1LCByZXN1bHQpOwogIH07CiAgQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlRnJvbUNhcnRlc2lhbjQgPSBmdW5jdGlvbihlbmNvZGVkLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZW5jb2RlZCIsIGVuY29kZWQpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZXN1bHQiLCByZXN1bHQpOwogICAgY29uc3QgeCA9IGVuY29kZWQueDsKICAgIGNvbnN0IHkgPSBlbmNvZGVkLnk7CiAgICBjb25zdCB6ID0gZW5jb2RlZC56OwogICAgY29uc3QgdyA9IGVuY29kZWQudzsKICAgIGlmICh4IDwgMCB8fCB4ID4gMjU1IHx8IHkgPCAwIHx8IHkgPiAyNTUgfHwgeiA8IDAgfHwgeiA+IDI1NSB8fCB3IDwgMCB8fCB3ID4gMjU1KSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJ4LCB5LCB6LCBhbmQgdyBtdXN0IGJlIHVuc2lnbmVkIG5vcm1hbGl6ZWQgaW50ZWdlcnMgYmV0d2VlbiAwIGFuZCAyNTUiCiAgICAgICk7CiAgICB9CiAgICBjb25zdCB4T2N0MTYgPSB4ICogTEVGVF9TSElGVCArIHk7CiAgICBjb25zdCB5T2N0MTYgPSB6ICogTEVGVF9TSElGVCArIHc7CiAgICByZXR1cm4gQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlSW5SYW5nZSh4T2N0MTYsIHlPY3QxNiwgNjU1MzUsIHJlc3VsdCk7CiAgfTsKICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RQYWNrRmxvYXQgPSBmdW5jdGlvbihlbmNvZGVkKSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImVuY29kZWQiLCBlbmNvZGVkKTsKICAgIHJldHVybiAyNTYgKiBlbmNvZGVkLnggKyBlbmNvZGVkLnk7CiAgfTsKICB2YXIgc2NyYXRjaEVuY29kZUNhcnQyID0gbmV3IENhcnRlc2lhbjJfZGVmYXVsdCgpOwogIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZUZsb2F0ID0gZnVuY3Rpb24odmVjdG9yKSB7CiAgICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGUodmVjdG9yLCBzY3JhdGNoRW5jb2RlQ2FydDIpOwogICAgcmV0dXJuIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdFBhY2tGbG9hdChzY3JhdGNoRW5jb2RlQ2FydDIpOwogIH07CiAgQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlRmxvYXQgPSBmdW5jdGlvbih2YWx1ZSwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInZhbHVlIiwgdmFsdWUpOwogICAgY29uc3QgdGVtcCA9IHZhbHVlIC8gMjU2OwogICAgY29uc3QgeCA9IE1hdGguZmxvb3IodGVtcCk7CiAgICBjb25zdCB5ID0gKHRlbXAgLSB4KSAqIDI1NjsKICAgIHJldHVybiBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGUoeCwgeSwgcmVzdWx0KTsKICB9OwogIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdFBhY2sgPSBmdW5jdGlvbih2MSwgdjIsIHYzLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgidjEiLCB2MSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInYyIiwgdjIpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ2MyIsIHYzKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgicmVzdWx0IiwgcmVzdWx0KTsKICAgIGNvbnN0IGVuY29kZWQxID0gQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RW5jb2RlRmxvYXQodjEpOwogICAgY29uc3QgZW5jb2RlZDIgPSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGVGbG9hdCh2Mik7CiAgICBjb25zdCBlbmNvZGVkMyA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZSh2Mywgc2NyYXRjaEVuY29kZUNhcnQyKTsKICAgIHJlc3VsdC54ID0gNjU1MzYgKiBlbmNvZGVkMy54ICsgZW5jb2RlZDE7CiAgICByZXN1bHQueSA9IDY1NTM2ICogZW5jb2RlZDMueSArIGVuY29kZWQyOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdFVucGFjayA9IGZ1bmN0aW9uKHBhY2tlZCwgdjEsIHYyLCB2MykgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJwYWNrZWQiLCBwYWNrZWQpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ2MSIsIHYxKTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgidjIiLCB2Mik7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInYzIiwgdjMpOwogICAgbGV0IHRlbXAgPSBwYWNrZWQueCAvIDY1NTM2OwogICAgY29uc3QgeCA9IE1hdGguZmxvb3IodGVtcCk7CiAgICBjb25zdCBlbmNvZGVkRmxvYXQxID0gKHRlbXAgLSB4KSAqIDY1NTM2OwogICAgdGVtcCA9IHBhY2tlZC55IC8gNjU1MzY7CiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcih0ZW1wKTsKICAgIGNvbnN0IGVuY29kZWRGbG9hdDIgPSAodGVtcCAtIHkpICogNjU1MzY7CiAgICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGVGbG9hdChlbmNvZGVkRmxvYXQxLCB2MSk7CiAgICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGVGbG9hdChlbmNvZGVkRmxvYXQyLCB2Mik7CiAgICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGUoeCwgeSwgdjMpOwogIH07CiAgQXR0cmlidXRlQ29tcHJlc3Npb24uY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbih0ZXh0dXJlQ29vcmRpbmF0ZXMpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgidGV4dHVyZUNvb3JkaW5hdGVzIiwgdGV4dHVyZUNvb3JkaW5hdGVzKTsKICAgIGNvbnN0IHggPSB0ZXh0dXJlQ29vcmRpbmF0ZXMueCAqIDQwOTUgfCAwOwogICAgY29uc3QgeSA9IHRleHR1cmVDb29yZGluYXRlcy55ICogNDA5NSB8IDA7CiAgICByZXR1cm4gNDA5NiAqIHggKyB5OwogIH07CiAgQXR0cmlidXRlQ29tcHJlc3Npb24uZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyA9IGZ1bmN0aW9uKGNvbXByZXNzZWQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJjb21wcmVzc2VkIiwgY29tcHJlc3NlZCk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInJlc3VsdCIsIHJlc3VsdCk7CiAgICBjb25zdCB0ZW1wID0gY29tcHJlc3NlZCAvIDQwOTY7CiAgICBjb25zdCB4WmVyb1RvNDA5NSA9IE1hdGguZmxvb3IodGVtcCk7CiAgICByZXN1bHQueCA9IHhaZXJvVG80MDk1IC8gNDA5NTsKICAgIHJlc3VsdC55ID0gKGNvbXByZXNzZWQgLSB4WmVyb1RvNDA5NSAqIDQwOTYpIC8gNDA5NTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBmdW5jdGlvbiB6aWdaYWdEZWNvZGUodmFsdWUpIHsKICAgIHJldHVybiB2YWx1ZSA+PiAxIF4gLSh2YWx1ZSAmIDEpOwogIH0KICBBdHRyaWJ1dGVDb21wcmVzc2lvbi56aWdaYWdEZWx0YURlY29kZSA9IGZ1bmN0aW9uKHVCdWZmZXIsIHZCdWZmZXIsIGhlaWdodEJ1ZmZlcikgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ1QnVmZmVyIiwgdUJ1ZmZlcik7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInZCdWZmZXIiLCB2QnVmZmVyKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlci5lcXVhbHMoCiAgICAgICJ1QnVmZmVyLmxlbmd0aCIsCiAgICAgICJ2QnVmZmVyLmxlbmd0aCIsCiAgICAgIHVCdWZmZXIubGVuZ3RoLAogICAgICB2QnVmZmVyLmxlbmd0aAogICAgKTsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoaGVpZ2h0QnVmZmVyKSkgewogICAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIuZXF1YWxzKAogICAgICAgICJ1QnVmZmVyLmxlbmd0aCIsCiAgICAgICAgImhlaWdodEJ1ZmZlci5sZW5ndGgiLAogICAgICAgIHVCdWZmZXIubGVuZ3RoLAogICAgICAgIGhlaWdodEJ1ZmZlci5sZW5ndGgKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IGNvdW50ID0gdUJ1ZmZlci5sZW5ndGg7CiAgICBsZXQgdTIgPSAwOwogICAgbGV0IHYyID0gMDsKICAgIGxldCBoZWlnaHQgPSAwOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7CiAgICAgIHUyICs9IHppZ1phZ0RlY29kZSh1QnVmZmVyW2ldKTsKICAgICAgdjIgKz0gemlnWmFnRGVjb2RlKHZCdWZmZXJbaV0pOwogICAgICB1QnVmZmVyW2ldID0gdTI7CiAgICAgIHZCdWZmZXJbaV0gPSB2MjsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChoZWlnaHRCdWZmZXIpKSB7CiAgICAgICAgaGVpZ2h0ICs9IHppZ1phZ0RlY29kZShoZWlnaHRCdWZmZXJbaV0pOwogICAgICAgIGhlaWdodEJ1ZmZlcltpXSA9IGhlaWdodDsKICAgICAgfQogICAgfQogIH07CiAgQXR0cmlidXRlQ29tcHJlc3Npb24uZGVxdWFudGl6ZSA9IGZ1bmN0aW9uKHR5cGVkQXJyYXksIGNvbXBvbmVudERhdGF0eXBlLCB0eXBlLCBjb3VudCkgewogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ0eXBlZEFycmF5IiwgdHlwZWRBcnJheSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImNvbXBvbmVudERhdGF0eXBlIiwgY29tcG9uZW50RGF0YXR5cGUpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJ0eXBlIiwgdHlwZSk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImNvdW50IiwgY291bnQpOwogICAgY29uc3QgY29tcG9uZW50c1BlckF0dHJpYnV0ZSA9IEF0dHJpYnV0ZVR5cGVfZGVmYXVsdC5nZXROdW1iZXJPZkNvbXBvbmVudHModHlwZSk7CiAgICBsZXQgZGl2aXNvcjsKICAgIHN3aXRjaCAoY29tcG9uZW50RGF0YXR5cGUpIHsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZV9kZWZhdWx0LkJZVEU6CiAgICAgICAgZGl2aXNvciA9IDEyNzsKICAgICAgICBicmVhazsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZV9kZWZhdWx0LlVOU0lHTkVEX0JZVEU6CiAgICAgICAgZGl2aXNvciA9IDI1NTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZV9kZWZhdWx0LlNIT1JUOgogICAgICAgIGRpdmlzb3IgPSAzMjc2NzsKICAgICAgICBicmVhazsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZV9kZWZhdWx0LlVOU0lHTkVEX1NIT1JUOgogICAgICAgIGRpdmlzb3IgPSA2NTUzNTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZV9kZWZhdWx0LklOVDoKICAgICAgICBkaXZpc29yID0gMjE0NzQ4MzY0NzsKICAgICAgICBicmVhazsKICAgICAgY2FzZSBDb21wb25lbnREYXRhdHlwZV9kZWZhdWx0LlVOU0lHTkVEX0lOVDoKICAgICAgICBkaXZpc29yID0gNDI5NDk2NzI5NTsKICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAgIGBDYW5ub3QgZGVxdWFudGl6ZSBjb21wb25lbnQgZGF0YXR5cGU6ICR7Y29tcG9uZW50RGF0YXR5cGV9YAogICAgICAgICk7CiAgICB9CiAgICBjb25zdCBkZXF1YW50aXplZFR5cGVkQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KAogICAgICBjb3VudCAqIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGUKICAgICk7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHsKICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb21wb25lbnRzUGVyQXR0cmlidXRlOyBqKyspIHsKICAgICAgICBjb25zdCBpbmRleCA9IGkgKiBjb21wb25lbnRzUGVyQXR0cmlidXRlICsgajsKICAgICAgICBkZXF1YW50aXplZFR5cGVkQXJyYXlbaW5kZXhdID0gTWF0aC5tYXgoCiAgICAgICAgICB0eXBlZEFycmF5W2luZGV4XSAvIGRpdmlzb3IsCiAgICAgICAgICAtMQogICAgICAgICk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBkZXF1YW50aXplZFR5cGVkQXJyYXk7CiAgfTsKICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5kZWNvZGVSR0I1NjUgPSBmdW5jdGlvbih0eXBlZEFycmF5LCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgidHlwZWRBcnJheSIsIHR5cGVkQXJyYXkpOwogICAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSB0eXBlZEFycmF5Lmxlbmd0aCAqIDM7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyLmVxdWFscygKICAgICAgICAicmVzdWx0Lmxlbmd0aCIsCiAgICAgICAgInR5cGVkQXJyYXkubGVuZ3RoICogMyIsCiAgICAgICAgcmVzdWx0Lmxlbmd0aCwKICAgICAgICBleHBlY3RlZExlbmd0aAogICAgICApOwogICAgfQogICAgY29uc3QgY291bnQgPSB0eXBlZEFycmF5Lmxlbmd0aDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIDMpOwogICAgfQogICAgY29uc3QgbWFzazUgPSAoMSA8PCA1KSAtIDE7CiAgICBjb25zdCBtYXNrNiA9ICgxIDw8IDYpIC0gMTsKICAgIGNvbnN0IG5vcm1hbGl6ZTUgPSAxIC8gMzE7CiAgICBjb25zdCBub3JtYWxpemU2ID0gMSAvIDYzOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7CiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZWRBcnJheVtpXTsKICAgICAgY29uc3QgcmVkID0gdmFsdWUgPj4gMTE7CiAgICAgIGNvbnN0IGdyZWVuID0gdmFsdWUgPj4gNSAmIG1hc2s2OwogICAgICBjb25zdCBibHVlID0gdmFsdWUgJiBtYXNrNTsKICAgICAgY29uc3Qgb2Zmc2V0ID0gMyAqIGk7CiAgICAgIHJlc3VsdFtvZmZzZXRdID0gcmVkICogbm9ybWFsaXplNTsKICAgICAgcmVzdWx0W29mZnNldCArIDFdID0gZ3JlZW4gKiBub3JtYWxpemU2OwogICAgICByZXN1bHRbb2Zmc2V0ICsgMl0gPSBibHVlICogbm9ybWFsaXplNTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgQXR0cmlidXRlQ29tcHJlc3Npb25fZGVmYXVsdCA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvV2ViTWVyY2F0b3JQcm9qZWN0aW9uLmpzCiAgZnVuY3Rpb24gV2ViTWVyY2F0b3JQcm9qZWN0aW9uKGVsbGlwc29pZCkgewogICAgdGhpcy5fZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoZWxsaXBzb2lkLCBFbGxpcHNvaWRfZGVmYXVsdC5XR1M4NCk7CiAgICB0aGlzLl9zZW1pbWFqb3JBeGlzID0gdGhpcy5fZWxsaXBzb2lkLm1heGltdW1SYWRpdXM7CiAgICB0aGlzLl9vbmVPdmVyU2VtaW1ham9yQXhpcyA9IDEgLyB0aGlzLl9zZW1pbWFqb3JBeGlzOwogIH0KICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJNZXJjYXRvclByb2plY3Rpb24ucHJvdG90eXBlLCB7CiAgICBlbGxpcHNvaWQ6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fZWxsaXBzb2lkOwogICAgICB9CiAgICB9CiAgfSk7CiAgV2ViTWVyY2F0b3JQcm9qZWN0aW9uLm1lcmNhdG9yQW5nbGVUb0dlb2RldGljTGF0aXR1ZGUgPSBmdW5jdGlvbihtZXJjYXRvckFuZ2xlKSB7CiAgICByZXR1cm4gTWF0aF9kZWZhdWx0LlBJX09WRVJfVFdPIC0gMiAqIE1hdGguYXRhbihNYXRoLmV4cCgtbWVyY2F0b3JBbmdsZSkpOwogIH07CiAgV2ViTWVyY2F0b3JQcm9qZWN0aW9uLmdlb2RldGljTGF0aXR1ZGVUb01lcmNhdG9yQW5nbGUgPSBmdW5jdGlvbihsYXRpdHVkZSkgewogICAgaWYgKGxhdGl0dWRlID4gV2ViTWVyY2F0b3JQcm9qZWN0aW9uLk1heGltdW1MYXRpdHVkZSkgewogICAgICBsYXRpdHVkZSA9IFdlYk1lcmNhdG9yUHJvamVjdGlvbi5NYXhpbXVtTGF0aXR1ZGU7CiAgICB9IGVsc2UgaWYgKGxhdGl0dWRlIDwgLVdlYk1lcmNhdG9yUHJvamVjdGlvbi5NYXhpbXVtTGF0aXR1ZGUpIHsKICAgICAgbGF0aXR1ZGUgPSAtV2ViTWVyY2F0b3JQcm9qZWN0aW9uLk1heGltdW1MYXRpdHVkZTsKICAgIH0KICAgIGNvbnN0IHNpbkxhdGl0dWRlID0gTWF0aC5zaW4obGF0aXR1ZGUpOwogICAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKCgxICsgc2luTGF0aXR1ZGUpIC8gKDEgLSBzaW5MYXRpdHVkZSkpOwogIH07CiAgV2ViTWVyY2F0b3JQcm9qZWN0aW9uLk1heGltdW1MYXRpdHVkZSA9IFdlYk1lcmNhdG9yUHJvamVjdGlvbi5tZXJjYXRvckFuZ2xlVG9HZW9kZXRpY0xhdGl0dWRlKAogICAgTWF0aC5QSQogICk7CiAgV2ViTWVyY2F0b3JQcm9qZWN0aW9uLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24oY2FydG9ncmFwaGljLCByZXN1bHQpIHsKICAgIGNvbnN0IHNlbWltYWpvckF4aXMgPSB0aGlzLl9zZW1pbWFqb3JBeGlzOwogICAgY29uc3QgeCA9IGNhcnRvZ3JhcGhpYy5sb25naXR1ZGUgKiBzZW1pbWFqb3JBeGlzOwogICAgY29uc3QgeSA9IFdlYk1lcmNhdG9yUHJvamVjdGlvbi5nZW9kZXRpY0xhdGl0dWRlVG9NZXJjYXRvckFuZ2xlKAogICAgICBjYXJ0b2dyYXBoaWMubGF0aXR1ZGUKICAgICkgKiBzZW1pbWFqb3JBeGlzOwogICAgY29uc3QgeiA9IGNhcnRvZ3JhcGhpYy5oZWlnaHQ7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KHgsIHksIHopOwogICAgfQogICAgcmVzdWx0LnggPSB4OwogICAgcmVzdWx0LnkgPSB5OwogICAgcmVzdWx0LnogPSB6OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFdlYk1lcmNhdG9yUHJvamVjdGlvbi5wcm90b3R5cGUudW5wcm9qZWN0ID0gZnVuY3Rpb24oY2FydGVzaWFuLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNhcnRlc2lhbikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImNhcnRlc2lhbiBpcyByZXF1aXJlZCIpOwogICAgfQogICAgY29uc3Qgb25lT3ZlckVhcnRoU2VtaW1ham9yQXhpcyA9IHRoaXMuX29uZU92ZXJTZW1pbWFqb3JBeGlzOwogICAgY29uc3QgbG9uZ2l0dWRlID0gY2FydGVzaWFuLnggKiBvbmVPdmVyRWFydGhTZW1pbWFqb3JBeGlzOwogICAgY29uc3QgbGF0aXR1ZGUgPSBXZWJNZXJjYXRvclByb2plY3Rpb24ubWVyY2F0b3JBbmdsZVRvR2VvZGV0aWNMYXRpdHVkZSgKICAgICAgY2FydGVzaWFuLnkgKiBvbmVPdmVyRWFydGhTZW1pbWFqb3JBeGlzCiAgICApOwogICAgY29uc3QgaGVpZ2h0ID0gY2FydGVzaWFuLno7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydG9ncmFwaGljX2RlZmF1bHQobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0KTsKICAgIH0KICAgIHJlc3VsdC5sb25naXR1ZGUgPSBsb25naXR1ZGU7CiAgICByZXN1bHQubGF0aXR1ZGUgPSBsYXRpdHVkZTsKICAgIHJlc3VsdC5oZWlnaHQgPSBoZWlnaHQ7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIFdlYk1lcmNhdG9yUHJvamVjdGlvbl9kZWZhdWx0ID0gV2ViTWVyY2F0b3JQcm9qZWN0aW9uOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ3JlZGl0LmpzCiAgdmFyIGltcG9ydF9kb21wdXJpZnkgPSBfX3RvRVNNKHJlcXVpcmVfcHVyaWZ5KCksIDEpOwogIHZhciBuZXh0Q3JlZGl0SWQgPSAwOwogIHZhciBjcmVkaXRUb0lkID0ge307CiAgZnVuY3Rpb24gQ3JlZGl0KGh0bWwsIHNob3dPblNjcmVlbikgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yuc3RyaW5nKCJodG1sIiwgaHRtbCk7CiAgICBsZXQgaWQ7CiAgICBjb25zdCBrZXkgPSBodG1sOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChjcmVkaXRUb0lkW2tleV0pKSB7CiAgICAgIGlkID0gY3JlZGl0VG9JZFtrZXldOwogICAgfSBlbHNlIHsKICAgICAgaWQgPSBuZXh0Q3JlZGl0SWQrKzsKICAgICAgY3JlZGl0VG9JZFtrZXldID0gaWQ7CiAgICB9CiAgICBzaG93T25TY3JlZW4gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChzaG93T25TY3JlZW4sIGZhbHNlKTsKICAgIHRoaXMuX2lkID0gaWQ7CiAgICB0aGlzLl9odG1sID0gaHRtbDsKICAgIHRoaXMuX3Nob3dPblNjcmVlbiA9IHNob3dPblNjcmVlbjsKICAgIHRoaXMuX2VsZW1lbnQgPSB2b2lkIDA7CiAgfQogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENyZWRpdC5wcm90b3R5cGUsIHsKICAgIGh0bWw6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5faHRtbDsKICAgICAgfQogICAgfSwKICAgIGlkOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2lkOwogICAgICB9CiAgICB9LAogICAgc2hvd09uU2NyZWVuOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dPblNjcmVlbjsKICAgICAgfSwKICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkgewogICAgICAgIHRoaXMuX3Nob3dPblNjcmVlbiA9IHZhbHVlOwogICAgICB9CiAgICB9LAogICAgZWxlbWVudDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRoaXMuX2VsZW1lbnQpKSB7CiAgICAgICAgICBjb25zdCBodG1sID0gaW1wb3J0X2RvbXB1cmlmeS5kZWZhdWx0LnNhbml0aXplKHRoaXMuX2h0bWwpOwogICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CiAgICAgICAgICBkaXYuX2NyZWRpdElkID0gdGhpcy5faWQ7CiAgICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9ICJpbmxpbmUiOwogICAgICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7CiAgICAgICAgICBjb25zdCBsaW5rcyA9IGRpdi5xdWVyeVNlbGVjdG9yQWxsKCJhIik7CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGxpbmtzW2ldLnNldEF0dHJpYnV0ZSgidGFyZ2V0IiwgIl9ibGFuayIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZWxlbWVudCA9IGRpdjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7CiAgICAgIH0KICAgIH0KICB9KTsKICBDcmVkaXQuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsKICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCBkZWZpbmVkX2RlZmF1bHQobGVmdCkgJiYgZGVmaW5lZF9kZWZhdWx0KHJpZ2h0KSAmJiBsZWZ0Ll9pZCA9PT0gcmlnaHQuX2lkICYmIGxlZnQuX3Nob3dPblNjcmVlbiA9PT0gcmlnaHQuX3Nob3dPblNjcmVlbjsKICB9OwogIENyZWRpdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oY3JlZGl0KSB7CiAgICByZXR1cm4gQ3JlZGl0LmVxdWFscyh0aGlzLCBjcmVkaXQpOwogIH07CiAgQ3JlZGl0LmdldElvbkNyZWRpdCA9IGZ1bmN0aW9uKGF0dHJpYnV0aW9uKSB7CiAgICBjb25zdCBzaG93T25TY3JlZW4gPSBkZWZpbmVkX2RlZmF1bHQoYXR0cmlidXRpb24uY29sbGFwc2libGUpICYmICFhdHRyaWJ1dGlvbi5jb2xsYXBzaWJsZTsKICAgIGNvbnN0IGNyZWRpdCA9IG5ldyBDcmVkaXQoYXR0cmlidXRpb24uaHRtbCwgc2hvd09uU2NyZWVuKTsKICAgIGNyZWRpdC5faXNJb24gPSBjcmVkaXQuaHRtbC5pbmRleE9mKCJpb24tY3JlZGl0LnBuZyIpICE9PSAtMTsKICAgIHJldHVybiBjcmVkaXQ7CiAgfTsKICBDcmVkaXQuY2xvbmUgPSBmdW5jdGlvbihjcmVkaXQpIHsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoY3JlZGl0KSkgewogICAgICByZXR1cm4gbmV3IENyZWRpdChjcmVkaXQuaHRtbCwgY3JlZGl0LnNob3dPblNjcmVlbik7CiAgICB9CiAgfTsKICB2YXIgQ3JlZGl0X2RlZmF1bHQgPSBDcmVkaXQ7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9nZXRTdHJpbmdGcm9tVHlwZWRBcnJheS5qcwogIGZ1bmN0aW9uIGdldFN0cmluZ0Zyb21UeXBlZEFycmF5KHVpbnQ4QXJyYXksIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHVpbnQ4QXJyYXkpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ1aW50OEFycmF5IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJieXRlT2Zmc2V0IGNhbm5vdCBiZSBuZWdhdGl2ZS4iKTsKICAgIH0KICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiYnl0ZUxlbmd0aCBjYW5ub3QgYmUgbmVnYXRpdmUuIik7CiAgICB9CiAgICBpZiAoYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGggPiB1aW50OEFycmF5LmJ5dGVMZW5ndGgpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInN1Yi1yZWdpb24gZXhjZWVkcyBhcnJheSBib3VuZHMuIik7CiAgICB9CiAgICBieXRlT2Zmc2V0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoYnl0ZU9mZnNldCwgMCk7CiAgICBieXRlTGVuZ3RoID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoYnl0ZUxlbmd0aCwgdWludDhBcnJheS5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldCk7CiAgICB1aW50OEFycmF5ID0gdWludDhBcnJheS5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7CiAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVR5cGVkQXJyYXkuZGVjb2RlKHVpbnQ4QXJyYXkpOwogIH0KICBnZXRTdHJpbmdGcm9tVHlwZWRBcnJheS5kZWNvZGVXaXRoVGV4dERlY29kZXIgPSBmdW5jdGlvbih2aWV3KSB7CiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCJ1dGYtOCIpOwogICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKHZpZXcpOwogIH07CiAgZ2V0U3RyaW5nRnJvbVR5cGVkQXJyYXkuZGVjb2RlV2l0aEZyb21DaGFyQ29kZSA9IGZ1bmN0aW9uKHZpZXcpIHsKICAgIGxldCByZXN1bHQgPSAiIjsKICAgIGNvbnN0IGNvZGVQb2ludHMgPSB1dGY4SGFuZGxlcih2aWV3KTsKICAgIGNvbnN0IGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICBsZXQgY3AgPSBjb2RlUG9pbnRzW2ldOwogICAgICBpZiAoY3AgPD0gNjU1MzUpIHsKICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY3AgLT0gNjU1MzY7CiAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNwID4+IDEwKSArIDU1Mjk2LCAoY3AgJiAxMDIzKSArIDU2MzIwKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIGZ1bmN0aW9uIGluUmFuZ2UoYTMsIG1pbiwgbWF4KSB7CiAgICByZXR1cm4gbWluIDw9IGEzICYmIGEzIDw9IG1heDsKICB9CiAgZnVuY3Rpb24gdXRmOEhhbmRsZXIodXRmQnl0ZXMpIHsKICAgIGxldCBjb2RlUG9pbnQgPSAwOwogICAgbGV0IGJ5dGVzU2VlbiA9IDA7CiAgICBsZXQgYnl0ZXNOZWVkZWQgPSAwOwogICAgbGV0IGxvd2VyQm91bmRhcnkgPSAxMjg7CiAgICBsZXQgdXBwZXJCb3VuZGFyeSA9IDE5MTsKICAgIGNvbnN0IGNvZGVQb2ludHMgPSBbXTsKICAgIGNvbnN0IGxlbmd0aCA9IHV0ZkJ5dGVzLmxlbmd0aDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgY29uc3QgY3VycmVudEJ5dGUgPSB1dGZCeXRlc1tpXTsKICAgICAgaWYgKGJ5dGVzTmVlZGVkID09PSAwKSB7CiAgICAgICAgaWYgKGluUmFuZ2UoY3VycmVudEJ5dGUsIDAsIDEyNykpIHsKICAgICAgICAgIGNvZGVQb2ludHMucHVzaChjdXJyZW50Qnl0ZSk7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGluUmFuZ2UoY3VycmVudEJ5dGUsIDE5NCwgMjIzKSkgewogICAgICAgICAgYnl0ZXNOZWVkZWQgPSAxOwogICAgICAgICAgY29kZVBvaW50ID0gY3VycmVudEJ5dGUgJiAzMTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBpZiAoaW5SYW5nZShjdXJyZW50Qnl0ZSwgMjI0LCAyMzkpKSB7CiAgICAgICAgICBpZiAoY3VycmVudEJ5dGUgPT09IDIyNCkgewogICAgICAgICAgICBsb3dlckJvdW5kYXJ5ID0gMTYwOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGN1cnJlbnRCeXRlID09PSAyMzcpIHsKICAgICAgICAgICAgdXBwZXJCb3VuZGFyeSA9IDE1OTsKICAgICAgICAgIH0KICAgICAgICAgIGJ5dGVzTmVlZGVkID0gMjsKICAgICAgICAgIGNvZGVQb2ludCA9IGN1cnJlbnRCeXRlICYgMTU7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGluUmFuZ2UoY3VycmVudEJ5dGUsIDI0MCwgMjQ0KSkgewogICAgICAgICAgaWYgKGN1cnJlbnRCeXRlID09PSAyNDApIHsKICAgICAgICAgICAgbG93ZXJCb3VuZGFyeSA9IDE0NDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjdXJyZW50Qnl0ZSA9PT0gMjQ0KSB7CiAgICAgICAgICAgIHVwcGVyQm91bmRhcnkgPSAxNDM7CiAgICAgICAgICB9CiAgICAgICAgICBieXRlc05lZWRlZCA9IDM7CiAgICAgICAgICBjb2RlUG9pbnQgPSBjdXJyZW50Qnl0ZSAmIDc7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KCJTdHJpbmcgZGVjb2RpbmcgZmFpbGVkLiIpOwogICAgICB9CiAgICAgIGlmICghaW5SYW5nZShjdXJyZW50Qnl0ZSwgbG93ZXJCb3VuZGFyeSwgdXBwZXJCb3VuZGFyeSkpIHsKICAgICAgICBjb2RlUG9pbnQgPSBieXRlc05lZWRlZCA9IGJ5dGVzU2VlbiA9IDA7CiAgICAgICAgbG93ZXJCb3VuZGFyeSA9IDEyODsKICAgICAgICB1cHBlckJvdW5kYXJ5ID0gMTkxOwogICAgICAgIC0taTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBsb3dlckJvdW5kYXJ5ID0gMTI4OwogICAgICB1cHBlckJvdW5kYXJ5ID0gMTkxOwogICAgICBjb2RlUG9pbnQgPSBjb2RlUG9pbnQgPDwgNiB8IGN1cnJlbnRCeXRlICYgNjM7CiAgICAgICsrYnl0ZXNTZWVuOwogICAgICBpZiAoYnl0ZXNTZWVuID09PSBieXRlc05lZWRlZCkgewogICAgICAgIGNvZGVQb2ludHMucHVzaChjb2RlUG9pbnQpOwogICAgICAgIGNvZGVQb2ludCA9IGJ5dGVzTmVlZGVkID0gYnl0ZXNTZWVuID0gMDsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGNvZGVQb2ludHM7CiAgfQogIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICJ1bmRlZmluZWQiKSB7CiAgICBnZXRTdHJpbmdGcm9tVHlwZWRBcnJheS5kZWNvZGUgPSBnZXRTdHJpbmdGcm9tVHlwZWRBcnJheS5kZWNvZGVXaXRoVGV4dERlY29kZXI7CiAgfSBlbHNlIHsKICAgIGdldFN0cmluZ0Zyb21UeXBlZEFycmF5LmRlY29kZSA9IGdldFN0cmluZ0Zyb21UeXBlZEFycmF5LmRlY29kZVdpdGhGcm9tQ2hhckNvZGU7CiAgfQogIHZhciBnZXRTdHJpbmdGcm9tVHlwZWRBcnJheV9kZWZhdWx0ID0gZ2V0U3RyaW5nRnJvbVR5cGVkQXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9nZXRKc29uRnJvbVR5cGVkQXJyYXkuanMKICBmdW5jdGlvbiBnZXRKc29uRnJvbVR5cGVkQXJyYXkodWludDhBcnJheSwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkgewogICAgcmV0dXJuIEpTT04ucGFyc2UoCiAgICAgIGdldFN0cmluZ0Zyb21UeXBlZEFycmF5X2RlZmF1bHQodWludDhBcnJheSwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkKICAgICk7CiAgfQogIHZhciBnZXRKc29uRnJvbVR5cGVkQXJyYXlfZGVmYXVsdCA9IGdldEpzb25Gcm9tVHlwZWRBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0VsbGlwc29pZGFsT2NjbHVkZXIuanMKICBmdW5jdGlvbiBFbGxpcHNvaWRhbE9jY2x1ZGVyKGVsbGlwc29pZCwgY2FtZXJhUG9zaXRpb24pIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgiZWxsaXBzb2lkIiwgZWxsaXBzb2lkKTsKICAgIHRoaXMuX2VsbGlwc29pZCA9IGVsbGlwc29pZDsKICAgIHRoaXMuX2NhbWVyYVBvc2l0aW9uID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogICAgdGhpcy5fY2FtZXJhUG9zaXRpb25JblNjYWxlZFNwYWNlID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogICAgdGhpcy5fZGlzdGFuY2VUb0xpbWJJblNjYWxlZFNwYWNlU3F1YXJlZCA9IDA7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KGNhbWVyYVBvc2l0aW9uKSkgewogICAgICB0aGlzLmNhbWVyYVBvc2l0aW9uID0gY2FtZXJhUG9zaXRpb247CiAgICB9CiAgfQogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsbGlwc29pZGFsT2NjbHVkZXIucHJvdG90eXBlLCB7CiAgICBlbGxpcHNvaWQ6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fZWxsaXBzb2lkOwogICAgICB9CiAgICB9LAogICAgY2FtZXJhUG9zaXRpb246IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fY2FtZXJhUG9zaXRpb247CiAgICAgIH0sCiAgICAgIHNldDogZnVuY3Rpb24oY2FtZXJhUG9zaXRpb24pIHsKICAgICAgICBjb25zdCBlbGxpcHNvaWQgPSB0aGlzLl9lbGxpcHNvaWQ7CiAgICAgICAgY29uc3QgY3YgPSBlbGxpcHNvaWQudHJhbnNmb3JtUG9zaXRpb25Ub1NjYWxlZFNwYWNlKAogICAgICAgICAgY2FtZXJhUG9zaXRpb24sCiAgICAgICAgICB0aGlzLl9jYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2UKICAgICAgICApOwogICAgICAgIGNvbnN0IHZoTWFnbml0dWRlU3F1YXJlZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKGN2KSAtIDE7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0LmNsb25lKGNhbWVyYVBvc2l0aW9uLCB0aGlzLl9jYW1lcmFQb3NpdGlvbik7CiAgICAgICAgdGhpcy5fY2FtZXJhUG9zaXRpb25JblNjYWxlZFNwYWNlID0gY3Y7CiAgICAgICAgdGhpcy5fZGlzdGFuY2VUb0xpbWJJblNjYWxlZFNwYWNlU3F1YXJlZCA9IHZoTWFnbml0dWRlU3F1YXJlZDsKICAgICAgfQogICAgfQogIH0pOwogIHZhciBzY3JhdGNoQ2FydGVzaWFuNyA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBFbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5pc1BvaW50VmlzaWJsZSA9IGZ1bmN0aW9uKG9jY2x1ZGVlKSB7CiAgICBjb25zdCBlbGxpcHNvaWQgPSB0aGlzLl9lbGxpcHNvaWQ7CiAgICBjb25zdCBvY2NsdWRlZVNjYWxlZFNwYWNlUG9zaXRpb24gPSBlbGxpcHNvaWQudHJhbnNmb3JtUG9zaXRpb25Ub1NjYWxlZFNwYWNlKAogICAgICBvY2NsdWRlZSwKICAgICAgc2NyYXRjaENhcnRlc2lhbjcKICAgICk7CiAgICByZXR1cm4gaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZSgKICAgICAgb2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uLAogICAgICB0aGlzLl9jYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2UsCiAgICAgIHRoaXMuX2Rpc3RhbmNlVG9MaW1iSW5TY2FsZWRTcGFjZVNxdWFyZWQKICAgICk7CiAgfTsKICBFbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5pc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlID0gZnVuY3Rpb24ob2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uKSB7CiAgICByZXR1cm4gaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZSgKICAgICAgb2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uLAogICAgICB0aGlzLl9jYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2UsCiAgICAgIHRoaXMuX2Rpc3RhbmNlVG9MaW1iSW5TY2FsZWRTcGFjZVNxdWFyZWQKICAgICk7CiAgfTsKICB2YXIgc2NyYXRjaENhbWVyYVBvc2l0aW9uSW5TY2FsZWRTcGFjZVNocnVuayA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBFbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5pc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlUG9zc2libHlVbmRlckVsbGlwc29pZCA9IGZ1bmN0aW9uKG9jY2x1ZGVlU2NhbGVkU3BhY2VQb3NpdGlvbiwgbWluaW11bUhlaWdodCkgewogICAgY29uc3QgZWxsaXBzb2lkID0gdGhpcy5fZWxsaXBzb2lkOwogICAgbGV0IHZoTWFnbml0dWRlU3F1YXJlZDsKICAgIGxldCBjdjsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQobWluaW11bUhlaWdodCkgJiYgbWluaW11bUhlaWdodCA8IDAgJiYgZWxsaXBzb2lkLm1pbmltdW1SYWRpdXMgPiAtbWluaW11bUhlaWdodCkgewogICAgICBjdiA9IHNjcmF0Y2hDYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2VTaHJ1bms7CiAgICAgIGN2LnggPSB0aGlzLl9jYW1lcmFQb3NpdGlvbi54IC8gKGVsbGlwc29pZC5yYWRpaS54ICsgbWluaW11bUhlaWdodCk7CiAgICAgIGN2LnkgPSB0aGlzLl9jYW1lcmFQb3NpdGlvbi55IC8gKGVsbGlwc29pZC5yYWRpaS55ICsgbWluaW11bUhlaWdodCk7CiAgICAgIGN2LnogPSB0aGlzLl9jYW1lcmFQb3NpdGlvbi56IC8gKGVsbGlwc29pZC5yYWRpaS56ICsgbWluaW11bUhlaWdodCk7CiAgICAgIHZoTWFnbml0dWRlU3F1YXJlZCA9IGN2LnggKiBjdi54ICsgY3YueSAqIGN2LnkgKyBjdi56ICogY3YueiAtIDE7CiAgICB9IGVsc2UgewogICAgICBjdiA9IHRoaXMuX2NhbWVyYVBvc2l0aW9uSW5TY2FsZWRTcGFjZTsKICAgICAgdmhNYWduaXR1ZGVTcXVhcmVkID0gdGhpcy5fZGlzdGFuY2VUb0xpbWJJblNjYWxlZFNwYWNlU3F1YXJlZDsKICAgIH0KICAgIHJldHVybiBpc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlKAogICAgICBvY2NsdWRlZVNjYWxlZFNwYWNlUG9zaXRpb24sCiAgICAgIGN2LAogICAgICB2aE1hZ25pdHVkZVNxdWFyZWQKICAgICk7CiAgfTsKICBFbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5jb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludCA9IGZ1bmN0aW9uKGRpcmVjdGlvblRvUG9pbnQsIHBvc2l0aW9ucywgcmVzdWx0KSB7CiAgICByZXR1cm4gY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tUG9zaXRpb25zKAogICAgICB0aGlzLl9lbGxpcHNvaWQsCiAgICAgIGRpcmVjdGlvblRvUG9pbnQsCiAgICAgIHBvc2l0aW9ucywKICAgICAgcmVzdWx0CiAgICApOwogIH07CiAgdmFyIHNjcmF0Y2hFbGxpcHNvaWRTaHJ1bmsgPSBFbGxpcHNvaWRfZGVmYXVsdC5jbG9uZShFbGxpcHNvaWRfZGVmYXVsdC5VTklUX1NQSEVSRSk7CiAgRWxsaXBzb2lkYWxPY2NsdWRlci5wcm90b3R5cGUuY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRQb3NzaWJseVVuZGVyRWxsaXBzb2lkID0gZnVuY3Rpb24oZGlyZWN0aW9uVG9Qb2ludCwgcG9zaXRpb25zLCBtaW5pbXVtSGVpZ2h0LCByZXN1bHQpIHsKICAgIGNvbnN0IHBvc3NpYmx5U2hydW5rRWxsaXBzb2lkID0gZ2V0UG9zc2libHlTaHJ1bmtFbGxpcHNvaWQoCiAgICAgIHRoaXMuX2VsbGlwc29pZCwKICAgICAgbWluaW11bUhlaWdodCwKICAgICAgc2NyYXRjaEVsbGlwc29pZFNocnVuawogICAgKTsKICAgIHJldHVybiBjb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21Qb3NpdGlvbnMoCiAgICAgIHBvc3NpYmx5U2hydW5rRWxsaXBzb2lkLAogICAgICBkaXJlY3Rpb25Ub1BvaW50LAogICAgICBwb3NpdGlvbnMsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIEVsbGlwc29pZGFsT2NjbHVkZXIucHJvdG90eXBlLmNvbXB1dGVIb3Jpem9uQ3VsbGluZ1BvaW50RnJvbVZlcnRpY2VzID0gZnVuY3Rpb24oZGlyZWN0aW9uVG9Qb2ludCwgdmVydGljZXMsIHN0cmlkZSwgY2VudGVyLCByZXN1bHQpIHsKICAgIHJldHVybiBjb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21WZXJ0aWNlcygKICAgICAgdGhpcy5fZWxsaXBzb2lkLAogICAgICBkaXJlY3Rpb25Ub1BvaW50LAogICAgICB2ZXJ0aWNlcywKICAgICAgc3RyaWRlLAogICAgICBjZW50ZXIsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIEVsbGlwc29pZGFsT2NjbHVkZXIucHJvdG90eXBlLmNvbXB1dGVIb3Jpem9uQ3VsbGluZ1BvaW50RnJvbVZlcnRpY2VzUG9zc2libHlVbmRlckVsbGlwc29pZCA9IGZ1bmN0aW9uKGRpcmVjdGlvblRvUG9pbnQsIHZlcnRpY2VzLCBzdHJpZGUsIGNlbnRlciwgbWluaW11bUhlaWdodCwgcmVzdWx0KSB7CiAgICBjb25zdCBwb3NzaWJseVNocnVua0VsbGlwc29pZCA9IGdldFBvc3NpYmx5U2hydW5rRWxsaXBzb2lkKAogICAgICB0aGlzLl9lbGxpcHNvaWQsCiAgICAgIG1pbmltdW1IZWlnaHQsCiAgICAgIHNjcmF0Y2hFbGxpcHNvaWRTaHJ1bmsKICAgICk7CiAgICByZXR1cm4gY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tVmVydGljZXMoCiAgICAgIHBvc3NpYmx5U2hydW5rRWxsaXBzb2lkLAogICAgICBkaXJlY3Rpb25Ub1BvaW50LAogICAgICB2ZXJ0aWNlcywKICAgICAgc3RyaWRlLAogICAgICBjZW50ZXIsCiAgICAgIHJlc3VsdAogICAgKTsKICB9OwogIHZhciBzdWJzYW1wbGVTY3JhdGNoID0gW107CiAgRWxsaXBzb2lkYWxPY2NsdWRlci5wcm90b3R5cGUuY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tUmVjdGFuZ2xlID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCBlbGxpcHNvaWQsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJyZWN0YW5nbGUiLCByZWN0YW5nbGUpOwogICAgY29uc3QgcG9zaXRpb25zID0gUmVjdGFuZ2xlX2RlZmF1bHQuc3Vic2FtcGxlKAogICAgICByZWN0YW5nbGUsCiAgICAgIGVsbGlwc29pZCwKICAgICAgMCwKICAgICAgc3Vic2FtcGxlU2NyYXRjaAogICAgKTsKICAgIGNvbnN0IGJzID0gQm91bmRpbmdTcGhlcmVfZGVmYXVsdC5mcm9tUG9pbnRzKHBvc2l0aW9ucyk7CiAgICBpZiAoQ2FydGVzaWFuM19kZWZhdWx0Lm1hZ25pdHVkZShicy5jZW50ZXIpIDwgMC4xICogZWxsaXBzb2lkLm1pbmltdW1SYWRpdXMpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIHJldHVybiB0aGlzLmNvbXB1dGVIb3Jpem9uQ3VsbGluZ1BvaW50KGJzLmNlbnRlciwgcG9zaXRpb25zLCByZXN1bHQpOwogIH07CiAgdmFyIHNjcmF0Y2hFbGxpcHNvaWRTaHJ1bmtSYWRpaSA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBmdW5jdGlvbiBnZXRQb3NzaWJseVNocnVua0VsbGlwc29pZChlbGxpcHNvaWQsIG1pbmltdW1IZWlnaHQsIHJlc3VsdCkgewogICAgaWYgKGRlZmluZWRfZGVmYXVsdChtaW5pbXVtSGVpZ2h0KSAmJiBtaW5pbXVtSGVpZ2h0IDwgMCAmJiBlbGxpcHNvaWQubWluaW11bVJhZGl1cyA+IC1taW5pbXVtSGVpZ2h0KSB7CiAgICAgIGNvbnN0IGVsbGlwc29pZFNocnVua1JhZGlpID0gQ2FydGVzaWFuM19kZWZhdWx0LmZyb21FbGVtZW50cygKICAgICAgICBlbGxpcHNvaWQucmFkaWkueCArIG1pbmltdW1IZWlnaHQsCiAgICAgICAgZWxsaXBzb2lkLnJhZGlpLnkgKyBtaW5pbXVtSGVpZ2h0LAogICAgICAgIGVsbGlwc29pZC5yYWRpaS56ICsgbWluaW11bUhlaWdodCwKICAgICAgICBzY3JhdGNoRWxsaXBzb2lkU2hydW5rUmFkaWkKICAgICAgKTsKICAgICAgZWxsaXBzb2lkID0gRWxsaXBzb2lkX2RlZmF1bHQuZnJvbUNhcnRlc2lhbjMoZWxsaXBzb2lkU2hydW5rUmFkaWksIHJlc3VsdCk7CiAgICB9CiAgICByZXR1cm4gZWxsaXBzb2lkOwogIH0KICBmdW5jdGlvbiBjb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21Qb3NpdGlvbnMoZWxsaXBzb2lkLCBkaXJlY3Rpb25Ub1BvaW50LCBwb3NpdGlvbnMsIHJlc3VsdCkgewogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2Yub2JqZWN0KCJkaXJlY3Rpb25Ub1BvaW50IiwgZGlyZWN0aW9uVG9Qb2ludCk7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoInBvc2l0aW9ucyIsIHBvc2l0aW9ucyk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIGNvbnN0IHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCA9IGNvbXB1dGVTY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQoCiAgICAgIGVsbGlwc29pZCwKICAgICAgZGlyZWN0aW9uVG9Qb2ludAogICAgKTsKICAgIGxldCByZXN1bHRNYWduaXR1ZGUgPSAwOwogICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47ICsraSkgewogICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpXTsKICAgICAgY29uc3QgY2FuZGlkYXRlTWFnbml0dWRlID0gY29tcHV0ZU1hZ25pdHVkZSgKICAgICAgICBlbGxpcHNvaWQsCiAgICAgICAgcG9zaXRpb24sCiAgICAgICAgc2NhbGVkU3BhY2VEaXJlY3Rpb25Ub1BvaW50CiAgICAgICk7CiAgICAgIGlmIChjYW5kaWRhdGVNYWduaXR1ZGUgPCAwKSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICByZXN1bHRNYWduaXR1ZGUgPSBNYXRoLm1heChyZXN1bHRNYWduaXR1ZGUsIGNhbmRpZGF0ZU1hZ25pdHVkZSk7CiAgICB9CiAgICByZXR1cm4gbWFnbml0dWRlVG9Qb2ludChzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQsIHJlc3VsdE1hZ25pdHVkZSwgcmVzdWx0KTsKICB9CiAgdmFyIHBvc2l0aW9uU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBmdW5jdGlvbiBjb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21WZXJ0aWNlcyhlbGxpcHNvaWQsIGRpcmVjdGlvblRvUG9pbnQsIHZlcnRpY2VzLCBzdHJpZGUsIGNlbnRlciwgcmVzdWx0KSB7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoImRpcmVjdGlvblRvUG9pbnQiLCBkaXJlY3Rpb25Ub1BvaW50KTsKICAgIENoZWNrX2RlZmF1bHQuZGVmaW5lZCgidmVydGljZXMiLCB2ZXJ0aWNlcyk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoInN0cmlkZSIsIHN0cmlkZSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIHN0cmlkZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0cmlkZSwgMyk7CiAgICBjZW50ZXIgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChjZW50ZXIsIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPKTsKICAgIGNvbnN0IHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCA9IGNvbXB1dGVTY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQoCiAgICAgIGVsbGlwc29pZCwKICAgICAgZGlyZWN0aW9uVG9Qb2ludAogICAgKTsKICAgIGxldCByZXN1bHRNYWduaXR1ZGUgPSAwOwogICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSBzdHJpZGUpIHsKICAgICAgcG9zaXRpb25TY3JhdGNoLnggPSB2ZXJ0aWNlc1tpXSArIGNlbnRlci54OwogICAgICBwb3NpdGlvblNjcmF0Y2gueSA9IHZlcnRpY2VzW2kgKyAxXSArIGNlbnRlci55OwogICAgICBwb3NpdGlvblNjcmF0Y2gueiA9IHZlcnRpY2VzW2kgKyAyXSArIGNlbnRlci56OwogICAgICBjb25zdCBjYW5kaWRhdGVNYWduaXR1ZGUgPSBjb21wdXRlTWFnbml0dWRlKAogICAgICAgIGVsbGlwc29pZCwKICAgICAgICBwb3NpdGlvblNjcmF0Y2gsCiAgICAgICAgc2NhbGVkU3BhY2VEaXJlY3Rpb25Ub1BvaW50CiAgICAgICk7CiAgICAgIGlmIChjYW5kaWRhdGVNYWduaXR1ZGUgPCAwKSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICByZXN1bHRNYWduaXR1ZGUgPSBNYXRoLm1heChyZXN1bHRNYWduaXR1ZGUsIGNhbmRpZGF0ZU1hZ25pdHVkZSk7CiAgICB9CiAgICByZXR1cm4gbWFnbml0dWRlVG9Qb2ludChzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQsIHJlc3VsdE1hZ25pdHVkZSwgcmVzdWx0KTsKICB9CiAgZnVuY3Rpb24gaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZShvY2NsdWRlZVNjYWxlZFNwYWNlUG9zaXRpb24sIGNhbWVyYVBvc2l0aW9uSW5TY2FsZWRTcGFjZSwgZGlzdGFuY2VUb0xpbWJJblNjYWxlZFNwYWNlU3F1YXJlZCkgewogICAgY29uc3QgY3YgPSBjYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2U7CiAgICBjb25zdCB2aE1hZ25pdHVkZVNxdWFyZWQgPSBkaXN0YW5jZVRvTGltYkluU2NhbGVkU3BhY2VTcXVhcmVkOwogICAgY29uc3QgdnQgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoCiAgICAgIG9jY2x1ZGVlU2NhbGVkU3BhY2VQb3NpdGlvbiwKICAgICAgY3YsCiAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW43CiAgICApOwogICAgY29uc3QgdnREb3RWYyA9IC1DYXJ0ZXNpYW4zX2RlZmF1bHQuZG90KHZ0LCBjdik7CiAgICBjb25zdCBpc09jY2x1ZGVkID0gdmhNYWduaXR1ZGVTcXVhcmVkIDwgMCA/IHZ0RG90VmMgPiAwIDogdnREb3RWYyA+IHZoTWFnbml0dWRlU3F1YXJlZCAmJiB2dERvdFZjICogdnREb3RWYyAvIENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKHZ0KSA+IHZoTWFnbml0dWRlU3F1YXJlZDsKICAgIHJldHVybiAhaXNPY2NsdWRlZDsKICB9CiAgdmFyIHNjYWxlZFNwYWNlU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICB2YXIgZGlyZWN0aW9uU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICBmdW5jdGlvbiBjb21wdXRlTWFnbml0dWRlKGVsbGlwc29pZCwgcG9zaXRpb24sIHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCkgewogICAgY29uc3Qgc2NhbGVkU3BhY2VQb3NpdGlvbiA9IGVsbGlwc29pZC50cmFuc2Zvcm1Qb3NpdGlvblRvU2NhbGVkU3BhY2UoCiAgICAgIHBvc2l0aW9uLAogICAgICBzY2FsZWRTcGFjZVNjcmF0Y2gKICAgICk7CiAgICBsZXQgbWFnbml0dWRlU3F1YXJlZCA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGVTcXVhcmVkKHNjYWxlZFNwYWNlUG9zaXRpb24pOwogICAgbGV0IG1hZ25pdHVkZSA9IE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkKTsKICAgIGNvbnN0IGRpcmVjdGlvbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5kaXZpZGVCeVNjYWxhcigKICAgICAgc2NhbGVkU3BhY2VQb3NpdGlvbiwKICAgICAgbWFnbml0dWRlLAogICAgICBkaXJlY3Rpb25TY3JhdGNoCiAgICApOwogICAgbWFnbml0dWRlU3F1YXJlZCA9IE1hdGgubWF4KDEsIG1hZ25pdHVkZVNxdWFyZWQpOwogICAgbWFnbml0dWRlID0gTWF0aC5tYXgoMSwgbWFnbml0dWRlKTsKICAgIGNvbnN0IGNvc0FscGhhID0gQ2FydGVzaWFuM19kZWZhdWx0LmRvdChkaXJlY3Rpb24sIHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCk7CiAgICBjb25zdCBzaW5BbHBoYSA9IENhcnRlc2lhbjNfZGVmYXVsdC5tYWduaXR1ZGUoCiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jcm9zcyhkaXJlY3Rpb24sIHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCwgZGlyZWN0aW9uKQogICAgKTsKICAgIGNvbnN0IGNvc0JldGEgPSAxIC8gbWFnbml0dWRlOwogICAgY29uc3Qgc2luQmV0YSA9IE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkIC0gMSkgKiBjb3NCZXRhOwogICAgcmV0dXJuIDEgLyAoY29zQWxwaGEgKiBjb3NCZXRhIC0gc2luQWxwaGEgKiBzaW5CZXRhKTsKICB9CiAgZnVuY3Rpb24gbWFnbml0dWRlVG9Qb2ludChzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQsIHJlc3VsdE1hZ25pdHVkZSwgcmVzdWx0KSB7CiAgICBpZiAocmVzdWx0TWFnbml0dWRlIDw9IDAgfHwgcmVzdWx0TWFnbml0dWRlID09PSAxIC8gMCB8fCByZXN1bHRNYWduaXR1ZGUgIT09IHJlc3VsdE1hZ25pdHVkZSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5tdWx0aXBseUJ5U2NhbGFyKAogICAgICBzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQsCiAgICAgIHJlc3VsdE1hZ25pdHVkZSwKICAgICAgcmVzdWx0CiAgICApOwogIH0KICB2YXIgZGlyZWN0aW9uVG9Qb2ludFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgZnVuY3Rpb24gY29tcHV0ZVNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludChlbGxpcHNvaWQsIGRpcmVjdGlvblRvUG9pbnQpIHsKICAgIGlmIChDYXJ0ZXNpYW4zX2RlZmF1bHQuZXF1YWxzKGRpcmVjdGlvblRvUG9pbnQsIENhcnRlc2lhbjNfZGVmYXVsdC5aRVJPKSkgewogICAgICByZXR1cm4gZGlyZWN0aW9uVG9Qb2ludDsKICAgIH0KICAgIGVsbGlwc29pZC50cmFuc2Zvcm1Qb3NpdGlvblRvU2NhbGVkU3BhY2UoCiAgICAgIGRpcmVjdGlvblRvUG9pbnQsCiAgICAgIGRpcmVjdGlvblRvUG9pbnRTY3JhdGNoCiAgICApOwogICAgcmV0dXJuIENhcnRlc2lhbjNfZGVmYXVsdC5ub3JtYWxpemUoZGlyZWN0aW9uVG9Qb2ludFNjcmF0Y2gsIGRpcmVjdGlvblRvUG9pbnRTY3JhdGNoKTsKICB9CiAgdmFyIEVsbGlwc29pZGFsT2NjbHVkZXJfZGVmYXVsdCA9IEVsbGlwc29pZGFsT2NjbHVkZXI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9IZWlnaHRtYXBFbmNvZGluZy5qcwogIHZhciBIZWlnaHRtYXBFbmNvZGluZyA9IHsKICAgIE5PTkU6IDAsCiAgICBMRVJDOiAxCiAgfTsKICB2YXIgSGVpZ2h0bWFwRW5jb2RpbmdfZGVmYXVsdCA9IE9iamVjdC5mcmVlemUoSGVpZ2h0bWFwRW5jb2RpbmcpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGVycmFpblF1YW50aXphdGlvbi5qcwogIHZhciBUZXJyYWluUXVhbnRpemF0aW9uID0gewogICAgTk9ORTogMCwKICAgIEJJVFMxMjogMQogIH07CiAgdmFyIFRlcnJhaW5RdWFudGl6YXRpb25fZGVmYXVsdCA9IE9iamVjdC5mcmVlemUoVGVycmFpblF1YW50aXphdGlvbik7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UZXJyYWluRW5jb2RpbmcuanMKICB2YXIgY2FydGVzaWFuM1NjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIGNhcnRlc2lhbjNEaW1TY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIHZhciBjYXJ0ZXNpYW4yU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICB2YXIgbWF0cml4NFNjcmF0Y2ggPSBuZXcgTWF0cml4NF9kZWZhdWx0KCk7CiAgdmFyIG1hdHJpeDRTY3JhdGNoMiA9IG5ldyBNYXRyaXg0X2RlZmF1bHQoKTsKICB2YXIgU0hJRlRfTEVGVF8xMiA9IE1hdGgucG93KDIsIDEyKTsKICBmdW5jdGlvbiBUZXJyYWluRW5jb2RpbmcoY2VudGVyLCBheGlzQWxpZ25lZEJvdW5kaW5nQm94LCBtaW5pbXVtSGVpZ2h0LCBtYXhpbXVtSGVpZ2h0LCBmcm9tRU5VLCBoYXNWZXJ0ZXhOb3JtYWxzLCBoYXNXZWJNZXJjYXRvclQsIGhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMsIGV4YWdnZXJhdGlvbiwgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQpIHsKICAgIGxldCBxdWFudGl6YXRpb24gPSBUZXJyYWluUXVhbnRpemF0aW9uX2RlZmF1bHQuTk9ORTsKICAgIGxldCB0b0VOVTsKICAgIGxldCBtYXRyaXg7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KGF4aXNBbGlnbmVkQm91bmRpbmdCb3gpICYmIGRlZmluZWRfZGVmYXVsdChtaW5pbXVtSGVpZ2h0KSAmJiBkZWZpbmVkX2RlZmF1bHQobWF4aW11bUhlaWdodCkgJiYgZGVmaW5lZF9kZWZhdWx0KGZyb21FTlUpKSB7CiAgICAgIGNvbnN0IG1pbmltdW0gPSBheGlzQWxpZ25lZEJvdW5kaW5nQm94Lm1pbmltdW07CiAgICAgIGNvbnN0IG1heGltdW0gPSBheGlzQWxpZ25lZEJvdW5kaW5nQm94Lm1heGltdW07CiAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuc3VidHJhY3QoCiAgICAgICAgbWF4aW11bSwKICAgICAgICBtaW5pbXVtLAogICAgICAgIGNhcnRlc2lhbjNEaW1TY3JhdGNoCiAgICAgICk7CiAgICAgIGNvbnN0IGhEaW0gPSBtYXhpbXVtSGVpZ2h0IC0gbWluaW11bUhlaWdodDsKICAgICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgoQ2FydGVzaWFuM19kZWZhdWx0Lm1heGltdW1Db21wb25lbnQoZGltZW5zaW9ucyksIGhEaW0pOwogICAgICBpZiAobWF4RGltIDwgU0hJRlRfTEVGVF8xMiAtIDEpIHsKICAgICAgICBxdWFudGl6YXRpb24gPSBUZXJyYWluUXVhbnRpemF0aW9uX2RlZmF1bHQuQklUUzEyOwogICAgICB9IGVsc2UgewogICAgICAgIHF1YW50aXphdGlvbiA9IFRlcnJhaW5RdWFudGl6YXRpb25fZGVmYXVsdC5OT05FOwogICAgICB9CiAgICAgIHRvRU5VID0gTWF0cml4NF9kZWZhdWx0LmludmVyc2VUcmFuc2Zvcm1hdGlvbihmcm9tRU5VLCBuZXcgTWF0cml4NF9kZWZhdWx0KCkpOwogICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IENhcnRlc2lhbjNfZGVmYXVsdC5uZWdhdGUobWluaW11bSwgY2FydGVzaWFuM1NjcmF0Y2gpOwogICAgICBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHkoCiAgICAgICAgTWF0cml4NF9kZWZhdWx0LmZyb21UcmFuc2xhdGlvbih0cmFuc2xhdGlvbiwgbWF0cml4NFNjcmF0Y2gpLAogICAgICAgIHRvRU5VLAogICAgICAgIHRvRU5VCiAgICAgICk7CiAgICAgIGNvbnN0IHNjYWxlID0gY2FydGVzaWFuM1NjcmF0Y2g7CiAgICAgIHNjYWxlLnggPSAxIC8gZGltZW5zaW9ucy54OwogICAgICBzY2FsZS55ID0gMSAvIGRpbWVuc2lvbnMueTsKICAgICAgc2NhbGUueiA9IDEgLyBkaW1lbnNpb25zLno7CiAgICAgIE1hdHJpeDRfZGVmYXVsdC5tdWx0aXBseShNYXRyaXg0X2RlZmF1bHQuZnJvbVNjYWxlKHNjYWxlLCBtYXRyaXg0U2NyYXRjaCksIHRvRU5VLCB0b0VOVSk7CiAgICAgIG1hdHJpeCA9IE1hdHJpeDRfZGVmYXVsdC5jbG9uZShmcm9tRU5VKTsKICAgICAgTWF0cml4NF9kZWZhdWx0LnNldFRyYW5zbGF0aW9uKG1hdHJpeCwgQ2FydGVzaWFuM19kZWZhdWx0LlpFUk8sIG1hdHJpeCk7CiAgICAgIGZyb21FTlUgPSBNYXRyaXg0X2RlZmF1bHQuY2xvbmUoZnJvbUVOVSwgbmV3IE1hdHJpeDRfZGVmYXVsdCgpKTsKICAgICAgY29uc3QgdHJhbnNsYXRpb25NYXRyaXggPSBNYXRyaXg0X2RlZmF1bHQuZnJvbVRyYW5zbGF0aW9uKG1pbmltdW0sIG1hdHJpeDRTY3JhdGNoKTsKICAgICAgY29uc3Qgc2NhbGVNYXRyaXggPSBNYXRyaXg0X2RlZmF1bHQuZnJvbVNjYWxlKGRpbWVuc2lvbnMsIG1hdHJpeDRTY3JhdGNoMik7CiAgICAgIGNvbnN0IHN0ID0gTWF0cml4NF9kZWZhdWx0Lm11bHRpcGx5KHRyYW5zbGF0aW9uTWF0cml4LCBzY2FsZU1hdHJpeCwgbWF0cml4NFNjcmF0Y2gpOwogICAgICBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHkoZnJvbUVOVSwgc3QsIGZyb21FTlUpOwogICAgICBNYXRyaXg0X2RlZmF1bHQubXVsdGlwbHkobWF0cml4LCBzdCwgbWF0cml4KTsKICAgIH0KICAgIHRoaXMucXVhbnRpemF0aW9uID0gcXVhbnRpemF0aW9uOwogICAgdGhpcy5taW5pbXVtSGVpZ2h0ID0gbWluaW11bUhlaWdodDsKICAgIHRoaXMubWF4aW11bUhlaWdodCA9IG1heGltdW1IZWlnaHQ7CiAgICB0aGlzLmNlbnRlciA9IENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShjZW50ZXIpOwogICAgdGhpcy50b1NjYWxlZEVOVSA9IHRvRU5VOwogICAgdGhpcy5mcm9tU2NhbGVkRU5VID0gZnJvbUVOVTsKICAgIHRoaXMubWF0cml4ID0gbWF0cml4OwogICAgdGhpcy5oYXNWZXJ0ZXhOb3JtYWxzID0gaGFzVmVydGV4Tm9ybWFsczsKICAgIHRoaXMuaGFzV2ViTWVyY2F0b3JUID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoaGFzV2ViTWVyY2F0b3JULCBmYWxzZSk7CiAgICB0aGlzLmhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscywKICAgICAgZmFsc2UKICAgICk7CiAgICB0aGlzLmV4YWdnZXJhdGlvbiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KGV4YWdnZXJhdGlvbiwgMSk7CiAgICB0aGlzLmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIGV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0LAogICAgICAwCiAgICApOwogICAgdGhpcy5zdHJpZGUgPSAwOwogICAgdGhpcy5fb2Zmc2V0R2VvZGV0aWNTdXJmYWNlTm9ybWFsID0gMDsKICAgIHRoaXMuX29mZnNldFZlcnRleE5vcm1hbCA9IDA7CiAgICB0aGlzLl9jYWxjdWxhdGVTdHJpZGVBbmRPZmZzZXRzKCk7CiAgfQogIFRlcnJhaW5FbmNvZGluZy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24odmVydGV4QnVmZmVyLCBidWZmZXJJbmRleCwgcG9zaXRpb24sIHV2LCBoZWlnaHQsIG5vcm1hbFRvUGFjaywgd2ViTWVyY2F0b3JULCBnZW9kZXRpY1N1cmZhY2VOb3JtYWwpIHsKICAgIGNvbnN0IHUyID0gdXYueDsKICAgIGNvbnN0IHYyID0gdXYueTsKICAgIGlmICh0aGlzLnF1YW50aXphdGlvbiA9PT0gVGVycmFpblF1YW50aXphdGlvbl9kZWZhdWx0LkJJVFMxMikgewogICAgICBwb3NpdGlvbiA9IE1hdHJpeDRfZGVmYXVsdC5tdWx0aXBseUJ5UG9pbnQoCiAgICAgICAgdGhpcy50b1NjYWxlZEVOVSwKICAgICAgICBwb3NpdGlvbiwKICAgICAgICBjYXJ0ZXNpYW4zU2NyYXRjaAogICAgICApOwogICAgICBwb3NpdGlvbi54ID0gTWF0aF9kZWZhdWx0LmNsYW1wKHBvc2l0aW9uLngsIDAsIDEpOwogICAgICBwb3NpdGlvbi55ID0gTWF0aF9kZWZhdWx0LmNsYW1wKHBvc2l0aW9uLnksIDAsIDEpOwogICAgICBwb3NpdGlvbi56ID0gTWF0aF9kZWZhdWx0LmNsYW1wKHBvc2l0aW9uLnosIDAsIDEpOwogICAgICBjb25zdCBoRGltID0gdGhpcy5tYXhpbXVtSGVpZ2h0IC0gdGhpcy5taW5pbXVtSGVpZ2h0OwogICAgICBjb25zdCBoID0gTWF0aF9kZWZhdWx0LmNsYW1wKChoZWlnaHQgLSB0aGlzLm1pbmltdW1IZWlnaHQpIC8gaERpbSwgMCwgMSk7CiAgICAgIENhcnRlc2lhbjJfZGVmYXVsdC5mcm9tRWxlbWVudHMocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgY2FydGVzaWFuMlNjcmF0Y2gpOwogICAgICBjb25zdCBjb21wcmVzc2VkMCA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uX2RlZmF1bHQuY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoCiAgICAgICAgY2FydGVzaWFuMlNjcmF0Y2gKICAgICAgKTsKICAgICAgQ2FydGVzaWFuMl9kZWZhdWx0LmZyb21FbGVtZW50cyhwb3NpdGlvbi56LCBoLCBjYXJ0ZXNpYW4yU2NyYXRjaCk7CiAgICAgIGNvbnN0IGNvbXByZXNzZWQxID0gQXR0cmlidXRlQ29tcHJlc3Npb25fZGVmYXVsdC5jb21wcmVzc1RleHR1cmVDb29yZGluYXRlcygKICAgICAgICBjYXJ0ZXNpYW4yU2NyYXRjaAogICAgICApOwogICAgICBDYXJ0ZXNpYW4yX2RlZmF1bHQuZnJvbUVsZW1lbnRzKHUyLCB2MiwgY2FydGVzaWFuMlNjcmF0Y2gpOwogICAgICBjb25zdCBjb21wcmVzc2VkMiA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uX2RlZmF1bHQuY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoCiAgICAgICAgY2FydGVzaWFuMlNjcmF0Y2gKICAgICAgKTsKICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gY29tcHJlc3NlZDA7CiAgICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IGNvbXByZXNzZWQxOwogICAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSBjb21wcmVzc2VkMjsKICAgICAgaWYgKHRoaXMuaGFzV2ViTWVyY2F0b3JUKSB7CiAgICAgICAgQ2FydGVzaWFuMl9kZWZhdWx0LmZyb21FbGVtZW50cyh3ZWJNZXJjYXRvclQsIDAsIGNhcnRlc2lhbjJTY3JhdGNoKTsKICAgICAgICBjb25zdCBjb21wcmVzc2VkMyA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uX2RlZmF1bHQuY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoCiAgICAgICAgICBjYXJ0ZXNpYW4yU2NyYXRjaAogICAgICAgICk7CiAgICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gY29tcHJlc3NlZDM7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5zdWJ0cmFjdChwb3NpdGlvbiwgdGhpcy5jZW50ZXIsIGNhcnRlc2lhbjNTY3JhdGNoKTsKICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gY2FydGVzaWFuM1NjcmF0Y2gueDsKICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gY2FydGVzaWFuM1NjcmF0Y2gueTsKICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gY2FydGVzaWFuM1NjcmF0Y2guejsKICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gaGVpZ2h0OwogICAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSB1MjsKICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gdjI7CiAgICAgIGlmICh0aGlzLmhhc1dlYk1lcmNhdG9yVCkgewogICAgICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IHdlYk1lcmNhdG9yVDsKICAgICAgfQogICAgfQogICAgaWYgKHRoaXMuaGFzVmVydGV4Tm9ybWFscykgewogICAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSBBdHRyaWJ1dGVDb21wcmVzc2lvbl9kZWZhdWx0Lm9jdFBhY2tGbG9hdCgKICAgICAgICBub3JtYWxUb1BhY2sKICAgICAgKTsKICAgIH0KICAgIGlmICh0aGlzLmhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMpIHsKICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLng7CiAgICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IGdlb2RldGljU3VyZmFjZU5vcm1hbC55OwogICAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSBnZW9kZXRpY1N1cmZhY2VOb3JtYWwuejsKICAgIH0KICAgIHJldHVybiBidWZmZXJJbmRleDsKICB9OwogIHZhciBzY3JhdGNoUG9zaXRpb24gPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIHNjcmF0Y2hHZW9kZXRpY1N1cmZhY2VOb3JtYWwgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5hZGRHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gZnVuY3Rpb24ob2xkQnVmZmVyLCBuZXdCdWZmZXIsIGVsbGlwc29pZCkgewogICAgaWYgKHRoaXMuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscykgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCBvbGRTdHJpZGUgPSB0aGlzLnN0cmlkZTsKICAgIGNvbnN0IHZlcnRleENvdW50ID0gb2xkQnVmZmVyLmxlbmd0aCAvIG9sZFN0cmlkZTsKICAgIHRoaXMuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscyA9IHRydWU7CiAgICB0aGlzLl9jYWxjdWxhdGVTdHJpZGVBbmRPZmZzZXRzKCk7CiAgICBjb25zdCBuZXdTdHJpZGUgPSB0aGlzLnN0cmlkZTsKICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2ZXJ0ZXhDb3VudDsgaW5kZXgrKykgewogICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBvbGRTdHJpZGU7IG9mZnNldCsrKSB7CiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSBpbmRleCAqIG9sZFN0cmlkZSArIG9mZnNldDsKICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICogbmV3U3RyaWRlICsgb2Zmc2V0OwogICAgICAgIG5ld0J1ZmZlcltuZXdJbmRleF0gPSBvbGRCdWZmZXJbb2xkSW5kZXhdOwogICAgICB9CiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5kZWNvZGVQb3NpdGlvbihuZXdCdWZmZXIsIGluZGV4LCBzY3JhdGNoUG9zaXRpb24pOwogICAgICBjb25zdCBnZW9kZXRpY1N1cmZhY2VOb3JtYWwgPSBlbGxpcHNvaWQuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKAogICAgICAgIHBvc2l0aW9uLAogICAgICAgIHNjcmF0Y2hHZW9kZXRpY1N1cmZhY2VOb3JtYWwKICAgICAgKTsKICAgICAgY29uc3QgYnVmZmVySW5kZXggPSBpbmRleCAqIG5ld1N0cmlkZSArIHRoaXMuX29mZnNldEdlb2RldGljU3VyZmFjZU5vcm1hbDsKICAgICAgbmV3QnVmZmVyW2J1ZmZlckluZGV4XSA9IGdlb2RldGljU3VyZmFjZU5vcm1hbC54OwogICAgICBuZXdCdWZmZXJbYnVmZmVySW5kZXggKyAxXSA9IGdlb2RldGljU3VyZmFjZU5vcm1hbC55OwogICAgICBuZXdCdWZmZXJbYnVmZmVySW5kZXggKyAyXSA9IGdlb2RldGljU3VyZmFjZU5vcm1hbC56OwogICAgfQogIH07CiAgVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5yZW1vdmVHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gZnVuY3Rpb24ob2xkQnVmZmVyLCBuZXdCdWZmZXIpIHsKICAgIGlmICghdGhpcy5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IG9sZFN0cmlkZSA9IHRoaXMuc3RyaWRlOwogICAgY29uc3QgdmVydGV4Q291bnQgPSBvbGRCdWZmZXIubGVuZ3RoIC8gb2xkU3RyaWRlOwogICAgdGhpcy5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gZmFsc2U7CiAgICB0aGlzLl9jYWxjdWxhdGVTdHJpZGVBbmRPZmZzZXRzKCk7CiAgICBjb25zdCBuZXdTdHJpZGUgPSB0aGlzLnN0cmlkZTsKICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2ZXJ0ZXhDb3VudDsgaW5kZXgrKykgewogICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuZXdTdHJpZGU7IG9mZnNldCsrKSB7CiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSBpbmRleCAqIG9sZFN0cmlkZSArIG9mZnNldDsKICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICogbmV3U3RyaWRlICsgb2Zmc2V0OwogICAgICAgIG5ld0J1ZmZlcltuZXdJbmRleF0gPSBvbGRCdWZmZXJbb2xkSW5kZXhdOwogICAgICB9CiAgICB9CiAgfTsKICBUZXJyYWluRW5jb2RpbmcucHJvdG90eXBlLmRlY29kZVBvc2l0aW9uID0gZnVuY3Rpb24oYnVmZmVyLCBpbmRleCwgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoKTsKICAgIH0KICAgIGluZGV4ICo9IHRoaXMuc3RyaWRlOwogICAgaWYgKHRoaXMucXVhbnRpemF0aW9uID09PSBUZXJyYWluUXVhbnRpemF0aW9uX2RlZmF1bHQuQklUUzEyKSB7CiAgICAgIGNvbnN0IHh5ID0gQXR0cmlidXRlQ29tcHJlc3Npb25fZGVmYXVsdC5kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzKAogICAgICAgIGJ1ZmZlcltpbmRleF0sCiAgICAgICAgY2FydGVzaWFuMlNjcmF0Y2gKICAgICAgKTsKICAgICAgcmVzdWx0LnggPSB4eS54OwogICAgICByZXN1bHQueSA9IHh5Lnk7CiAgICAgIGNvbnN0IHpoID0gQXR0cmlidXRlQ29tcHJlc3Npb25fZGVmYXVsdC5kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzKAogICAgICAgIGJ1ZmZlcltpbmRleCArIDFdLAogICAgICAgIGNhcnRlc2lhbjJTY3JhdGNoCiAgICAgICk7CiAgICAgIHJlc3VsdC56ID0gemgueDsKICAgICAgcmV0dXJuIE1hdHJpeDRfZGVmYXVsdC5tdWx0aXBseUJ5UG9pbnQodGhpcy5mcm9tU2NhbGVkRU5VLCByZXN1bHQsIHJlc3VsdCk7CiAgICB9CiAgICByZXN1bHQueCA9IGJ1ZmZlcltpbmRleF07CiAgICByZXN1bHQueSA9IGJ1ZmZlcltpbmRleCArIDFdOwogICAgcmVzdWx0LnogPSBidWZmZXJbaW5kZXggKyAyXTsKICAgIHJldHVybiBDYXJ0ZXNpYW4zX2RlZmF1bHQuYWRkKHJlc3VsdCwgdGhpcy5jZW50ZXIsIHJlc3VsdCk7CiAgfTsKICBUZXJyYWluRW5jb2RpbmcucHJvdG90eXBlLmdldEV4YWdnZXJhdGVkUG9zaXRpb24gPSBmdW5jdGlvbihidWZmZXIsIGluZGV4LCByZXN1bHQpIHsKICAgIHJlc3VsdCA9IHRoaXMuZGVjb2RlUG9zaXRpb24oYnVmZmVyLCBpbmRleCwgcmVzdWx0KTsKICAgIGNvbnN0IGV4YWdnZXJhdGlvbiA9IHRoaXMuZXhhZ2dlcmF0aW9uOwogICAgY29uc3QgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQgPSB0aGlzLmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0OwogICAgY29uc3QgaGFzRXhhZ2dlcmF0aW9uID0gZXhhZ2dlcmF0aW9uICE9PSAxOwogICAgaWYgKGhhc0V4YWdnZXJhdGlvbiAmJiB0aGlzLmhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMpIHsKICAgICAgY29uc3QgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsID0gdGhpcy5kZWNvZGVHZW9kZXRpY1N1cmZhY2VOb3JtYWwoCiAgICAgICAgYnVmZmVyLAogICAgICAgIGluZGV4LAogICAgICAgIHNjcmF0Y2hHZW9kZXRpY1N1cmZhY2VOb3JtYWwKICAgICAgKTsKICAgICAgY29uc3QgcmF3SGVpZ2h0ID0gdGhpcy5kZWNvZGVIZWlnaHQoYnVmZmVyLCBpbmRleCk7CiAgICAgIGNvbnN0IGhlaWdodERpZmZlcmVuY2UgPSBUZXJyYWluRXhhZ2dlcmF0aW9uX2RlZmF1bHQuZ2V0SGVpZ2h0KAogICAgICAgIHJhd0hlaWdodCwKICAgICAgICBleGFnZ2VyYXRpb24sCiAgICAgICAgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQKICAgICAgKSAtIHJhd0hlaWdodDsKICAgICAgcmVzdWx0LnggKz0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLnggKiBoZWlnaHREaWZmZXJlbmNlOwogICAgICByZXN1bHQueSArPSBnZW9kZXRpY1N1cmZhY2VOb3JtYWwueSAqIGhlaWdodERpZmZlcmVuY2U7CiAgICAgIHJlc3VsdC56ICs9IGdlb2RldGljU3VyZmFjZU5vcm1hbC56ICogaGVpZ2h0RGlmZmVyZW5jZTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBUZXJyYWluRW5jb2RpbmcucHJvdG90eXBlLmRlY29kZVRleHR1cmVDb29yZGluYXRlcyA9IGZ1bmN0aW9uKGJ1ZmZlciwgaW5kZXgsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KCk7CiAgICB9CiAgICBpbmRleCAqPSB0aGlzLnN0cmlkZTsKICAgIGlmICh0aGlzLnF1YW50aXphdGlvbiA9PT0gVGVycmFpblF1YW50aXphdGlvbl9kZWZhdWx0LkJJVFMxMikgewogICAgICByZXR1cm4gQXR0cmlidXRlQ29tcHJlc3Npb25fZGVmYXVsdC5kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzKAogICAgICAgIGJ1ZmZlcltpbmRleCArIDJdLAogICAgICAgIHJlc3VsdAogICAgICApOwogICAgfQogICAgcmV0dXJuIENhcnRlc2lhbjJfZGVmYXVsdC5mcm9tRWxlbWVudHMoYnVmZmVyW2luZGV4ICsgNF0sIGJ1ZmZlcltpbmRleCArIDVdLCByZXN1bHQpOwogIH07CiAgVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5kZWNvZGVIZWlnaHQgPSBmdW5jdGlvbihidWZmZXIsIGluZGV4KSB7CiAgICBpbmRleCAqPSB0aGlzLnN0cmlkZTsKICAgIGlmICh0aGlzLnF1YW50aXphdGlvbiA9PT0gVGVycmFpblF1YW50aXphdGlvbl9kZWZhdWx0LkJJVFMxMikgewogICAgICBjb25zdCB6aCA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uX2RlZmF1bHQuZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcygKICAgICAgICBidWZmZXJbaW5kZXggKyAxXSwKICAgICAgICBjYXJ0ZXNpYW4yU2NyYXRjaAogICAgICApOwogICAgICByZXR1cm4gemgueSAqICh0aGlzLm1heGltdW1IZWlnaHQgLSB0aGlzLm1pbmltdW1IZWlnaHQpICsgdGhpcy5taW5pbXVtSGVpZ2h0OwogICAgfQogICAgcmV0dXJuIGJ1ZmZlcltpbmRleCArIDNdOwogIH07CiAgVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5kZWNvZGVXZWJNZXJjYXRvclQgPSBmdW5jdGlvbihidWZmZXIsIGluZGV4KSB7CiAgICBpbmRleCAqPSB0aGlzLnN0cmlkZTsKICAgIGlmICh0aGlzLnF1YW50aXphdGlvbiA9PT0gVGVycmFpblF1YW50aXphdGlvbl9kZWZhdWx0LkJJVFMxMikgewogICAgICByZXR1cm4gQXR0cmlidXRlQ29tcHJlc3Npb25fZGVmYXVsdC5kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzKAogICAgICAgIGJ1ZmZlcltpbmRleCArIDNdLAogICAgICAgIGNhcnRlc2lhbjJTY3JhdGNoCiAgICAgICkueDsKICAgIH0KICAgIHJldHVybiBidWZmZXJbaW5kZXggKyA2XTsKICB9OwogIFRlcnJhaW5FbmNvZGluZy5wcm90b3R5cGUuZ2V0T2N0RW5jb2RlZE5vcm1hbCA9IGZ1bmN0aW9uKGJ1ZmZlciwgaW5kZXgsIHJlc3VsdCkgewogICAgaW5kZXggPSBpbmRleCAqIHRoaXMuc3RyaWRlICsgdGhpcy5fb2Zmc2V0VmVydGV4Tm9ybWFsOwogICAgY29uc3QgdGVtcCA9IGJ1ZmZlcltpbmRleF0gLyAyNTY7CiAgICBjb25zdCB4ID0gTWF0aC5mbG9vcih0ZW1wKTsKICAgIGNvbnN0IHkgPSAodGVtcCAtIHgpICogMjU2OwogICAgcmV0dXJuIENhcnRlc2lhbjJfZGVmYXVsdC5mcm9tRWxlbWVudHMoeCwgeSwgcmVzdWx0KTsKICB9OwogIFRlcnJhaW5FbmNvZGluZy5wcm90b3R5cGUuZGVjb2RlR2VvZGV0aWNTdXJmYWNlTm9ybWFsID0gZnVuY3Rpb24oYnVmZmVyLCBpbmRleCwgcmVzdWx0KSB7CiAgICBpbmRleCA9IGluZGV4ICogdGhpcy5zdHJpZGUgKyB0aGlzLl9vZmZzZXRHZW9kZXRpY1N1cmZhY2VOb3JtYWw7CiAgICByZXN1bHQueCA9IGJ1ZmZlcltpbmRleF07CiAgICByZXN1bHQueSA9IGJ1ZmZlcltpbmRleCArIDFdOwogICAgcmVzdWx0LnogPSBidWZmZXJbaW5kZXggKyAyXTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBUZXJyYWluRW5jb2RpbmcucHJvdG90eXBlLl9jYWxjdWxhdGVTdHJpZGVBbmRPZmZzZXRzID0gZnVuY3Rpb24oKSB7CiAgICBsZXQgdmVydGV4U3RyaWRlID0gMDsKICAgIHN3aXRjaCAodGhpcy5xdWFudGl6YXRpb24pIHsKICAgICAgY2FzZSBUZXJyYWluUXVhbnRpemF0aW9uX2RlZmF1bHQuQklUUzEyOgogICAgICAgIHZlcnRleFN0cmlkZSArPSAzOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OgogICAgICAgIHZlcnRleFN0cmlkZSArPSA2OwogICAgfQogICAgaWYgKHRoaXMuaGFzV2ViTWVyY2F0b3JUKSB7CiAgICAgIHZlcnRleFN0cmlkZSArPSAxOwogICAgfQogICAgaWYgKHRoaXMuaGFzVmVydGV4Tm9ybWFscykgewogICAgICB0aGlzLl9vZmZzZXRWZXJ0ZXhOb3JtYWwgPSB2ZXJ0ZXhTdHJpZGU7CiAgICAgIHZlcnRleFN0cmlkZSArPSAxOwogICAgfQogICAgaWYgKHRoaXMuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscykgewogICAgICB0aGlzLl9vZmZzZXRHZW9kZXRpY1N1cmZhY2VOb3JtYWwgPSB2ZXJ0ZXhTdHJpZGU7CiAgICAgIHZlcnRleFN0cmlkZSArPSAzOwogICAgfQogICAgdGhpcy5zdHJpZGUgPSB2ZXJ0ZXhTdHJpZGU7CiAgfTsKICB2YXIgYXR0cmlidXRlc0luZGljZXNOb25lID0gewogICAgcG9zaXRpb24zREFuZEhlaWdodDogMCwKICAgIHRleHR1cmVDb29yZEFuZEVuY29kZWROb3JtYWxzOiAxLAogICAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsOiAyCiAgfTsKICB2YXIgYXR0cmlidXRlc0luZGljZXNCaXRzMTIgPSB7CiAgICBjb21wcmVzc2VkMDogMCwKICAgIGNvbXByZXNzZWQxOiAxLAogICAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsOiAyCiAgfTsKICBUZXJyYWluRW5jb2RpbmcucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihidWZmZXIpIHsKICAgIGNvbnN0IGRhdGF0eXBlID0gQ29tcG9uZW50RGF0YXR5cGVfZGVmYXVsdC5GTE9BVDsKICAgIGNvbnN0IHNpemVJbkJ5dGVzID0gQ29tcG9uZW50RGF0YXR5cGVfZGVmYXVsdC5nZXRTaXplSW5CeXRlcyhkYXRhdHlwZSk7CiAgICBjb25zdCBzdHJpZGVJbkJ5dGVzID0gdGhpcy5zdHJpZGUgKiBzaXplSW5CeXRlczsKICAgIGxldCBvZmZzZXRJbkJ5dGVzID0gMDsKICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTsKICAgIGZ1bmN0aW9uIGFkZEF0dHJpYnV0ZShpbmRleCwgY29tcG9uZW50c1BlckF0dHJpYnV0ZSkgewogICAgICBhdHRyaWJ1dGVzLnB1c2goewogICAgICAgIGluZGV4LAogICAgICAgIHZlcnRleEJ1ZmZlcjogYnVmZmVyLAogICAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBkYXRhdHlwZSwKICAgICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlLAogICAgICAgIG9mZnNldEluQnl0ZXMsCiAgICAgICAgc3RyaWRlSW5CeXRlcwogICAgICB9KTsKICAgICAgb2Zmc2V0SW5CeXRlcyArPSBjb21wb25lbnRzUGVyQXR0cmlidXRlICogc2l6ZUluQnl0ZXM7CiAgICB9CiAgICBpZiAodGhpcy5xdWFudGl6YXRpb24gPT09IFRlcnJhaW5RdWFudGl6YXRpb25fZGVmYXVsdC5OT05FKSB7CiAgICAgIGFkZEF0dHJpYnV0ZShhdHRyaWJ1dGVzSW5kaWNlc05vbmUucG9zaXRpb24zREFuZEhlaWdodCwgNCk7CiAgICAgIGxldCBjb21wb25lbnRzVGV4Q29vcmRBbmROb3JtYWxzID0gMjsKICAgICAgY29tcG9uZW50c1RleENvb3JkQW5kTm9ybWFscyArPSB0aGlzLmhhc1dlYk1lcmNhdG9yVCA/IDEgOiAwOwogICAgICBjb21wb25lbnRzVGV4Q29vcmRBbmROb3JtYWxzICs9IHRoaXMuaGFzVmVydGV4Tm9ybWFscyA/IDEgOiAwOwogICAgICBhZGRBdHRyaWJ1dGUoCiAgICAgICAgYXR0cmlidXRlc0luZGljZXNOb25lLnRleHR1cmVDb29yZEFuZEVuY29kZWROb3JtYWxzLAogICAgICAgIGNvbXBvbmVudHNUZXhDb29yZEFuZE5vcm1hbHMKICAgICAgKTsKICAgICAgaWYgKHRoaXMuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscykgewogICAgICAgIGFkZEF0dHJpYnV0ZShhdHRyaWJ1dGVzSW5kaWNlc05vbmUuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLCAzKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgY29uc3QgdXNpbmdBdHRyaWJ1dGUwQ29tcG9uZW50NCA9IHRoaXMuaGFzV2ViTWVyY2F0b3JUIHx8IHRoaXMuaGFzVmVydGV4Tm9ybWFsczsKICAgICAgY29uc3QgdXNpbmdBdHRyaWJ1dGUxQ29tcG9uZW50MSA9IHRoaXMuaGFzV2ViTWVyY2F0b3JUICYmIHRoaXMuaGFzVmVydGV4Tm9ybWFsczsKICAgICAgYWRkQXR0cmlidXRlKAogICAgICAgIGF0dHJpYnV0ZXNJbmRpY2VzQml0czEyLmNvbXByZXNzZWQwLAogICAgICAgIHVzaW5nQXR0cmlidXRlMENvbXBvbmVudDQgPyA0IDogMwogICAgICApOwogICAgICBpZiAodXNpbmdBdHRyaWJ1dGUxQ29tcG9uZW50MSkgewogICAgICAgIGFkZEF0dHJpYnV0ZShhdHRyaWJ1dGVzSW5kaWNlc0JpdHMxMi5jb21wcmVzc2VkMSwgMSk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscykgewogICAgICAgIGFkZEF0dHJpYnV0ZShhdHRyaWJ1dGVzSW5kaWNlc0JpdHMxMi5nZW9kZXRpY1N1cmZhY2VOb3JtYWwsIDMpOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gYXR0cmlidXRlczsKICB9OwogIFRlcnJhaW5FbmNvZGluZy5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb25zID0gZnVuY3Rpb24oKSB7CiAgICBpZiAodGhpcy5xdWFudGl6YXRpb24gPT09IFRlcnJhaW5RdWFudGl6YXRpb25fZGVmYXVsdC5OT05FKSB7CiAgICAgIHJldHVybiBhdHRyaWJ1dGVzSW5kaWNlc05vbmU7CiAgICB9CiAgICByZXR1cm4gYXR0cmlidXRlc0luZGljZXNCaXRzMTI7CiAgfTsKICBUZXJyYWluRW5jb2RpbmcuY2xvbmUgPSBmdW5jdGlvbihlbmNvZGluZywgcmVzdWx0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChlbmNvZGluZykpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gbmV3IFRlcnJhaW5FbmNvZGluZygpOwogICAgfQogICAgcmVzdWx0LnF1YW50aXphdGlvbiA9IGVuY29kaW5nLnF1YW50aXphdGlvbjsKICAgIHJlc3VsdC5taW5pbXVtSGVpZ2h0ID0gZW5jb2RpbmcubWluaW11bUhlaWdodDsKICAgIHJlc3VsdC5tYXhpbXVtSGVpZ2h0ID0gZW5jb2RpbmcubWF4aW11bUhlaWdodDsKICAgIHJlc3VsdC5jZW50ZXIgPSBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUoZW5jb2RpbmcuY2VudGVyKTsKICAgIHJlc3VsdC50b1NjYWxlZEVOVSA9IE1hdHJpeDRfZGVmYXVsdC5jbG9uZShlbmNvZGluZy50b1NjYWxlZEVOVSk7CiAgICByZXN1bHQuZnJvbVNjYWxlZEVOVSA9IE1hdHJpeDRfZGVmYXVsdC5jbG9uZShlbmNvZGluZy5mcm9tU2NhbGVkRU5VKTsKICAgIHJlc3VsdC5tYXRyaXggPSBNYXRyaXg0X2RlZmF1bHQuY2xvbmUoZW5jb2RpbmcubWF0cml4KTsKICAgIHJlc3VsdC5oYXNWZXJ0ZXhOb3JtYWxzID0gZW5jb2RpbmcuaGFzVmVydGV4Tm9ybWFsczsKICAgIHJlc3VsdC5oYXNXZWJNZXJjYXRvclQgPSBlbmNvZGluZy5oYXNXZWJNZXJjYXRvclQ7CiAgICByZXN1bHQuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscyA9IGVuY29kaW5nLmhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHM7CiAgICByZXN1bHQuZXhhZ2dlcmF0aW9uID0gZW5jb2RpbmcuZXhhZ2dlcmF0aW9uOwogICAgcmVzdWx0LmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0ID0gZW5jb2RpbmcuZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQ7CiAgICByZXN1bHQuX2NhbGN1bGF0ZVN0cmlkZUFuZE9mZnNldHMoKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICB2YXIgVGVycmFpbkVuY29kaW5nX2RlZmF1bHQgPSBUZXJyYWluRW5jb2Rpbmc7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9IZWlnaHRtYXBUZXNzZWxsYXRvci5qcwogIHZhciBIZWlnaHRtYXBUZXNzZWxsYXRvciA9IHt9OwogIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFID0gT2JqZWN0LmZyZWV6ZSh7CiAgICBoZWlnaHRTY2FsZTogMSwKICAgIGhlaWdodE9mZnNldDogMCwKICAgIGVsZW1lbnRzUGVySGVpZ2h0OiAxLAogICAgc3RyaWRlOiAxLAogICAgZWxlbWVudE11bHRpcGxpZXI6IDI1NiwKICAgIGlzQmlnRW5kaWFuOiBmYWxzZQogIH0pOwogIHZhciBjYXJ0ZXNpYW4zU2NyYXRjaDIgPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIG1hdHJpeDRTY3JhdGNoMyA9IG5ldyBNYXRyaXg0X2RlZmF1bHQoKTsKICB2YXIgbWluaW11bVNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgdmFyIG1heGltdW1TY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIEhlaWdodG1hcFRlc3NlbGxhdG9yLmNvbXB1dGVWZXJ0aWNlcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMpIHx8ICFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5oZWlnaHRtYXApKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvcHRpb25zLmhlaWdodG1hcCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMud2lkdGgpIHx8ICFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5oZWlnaHQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvcHRpb25zLndpZHRoIGFuZCBvcHRpb25zLmhlaWdodCBhcmUgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLm5hdGl2ZVJlY3RhbmdsZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMubmF0aXZlUmVjdGFuZ2xlIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5za2lydEhlaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMuc2tpcnRIZWlnaHQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBjb3MgPSBNYXRoLmNvczsKICAgIGNvbnN0IHNpbiA9IE1hdGguc2luOwogICAgY29uc3Qgc3FydCA9IE1hdGguc3FydDsKICAgIGNvbnN0IGF0YW4gPSBNYXRoLmF0YW47CiAgICBjb25zdCBleHAgPSBNYXRoLmV4cDsKICAgIGNvbnN0IHBpT3ZlclR3byA9IE1hdGhfZGVmYXVsdC5QSV9PVkVSX1RXTzsKICAgIGNvbnN0IHRvUmFkaWFucyA9IE1hdGhfZGVmYXVsdC50b1JhZGlhbnM7CiAgICBjb25zdCBoZWlnaHRtYXAgPSBvcHRpb25zLmhlaWdodG1hcDsKICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucy53aWR0aDsKICAgIGNvbnN0IGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0OwogICAgY29uc3Qgc2tpcnRIZWlnaHQgPSBvcHRpb25zLnNraXJ0SGVpZ2h0OwogICAgY29uc3QgaGFzU2tpcnRzID0gc2tpcnRIZWlnaHQgPiAwOwogICAgY29uc3QgaXNHZW9ncmFwaGljID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5pc0dlb2dyYXBoaWMsIHRydWUpOwogICAgY29uc3QgZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5lbGxpcHNvaWQsIEVsbGlwc29pZF9kZWZhdWx0LldHUzg0KTsKICAgIGNvbnN0IG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXMgPSAxIC8gZWxsaXBzb2lkLm1heGltdW1SYWRpdXM7CiAgICBjb25zdCBuYXRpdmVSZWN0YW5nbGUgPSBSZWN0YW5nbGVfZGVmYXVsdC5jbG9uZShvcHRpb25zLm5hdGl2ZVJlY3RhbmdsZSk7CiAgICBjb25zdCByZWN0YW5nbGUgPSBSZWN0YW5nbGVfZGVmYXVsdC5jbG9uZShvcHRpb25zLnJlY3RhbmdsZSk7CiAgICBsZXQgZ2VvZ3JhcGhpY1dlc3Q7CiAgICBsZXQgZ2VvZ3JhcGhpY1NvdXRoOwogICAgbGV0IGdlb2dyYXBoaWNFYXN0OwogICAgbGV0IGdlb2dyYXBoaWNOb3J0aDsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlY3RhbmdsZSkpIHsKICAgICAgaWYgKGlzR2VvZ3JhcGhpYykgewogICAgICAgIGdlb2dyYXBoaWNXZXN0ID0gdG9SYWRpYW5zKG5hdGl2ZVJlY3RhbmdsZS53ZXN0KTsKICAgICAgICBnZW9ncmFwaGljU291dGggPSB0b1JhZGlhbnMobmF0aXZlUmVjdGFuZ2xlLnNvdXRoKTsKICAgICAgICBnZW9ncmFwaGljRWFzdCA9IHRvUmFkaWFucyhuYXRpdmVSZWN0YW5nbGUuZWFzdCk7CiAgICAgICAgZ2VvZ3JhcGhpY05vcnRoID0gdG9SYWRpYW5zKG5hdGl2ZVJlY3RhbmdsZS5ub3J0aCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZ2VvZ3JhcGhpY1dlc3QgPSBuYXRpdmVSZWN0YW5nbGUud2VzdCAqIG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXM7CiAgICAgICAgZ2VvZ3JhcGhpY1NvdXRoID0gcGlPdmVyVHdvIC0gMiAqIGF0YW4oZXhwKC1uYXRpdmVSZWN0YW5nbGUuc291dGggKiBvbmVPdmVyR2xvYmVTZW1pbWFqb3JBeGlzKSk7CiAgICAgICAgZ2VvZ3JhcGhpY0Vhc3QgPSBuYXRpdmVSZWN0YW5nbGUuZWFzdCAqIG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXM7CiAgICAgICAgZ2VvZ3JhcGhpY05vcnRoID0gcGlPdmVyVHdvIC0gMiAqIGF0YW4oZXhwKC1uYXRpdmVSZWN0YW5nbGUubm9ydGggKiBvbmVPdmVyR2xvYmVTZW1pbWFqb3JBeGlzKSk7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGdlb2dyYXBoaWNXZXN0ID0gcmVjdGFuZ2xlLndlc3Q7CiAgICAgIGdlb2dyYXBoaWNTb3V0aCA9IHJlY3RhbmdsZS5zb3V0aDsKICAgICAgZ2VvZ3JhcGhpY0Vhc3QgPSByZWN0YW5nbGUuZWFzdDsKICAgICAgZ2VvZ3JhcGhpY05vcnRoID0gcmVjdGFuZ2xlLm5vcnRoOwogICAgfQogICAgbGV0IHJlbGF0aXZlVG9DZW50ZXIgPSBvcHRpb25zLnJlbGF0aXZlVG9DZW50ZXI7CiAgICBjb25zdCBoYXNSZWxhdGl2ZVRvQ2VudGVyID0gZGVmaW5lZF9kZWZhdWx0KHJlbGF0aXZlVG9DZW50ZXIpOwogICAgcmVsYXRpdmVUb0NlbnRlciA9IGhhc1JlbGF0aXZlVG9DZW50ZXIgPyByZWxhdGl2ZVRvQ2VudGVyIDogQ2FydGVzaWFuM19kZWZhdWx0LlpFUk87CiAgICBjb25zdCBpbmNsdWRlV2ViTWVyY2F0b3JUID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5pbmNsdWRlV2ViTWVyY2F0b3JULCBmYWxzZSk7CiAgICBjb25zdCBleGFnZ2VyYXRpb24gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLmV4YWdnZXJhdGlvbiwgMSk7CiAgICBjb25zdCBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBvcHRpb25zLmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0LAogICAgICAwCiAgICApOwogICAgY29uc3QgaGFzRXhhZ2dlcmF0aW9uID0gZXhhZ2dlcmF0aW9uICE9PSAxOwogICAgY29uc3QgaW5jbHVkZUdlb2RldGljU3VyZmFjZU5vcm1hbHMgPSBoYXNFeGFnZ2VyYXRpb247CiAgICBjb25zdCBzdHJ1Y3R1cmUgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgb3B0aW9ucy5zdHJ1Y3R1cmUsCiAgICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFCiAgICApOwogICAgY29uc3QgaGVpZ2h0U2NhbGUgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgc3RydWN0dXJlLmhlaWdodFNjYWxlLAogICAgICBIZWlnaHRtYXBUZXNzZWxsYXRvci5ERUZBVUxUX1NUUlVDVFVSRS5oZWlnaHRTY2FsZQogICAgKTsKICAgIGNvbnN0IGhlaWdodE9mZnNldCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBzdHJ1Y3R1cmUuaGVpZ2h0T2Zmc2V0LAogICAgICBIZWlnaHRtYXBUZXNzZWxsYXRvci5ERUZBVUxUX1NUUlVDVFVSRS5oZWlnaHRPZmZzZXQKICAgICk7CiAgICBjb25zdCBlbGVtZW50c1BlckhlaWdodCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBzdHJ1Y3R1cmUuZWxlbWVudHNQZXJIZWlnaHQsCiAgICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFLmVsZW1lbnRzUGVySGVpZ2h0CiAgICApOwogICAgY29uc3Qgc3RyaWRlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIHN0cnVjdHVyZS5zdHJpZGUsCiAgICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFLnN0cmlkZQogICAgKTsKICAgIGNvbnN0IGVsZW1lbnRNdWx0aXBsaWVyID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIHN0cnVjdHVyZS5lbGVtZW50TXVsdGlwbGllciwKICAgICAgSGVpZ2h0bWFwVGVzc2VsbGF0b3IuREVGQVVMVF9TVFJVQ1RVUkUuZWxlbWVudE11bHRpcGxpZXIKICAgICk7CiAgICBjb25zdCBpc0JpZ0VuZGlhbiA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBzdHJ1Y3R1cmUuaXNCaWdFbmRpYW4sCiAgICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFLmlzQmlnRW5kaWFuCiAgICApOwogICAgbGV0IHJlY3RhbmdsZVdpZHRoID0gUmVjdGFuZ2xlX2RlZmF1bHQuY29tcHV0ZVdpZHRoKG5hdGl2ZVJlY3RhbmdsZSk7CiAgICBsZXQgcmVjdGFuZ2xlSGVpZ2h0ID0gUmVjdGFuZ2xlX2RlZmF1bHQuY29tcHV0ZUhlaWdodChuYXRpdmVSZWN0YW5nbGUpOwogICAgY29uc3QgZ3JhbnVsYXJpdHlYID0gcmVjdGFuZ2xlV2lkdGggLyAod2lkdGggLSAxKTsKICAgIGNvbnN0IGdyYW51bGFyaXR5WSA9IHJlY3RhbmdsZUhlaWdodCAvIChoZWlnaHQgLSAxKTsKICAgIGlmICghaXNHZW9ncmFwaGljKSB7CiAgICAgIHJlY3RhbmdsZVdpZHRoICo9IG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXM7CiAgICAgIHJlY3RhbmdsZUhlaWdodCAqPSBvbmVPdmVyR2xvYmVTZW1pbWFqb3JBeGlzOwogICAgfQogICAgY29uc3QgcmFkaWlTcXVhcmVkID0gZWxsaXBzb2lkLnJhZGlpU3F1YXJlZDsKICAgIGNvbnN0IHJhZGlpU3F1YXJlZFggPSByYWRpaVNxdWFyZWQueDsKICAgIGNvbnN0IHJhZGlpU3F1YXJlZFkgPSByYWRpaVNxdWFyZWQueTsKICAgIGNvbnN0IHJhZGlpU3F1YXJlZFogPSByYWRpaVNxdWFyZWQuejsKICAgIGxldCBtaW5pbXVtSGVpZ2h0ID0gNjU1MzY7CiAgICBsZXQgbWF4aW11bUhlaWdodCA9IC02NTUzNjsKICAgIGNvbnN0IGZyb21FTlUgPSBUcmFuc2Zvcm1zX2RlZmF1bHQuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWUoCiAgICAgIHJlbGF0aXZlVG9DZW50ZXIsCiAgICAgIGVsbGlwc29pZAogICAgKTsKICAgIGNvbnN0IHRvRU5VID0gTWF0cml4NF9kZWZhdWx0LmludmVyc2VUcmFuc2Zvcm1hdGlvbihmcm9tRU5VLCBtYXRyaXg0U2NyYXRjaDMpOwogICAgbGV0IHNvdXRoTWVyY2F0b3JZOwogICAgbGV0IG9uZU92ZXJNZXJjYXRvckhlaWdodDsKICAgIGlmIChpbmNsdWRlV2ViTWVyY2F0b3JUKSB7CiAgICAgIHNvdXRoTWVyY2F0b3JZID0gV2ViTWVyY2F0b3JQcm9qZWN0aW9uX2RlZmF1bHQuZ2VvZGV0aWNMYXRpdHVkZVRvTWVyY2F0b3JBbmdsZSgKICAgICAgICBnZW9ncmFwaGljU291dGgKICAgICAgKTsKICAgICAgb25lT3Zlck1lcmNhdG9ySGVpZ2h0ID0gMSAvIChXZWJNZXJjYXRvclByb2plY3Rpb25fZGVmYXVsdC5nZW9kZXRpY0xhdGl0dWRlVG9NZXJjYXRvckFuZ2xlKGdlb2dyYXBoaWNOb3J0aCkgLSBzb3V0aE1lcmNhdG9yWSk7CiAgICB9CiAgICBjb25zdCBtaW5pbXVtID0gbWluaW11bVNjcmF0Y2g7CiAgICBtaW5pbXVtLnggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7CiAgICBtaW5pbXVtLnkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7CiAgICBtaW5pbXVtLnogPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7CiAgICBjb25zdCBtYXhpbXVtID0gbWF4aW11bVNjcmF0Y2g7CiAgICBtYXhpbXVtLnggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7CiAgICBtYXhpbXVtLnkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7CiAgICBtYXhpbXVtLnogPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7CiAgICBsZXQgaE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsKICAgIGNvbnN0IGdyaWRWZXJ0ZXhDb3VudCA9IHdpZHRoICogaGVpZ2h0OwogICAgY29uc3QgZWRnZVZlcnRleENvdW50ID0gc2tpcnRIZWlnaHQgPiAwID8gd2lkdGggKiAyICsgaGVpZ2h0ICogMiA6IDA7CiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGdyaWRWZXJ0ZXhDb3VudCArIGVkZ2VWZXJ0ZXhDb3VudDsKICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCk7CiAgICBjb25zdCBoZWlnaHRzID0gbmV3IEFycmF5KHZlcnRleENvdW50KTsKICAgIGNvbnN0IHV2cyA9IG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCk7CiAgICBjb25zdCB3ZWJNZXJjYXRvclRzID0gaW5jbHVkZVdlYk1lcmNhdG9yVCA/IG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCkgOiBbXTsKICAgIGNvbnN0IGdlb2RldGljU3VyZmFjZU5vcm1hbHMgPSBpbmNsdWRlR2VvZGV0aWNTdXJmYWNlTm9ybWFscyA/IG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCkgOiBbXTsKICAgIGxldCBzdGFydFJvdyA9IDA7CiAgICBsZXQgZW5kUm93ID0gaGVpZ2h0OwogICAgbGV0IHN0YXJ0Q29sID0gMDsKICAgIGxldCBlbmRDb2wgPSB3aWR0aDsKICAgIGlmIChoYXNTa2lydHMpIHsKICAgICAgLS1zdGFydFJvdzsKICAgICAgKytlbmRSb3c7CiAgICAgIC0tc3RhcnRDb2w7CiAgICAgICsrZW5kQ29sOwogICAgfQogICAgY29uc3Qgc2tpcnRPZmZzZXRQZXJjZW50YWdlID0gMWUtNTsKICAgIGZvciAobGV0IHJvd0luZGV4ID0gc3RhcnRSb3c7IHJvd0luZGV4IDwgZW5kUm93OyArK3Jvd0luZGV4KSB7CiAgICAgIGxldCByb3cgPSByb3dJbmRleDsKICAgICAgaWYgKHJvdyA8IDApIHsKICAgICAgICByb3cgPSAwOwogICAgICB9CiAgICAgIGlmIChyb3cgPj0gaGVpZ2h0KSB7CiAgICAgICAgcm93ID0gaGVpZ2h0IC0gMTsKICAgICAgfQogICAgICBsZXQgbGF0aXR1ZGUgPSBuYXRpdmVSZWN0YW5nbGUubm9ydGggLSBncmFudWxhcml0eVkgKiByb3c7CiAgICAgIGlmICghaXNHZW9ncmFwaGljKSB7CiAgICAgICAgbGF0aXR1ZGUgPSBwaU92ZXJUd28gLSAyICogYXRhbihleHAoLWxhdGl0dWRlICogb25lT3Zlckdsb2JlU2VtaW1ham9yQXhpcykpOwogICAgICB9IGVsc2UgewogICAgICAgIGxhdGl0dWRlID0gdG9SYWRpYW5zKGxhdGl0dWRlKTsKICAgICAgfQogICAgICBsZXQgdjIgPSAobGF0aXR1ZGUgLSBnZW9ncmFwaGljU291dGgpIC8gKGdlb2dyYXBoaWNOb3J0aCAtIGdlb2dyYXBoaWNTb3V0aCk7CiAgICAgIHYyID0gTWF0aF9kZWZhdWx0LmNsYW1wKHYyLCAwLCAxKTsKICAgICAgY29uc3QgaXNOb3J0aEVkZ2UgPSByb3dJbmRleCA9PT0gc3RhcnRSb3c7CiAgICAgIGNvbnN0IGlzU291dGhFZGdlID0gcm93SW5kZXggPT09IGVuZFJvdyAtIDE7CiAgICAgIGlmIChza2lydEhlaWdodCA+IDApIHsKICAgICAgICBpZiAoaXNOb3J0aEVkZ2UpIHsKICAgICAgICAgIGxhdGl0dWRlICs9IHNraXJ0T2Zmc2V0UGVyY2VudGFnZSAqIHJlY3RhbmdsZUhlaWdodDsKICAgICAgICB9IGVsc2UgaWYgKGlzU291dGhFZGdlKSB7CiAgICAgICAgICBsYXRpdHVkZSAtPSBza2lydE9mZnNldFBlcmNlbnRhZ2UgKiByZWN0YW5nbGVIZWlnaHQ7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGNvc0xhdGl0dWRlID0gY29zKGxhdGl0dWRlKTsKICAgICAgY29uc3QgblogPSBzaW4obGF0aXR1ZGUpOwogICAgICBjb25zdCBrWiA9IHJhZGlpU3F1YXJlZFogKiBuWjsKICAgICAgbGV0IHdlYk1lcmNhdG9yVDsKICAgICAgaWYgKGluY2x1ZGVXZWJNZXJjYXRvclQpIHsKICAgICAgICB3ZWJNZXJjYXRvclQgPSAoV2ViTWVyY2F0b3JQcm9qZWN0aW9uX2RlZmF1bHQuZ2VvZGV0aWNMYXRpdHVkZVRvTWVyY2F0b3JBbmdsZShsYXRpdHVkZSkgLSBzb3V0aE1lcmNhdG9yWSkgKiBvbmVPdmVyTWVyY2F0b3JIZWlnaHQ7CiAgICAgIH0KICAgICAgZm9yIChsZXQgY29sSW5kZXggPSBzdGFydENvbDsgY29sSW5kZXggPCBlbmRDb2w7ICsrY29sSW5kZXgpIHsKICAgICAgICBsZXQgY29sID0gY29sSW5kZXg7CiAgICAgICAgaWYgKGNvbCA8IDApIHsKICAgICAgICAgIGNvbCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChjb2wgPj0gd2lkdGgpIHsKICAgICAgICAgIGNvbCA9IHdpZHRoIC0gMTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdGVycmFpbk9mZnNldCA9IHJvdyAqICh3aWR0aCAqIHN0cmlkZSkgKyBjb2wgKiBzdHJpZGU7CiAgICAgICAgbGV0IGhlaWdodFNhbXBsZTsKICAgICAgICBpZiAoZWxlbWVudHNQZXJIZWlnaHQgPT09IDEpIHsKICAgICAgICAgIGhlaWdodFNhbXBsZSA9IGhlaWdodG1hcFt0ZXJyYWluT2Zmc2V0XTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaGVpZ2h0U2FtcGxlID0gMDsKICAgICAgICAgIGxldCBlbGVtZW50T2Zmc2V0OwogICAgICAgICAgaWYgKGlzQmlnRW5kaWFuKSB7CiAgICAgICAgICAgIGZvciAoZWxlbWVudE9mZnNldCA9IDA7IGVsZW1lbnRPZmZzZXQgPCBlbGVtZW50c1BlckhlaWdodDsgKytlbGVtZW50T2Zmc2V0KSB7CiAgICAgICAgICAgICAgaGVpZ2h0U2FtcGxlID0gaGVpZ2h0U2FtcGxlICogZWxlbWVudE11bHRpcGxpZXIgKyBoZWlnaHRtYXBbdGVycmFpbk9mZnNldCArIGVsZW1lbnRPZmZzZXRdOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBmb3IgKGVsZW1lbnRPZmZzZXQgPSBlbGVtZW50c1BlckhlaWdodCAtIDE7IGVsZW1lbnRPZmZzZXQgPj0gMDsgLS1lbGVtZW50T2Zmc2V0KSB7CiAgICAgICAgICAgICAgaGVpZ2h0U2FtcGxlID0gaGVpZ2h0U2FtcGxlICogZWxlbWVudE11bHRpcGxpZXIgKyBoZWlnaHRtYXBbdGVycmFpbk9mZnNldCArIGVsZW1lbnRPZmZzZXRdOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGhlaWdodFNhbXBsZSA9IGhlaWdodFNhbXBsZSAqIGhlaWdodFNjYWxlICsgaGVpZ2h0T2Zmc2V0OwogICAgICAgIG1heGltdW1IZWlnaHQgPSBNYXRoLm1heChtYXhpbXVtSGVpZ2h0LCBoZWlnaHRTYW1wbGUpOwogICAgICAgIG1pbmltdW1IZWlnaHQgPSBNYXRoLm1pbihtaW5pbXVtSGVpZ2h0LCBoZWlnaHRTYW1wbGUpOwogICAgICAgIGxldCBsb25naXR1ZGUgPSBuYXRpdmVSZWN0YW5nbGUud2VzdCArIGdyYW51bGFyaXR5WCAqIGNvbDsKICAgICAgICBpZiAoIWlzR2VvZ3JhcGhpYykgewogICAgICAgICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICogb25lT3Zlckdsb2JlU2VtaW1ham9yQXhpczsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbG9uZ2l0dWRlID0gdG9SYWRpYW5zKGxvbmdpdHVkZSk7CiAgICAgICAgfQogICAgICAgIGxldCB1MiA9IChsb25naXR1ZGUgLSBnZW9ncmFwaGljV2VzdCkgLyAoZ2VvZ3JhcGhpY0Vhc3QgLSBnZW9ncmFwaGljV2VzdCk7CiAgICAgICAgdTIgPSBNYXRoX2RlZmF1bHQuY2xhbXAodTIsIDAsIDEpOwogICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHdpZHRoICsgY29sOwogICAgICAgIGlmIChza2lydEhlaWdodCA+IDApIHsKICAgICAgICAgIGNvbnN0IGlzV2VzdEVkZ2UgPSBjb2xJbmRleCA9PT0gc3RhcnRDb2w7CiAgICAgICAgICBjb25zdCBpc0Vhc3RFZGdlID0gY29sSW5kZXggPT09IGVuZENvbCAtIDE7CiAgICAgICAgICBjb25zdCBpc0VkZ2UyID0gaXNOb3J0aEVkZ2UgfHwgaXNTb3V0aEVkZ2UgfHwgaXNXZXN0RWRnZSB8fCBpc0Vhc3RFZGdlOwogICAgICAgICAgY29uc3QgaXNDb3JuZXIgPSAoaXNOb3J0aEVkZ2UgfHwgaXNTb3V0aEVkZ2UpICYmIChpc1dlc3RFZGdlIHx8IGlzRWFzdEVkZ2UpOwogICAgICAgICAgaWYgKGlzQ29ybmVyKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChpc0VkZ2UyKSB7CiAgICAgICAgICAgIGhlaWdodFNhbXBsZSAtPSBza2lydEhlaWdodDsKICAgICAgICAgICAgaWYgKGlzV2VzdEVkZ2UpIHsKICAgICAgICAgICAgICBpbmRleCA9IGdyaWRWZXJ0ZXhDb3VudCArIChoZWlnaHQgLSByb3cgLSAxKTsKICAgICAgICAgICAgICBsb25naXR1ZGUgLT0gc2tpcnRPZmZzZXRQZXJjZW50YWdlICogcmVjdGFuZ2xlV2lkdGg7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTb3V0aEVkZ2UpIHsKICAgICAgICAgICAgICBpbmRleCA9IGdyaWRWZXJ0ZXhDb3VudCArIGhlaWdodCArICh3aWR0aCAtIGNvbCAtIDEpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGlzRWFzdEVkZ2UpIHsKICAgICAgICAgICAgICBpbmRleCA9IGdyaWRWZXJ0ZXhDb3VudCArIGhlaWdodCArIHdpZHRoICsgcm93OwogICAgICAgICAgICAgIGxvbmdpdHVkZSArPSBza2lydE9mZnNldFBlcmNlbnRhZ2UgKiByZWN0YW5nbGVXaWR0aDsKICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vcnRoRWRnZSkgewogICAgICAgICAgICAgIGluZGV4ID0gZ3JpZFZlcnRleENvdW50ICsgaGVpZ2h0ICsgd2lkdGggKyBoZWlnaHQgKyBjb2w7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgblggPSBjb3NMYXRpdHVkZSAqIGNvcyhsb25naXR1ZGUpOwogICAgICAgIGNvbnN0IG5ZID0gY29zTGF0aXR1ZGUgKiBzaW4obG9uZ2l0dWRlKTsKICAgICAgICBjb25zdCBrWCA9IHJhZGlpU3F1YXJlZFggKiBuWDsKICAgICAgICBjb25zdCBrWSA9IHJhZGlpU3F1YXJlZFkgKiBuWTsKICAgICAgICBjb25zdCBnYW1tYSA9IHNxcnQoa1ggKiBuWCArIGtZICogblkgKyBrWiAqIG5aKTsKICAgICAgICBjb25zdCBvbmVPdmVyR2FtbWEgPSAxIC8gZ2FtbWE7CiAgICAgICAgY29uc3QgclN1cmZhY2VYID0ga1ggKiBvbmVPdmVyR2FtbWE7CiAgICAgICAgY29uc3QgclN1cmZhY2VZID0ga1kgKiBvbmVPdmVyR2FtbWE7CiAgICAgICAgY29uc3QgclN1cmZhY2VaID0ga1ogKiBvbmVPdmVyR2FtbWE7CiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KCk7CiAgICAgICAgcG9zaXRpb24ueCA9IHJTdXJmYWNlWCArIG5YICogaGVpZ2h0U2FtcGxlOwogICAgICAgIHBvc2l0aW9uLnkgPSByU3VyZmFjZVkgKyBuWSAqIGhlaWdodFNhbXBsZTsKICAgICAgICBwb3NpdGlvbi56ID0gclN1cmZhY2VaICsgblogKiBoZWlnaHRTYW1wbGU7CiAgICAgICAgTWF0cml4NF9kZWZhdWx0Lm11bHRpcGx5QnlQb2ludCh0b0VOVSwgcG9zaXRpb24sIGNhcnRlc2lhbjNTY3JhdGNoMik7CiAgICAgICAgQ2FydGVzaWFuM19kZWZhdWx0Lm1pbmltdW1CeUNvbXBvbmVudChjYXJ0ZXNpYW4zU2NyYXRjaDIsIG1pbmltdW0sIG1pbmltdW0pOwogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5tYXhpbXVtQnlDb21wb25lbnQoY2FydGVzaWFuM1NjcmF0Y2gyLCBtYXhpbXVtLCBtYXhpbXVtKTsKICAgICAgICBoTWluID0gTWF0aC5taW4oaE1pbiwgaGVpZ2h0U2FtcGxlKTsKICAgICAgICBwb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247CiAgICAgICAgdXZzW2luZGV4XSA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQodTIsIHYyKTsKICAgICAgICBoZWlnaHRzW2luZGV4XSA9IGhlaWdodFNhbXBsZTsKICAgICAgICBpZiAoaW5jbHVkZVdlYk1lcmNhdG9yVCkgewogICAgICAgICAgd2ViTWVyY2F0b3JUc1tpbmRleF0gPSB3ZWJNZXJjYXRvclQ7CiAgICAgICAgfQogICAgICAgIGlmIChpbmNsdWRlR2VvZGV0aWNTdXJmYWNlTm9ybWFscykgewogICAgICAgICAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsc1tpbmRleF0gPSBlbGxpcHNvaWQuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKAogICAgICAgICAgICBwb3NpdGlvbgogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGNvbnN0IGJvdW5kaW5nU3BoZXJlM0QgPSBCb3VuZGluZ1NwaGVyZV9kZWZhdWx0LmZyb21Qb2ludHMocG9zaXRpb25zKTsKICAgIGxldCBvcmllbnRlZEJvdW5kaW5nQm94OwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChyZWN0YW5nbGUpKSB7CiAgICAgIG9yaWVudGVkQm91bmRpbmdCb3ggPSBPcmllbnRlZEJvdW5kaW5nQm94X2RlZmF1bHQuZnJvbVJlY3RhbmdsZSgKICAgICAgICByZWN0YW5nbGUsCiAgICAgICAgbWluaW11bUhlaWdodCwKICAgICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICAgIGVsbGlwc29pZAogICAgICApOwogICAgfQogICAgbGV0IG9jY2x1ZGVlUG9pbnRJblNjYWxlZFNwYWNlOwogICAgaWYgKGhhc1JlbGF0aXZlVG9DZW50ZXIpIHsKICAgICAgY29uc3Qgb2NjbHVkZXIgPSBuZXcgRWxsaXBzb2lkYWxPY2NsdWRlcl9kZWZhdWx0KGVsbGlwc29pZCk7CiAgICAgIG9jY2x1ZGVlUG9pbnRJblNjYWxlZFNwYWNlID0gb2NjbHVkZXIuY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRQb3NzaWJseVVuZGVyRWxsaXBzb2lkKAogICAgICAgIHJlbGF0aXZlVG9DZW50ZXIsCiAgICAgICAgcG9zaXRpb25zLAogICAgICAgIG1pbmltdW1IZWlnaHQKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IGFhQm94ID0gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3hfZGVmYXVsdChtaW5pbXVtLCBtYXhpbXVtLCByZWxhdGl2ZVRvQ2VudGVyKTsKICAgIGNvbnN0IGVuY29kaW5nID0gbmV3IFRlcnJhaW5FbmNvZGluZ19kZWZhdWx0KAogICAgICByZWxhdGl2ZVRvQ2VudGVyLAogICAgICBhYUJveCwKICAgICAgaE1pbiwKICAgICAgbWF4aW11bUhlaWdodCwKICAgICAgZnJvbUVOVSwKICAgICAgZmFsc2UsCiAgICAgIGluY2x1ZGVXZWJNZXJjYXRvclQsCiAgICAgIGluY2x1ZGVHZW9kZXRpY1N1cmZhY2VOb3JtYWxzLAogICAgICBleGFnZ2VyYXRpb24sCiAgICAgIGV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0CiAgICApOwogICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogZW5jb2Rpbmcuc3RyaWRlKTsKICAgIGxldCBidWZmZXJJbmRleCA9IDA7CiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZlcnRleENvdW50OyArK2opIHsKICAgICAgYnVmZmVySW5kZXggPSBlbmNvZGluZy5lbmNvZGUoCiAgICAgICAgdmVydGljZXMsCiAgICAgICAgYnVmZmVySW5kZXgsCiAgICAgICAgcG9zaXRpb25zW2pdLAogICAgICAgIHV2c1tqXSwKICAgICAgICBoZWlnaHRzW2pdLAogICAgICAgIHZvaWQgMCwKICAgICAgICB3ZWJNZXJjYXRvclRzW2pdLAogICAgICAgIGdlb2RldGljU3VyZmFjZU5vcm1hbHNbal0KICAgICAgKTsKICAgIH0KICAgIHJldHVybiB7CiAgICAgIHZlcnRpY2VzLAogICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICBtaW5pbXVtSGVpZ2h0LAogICAgICBlbmNvZGluZywKICAgICAgYm91bmRpbmdTcGhlcmUzRCwKICAgICAgb3JpZW50ZWRCb3VuZGluZ0JveCwKICAgICAgb2NjbHVkZWVQb2ludEluU2NhbGVkU3BhY2UKICAgIH07CiAgfTsKICB2YXIgSGVpZ2h0bWFwVGVzc2VsbGF0b3JfZGVmYXVsdCA9IEhlaWdodG1hcFRlc3NlbGxhdG9yOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGVycmFpbkRhdGEuanMKICBmdW5jdGlvbiBUZXJyYWluRGF0YSgpIHsKICAgIERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IoKTsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGVycmFpbkRhdGEucHJvdG90eXBlLCB7CiAgICBjcmVkaXRzOiB7CiAgICAgIGdldDogRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdC50aHJvd0luc3RhbnRpYXRpb25FcnJvcgogICAgfSwKICAgIHdhdGVyTWFzazogewogICAgICBnZXQ6IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IKICAgIH0KICB9KTsKICBUZXJyYWluRGF0YS5wcm90b3R5cGUuaW50ZXJwb2xhdGVIZWlnaHQgPSBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0LnRocm93SW5zdGFudGlhdGlvbkVycm9yOwogIFRlcnJhaW5EYXRhLnByb3RvdHlwZS5pc0NoaWxkQXZhaWxhYmxlID0gRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdC50aHJvd0luc3RhbnRpYXRpb25FcnJvcjsKICBUZXJyYWluRGF0YS5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7CiAgVGVycmFpbkRhdGEucHJvdG90eXBlLnVwc2FtcGxlID0gRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdC50aHJvd0luc3RhbnRpYXRpb25FcnJvcjsKICBUZXJyYWluRGF0YS5wcm90b3R5cGUud2FzQ3JlYXRlZEJ5VXBzYW1wbGluZyA9IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7CiAgVGVycmFpbkRhdGEubWF4aW11bUFzeW5jaHJvbm91c1Rhc2tzID0gNTsKICB2YXIgVGVycmFpbkRhdGFfZGVmYXVsdCA9IFRlcnJhaW5EYXRhOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGVycmFpbk1lc2guanMKICBmdW5jdGlvbiBUZXJyYWluTWVzaChjZW50ZXIsIHZlcnRpY2VzLCBpbmRpY2VzLCBpbmRleENvdW50V2l0aG91dFNraXJ0cywgdmVydGV4Q291bnRXaXRob3V0U2tpcnRzLCBtaW5pbXVtSGVpZ2h0LCBtYXhpbXVtSGVpZ2h0LCBib3VuZGluZ1NwaGVyZTNELCBvY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZSwgdmVydGV4U3RyaWRlLCBvcmllbnRlZEJvdW5kaW5nQm94LCBlbmNvZGluZywgd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsIGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLCBub3J0aEluZGljZXNXZXN0VG9FYXN0KSB7CiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjsKICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlczsKICAgIHRoaXMuc3RyaWRlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQodmVydGV4U3RyaWRlLCA2KTsKICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXM7CiAgICB0aGlzLmluZGV4Q291bnRXaXRob3V0U2tpcnRzID0gaW5kZXhDb3VudFdpdGhvdXRTa2lydHM7CiAgICB0aGlzLnZlcnRleENvdW50V2l0aG91dFNraXJ0cyA9IHZlcnRleENvdW50V2l0aG91dFNraXJ0czsKICAgIHRoaXMubWluaW11bUhlaWdodCA9IG1pbmltdW1IZWlnaHQ7CiAgICB0aGlzLm1heGltdW1IZWlnaHQgPSBtYXhpbXVtSGVpZ2h0OwogICAgdGhpcy5ib3VuZGluZ1NwaGVyZTNEID0gYm91bmRpbmdTcGhlcmUzRDsKICAgIHRoaXMub2NjbHVkZWVQb2ludEluU2NhbGVkU3BhY2UgPSBvY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZTsKICAgIHRoaXMub3JpZW50ZWRCb3VuZGluZ0JveCA9IG9yaWVudGVkQm91bmRpbmdCb3g7CiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7CiAgICB0aGlzLndlc3RJbmRpY2VzU291dGhUb05vcnRoID0gd2VzdEluZGljZXNTb3V0aFRvTm9ydGg7CiAgICB0aGlzLnNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QgPSBzb3V0aEluZGljZXNFYXN0VG9XZXN0OwogICAgdGhpcy5lYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCA9IGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoOwogICAgdGhpcy5ub3J0aEluZGljZXNXZXN0VG9FYXN0ID0gbm9ydGhJbmRpY2VzV2VzdFRvRWFzdDsKICB9CiAgdmFyIFRlcnJhaW5NZXNoX2RlZmF1bHQgPSBUZXJyYWluTWVzaDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RlcnJhaW5Qcm92aWRlci5qcwogIGZ1bmN0aW9uIFRlcnJhaW5Qcm92aWRlcigpIHsKICAgIERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IoKTsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZSwgewogICAgZXJyb3JFdmVudDogewogICAgICBnZXQ6IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IKICAgIH0sCiAgICBjcmVkaXQ6IHsKICAgICAgZ2V0OiBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0LnRocm93SW5zdGFudGlhdGlvbkVycm9yCiAgICB9LAogICAgdGlsaW5nU2NoZW1lOiB7CiAgICAgIGdldDogRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdC50aHJvd0luc3RhbnRpYXRpb25FcnJvcgogICAgfSwKICAgIHJlYWR5OiB7CiAgICAgIGdldDogRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdC50aHJvd0luc3RhbnRpYXRpb25FcnJvcgogICAgfSwKICAgIHJlYWR5UHJvbWlzZTogewogICAgICBnZXQ6IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IKICAgIH0sCiAgICBoYXNXYXRlck1hc2s6IHsKICAgICAgZ2V0OiBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0LnRocm93SW5zdGFudGlhdGlvbkVycm9yCiAgICB9LAogICAgaGFzVmVydGV4Tm9ybWFsczogewogICAgICBnZXQ6IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IKICAgIH0sCiAgICBhdmFpbGFiaWxpdHk6IHsKICAgICAgZ2V0OiBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0LnRocm93SW5zdGFudGlhdGlvbkVycm9yCiAgICB9CiAgfSk7CiAgdmFyIHJlZ3VsYXJHcmlkSW5kaWNlc0NhY2hlID0gW107CiAgVGVycmFpblByb3ZpZGVyLmdldFJlZ3VsYXJHcmlkSW5kaWNlcyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHsKICAgIGlmICh3aWR0aCAqIGhlaWdodCA+PSBNYXRoX2RlZmF1bHQuRk9VUl9HSUdBQllURVMpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgIlRoZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXMgKHdpZHRoICogaGVpZ2h0KSBtdXN0IGJlIGxlc3MgdGhhbiA0LDI5NCw5NjcsMjk2LiIKICAgICAgKTsKICAgIH0KICAgIGxldCBieVdpZHRoID0gcmVndWxhckdyaWRJbmRpY2VzQ2FjaGVbd2lkdGhdOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYnlXaWR0aCkpIHsKICAgICAgcmVndWxhckdyaWRJbmRpY2VzQ2FjaGVbd2lkdGhdID0gYnlXaWR0aCA9IFtdOwogICAgfQogICAgbGV0IGluZGljZXMgPSBieVdpZHRoW2hlaWdodF07CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpbmRpY2VzKSkgewogICAgICBpZiAod2lkdGggKiBoZWlnaHQgPCBNYXRoX2RlZmF1bHQuU0lYVFlfRk9VUl9LSUxPQllURVMpIHsKICAgICAgICBpbmRpY2VzID0gYnlXaWR0aFtoZWlnaHRdID0gbmV3IFVpbnQxNkFycmF5KAogICAgICAgICAgKHdpZHRoIC0gMSkgKiAoaGVpZ2h0IC0gMSkgKiA2CiAgICAgICAgKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbmRpY2VzID0gYnlXaWR0aFtoZWlnaHRdID0gbmV3IFVpbnQzMkFycmF5KAogICAgICAgICAgKHdpZHRoIC0gMSkgKiAoaGVpZ2h0IC0gMSkgKiA2CiAgICAgICAgKTsKICAgICAgfQogICAgICBhZGRSZWd1bGFyR3JpZEluZGljZXMod2lkdGgsIGhlaWdodCwgaW5kaWNlcywgMCk7CiAgICB9CiAgICByZXR1cm4gaW5kaWNlczsKICB9OwogIHZhciByZWd1bGFyR3JpZEFuZEVkZ2VJbmRpY2VzQ2FjaGUgPSBbXTsKICBUZXJyYWluUHJvdmlkZXIuZ2V0UmVndWxhckdyaWRJbmRpY2VzQW5kRWRnZUluZGljZXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7CiAgICBpZiAod2lkdGggKiBoZWlnaHQgPj0gTWF0aF9kZWZhdWx0LkZPVVJfR0lHQUJZVEVTKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJUaGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzICh3aWR0aCAqIGhlaWdodCkgbXVzdCBiZSBsZXNzIHRoYW4gNCwyOTQsOTY3LDI5Ni4iCiAgICAgICk7CiAgICB9CiAgICBsZXQgYnlXaWR0aCA9IHJlZ3VsYXJHcmlkQW5kRWRnZUluZGljZXNDYWNoZVt3aWR0aF07CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChieVdpZHRoKSkgewogICAgICByZWd1bGFyR3JpZEFuZEVkZ2VJbmRpY2VzQ2FjaGVbd2lkdGhdID0gYnlXaWR0aCA9IFtdOwogICAgfQogICAgbGV0IGluZGljZXNBbmRFZGdlcyA9IGJ5V2lkdGhbaGVpZ2h0XTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGluZGljZXNBbmRFZGdlcykpIHsKICAgICAgY29uc3QgaW5kaWNlcyA9IFRlcnJhaW5Qcm92aWRlci5nZXRSZWd1bGFyR3JpZEluZGljZXMod2lkdGgsIGhlaWdodCk7CiAgICAgIGNvbnN0IGVkZ2VJbmRpY2VzID0gZ2V0RWRnZUluZGljZXMod2lkdGgsIGhlaWdodCk7CiAgICAgIGNvbnN0IHdlc3RJbmRpY2VzU291dGhUb05vcnRoID0gZWRnZUluZGljZXMud2VzdEluZGljZXNTb3V0aFRvTm9ydGg7CiAgICAgIGNvbnN0IHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QgPSBlZGdlSW5kaWNlcy5zb3V0aEluZGljZXNFYXN0VG9XZXN0OwogICAgICBjb25zdCBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCA9IGVkZ2VJbmRpY2VzLmVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoOwogICAgICBjb25zdCBub3J0aEluZGljZXNXZXN0VG9FYXN0ID0gZWRnZUluZGljZXMubm9ydGhJbmRpY2VzV2VzdFRvRWFzdDsKICAgICAgaW5kaWNlc0FuZEVkZ2VzID0gYnlXaWR0aFtoZWlnaHRdID0gewogICAgICAgIGluZGljZXMsCiAgICAgICAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsCiAgICAgICAgc291dGhJbmRpY2VzRWFzdFRvV2VzdCwKICAgICAgICBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCwKICAgICAgICBub3J0aEluZGljZXNXZXN0VG9FYXN0CiAgICAgIH07CiAgICB9CiAgICByZXR1cm4gaW5kaWNlc0FuZEVkZ2VzOwogIH07CiAgdmFyIHJlZ3VsYXJHcmlkQW5kU2tpcnRBbmRFZGdlSW5kaWNlc0NhY2hlID0gW107CiAgVGVycmFpblByb3ZpZGVyLmdldFJlZ3VsYXJHcmlkQW5kU2tpcnRJbmRpY2VzQW5kRWRnZUluZGljZXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7CiAgICBpZiAod2lkdGggKiBoZWlnaHQgPj0gTWF0aF9kZWZhdWx0LkZPVVJfR0lHQUJZVEVTKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICJUaGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzICh3aWR0aCAqIGhlaWdodCkgbXVzdCBiZSBsZXNzIHRoYW4gNCwyOTQsOTY3LDI5Ni4iCiAgICAgICk7CiAgICB9CiAgICBsZXQgYnlXaWR0aCA9IHJlZ3VsYXJHcmlkQW5kU2tpcnRBbmRFZGdlSW5kaWNlc0NhY2hlW3dpZHRoXTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJ5V2lkdGgpKSB7CiAgICAgIHJlZ3VsYXJHcmlkQW5kU2tpcnRBbmRFZGdlSW5kaWNlc0NhY2hlW3dpZHRoXSA9IGJ5V2lkdGggPSBbXTsKICAgIH0KICAgIGxldCBpbmRpY2VzQW5kRWRnZXMgPSBieVdpZHRoW2hlaWdodF07CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChpbmRpY2VzQW5kRWRnZXMpKSB7CiAgICAgIGNvbnN0IGdyaWRWZXJ0ZXhDb3VudCA9IHdpZHRoICogaGVpZ2h0OwogICAgICBjb25zdCBncmlkSW5kZXhDb3VudCA9ICh3aWR0aCAtIDEpICogKGhlaWdodCAtIDEpICogNjsKICAgICAgY29uc3QgZWRnZVZlcnRleENvdW50ID0gd2lkdGggKiAyICsgaGVpZ2h0ICogMjsKICAgICAgY29uc3QgZWRnZUluZGV4Q291bnQgPSBNYXRoLm1heCgwLCBlZGdlVmVydGV4Q291bnQgLSA0KSAqIDY7CiAgICAgIGNvbnN0IHZlcnRleENvdW50ID0gZ3JpZFZlcnRleENvdW50ICsgZWRnZVZlcnRleENvdW50OwogICAgICBjb25zdCBpbmRleENvdW50ID0gZ3JpZEluZGV4Q291bnQgKyBlZGdlSW5kZXhDb3VudDsKICAgICAgY29uc3QgZWRnZUluZGljZXMgPSBnZXRFZGdlSW5kaWNlcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgY29uc3Qgd2VzdEluZGljZXNTb3V0aFRvTm9ydGggPSBlZGdlSW5kaWNlcy53ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aDsKICAgICAgY29uc3Qgc291dGhJbmRpY2VzRWFzdFRvV2VzdCA9IGVkZ2VJbmRpY2VzLnNvdXRoSW5kaWNlc0Vhc3RUb1dlc3Q7CiAgICAgIGNvbnN0IGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoID0gZWRnZUluZGljZXMuZWFzdEluZGljZXNOb3J0aFRvU291dGg7CiAgICAgIGNvbnN0IG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QgPSBlZGdlSW5kaWNlcy5ub3J0aEluZGljZXNXZXN0VG9FYXN0OwogICAgICBjb25zdCBpbmRpY2VzID0gSW5kZXhEYXRhdHlwZV9kZWZhdWx0LmNyZWF0ZVR5cGVkQXJyYXkodmVydGV4Q291bnQsIGluZGV4Q291bnQpOwogICAgICBhZGRSZWd1bGFyR3JpZEluZGljZXMod2lkdGgsIGhlaWdodCwgaW5kaWNlcywgMCk7CiAgICAgIFRlcnJhaW5Qcm92aWRlci5hZGRTa2lydEluZGljZXMoCiAgICAgICAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsCiAgICAgICAgc291dGhJbmRpY2VzRWFzdFRvV2VzdCwKICAgICAgICBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCwKICAgICAgICBub3J0aEluZGljZXNXZXN0VG9FYXN0LAogICAgICAgIGdyaWRWZXJ0ZXhDb3VudCwKICAgICAgICBpbmRpY2VzLAogICAgICAgIGdyaWRJbmRleENvdW50CiAgICAgICk7CiAgICAgIGluZGljZXNBbmRFZGdlcyA9IGJ5V2lkdGhbaGVpZ2h0XSA9IHsKICAgICAgICBpbmRpY2VzLAogICAgICAgIHdlc3RJbmRpY2VzU291dGhUb05vcnRoLAogICAgICAgIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsCiAgICAgICAgZWFzdEluZGljZXNOb3J0aFRvU291dGgsCiAgICAgICAgbm9ydGhJbmRpY2VzV2VzdFRvRWFzdCwKICAgICAgICBpbmRleENvdW50V2l0aG91dFNraXJ0czogZ3JpZEluZGV4Q291bnQKICAgICAgfTsKICAgIH0KICAgIHJldHVybiBpbmRpY2VzQW5kRWRnZXM7CiAgfTsKICBUZXJyYWluUHJvdmlkZXIuYWRkU2tpcnRJbmRpY2VzID0gZnVuY3Rpb24od2VzdEluZGljZXNTb3V0aFRvTm9ydGgsIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsIGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLCBub3J0aEluZGljZXNXZXN0VG9FYXN0LCB2ZXJ0ZXhDb3VudCwgaW5kaWNlcywgb2Zmc2V0KSB7CiAgICBsZXQgdmVydGV4SW5kZXggPSB2ZXJ0ZXhDb3VudDsKICAgIG9mZnNldCA9IGFkZFNraXJ0SW5kaWNlcygKICAgICAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsCiAgICAgIHZlcnRleEluZGV4LAogICAgICBpbmRpY2VzLAogICAgICBvZmZzZXQKICAgICk7CiAgICB2ZXJ0ZXhJbmRleCArPSB3ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aC5sZW5ndGg7CiAgICBvZmZzZXQgPSBhZGRTa2lydEluZGljZXMoCiAgICAgIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsCiAgICAgIHZlcnRleEluZGV4LAogICAgICBpbmRpY2VzLAogICAgICBvZmZzZXQKICAgICk7CiAgICB2ZXJ0ZXhJbmRleCArPSBzb3V0aEluZGljZXNFYXN0VG9XZXN0Lmxlbmd0aDsKICAgIG9mZnNldCA9IGFkZFNraXJ0SW5kaWNlcygKICAgICAgZWFzdEluZGljZXNOb3J0aFRvU291dGgsCiAgICAgIHZlcnRleEluZGV4LAogICAgICBpbmRpY2VzLAogICAgICBvZmZzZXQKICAgICk7CiAgICB2ZXJ0ZXhJbmRleCArPSBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aC5sZW5ndGg7CiAgICBhZGRTa2lydEluZGljZXMobm9ydGhJbmRpY2VzV2VzdFRvRWFzdCwgdmVydGV4SW5kZXgsIGluZGljZXMsIG9mZnNldCk7CiAgfTsKICBmdW5jdGlvbiBnZXRFZGdlSW5kaWNlcyh3aWR0aCwgaGVpZ2h0KSB7CiAgICBjb25zdCB3ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aCA9IG5ldyBBcnJheShoZWlnaHQpOwogICAgY29uc3Qgc291dGhJbmRpY2VzRWFzdFRvV2VzdCA9IG5ldyBBcnJheSh3aWR0aCk7CiAgICBjb25zdCBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCA9IG5ldyBBcnJheShoZWlnaHQpOwogICAgY29uc3Qgbm9ydGhJbmRpY2VzV2VzdFRvRWFzdCA9IG5ldyBBcnJheSh3aWR0aCk7CiAgICBsZXQgaTsKICAgIGZvciAoaSA9IDA7IGkgPCB3aWR0aDsgKytpKSB7CiAgICAgIG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3RbaV0gPSBpOwogICAgICBzb3V0aEluZGljZXNFYXN0VG9XZXN0W2ldID0gd2lkdGggKiBoZWlnaHQgLSAxIC0gaTsKICAgIH0KICAgIGZvciAoaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkgewogICAgICBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aFtpXSA9IChpICsgMSkgKiB3aWR0aCAtIDE7CiAgICAgIHdlc3RJbmRpY2VzU291dGhUb05vcnRoW2ldID0gKGhlaWdodCAtIGkgLSAxKSAqIHdpZHRoOwogICAgfQogICAgcmV0dXJuIHsKICAgICAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsCiAgICAgIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsCiAgICAgIGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLAogICAgICBub3J0aEluZGljZXNXZXN0VG9FYXN0CiAgICB9OwogIH0KICBmdW5jdGlvbiBhZGRSZWd1bGFyR3JpZEluZGljZXMod2lkdGgsIGhlaWdodCwgaW5kaWNlcywgb2Zmc2V0KSB7CiAgICBsZXQgaW5kZXggPSAwOwogICAgZm9yIChsZXQgaiA9IDA7IGogPCBoZWlnaHQgLSAxOyArK2opIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aCAtIDE7ICsraSkgewogICAgICAgIGNvbnN0IHVwcGVyTGVmdCA9IGluZGV4OwogICAgICAgIGNvbnN0IGxvd2VyTGVmdCA9IHVwcGVyTGVmdCArIHdpZHRoOwogICAgICAgIGNvbnN0IGxvd2VyUmlnaHQgPSBsb3dlckxlZnQgKyAxOwogICAgICAgIGNvbnN0IHVwcGVyUmlnaHQgPSB1cHBlckxlZnQgKyAxOwogICAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gdXBwZXJMZWZ0OwogICAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gbG93ZXJMZWZ0OwogICAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gdXBwZXJSaWdodDsKICAgICAgICBpbmRpY2VzW29mZnNldCsrXSA9IHVwcGVyUmlnaHQ7CiAgICAgICAgaW5kaWNlc1tvZmZzZXQrK10gPSBsb3dlckxlZnQ7CiAgICAgICAgaW5kaWNlc1tvZmZzZXQrK10gPSBsb3dlclJpZ2h0OwogICAgICAgICsraW5kZXg7CiAgICAgIH0KICAgICAgKytpbmRleDsKICAgIH0KICB9CiAgZnVuY3Rpb24gYWRkU2tpcnRJbmRpY2VzKGVkZ2VJbmRpY2VzLCB2ZXJ0ZXhJbmRleCwgaW5kaWNlcywgb2Zmc2V0KSB7CiAgICBsZXQgcHJldmlvdXNJbmRleCA9IGVkZ2VJbmRpY2VzWzBdOwogICAgY29uc3QgbGVuZ3RoID0gZWRnZUluZGljZXMubGVuZ3RoOwogICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICBjb25zdCBpbmRleCA9IGVkZ2VJbmRpY2VzW2ldOwogICAgICBpbmRpY2VzW29mZnNldCsrXSA9IHByZXZpb3VzSW5kZXg7CiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gaW5kZXg7CiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gdmVydGV4SW5kZXg7CiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gdmVydGV4SW5kZXg7CiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gaW5kZXg7CiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gdmVydGV4SW5kZXggKyAxOwogICAgICBwcmV2aW91c0luZGV4ID0gaW5kZXg7CiAgICAgICsrdmVydGV4SW5kZXg7CiAgICB9CiAgICByZXR1cm4gb2Zmc2V0OwogIH0KICBUZXJyYWluUHJvdmlkZXIuaGVpZ2h0bWFwVGVycmFpblF1YWxpdHkgPSAwLjI1OwogIFRlcnJhaW5Qcm92aWRlci5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAgPSBmdW5jdGlvbihlbGxpcHNvaWQsIHRpbGVJbWFnZVdpZHRoLCBudW1iZXJPZlRpbGVzQXRMZXZlbFplcm8pIHsKICAgIHJldHVybiBlbGxpcHNvaWQubWF4aW11bVJhZGl1cyAqIDIgKiBNYXRoLlBJICogVGVycmFpblByb3ZpZGVyLmhlaWdodG1hcFRlcnJhaW5RdWFsaXR5IC8gKHRpbGVJbWFnZVdpZHRoICogbnVtYmVyT2ZUaWxlc0F0TGV2ZWxaZXJvKTsKICB9OwogIFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUucmVxdWVzdFRpbGVHZW9tZXRyeSA9IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7CiAgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5nZXRMZXZlbE1heGltdW1HZW9tZXRyaWNFcnJvciA9IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7CiAgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5nZXRUaWxlRGF0YUF2YWlsYWJsZSA9IERldmVsb3BlckVycm9yX2RlZmF1bHQudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7CiAgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5sb2FkVGlsZURhdGFBdmFpbGFiaWxpdHkgPSBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0LnRocm93SW5zdGFudGlhdGlvbkVycm9yOwogIHZhciBUZXJyYWluUHJvdmlkZXJfZGVmYXVsdCA9IFRlcnJhaW5Qcm92aWRlcjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0hlaWdodG1hcFRlcnJhaW5EYXRhLmpzCiAgZnVuY3Rpb24gSGVpZ2h0bWFwVGVycmFpbkRhdGEob3B0aW9ucykgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucykgfHwgIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLmJ1ZmZlcikpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMuYnVmZmVyIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy53aWR0aCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMud2lkdGggaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLmhlaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMuaGVpZ2h0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgdGhpcy5fYnVmZmVyID0gb3B0aW9ucy5idWZmZXI7CiAgICB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGg7CiAgICB0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodDsKICAgIHRoaXMuX2NoaWxkVGlsZU1hc2sgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLmNoaWxkVGlsZU1hc2ssIDE1KTsKICAgIHRoaXMuX2VuY29kaW5nID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5lbmNvZGluZywgSGVpZ2h0bWFwRW5jb2RpbmdfZGVmYXVsdC5OT05FKTsKICAgIGNvbnN0IGRlZmF1bHRTdHJ1Y3R1cmUgPSBIZWlnaHRtYXBUZXNzZWxsYXRvcl9kZWZhdWx0LkRFRkFVTFRfU1RSVUNUVVJFOwogICAgbGV0IHN0cnVjdHVyZSA9IG9wdGlvbnMuc3RydWN0dXJlOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoc3RydWN0dXJlKSkgewogICAgICBzdHJ1Y3R1cmUgPSBkZWZhdWx0U3RydWN0dXJlOwogICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmUgIT09IGRlZmF1bHRTdHJ1Y3R1cmUpIHsKICAgICAgc3RydWN0dXJlLmhlaWdodFNjYWxlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgICAgc3RydWN0dXJlLmhlaWdodFNjYWxlLAogICAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuaGVpZ2h0U2NhbGUKICAgICAgKTsKICAgICAgc3RydWN0dXJlLmhlaWdodE9mZnNldCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICAgIHN0cnVjdHVyZS5oZWlnaHRPZmZzZXQsCiAgICAgICAgZGVmYXVsdFN0cnVjdHVyZS5oZWlnaHRPZmZzZXQKICAgICAgKTsKICAgICAgc3RydWN0dXJlLmVsZW1lbnRzUGVySGVpZ2h0ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgICAgc3RydWN0dXJlLmVsZW1lbnRzUGVySGVpZ2h0LAogICAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuZWxlbWVudHNQZXJIZWlnaHQKICAgICAgKTsKICAgICAgc3RydWN0dXJlLnN0cmlkZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHN0cnVjdHVyZS5zdHJpZGUsIGRlZmF1bHRTdHJ1Y3R1cmUuc3RyaWRlKTsKICAgICAgc3RydWN0dXJlLmVsZW1lbnRNdWx0aXBsaWVyID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgICAgc3RydWN0dXJlLmVsZW1lbnRNdWx0aXBsaWVyLAogICAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuZWxlbWVudE11bHRpcGxpZXIKICAgICAgKTsKICAgICAgc3RydWN0dXJlLmlzQmlnRW5kaWFuID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgICAgc3RydWN0dXJlLmlzQmlnRW5kaWFuLAogICAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuaXNCaWdFbmRpYW4KICAgICAgKTsKICAgIH0KICAgIHRoaXMuX3N0cnVjdHVyZSA9IHN0cnVjdHVyZTsKICAgIHRoaXMuX2NyZWF0ZWRCeVVwc2FtcGxpbmcgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLmNyZWF0ZWRCeVVwc2FtcGxpbmcsIGZhbHNlKTsKICAgIHRoaXMuX3dhdGVyTWFzayA9IG9wdGlvbnMud2F0ZXJNYXNrOwogICAgdGhpcy5fc2tpcnRIZWlnaHQgPSB2b2lkIDA7CiAgICB0aGlzLl9idWZmZXJUeXBlID0gdGhpcy5fZW5jb2RpbmcgPT09IEhlaWdodG1hcEVuY29kaW5nX2RlZmF1bHQuTEVSQyA/IEZsb2F0MzJBcnJheSA6IHRoaXMuX2J1ZmZlci5jb25zdHJ1Y3RvcjsKICAgIHRoaXMuX21lc2ggPSB2b2lkIDA7CiAgfQogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlaWdodG1hcFRlcnJhaW5EYXRhLnByb3RvdHlwZSwgewogICAgY3JlZGl0czogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgIH0KICAgIH0sCiAgICB3YXRlck1hc2s6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fd2F0ZXJNYXNrOwogICAgICB9CiAgICB9LAogICAgY2hpbGRUaWxlTWFzazogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9jaGlsZFRpbGVNYXNrOwogICAgICB9CiAgICB9CiAgfSk7CiAgdmFyIGNyZWF0ZU1lc2hUYXNrTmFtZSA9ICJjcmVhdGVWZXJ0aWNlc0Zyb21IZWlnaHRtYXAiOwogIHZhciBjcmVhdGVNZXNoVGFza1Byb2Nlc3Nvck5vVGhyb3R0bGUgPSBuZXcgVGFza1Byb2Nlc3Nvcl9kZWZhdWx0KGNyZWF0ZU1lc2hUYXNrTmFtZSk7CiAgdmFyIGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yVGhyb3R0bGUgPSBuZXcgVGFza1Byb2Nlc3Nvcl9kZWZhdWx0KAogICAgY3JlYXRlTWVzaFRhc2tOYW1lLAogICAgVGVycmFpbkRhdGFfZGVmYXVsdC5tYXhpbXVtQXN5bmNocm9ub3VzVGFza3MKICApOwogIEhlaWdodG1hcFRlcnJhaW5EYXRhLnByb3RvdHlwZS5jcmVhdGVNZXNoID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMsIGRlZmF1bHRWYWx1ZV9kZWZhdWx0LkVNUFRZX09CSkVDVCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm9wdGlvbnMudGlsaW5nU2NoZW1lIiwgb3B0aW9ucy50aWxpbmdTY2hlbWUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJvcHRpb25zLngiLCBvcHRpb25zLngpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJvcHRpb25zLnkiLCBvcHRpb25zLnkpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJvcHRpb25zLmxldmVsIiwgb3B0aW9ucy5sZXZlbCk7CiAgICBjb25zdCB0aWxpbmdTY2hlbWUgPSBvcHRpb25zLnRpbGluZ1NjaGVtZTsKICAgIGNvbnN0IHggPSBvcHRpb25zLng7CiAgICBjb25zdCB5ID0gb3B0aW9ucy55OwogICAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsOwogICAgY29uc3QgZXhhZ2dlcmF0aW9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5leGFnZ2VyYXRpb24sIDEpOwogICAgY29uc3QgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgb3B0aW9ucy5leGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCwKICAgICAgMAogICAgKTsKICAgIGNvbnN0IHRocm90dGxlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy50aHJvdHRsZSwgdHJ1ZSk7CiAgICBjb25zdCBlbGxpcHNvaWQgPSB0aWxpbmdTY2hlbWUuZWxsaXBzb2lkOwogICAgY29uc3QgbmF0aXZlUmVjdGFuZ2xlID0gdGlsaW5nU2NoZW1lLnRpbGVYWVRvTmF0aXZlUmVjdGFuZ2xlKHgsIHksIGxldmVsKTsKICAgIGNvbnN0IHJlY3RhbmdsZSA9IHRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZSh4LCB5LCBsZXZlbCk7CiAgICBjb25zdCBjZW50ZXIgPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oUmVjdGFuZ2xlX2RlZmF1bHQuY2VudGVyKHJlY3RhbmdsZSkpOwogICAgY29uc3Qgc3RydWN0dXJlID0gdGhpcy5fc3RydWN0dXJlOwogICAgY29uc3QgbGV2ZWxaZXJvTWF4RXJyb3IgPSBUZXJyYWluUHJvdmlkZXJfZGVmYXVsdC5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAoCiAgICAgIGVsbGlwc29pZCwKICAgICAgdGhpcy5fd2lkdGgsCiAgICAgIHRpbGluZ1NjaGVtZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwoMCkKICAgICk7CiAgICBjb25zdCB0aGlzTGV2ZWxNYXhFcnJvciA9IGxldmVsWmVyb01heEVycm9yIC8gKDEgPDwgbGV2ZWwpOwogICAgdGhpcy5fc2tpcnRIZWlnaHQgPSBNYXRoLm1pbih0aGlzTGV2ZWxNYXhFcnJvciAqIDQsIDFlMyk7CiAgICBjb25zdCBjcmVhdGVNZXNoVGFza1Byb2Nlc3NvciA9IHRocm90dGxlID8gY3JlYXRlTWVzaFRhc2tQcm9jZXNzb3JUaHJvdHRsZSA6IGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yTm9UaHJvdHRsZTsKICAgIGNvbnN0IHZlcnRpY2VzUHJvbWlzZSA9IGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yLnNjaGVkdWxlVGFzayh7CiAgICAgIGhlaWdodG1hcDogdGhpcy5fYnVmZmVyLAogICAgICBzdHJ1Y3R1cmUsCiAgICAgIGluY2x1ZGVXZWJNZXJjYXRvclQ6IHRydWUsCiAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCwKICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsCiAgICAgIG5hdGl2ZVJlY3RhbmdsZSwKICAgICAgcmVjdGFuZ2xlLAogICAgICByZWxhdGl2ZVRvQ2VudGVyOiBjZW50ZXIsCiAgICAgIGVsbGlwc29pZCwKICAgICAgc2tpcnRIZWlnaHQ6IHRoaXMuX3NraXJ0SGVpZ2h0LAogICAgICBpc0dlb2dyYXBoaWM6IHRpbGluZ1NjaGVtZS5wcm9qZWN0aW9uIGluc3RhbmNlb2YgR2VvZ3JhcGhpY1Byb2plY3Rpb25fZGVmYXVsdCwKICAgICAgZXhhZ2dlcmF0aW9uLAogICAgICBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCwKICAgICAgZW5jb2Rpbmc6IHRoaXMuX2VuY29kaW5nCiAgICB9KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHZlcnRpY2VzUHJvbWlzZSkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGNvbnN0IHRoYXQgPSB0aGlzOwogICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJ0aWNlc1Byb21pc2UpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7CiAgICAgIGxldCBpbmRpY2VzQW5kRWRnZXM7CiAgICAgIGlmICh0aGF0Ll9za2lydEhlaWdodCA+IDApIHsKICAgICAgICBpbmRpY2VzQW5kRWRnZXMgPSBUZXJyYWluUHJvdmlkZXJfZGVmYXVsdC5nZXRSZWd1bGFyR3JpZEFuZFNraXJ0SW5kaWNlc0FuZEVkZ2VJbmRpY2VzKAogICAgICAgICAgcmVzdWx0LmdyaWRXaWR0aCwKICAgICAgICAgIHJlc3VsdC5ncmlkSGVpZ2h0CiAgICAgICAgKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbmRpY2VzQW5kRWRnZXMgPSBUZXJyYWluUHJvdmlkZXJfZGVmYXVsdC5nZXRSZWd1bGFyR3JpZEluZGljZXNBbmRFZGdlSW5kaWNlcygKICAgICAgICAgIHJlc3VsdC5ncmlkV2lkdGgsCiAgICAgICAgICByZXN1bHQuZ3JpZEhlaWdodAogICAgICAgICk7CiAgICAgIH0KICAgICAgY29uc3QgdmVydGV4Q291bnRXaXRob3V0U2tpcnRzID0gcmVzdWx0LmdyaWRXaWR0aCAqIHJlc3VsdC5ncmlkSGVpZ2h0OwogICAgICB0aGF0Ll9tZXNoID0gbmV3IFRlcnJhaW5NZXNoX2RlZmF1bHQoCiAgICAgICAgY2VudGVyLAogICAgICAgIG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LnZlcnRpY2VzKSwKICAgICAgICBpbmRpY2VzQW5kRWRnZXMuaW5kaWNlcywKICAgICAgICBpbmRpY2VzQW5kRWRnZXMuaW5kZXhDb3VudFdpdGhvdXRTa2lydHMsCiAgICAgICAgdmVydGV4Q291bnRXaXRob3V0U2tpcnRzLAogICAgICAgIHJlc3VsdC5taW5pbXVtSGVpZ2h0LAogICAgICAgIHJlc3VsdC5tYXhpbXVtSGVpZ2h0LAogICAgICAgIEJvdW5kaW5nU3BoZXJlX2RlZmF1bHQuY2xvbmUocmVzdWx0LmJvdW5kaW5nU3BoZXJlM0QpLAogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShyZXN1bHQub2NjbHVkZWVQb2ludEluU2NhbGVkU3BhY2UpLAogICAgICAgIHJlc3VsdC5udW1iZXJPZkF0dHJpYnV0ZXMsCiAgICAgICAgT3JpZW50ZWRCb3VuZGluZ0JveF9kZWZhdWx0LmNsb25lKHJlc3VsdC5vcmllbnRlZEJvdW5kaW5nQm94KSwKICAgICAgICBUZXJyYWluRW5jb2RpbmdfZGVmYXVsdC5jbG9uZShyZXN1bHQuZW5jb2RpbmcpLAogICAgICAgIGluZGljZXNBbmRFZGdlcy53ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aCwKICAgICAgICBpbmRpY2VzQW5kRWRnZXMuc291dGhJbmRpY2VzRWFzdFRvV2VzdCwKICAgICAgICBpbmRpY2VzQW5kRWRnZXMuZWFzdEluZGljZXNOb3J0aFRvU291dGgsCiAgICAgICAgaW5kaWNlc0FuZEVkZ2VzLm5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QKICAgICAgKTsKICAgICAgdGhhdC5fYnVmZmVyID0gdm9pZCAwOwogICAgICByZXR1cm4gdGhhdC5fbWVzaDsKICAgIH0pOwogIH07CiAgSGVpZ2h0bWFwVGVycmFpbkRhdGEucHJvdG90eXBlLl9jcmVhdGVNZXNoU3luYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm9iamVjdCgib3B0aW9ucy50aWxpbmdTY2hlbWUiLCBvcHRpb25zLnRpbGluZ1NjaGVtZSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoIm9wdGlvbnMueCIsIG9wdGlvbnMueCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoIm9wdGlvbnMueSIsIG9wdGlvbnMueSk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5udW1iZXIoIm9wdGlvbnMubGV2ZWwiLCBvcHRpb25zLmxldmVsKTsKICAgIGNvbnN0IHRpbGluZ1NjaGVtZSA9IG9wdGlvbnMudGlsaW5nU2NoZW1lOwogICAgY29uc3QgeCA9IG9wdGlvbnMueDsKICAgIGNvbnN0IHkgPSBvcHRpb25zLnk7CiAgICBjb25zdCBsZXZlbCA9IG9wdGlvbnMubGV2ZWw7CiAgICBjb25zdCBleGFnZ2VyYXRpb24gPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLmV4YWdnZXJhdGlvbiwgMSk7CiAgICBjb25zdCBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBvcHRpb25zLmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0LAogICAgICAwCiAgICApOwogICAgY29uc3QgZWxsaXBzb2lkID0gdGlsaW5nU2NoZW1lLmVsbGlwc29pZDsKICAgIGNvbnN0IG5hdGl2ZVJlY3RhbmdsZSA9IHRpbGluZ1NjaGVtZS50aWxlWFlUb05hdGl2ZVJlY3RhbmdsZSh4LCB5LCBsZXZlbCk7CiAgICBjb25zdCByZWN0YW5nbGUgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwpOwogICAgY29uc3QgY2VudGVyID0gZWxsaXBzb2lkLmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKFJlY3RhbmdsZV9kZWZhdWx0LmNlbnRlcihyZWN0YW5nbGUpKTsKICAgIGNvbnN0IHN0cnVjdHVyZSA9IHRoaXMuX3N0cnVjdHVyZTsKICAgIGNvbnN0IGxldmVsWmVyb01heEVycm9yID0gVGVycmFpblByb3ZpZGVyX2RlZmF1bHQuZ2V0RXN0aW1hdGVkTGV2ZWxaZXJvR2VvbWV0cmljRXJyb3JGb3JBSGVpZ2h0bWFwKAogICAgICBlbGxpcHNvaWQsCiAgICAgIHRoaXMuX3dpZHRoLAogICAgICB0aWxpbmdTY2hlbWUuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsKDApCiAgICApOwogICAgY29uc3QgdGhpc0xldmVsTWF4RXJyb3IgPSBsZXZlbFplcm9NYXhFcnJvciAvICgxIDw8IGxldmVsKTsKICAgIHRoaXMuX3NraXJ0SGVpZ2h0ID0gTWF0aC5taW4odGhpc0xldmVsTWF4RXJyb3IgKiA0LCAxZTMpOwogICAgY29uc3QgcmVzdWx0ID0gSGVpZ2h0bWFwVGVzc2VsbGF0b3JfZGVmYXVsdC5jb21wdXRlVmVydGljZXMoewogICAgICBoZWlnaHRtYXA6IHRoaXMuX2J1ZmZlciwKICAgICAgc3RydWN0dXJlLAogICAgICBpbmNsdWRlV2ViTWVyY2F0b3JUOiB0cnVlLAogICAgICB3aWR0aDogdGhpcy5fd2lkdGgsCiAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LAogICAgICBuYXRpdmVSZWN0YW5nbGUsCiAgICAgIHJlY3RhbmdsZSwKICAgICAgcmVsYXRpdmVUb0NlbnRlcjogY2VudGVyLAogICAgICBlbGxpcHNvaWQsCiAgICAgIHNraXJ0SGVpZ2h0OiB0aGlzLl9za2lydEhlaWdodCwKICAgICAgaXNHZW9ncmFwaGljOiB0aWxpbmdTY2hlbWUucHJvamVjdGlvbiBpbnN0YW5jZW9mIEdlb2dyYXBoaWNQcm9qZWN0aW9uX2RlZmF1bHQsCiAgICAgIGV4YWdnZXJhdGlvbiwKICAgICAgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQKICAgIH0pOwogICAgdGhpcy5fYnVmZmVyID0gdm9pZCAwOwogICAgbGV0IGluZGljZXNBbmRFZGdlczsKICAgIGlmICh0aGlzLl9za2lydEhlaWdodCA+IDApIHsKICAgICAgaW5kaWNlc0FuZEVkZ2VzID0gVGVycmFpblByb3ZpZGVyX2RlZmF1bHQuZ2V0UmVndWxhckdyaWRBbmRTa2lydEluZGljZXNBbmRFZGdlSW5kaWNlcygKICAgICAgICB0aGlzLl93aWR0aCwKICAgICAgICB0aGlzLl9oZWlnaHQKICAgICAgKTsKICAgIH0gZWxzZSB7CiAgICAgIGluZGljZXNBbmRFZGdlcyA9IFRlcnJhaW5Qcm92aWRlcl9kZWZhdWx0LmdldFJlZ3VsYXJHcmlkSW5kaWNlc0FuZEVkZ2VJbmRpY2VzKAogICAgICAgIHRoaXMuX3dpZHRoLAogICAgICAgIHRoaXMuX2hlaWdodAogICAgICApOwogICAgfQogICAgY29uc3QgdmVydGV4Q291bnRXaXRob3V0U2tpcnRzID0gcmVzdWx0LmdyaWRXaWR0aCAqIHJlc3VsdC5ncmlkSGVpZ2h0OwogICAgdGhpcy5fbWVzaCA9IG5ldyBUZXJyYWluTWVzaF9kZWZhdWx0KAogICAgICBjZW50ZXIsCiAgICAgIHJlc3VsdC52ZXJ0aWNlcywKICAgICAgaW5kaWNlc0FuZEVkZ2VzLmluZGljZXMsCiAgICAgIGluZGljZXNBbmRFZGdlcy5pbmRleENvdW50V2l0aG91dFNraXJ0cywKICAgICAgdmVydGV4Q291bnRXaXRob3V0U2tpcnRzLAogICAgICByZXN1bHQubWluaW11bUhlaWdodCwKICAgICAgcmVzdWx0Lm1heGltdW1IZWlnaHQsCiAgICAgIHJlc3VsdC5ib3VuZGluZ1NwaGVyZTNELAogICAgICByZXN1bHQub2NjbHVkZWVQb2ludEluU2NhbGVkU3BhY2UsCiAgICAgIHJlc3VsdC5lbmNvZGluZy5zdHJpZGUsCiAgICAgIHJlc3VsdC5vcmllbnRlZEJvdW5kaW5nQm94LAogICAgICByZXN1bHQuZW5jb2RpbmcsCiAgICAgIGluZGljZXNBbmRFZGdlcy53ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aCwKICAgICAgaW5kaWNlc0FuZEVkZ2VzLnNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsCiAgICAgIGluZGljZXNBbmRFZGdlcy5lYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCwKICAgICAgaW5kaWNlc0FuZEVkZ2VzLm5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QKICAgICk7CiAgICByZXR1cm4gdGhpcy5fbWVzaDsKICB9OwogIEhlaWdodG1hcFRlcnJhaW5EYXRhLnByb3RvdHlwZS5pbnRlcnBvbGF0ZUhlaWdodCA9IGZ1bmN0aW9uKHJlY3RhbmdsZSwgbG9uZ2l0dWRlLCBsYXRpdHVkZSkgewogICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aDsKICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2hlaWdodDsKICAgIGNvbnN0IHN0cnVjdHVyZSA9IHRoaXMuX3N0cnVjdHVyZTsKICAgIGNvbnN0IHN0cmlkZSA9IHN0cnVjdHVyZS5zdHJpZGU7CiAgICBjb25zdCBlbGVtZW50c1BlckhlaWdodCA9IHN0cnVjdHVyZS5lbGVtZW50c1BlckhlaWdodDsKICAgIGNvbnN0IGVsZW1lbnRNdWx0aXBsaWVyID0gc3RydWN0dXJlLmVsZW1lbnRNdWx0aXBsaWVyOwogICAgY29uc3QgaXNCaWdFbmRpYW4gPSBzdHJ1Y3R1cmUuaXNCaWdFbmRpYW47CiAgICBjb25zdCBoZWlnaHRPZmZzZXQgPSBzdHJ1Y3R1cmUuaGVpZ2h0T2Zmc2V0OwogICAgY29uc3QgaGVpZ2h0U2NhbGUgPSBzdHJ1Y3R1cmUuaGVpZ2h0U2NhbGU7CiAgICBjb25zdCBpc01lc2hDcmVhdGVkID0gZGVmaW5lZF9kZWZhdWx0KHRoaXMuX21lc2gpOwogICAgY29uc3QgaXNMRVJDRW5jb2RpbmcgPSB0aGlzLl9lbmNvZGluZyA9PT0gSGVpZ2h0bWFwRW5jb2RpbmdfZGVmYXVsdC5MRVJDOwogICAgY29uc3QgaXNJbnRlcnBvbGF0aW9uSW1wb3NzaWJsZSA9ICFpc01lc2hDcmVhdGVkICYmIGlzTEVSQ0VuY29kaW5nOwogICAgaWYgKGlzSW50ZXJwb2xhdGlvbkltcG9zc2libGUpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGxldCBoZWlnaHRTYW1wbGU7CiAgICBpZiAoaXNNZXNoQ3JlYXRlZCkgewogICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9tZXNoLnZlcnRpY2VzOwogICAgICBjb25zdCBlbmNvZGluZyA9IHRoaXMuX21lc2guZW5jb2Rpbmc7CiAgICAgIGhlaWdodFNhbXBsZSA9IGludGVycG9sYXRlTWVzaEhlaWdodCgKICAgICAgICBidWZmZXIsCiAgICAgICAgZW5jb2RpbmcsCiAgICAgICAgaGVpZ2h0T2Zmc2V0LAogICAgICAgIGhlaWdodFNjYWxlLAogICAgICAgIHJlY3RhbmdsZSwKICAgICAgICB3aWR0aCwKICAgICAgICBoZWlnaHQsCiAgICAgICAgbG9uZ2l0dWRlLAogICAgICAgIGxhdGl0dWRlCiAgICAgICk7CiAgICB9IGVsc2UgewogICAgICBoZWlnaHRTYW1wbGUgPSBpbnRlcnBvbGF0ZUhlaWdodCgKICAgICAgICB0aGlzLl9idWZmZXIsCiAgICAgICAgZWxlbWVudHNQZXJIZWlnaHQsCiAgICAgICAgZWxlbWVudE11bHRpcGxpZXIsCiAgICAgICAgc3RyaWRlLAogICAgICAgIGlzQmlnRW5kaWFuLAogICAgICAgIHJlY3RhbmdsZSwKICAgICAgICB3aWR0aCwKICAgICAgICBoZWlnaHQsCiAgICAgICAgbG9uZ2l0dWRlLAogICAgICAgIGxhdGl0dWRlCiAgICAgICk7CiAgICAgIGhlaWdodFNhbXBsZSA9IGhlaWdodFNhbXBsZSAqIGhlaWdodFNjYWxlICsgaGVpZ2h0T2Zmc2V0OwogICAgfQogICAgcmV0dXJuIGhlaWdodFNhbXBsZTsKICB9OwogIEhlaWdodG1hcFRlcnJhaW5EYXRhLnByb3RvdHlwZS51cHNhbXBsZSA9IGZ1bmN0aW9uKHRpbGluZ1NjaGVtZSwgdGhpc1gsIHRoaXNZLCB0aGlzTGV2ZWwsIGRlc2NlbmRhbnRYLCBkZXNjZW5kYW50WSwgZGVzY2VuZGFudExldmVsKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh0aWxpbmdTY2hlbWUpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ0aWxpbmdTY2hlbWUgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh0aGlzWCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInRoaXNYIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpc1kpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ0aGlzWSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRoaXNMZXZlbCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInRoaXNMZXZlbCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGRlc2NlbmRhbnRYKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZGVzY2VuZGFudFggaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChkZXNjZW5kYW50WSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImRlc2NlbmRhbnRZIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZGVzY2VuZGFudExldmVsKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZGVzY2VuZGFudExldmVsIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgY29uc3QgbGV2ZWxEaWZmZXJlbmNlID0gZGVzY2VuZGFudExldmVsIC0gdGhpc0xldmVsOwogICAgaWYgKGxldmVsRGlmZmVyZW5jZSA+IDEpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoCiAgICAgICAgIlVwc2FtcGxpbmcgdGhyb3VnaCBtb3JlIHRoYW4gb25lIGxldmVsIGF0IGEgdGltZSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4iCiAgICAgICk7CiAgICB9CiAgICBjb25zdCBtZXNoRGF0YSA9IHRoaXMuX21lc2g7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChtZXNoRGF0YSkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGg7CiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7CiAgICBjb25zdCBzdHJ1Y3R1cmUgPSB0aGlzLl9zdHJ1Y3R1cmU7CiAgICBjb25zdCBzdHJpZGUgPSBzdHJ1Y3R1cmUuc3RyaWRlOwogICAgY29uc3QgaGVpZ2h0cyA9IG5ldyB0aGlzLl9idWZmZXJUeXBlKHdpZHRoICogaGVpZ2h0ICogc3RyaWRlKTsKICAgIGNvbnN0IGJ1ZmZlciA9IG1lc2hEYXRhLnZlcnRpY2VzOwogICAgY29uc3QgZW5jb2RpbmcgPSBtZXNoRGF0YS5lbmNvZGluZzsKICAgIGNvbnN0IHNvdXJjZVJlY3RhbmdsZSA9IHRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZSgKICAgICAgdGhpc1gsCiAgICAgIHRoaXNZLAogICAgICB0aGlzTGV2ZWwKICAgICk7CiAgICBjb25zdCBkZXN0aW5hdGlvblJlY3RhbmdsZSA9IHRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZSgKICAgICAgZGVzY2VuZGFudFgsCiAgICAgIGRlc2NlbmRhbnRZLAogICAgICBkZXNjZW5kYW50TGV2ZWwKICAgICk7CiAgICBjb25zdCBoZWlnaHRPZmZzZXQgPSBzdHJ1Y3R1cmUuaGVpZ2h0T2Zmc2V0OwogICAgY29uc3QgaGVpZ2h0U2NhbGUgPSBzdHJ1Y3R1cmUuaGVpZ2h0U2NhbGU7CiAgICBjb25zdCBlbGVtZW50c1BlckhlaWdodCA9IHN0cnVjdHVyZS5lbGVtZW50c1BlckhlaWdodDsKICAgIGNvbnN0IGVsZW1lbnRNdWx0aXBsaWVyID0gc3RydWN0dXJlLmVsZW1lbnRNdWx0aXBsaWVyOwogICAgY29uc3QgaXNCaWdFbmRpYW4gPSBzdHJ1Y3R1cmUuaXNCaWdFbmRpYW47CiAgICBjb25zdCBkaXZpc29yID0gTWF0aC5wb3coZWxlbWVudE11bHRpcGxpZXIsIGVsZW1lbnRzUGVySGVpZ2h0IC0gMSk7CiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgKytqKSB7CiAgICAgIGNvbnN0IGxhdGl0dWRlID0gTWF0aF9kZWZhdWx0LmxlcnAoCiAgICAgICAgZGVzdGluYXRpb25SZWN0YW5nbGUubm9ydGgsCiAgICAgICAgZGVzdGluYXRpb25SZWN0YW5nbGUuc291dGgsCiAgICAgICAgaiAvIChoZWlnaHQgLSAxKQogICAgICApOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyArK2kpIHsKICAgICAgICBjb25zdCBsb25naXR1ZGUgPSBNYXRoX2RlZmF1bHQubGVycCgKICAgICAgICAgIGRlc3RpbmF0aW9uUmVjdGFuZ2xlLndlc3QsCiAgICAgICAgICBkZXN0aW5hdGlvblJlY3RhbmdsZS5lYXN0LAogICAgICAgICAgaSAvICh3aWR0aCAtIDEpCiAgICAgICAgKTsKICAgICAgICBsZXQgaGVpZ2h0U2FtcGxlID0gaW50ZXJwb2xhdGVNZXNoSGVpZ2h0KAogICAgICAgICAgYnVmZmVyLAogICAgICAgICAgZW5jb2RpbmcsCiAgICAgICAgICBoZWlnaHRPZmZzZXQsCiAgICAgICAgICBoZWlnaHRTY2FsZSwKICAgICAgICAgIHNvdXJjZVJlY3RhbmdsZSwKICAgICAgICAgIHdpZHRoLAogICAgICAgICAgaGVpZ2h0LAogICAgICAgICAgbG9uZ2l0dWRlLAogICAgICAgICAgbGF0aXR1ZGUKICAgICAgICApOwogICAgICAgIGhlaWdodFNhbXBsZSA9IGhlaWdodFNhbXBsZSA8IHN0cnVjdHVyZS5sb3dlc3RFbmNvZGVkSGVpZ2h0ID8gc3RydWN0dXJlLmxvd2VzdEVuY29kZWRIZWlnaHQgOiBoZWlnaHRTYW1wbGU7CiAgICAgICAgaGVpZ2h0U2FtcGxlID0gaGVpZ2h0U2FtcGxlID4gc3RydWN0dXJlLmhpZ2hlc3RFbmNvZGVkSGVpZ2h0ID8gc3RydWN0dXJlLmhpZ2hlc3RFbmNvZGVkSGVpZ2h0IDogaGVpZ2h0U2FtcGxlOwogICAgICAgIHNldEhlaWdodCgKICAgICAgICAgIGhlaWdodHMsCiAgICAgICAgICBlbGVtZW50c1BlckhlaWdodCwKICAgICAgICAgIGVsZW1lbnRNdWx0aXBsaWVyLAogICAgICAgICAgZGl2aXNvciwKICAgICAgICAgIHN0cmlkZSwKICAgICAgICAgIGlzQmlnRW5kaWFuLAogICAgICAgICAgaiAqIHdpZHRoICsgaSwKICAgICAgICAgIGhlaWdodFNhbXBsZQogICAgICAgICk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoCiAgICAgIG5ldyBIZWlnaHRtYXBUZXJyYWluRGF0YSh7CiAgICAgICAgYnVmZmVyOiBoZWlnaHRzLAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBjaGlsZFRpbGVNYXNrOiAwLAogICAgICAgIHN0cnVjdHVyZTogdGhpcy5fc3RydWN0dXJlLAogICAgICAgIGNyZWF0ZWRCeVVwc2FtcGxpbmc6IHRydWUKICAgICAgfSkKICAgICk7CiAgfTsKICBIZWlnaHRtYXBUZXJyYWluRGF0YS5wcm90b3R5cGUuaXNDaGlsZEF2YWlsYWJsZSA9IGZ1bmN0aW9uKHRoaXNYLCB0aGlzWSwgY2hpbGRYLCBjaGlsZFkpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRoaXNYKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidGhpc1ggaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh0aGlzWSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInRoaXNZIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY2hpbGRYKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY2hpbGRYIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoY2hpbGRZKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiY2hpbGRZIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgbGV0IGJpdE51bWJlciA9IDI7CiAgICBpZiAoY2hpbGRYICE9PSB0aGlzWCAqIDIpIHsKICAgICAgKytiaXROdW1iZXI7CiAgICB9CiAgICBpZiAoY2hpbGRZICE9PSB0aGlzWSAqIDIpIHsKICAgICAgYml0TnVtYmVyIC09IDI7CiAgICB9CiAgICByZXR1cm4gKHRoaXMuX2NoaWxkVGlsZU1hc2sgJiAxIDw8IGJpdE51bWJlcikgIT09IDA7CiAgfTsKICBIZWlnaHRtYXBUZXJyYWluRGF0YS5wcm90b3R5cGUud2FzQ3JlYXRlZEJ5VXBzYW1wbGluZyA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMuX2NyZWF0ZWRCeVVwc2FtcGxpbmc7CiAgfTsKICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUhlaWdodChzb3VyY2VIZWlnaHRzLCBlbGVtZW50c1BlckhlaWdodCwgZWxlbWVudE11bHRpcGxpZXIsIHN0cmlkZSwgaXNCaWdFbmRpYW4sIHNvdXJjZVJlY3RhbmdsZSwgd2lkdGgsIGhlaWdodCwgbG9uZ2l0dWRlLCBsYXRpdHVkZSkgewogICAgY29uc3QgZnJvbVdlc3QgPSAobG9uZ2l0dWRlIC0gc291cmNlUmVjdGFuZ2xlLndlc3QpICogKHdpZHRoIC0gMSkgLyAoc291cmNlUmVjdGFuZ2xlLmVhc3QgLSBzb3VyY2VSZWN0YW5nbGUud2VzdCk7CiAgICBjb25zdCBmcm9tU291dGggPSAobGF0aXR1ZGUgLSBzb3VyY2VSZWN0YW5nbGUuc291dGgpICogKGhlaWdodCAtIDEpIC8gKHNvdXJjZVJlY3RhbmdsZS5ub3J0aCAtIHNvdXJjZVJlY3RhbmdsZS5zb3V0aCk7CiAgICBsZXQgd2VzdEludGVnZXIgPSBmcm9tV2VzdCB8IDA7CiAgICBsZXQgZWFzdEludGVnZXIgPSB3ZXN0SW50ZWdlciArIDE7CiAgICBpZiAoZWFzdEludGVnZXIgPj0gd2lkdGgpIHsKICAgICAgZWFzdEludGVnZXIgPSB3aWR0aCAtIDE7CiAgICAgIHdlc3RJbnRlZ2VyID0gd2lkdGggLSAyOwogICAgfQogICAgbGV0IHNvdXRoSW50ZWdlciA9IGZyb21Tb3V0aCB8IDA7CiAgICBsZXQgbm9ydGhJbnRlZ2VyID0gc291dGhJbnRlZ2VyICsgMTsKICAgIGlmIChub3J0aEludGVnZXIgPj0gaGVpZ2h0KSB7CiAgICAgIG5vcnRoSW50ZWdlciA9IGhlaWdodCAtIDE7CiAgICAgIHNvdXRoSW50ZWdlciA9IGhlaWdodCAtIDI7CiAgICB9CiAgICBjb25zdCBkeCA9IGZyb21XZXN0IC0gd2VzdEludGVnZXI7CiAgICBjb25zdCBkeSA9IGZyb21Tb3V0aCAtIHNvdXRoSW50ZWdlcjsKICAgIHNvdXRoSW50ZWdlciA9IGhlaWdodCAtIDEgLSBzb3V0aEludGVnZXI7CiAgICBub3J0aEludGVnZXIgPSBoZWlnaHQgLSAxIC0gbm9ydGhJbnRlZ2VyOwogICAgY29uc3Qgc291dGh3ZXN0SGVpZ2h0ID0gZ2V0SGVpZ2h0KAogICAgICBzb3VyY2VIZWlnaHRzLAogICAgICBlbGVtZW50c1BlckhlaWdodCwKICAgICAgZWxlbWVudE11bHRpcGxpZXIsCiAgICAgIHN0cmlkZSwKICAgICAgaXNCaWdFbmRpYW4sCiAgICAgIHNvdXRoSW50ZWdlciAqIHdpZHRoICsgd2VzdEludGVnZXIKICAgICk7CiAgICBjb25zdCBzb3V0aGVhc3RIZWlnaHQgPSBnZXRIZWlnaHQoCiAgICAgIHNvdXJjZUhlaWdodHMsCiAgICAgIGVsZW1lbnRzUGVySGVpZ2h0LAogICAgICBlbGVtZW50TXVsdGlwbGllciwKICAgICAgc3RyaWRlLAogICAgICBpc0JpZ0VuZGlhbiwKICAgICAgc291dGhJbnRlZ2VyICogd2lkdGggKyBlYXN0SW50ZWdlcgogICAgKTsKICAgIGNvbnN0IG5vcnRod2VzdEhlaWdodCA9IGdldEhlaWdodCgKICAgICAgc291cmNlSGVpZ2h0cywKICAgICAgZWxlbWVudHNQZXJIZWlnaHQsCiAgICAgIGVsZW1lbnRNdWx0aXBsaWVyLAogICAgICBzdHJpZGUsCiAgICAgIGlzQmlnRW5kaWFuLAogICAgICBub3J0aEludGVnZXIgKiB3aWR0aCArIHdlc3RJbnRlZ2VyCiAgICApOwogICAgY29uc3Qgbm9ydGhlYXN0SGVpZ2h0ID0gZ2V0SGVpZ2h0KAogICAgICBzb3VyY2VIZWlnaHRzLAogICAgICBlbGVtZW50c1BlckhlaWdodCwKICAgICAgZWxlbWVudE11bHRpcGxpZXIsCiAgICAgIHN0cmlkZSwKICAgICAgaXNCaWdFbmRpYW4sCiAgICAgIG5vcnRoSW50ZWdlciAqIHdpZHRoICsgZWFzdEludGVnZXIKICAgICk7CiAgICByZXR1cm4gdHJpYW5nbGVJbnRlcnBvbGF0ZUhlaWdodCgKICAgICAgZHgsCiAgICAgIGR5LAogICAgICBzb3V0aHdlc3RIZWlnaHQsCiAgICAgIHNvdXRoZWFzdEhlaWdodCwKICAgICAgbm9ydGh3ZXN0SGVpZ2h0LAogICAgICBub3J0aGVhc3RIZWlnaHQKICAgICk7CiAgfQogIGZ1bmN0aW9uIGludGVycG9sYXRlTWVzaEhlaWdodChidWZmZXIsIGVuY29kaW5nLCBoZWlnaHRPZmZzZXQsIGhlaWdodFNjYWxlLCBzb3VyY2VSZWN0YW5nbGUsIHdpZHRoLCBoZWlnaHQsIGxvbmdpdHVkZSwgbGF0aXR1ZGUpIHsKICAgIGNvbnN0IGZyb21XZXN0ID0gKGxvbmdpdHVkZSAtIHNvdXJjZVJlY3RhbmdsZS53ZXN0KSAqICh3aWR0aCAtIDEpIC8gKHNvdXJjZVJlY3RhbmdsZS5lYXN0IC0gc291cmNlUmVjdGFuZ2xlLndlc3QpOwogICAgY29uc3QgZnJvbVNvdXRoID0gKGxhdGl0dWRlIC0gc291cmNlUmVjdGFuZ2xlLnNvdXRoKSAqIChoZWlnaHQgLSAxKSAvIChzb3VyY2VSZWN0YW5nbGUubm9ydGggLSBzb3VyY2VSZWN0YW5nbGUuc291dGgpOwogICAgbGV0IHdlc3RJbnRlZ2VyID0gZnJvbVdlc3QgfCAwOwogICAgbGV0IGVhc3RJbnRlZ2VyID0gd2VzdEludGVnZXIgKyAxOwogICAgaWYgKGVhc3RJbnRlZ2VyID49IHdpZHRoKSB7CiAgICAgIGVhc3RJbnRlZ2VyID0gd2lkdGggLSAxOwogICAgICB3ZXN0SW50ZWdlciA9IHdpZHRoIC0gMjsKICAgIH0KICAgIGxldCBzb3V0aEludGVnZXIgPSBmcm9tU291dGggfCAwOwogICAgbGV0IG5vcnRoSW50ZWdlciA9IHNvdXRoSW50ZWdlciArIDE7CiAgICBpZiAobm9ydGhJbnRlZ2VyID49IGhlaWdodCkgewogICAgICBub3J0aEludGVnZXIgPSBoZWlnaHQgLSAxOwogICAgICBzb3V0aEludGVnZXIgPSBoZWlnaHQgLSAyOwogICAgfQogICAgY29uc3QgZHggPSBmcm9tV2VzdCAtIHdlc3RJbnRlZ2VyOwogICAgY29uc3QgZHkgPSBmcm9tU291dGggLSBzb3V0aEludGVnZXI7CiAgICBzb3V0aEludGVnZXIgPSBoZWlnaHQgLSAxIC0gc291dGhJbnRlZ2VyOwogICAgbm9ydGhJbnRlZ2VyID0gaGVpZ2h0IC0gMSAtIG5vcnRoSW50ZWdlcjsKICAgIGNvbnN0IHNvdXRod2VzdEhlaWdodCA9IChlbmNvZGluZy5kZWNvZGVIZWlnaHQoYnVmZmVyLCBzb3V0aEludGVnZXIgKiB3aWR0aCArIHdlc3RJbnRlZ2VyKSAtIGhlaWdodE9mZnNldCkgLyBoZWlnaHRTY2FsZTsKICAgIGNvbnN0IHNvdXRoZWFzdEhlaWdodCA9IChlbmNvZGluZy5kZWNvZGVIZWlnaHQoYnVmZmVyLCBzb3V0aEludGVnZXIgKiB3aWR0aCArIGVhc3RJbnRlZ2VyKSAtIGhlaWdodE9mZnNldCkgLyBoZWlnaHRTY2FsZTsKICAgIGNvbnN0IG5vcnRod2VzdEhlaWdodCA9IChlbmNvZGluZy5kZWNvZGVIZWlnaHQoYnVmZmVyLCBub3J0aEludGVnZXIgKiB3aWR0aCArIHdlc3RJbnRlZ2VyKSAtIGhlaWdodE9mZnNldCkgLyBoZWlnaHRTY2FsZTsKICAgIGNvbnN0IG5vcnRoZWFzdEhlaWdodCA9IChlbmNvZGluZy5kZWNvZGVIZWlnaHQoYnVmZmVyLCBub3J0aEludGVnZXIgKiB3aWR0aCArIGVhc3RJbnRlZ2VyKSAtIGhlaWdodE9mZnNldCkgLyBoZWlnaHRTY2FsZTsKICAgIHJldHVybiB0cmlhbmdsZUludGVycG9sYXRlSGVpZ2h0KAogICAgICBkeCwKICAgICAgZHksCiAgICAgIHNvdXRod2VzdEhlaWdodCwKICAgICAgc291dGhlYXN0SGVpZ2h0LAogICAgICBub3J0aHdlc3RIZWlnaHQsCiAgICAgIG5vcnRoZWFzdEhlaWdodAogICAgKTsKICB9CiAgZnVuY3Rpb24gdHJpYW5nbGVJbnRlcnBvbGF0ZUhlaWdodChkWCwgZFksIHNvdXRod2VzdEhlaWdodCwgc291dGhlYXN0SGVpZ2h0LCBub3J0aHdlc3RIZWlnaHQsIG5vcnRoZWFzdEhlaWdodCkgewogICAgaWYgKGRZIDwgZFgpIHsKICAgICAgcmV0dXJuIHNvdXRod2VzdEhlaWdodCArIGRYICogKHNvdXRoZWFzdEhlaWdodCAtIHNvdXRod2VzdEhlaWdodCkgKyBkWSAqIChub3J0aGVhc3RIZWlnaHQgLSBzb3V0aGVhc3RIZWlnaHQpOwogICAgfQogICAgcmV0dXJuIHNvdXRod2VzdEhlaWdodCArIGRYICogKG5vcnRoZWFzdEhlaWdodCAtIG5vcnRod2VzdEhlaWdodCkgKyBkWSAqIChub3J0aHdlc3RIZWlnaHQgLSBzb3V0aHdlc3RIZWlnaHQpOwogIH0KICBmdW5jdGlvbiBnZXRIZWlnaHQoaGVpZ2h0cywgZWxlbWVudHNQZXJIZWlnaHQsIGVsZW1lbnRNdWx0aXBsaWVyLCBzdHJpZGUsIGlzQmlnRW5kaWFuLCBpbmRleCkgewogICAgaW5kZXggKj0gc3RyaWRlOwogICAgbGV0IGhlaWdodCA9IDA7CiAgICBsZXQgaTsKICAgIGlmIChpc0JpZ0VuZGlhbikgewogICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHNQZXJIZWlnaHQ7ICsraSkgewogICAgICAgIGhlaWdodCA9IGhlaWdodCAqIGVsZW1lbnRNdWx0aXBsaWVyICsgaGVpZ2h0c1tpbmRleCArIGldOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBmb3IgKGkgPSBlbGVtZW50c1BlckhlaWdodCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogZWxlbWVudE11bHRpcGxpZXIgKyBoZWlnaHRzW2luZGV4ICsgaV07CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBoZWlnaHQ7CiAgfQogIGZ1bmN0aW9uIHNldEhlaWdodChoZWlnaHRzLCBlbGVtZW50c1BlckhlaWdodCwgZWxlbWVudE11bHRpcGxpZXIsIGRpdmlzb3IsIHN0cmlkZSwgaXNCaWdFbmRpYW4sIGluZGV4LCBoZWlnaHQpIHsKICAgIGluZGV4ICo9IHN0cmlkZTsKICAgIGxldCBpOwogICAgaWYgKGlzQmlnRW5kaWFuKSB7CiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50c1BlckhlaWdodCAtIDE7ICsraSkgewogICAgICAgIGhlaWdodHNbaW5kZXggKyBpXSA9IGhlaWdodCAvIGRpdmlzb3IgfCAwOwogICAgICAgIGhlaWdodCAtPSBoZWlnaHRzW2luZGV4ICsgaV0gKiBkaXZpc29yOwogICAgICAgIGRpdmlzb3IgLz0gZWxlbWVudE11bHRpcGxpZXI7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGZvciAoaSA9IGVsZW1lbnRzUGVySGVpZ2h0IC0gMTsgaSA+IDA7IC0taSkgewogICAgICAgIGhlaWdodHNbaW5kZXggKyBpXSA9IGhlaWdodCAvIGRpdmlzb3IgfCAwOwogICAgICAgIGhlaWdodCAtPSBoZWlnaHRzW2luZGV4ICsgaV0gKiBkaXZpc29yOwogICAgICAgIGRpdmlzb3IgLz0gZWxlbWVudE11bHRpcGxpZXI7CiAgICAgIH0KICAgIH0KICAgIGhlaWdodHNbaW5kZXggKyBpXSA9IGhlaWdodDsKICB9CiAgdmFyIEhlaWdodG1hcFRlcnJhaW5EYXRhX2RlZmF1bHQgPSBIZWlnaHRtYXBUZXJyYWluRGF0YTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RpbGVBdmFpbGFiaWxpdHkuanMKICBmdW5jdGlvbiBUaWxlQXZhaWxhYmlsaXR5KHRpbGluZ1NjaGVtZSwgbWF4aW11bUxldmVsKSB7CiAgICB0aGlzLl90aWxpbmdTY2hlbWUgPSB0aWxpbmdTY2hlbWU7CiAgICB0aGlzLl9tYXhpbXVtTGV2ZWwgPSBtYXhpbXVtTGV2ZWw7CiAgICB0aGlzLl9yb290Tm9kZXMgPSBbXTsKICB9CiAgdmFyIHJlY3RhbmdsZVNjcmF0Y2ggPSBuZXcgUmVjdGFuZ2xlX2RlZmF1bHQoKTsKICBmdW5jdGlvbiBmaW5kTm9kZShsZXZlbCwgeCwgeSwgbm9kZXMpIHsKICAgIGNvbnN0IGNvdW50ID0gbm9kZXMubGVuZ3RoOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7CiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTsKICAgICAgaWYgKG5vZGUueCA9PT0geCAmJiBub2RlLnkgPT09IHkgJiYgbm9kZS5sZXZlbCA9PT0gbGV2ZWwpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH0KICBUaWxlQXZhaWxhYmlsaXR5LnByb3RvdHlwZS5hZGRBdmFpbGFibGVUaWxlUmFuZ2UgPSBmdW5jdGlvbihsZXZlbCwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkpIHsKICAgIGNvbnN0IHRpbGluZ1NjaGVtZSA9IHRoaXMuX3RpbGluZ1NjaGVtZTsKICAgIGNvbnN0IHJvb3ROb2RlcyA9IHRoaXMuX3Jvb3ROb2RlczsKICAgIGlmIChsZXZlbCA9PT0gMCkgewogICAgICBmb3IgKGxldCB5ID0gc3RhcnRZOyB5IDw9IGVuZFk7ICsreSkgewogICAgICAgIGZvciAobGV0IHggPSBzdGFydFg7IHggPD0gZW5kWDsgKyt4KSB7CiAgICAgICAgICBpZiAoIWZpbmROb2RlKGxldmVsLCB4LCB5LCByb290Tm9kZXMpKSB7CiAgICAgICAgICAgIHJvb3ROb2Rlcy5wdXNoKG5ldyBRdWFkdHJlZU5vZGUodGlsaW5nU2NoZW1lLCB2b2lkIDAsIDAsIHgsIHkpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZShzdGFydFgsIHN0YXJ0WSwgbGV2ZWwsIHJlY3RhbmdsZVNjcmF0Y2gpOwogICAgY29uc3Qgd2VzdCA9IHJlY3RhbmdsZVNjcmF0Y2gud2VzdDsKICAgIGNvbnN0IG5vcnRoID0gcmVjdGFuZ2xlU2NyYXRjaC5ub3J0aDsKICAgIHRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZShlbmRYLCBlbmRZLCBsZXZlbCwgcmVjdGFuZ2xlU2NyYXRjaCk7CiAgICBjb25zdCBlYXN0ID0gcmVjdGFuZ2xlU2NyYXRjaC5lYXN0OwogICAgY29uc3Qgc291dGggPSByZWN0YW5nbGVTY3JhdGNoLnNvdXRoOwogICAgY29uc3QgcmVjdGFuZ2xlV2l0aExldmVsID0gbmV3IFJlY3RhbmdsZVdpdGhMZXZlbCgKICAgICAgbGV2ZWwsCiAgICAgIHdlc3QsCiAgICAgIHNvdXRoLAogICAgICBlYXN0LAogICAgICBub3J0aAogICAgKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm9vdE5vZGVzLmxlbmd0aDsgKytpKSB7CiAgICAgIGNvbnN0IHJvb3ROb2RlID0gcm9vdE5vZGVzW2ldOwogICAgICBpZiAocmVjdGFuZ2xlc092ZXJsYXAocm9vdE5vZGUuZXh0ZW50LCByZWN0YW5nbGVXaXRoTGV2ZWwpKSB7CiAgICAgICAgcHV0UmVjdGFuZ2xlSW5RdWFkdHJlZSh0aGlzLl9tYXhpbXVtTGV2ZWwsIHJvb3ROb2RlLCByZWN0YW5nbGVXaXRoTGV2ZWwpOwogICAgICB9CiAgICB9CiAgfTsKICBUaWxlQXZhaWxhYmlsaXR5LnByb3RvdHlwZS5jb21wdXRlTWF4aW11bUxldmVsQXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7CiAgICBsZXQgbm9kZTsKICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDA7IG5vZGVJbmRleCA8IHRoaXMuX3Jvb3ROb2Rlcy5sZW5ndGg7ICsrbm9kZUluZGV4KSB7CiAgICAgIGNvbnN0IHJvb3ROb2RlID0gdGhpcy5fcm9vdE5vZGVzW25vZGVJbmRleF07CiAgICAgIGlmIChyZWN0YW5nbGVDb250YWluc1Bvc2l0aW9uKHJvb3ROb2RlLmV4dGVudCwgcG9zaXRpb24pKSB7CiAgICAgICAgbm9kZSA9IHJvb3ROb2RlOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChub2RlKSkgewogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICByZXR1cm4gZmluZE1heExldmVsRnJvbU5vZGUodm9pZCAwLCBub2RlLCBwb3NpdGlvbik7CiAgfTsKICB2YXIgcmVjdGFuZ2xlc1NjcmF0Y2ggPSBbXTsKICB2YXIgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWxTY3JhdGNoID0gW107CiAgdmFyIHdlc3RTY3JhdGNoID0gbmV3IFJlY3RhbmdsZV9kZWZhdWx0KCk7CiAgdmFyIGVhc3RTY3JhdGNoID0gbmV3IFJlY3RhbmdsZV9kZWZhdWx0KCk7CiAgVGlsZUF2YWlsYWJpbGl0eS5wcm90b3R5cGUuY29tcHV0ZUJlc3RBdmFpbGFibGVMZXZlbE92ZXJSZWN0YW5nbGUgPSBmdW5jdGlvbihyZWN0YW5nbGUpIHsKICAgIGNvbnN0IHJlY3RhbmdsZXMgPSByZWN0YW5nbGVzU2NyYXRjaDsKICAgIHJlY3RhbmdsZXMubGVuZ3RoID0gMDsKICAgIGlmIChyZWN0YW5nbGUuZWFzdCA8IHJlY3RhbmdsZS53ZXN0KSB7CiAgICAgIHJlY3RhbmdsZXMucHVzaCgKICAgICAgICBSZWN0YW5nbGVfZGVmYXVsdC5mcm9tUmFkaWFucygKICAgICAgICAgIC1NYXRoLlBJLAogICAgICAgICAgcmVjdGFuZ2xlLnNvdXRoLAogICAgICAgICAgcmVjdGFuZ2xlLmVhc3QsCiAgICAgICAgICByZWN0YW5nbGUubm9ydGgsCiAgICAgICAgICB3ZXN0U2NyYXRjaAogICAgICAgICkKICAgICAgKTsKICAgICAgcmVjdGFuZ2xlcy5wdXNoKAogICAgICAgIFJlY3RhbmdsZV9kZWZhdWx0LmZyb21SYWRpYW5zKAogICAgICAgICAgcmVjdGFuZ2xlLndlc3QsCiAgICAgICAgICByZWN0YW5nbGUuc291dGgsCiAgICAgICAgICBNYXRoLlBJLAogICAgICAgICAgcmVjdGFuZ2xlLm5vcnRoLAogICAgICAgICAgZWFzdFNjcmF0Y2gKICAgICAgICApCiAgICAgICk7CiAgICB9IGVsc2UgewogICAgICByZWN0YW5nbGVzLnB1c2gocmVjdGFuZ2xlKTsKICAgIH0KICAgIGNvbnN0IHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsID0gcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWxTY3JhdGNoOwogICAgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWwubGVuZ3RoID0gMDsKICAgIGxldCBpOwogICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX3Jvb3ROb2Rlcy5sZW5ndGg7ICsraSkgewogICAgICB1cGRhdGVDb3ZlcmFnZVdpdGhOb2RlKAogICAgICAgIHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsLAogICAgICAgIHRoaXMuX3Jvb3ROb2Rlc1tpXSwKICAgICAgICByZWN0YW5nbGVzCiAgICAgICk7CiAgICB9CiAgICBmb3IgKGkgPSByZW1haW5pbmdUb0NvdmVyQnlMZXZlbC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgewogICAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsW2ldKSAmJiByZW1haW5pbmdUb0NvdmVyQnlMZXZlbFtpXS5sZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIDA7CiAgfTsKICB2YXIgY2FydG9ncmFwaGljU2NyYXRjaCA9IG5ldyBDYXJ0b2dyYXBoaWNfZGVmYXVsdCgpOwogIFRpbGVBdmFpbGFiaWxpdHkucHJvdG90eXBlLmlzVGlsZUF2YWlsYWJsZSA9IGZ1bmN0aW9uKGxldmVsLCB4LCB5KSB7CiAgICBjb25zdCByZWN0YW5nbGUgPSB0aGlzLl90aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoCiAgICAgIHgsCiAgICAgIHksCiAgICAgIGxldmVsLAogICAgICByZWN0YW5nbGVTY3JhdGNoCiAgICApOwogICAgUmVjdGFuZ2xlX2RlZmF1bHQuY2VudGVyKHJlY3RhbmdsZSwgY2FydG9ncmFwaGljU2NyYXRjaCk7CiAgICByZXR1cm4gdGhpcy5jb21wdXRlTWF4aW11bUxldmVsQXRQb3NpdGlvbihjYXJ0b2dyYXBoaWNTY3JhdGNoKSA+PSBsZXZlbDsKICB9OwogIFRpbGVBdmFpbGFiaWxpdHkucHJvdG90eXBlLmNvbXB1dGVDaGlsZE1hc2tGb3JUaWxlID0gZnVuY3Rpb24obGV2ZWwsIHgsIHkpIHsKICAgIGNvbnN0IGNoaWxkTGV2ZWwgPSBsZXZlbCArIDE7CiAgICBpZiAoY2hpbGRMZXZlbCA+PSB0aGlzLl9tYXhpbXVtTGV2ZWwpIHsKICAgICAgcmV0dXJuIDA7CiAgICB9CiAgICBsZXQgbWFzayA9IDA7CiAgICBtYXNrIHw9IHRoaXMuaXNUaWxlQXZhaWxhYmxlKGNoaWxkTGV2ZWwsIDIgKiB4LCAyICogeSArIDEpID8gMSA6IDA7CiAgICBtYXNrIHw9IHRoaXMuaXNUaWxlQXZhaWxhYmxlKGNoaWxkTGV2ZWwsIDIgKiB4ICsgMSwgMiAqIHkgKyAxKSA/IDIgOiAwOwogICAgbWFzayB8PSB0aGlzLmlzVGlsZUF2YWlsYWJsZShjaGlsZExldmVsLCAyICogeCwgMiAqIHkpID8gNCA6IDA7CiAgICBtYXNrIHw9IHRoaXMuaXNUaWxlQXZhaWxhYmxlKGNoaWxkTGV2ZWwsIDIgKiB4ICsgMSwgMiAqIHkpID8gOCA6IDA7CiAgICByZXR1cm4gbWFzazsKICB9OwogIGZ1bmN0aW9uIFF1YWR0cmVlTm9kZSh0aWxpbmdTY2hlbWUsIHBhcmVudCwgbGV2ZWwsIHgsIHkpIHsKICAgIHRoaXMudGlsaW5nU2NoZW1lID0gdGlsaW5nU2NoZW1lOwogICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7CiAgICB0aGlzLmxldmVsID0gbGV2ZWw7CiAgICB0aGlzLnggPSB4OwogICAgdGhpcy55ID0geTsKICAgIHRoaXMuZXh0ZW50ID0gdGlsaW5nU2NoZW1lLnRpbGVYWVRvUmVjdGFuZ2xlKHgsIHksIGxldmVsKTsKICAgIHRoaXMucmVjdGFuZ2xlcyA9IFtdOwogICAgdGhpcy5fc3cgPSB2b2lkIDA7CiAgICB0aGlzLl9zZSA9IHZvaWQgMDsKICAgIHRoaXMuX253ID0gdm9pZCAwOwogICAgdGhpcy5fbmUgPSB2b2lkIDA7CiAgfQogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFF1YWR0cmVlTm9kZS5wcm90b3R5cGUsIHsKICAgIG53OiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKCF0aGlzLl9udykgewogICAgICAgICAgdGhpcy5fbncgPSBuZXcgUXVhZHRyZWVOb2RlKAogICAgICAgICAgICB0aGlzLnRpbGluZ1NjaGVtZSwKICAgICAgICAgICAgdGhpcywKICAgICAgICAgICAgdGhpcy5sZXZlbCArIDEsCiAgICAgICAgICAgIHRoaXMueCAqIDIsCiAgICAgICAgICAgIHRoaXMueSAqIDIKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzLl9udzsKICAgICAgfQogICAgfSwKICAgIG5lOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKCF0aGlzLl9uZSkgewogICAgICAgICAgdGhpcy5fbmUgPSBuZXcgUXVhZHRyZWVOb2RlKAogICAgICAgICAgICB0aGlzLnRpbGluZ1NjaGVtZSwKICAgICAgICAgICAgdGhpcywKICAgICAgICAgICAgdGhpcy5sZXZlbCArIDEsCiAgICAgICAgICAgIHRoaXMueCAqIDIgKyAxLAogICAgICAgICAgICB0aGlzLnkgKiAyCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5fbmU7CiAgICAgIH0KICAgIH0sCiAgICBzdzogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghdGhpcy5fc3cpIHsKICAgICAgICAgIHRoaXMuX3N3ID0gbmV3IFF1YWR0cmVlTm9kZSgKICAgICAgICAgICAgdGhpcy50aWxpbmdTY2hlbWUsCiAgICAgICAgICAgIHRoaXMsCiAgICAgICAgICAgIHRoaXMubGV2ZWwgKyAxLAogICAgICAgICAgICB0aGlzLnggKiAyLAogICAgICAgICAgICB0aGlzLnkgKiAyICsgMQogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX3N3OwogICAgICB9CiAgICB9LAogICAgc2U6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICBpZiAoIXRoaXMuX3NlKSB7CiAgICAgICAgICB0aGlzLl9zZSA9IG5ldyBRdWFkdHJlZU5vZGUoCiAgICAgICAgICAgIHRoaXMudGlsaW5nU2NoZW1lLAogICAgICAgICAgICB0aGlzLAogICAgICAgICAgICB0aGlzLmxldmVsICsgMSwKICAgICAgICAgICAgdGhpcy54ICogMiArIDEsCiAgICAgICAgICAgIHRoaXMueSAqIDIgKyAxCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5fc2U7CiAgICAgIH0KICAgIH0KICB9KTsKICBmdW5jdGlvbiBSZWN0YW5nbGVXaXRoTGV2ZWwobGV2ZWwsIHdlc3QsIHNvdXRoLCBlYXN0LCBub3J0aCkgewogICAgdGhpcy5sZXZlbCA9IGxldmVsOwogICAgdGhpcy53ZXN0ID0gd2VzdDsKICAgIHRoaXMuc291dGggPSBzb3V0aDsKICAgIHRoaXMuZWFzdCA9IGVhc3Q7CiAgICB0aGlzLm5vcnRoID0gbm9ydGg7CiAgfQogIGZ1bmN0aW9uIHJlY3RhbmdsZXNPdmVybGFwKHJlY3RhbmdsZTEsIHJlY3RhbmdsZTIpIHsKICAgIGNvbnN0IHdlc3QgPSBNYXRoLm1heChyZWN0YW5nbGUxLndlc3QsIHJlY3RhbmdsZTIud2VzdCk7CiAgICBjb25zdCBzb3V0aCA9IE1hdGgubWF4KHJlY3RhbmdsZTEuc291dGgsIHJlY3RhbmdsZTIuc291dGgpOwogICAgY29uc3QgZWFzdCA9IE1hdGgubWluKHJlY3RhbmdsZTEuZWFzdCwgcmVjdGFuZ2xlMi5lYXN0KTsKICAgIGNvbnN0IG5vcnRoID0gTWF0aC5taW4ocmVjdGFuZ2xlMS5ub3J0aCwgcmVjdGFuZ2xlMi5ub3J0aCk7CiAgICByZXR1cm4gc291dGggPCBub3J0aCAmJiB3ZXN0IDwgZWFzdDsKICB9CiAgZnVuY3Rpb24gcHV0UmVjdGFuZ2xlSW5RdWFkdHJlZShtYXhEZXB0aCwgbm9kZSwgcmVjdGFuZ2xlKSB7CiAgICB3aGlsZSAobm9kZS5sZXZlbCA8IG1heERlcHRoKSB7CiAgICAgIGlmIChyZWN0YW5nbGVGdWxseUNvbnRhaW5zUmVjdGFuZ2xlKG5vZGUubncuZXh0ZW50LCByZWN0YW5nbGUpKSB7CiAgICAgICAgbm9kZSA9IG5vZGUubnc7CiAgICAgIH0gZWxzZSBpZiAocmVjdGFuZ2xlRnVsbHlDb250YWluc1JlY3RhbmdsZShub2RlLm5lLmV4dGVudCwgcmVjdGFuZ2xlKSkgewogICAgICAgIG5vZGUgPSBub2RlLm5lOwogICAgICB9IGVsc2UgaWYgKHJlY3RhbmdsZUZ1bGx5Q29udGFpbnNSZWN0YW5nbGUobm9kZS5zdy5leHRlbnQsIHJlY3RhbmdsZSkpIHsKICAgICAgICBub2RlID0gbm9kZS5zdzsKICAgICAgfSBlbHNlIGlmIChyZWN0YW5nbGVGdWxseUNvbnRhaW5zUmVjdGFuZ2xlKG5vZGUuc2UuZXh0ZW50LCByZWN0YW5nbGUpKSB7CiAgICAgICAgbm9kZSA9IG5vZGUuc2U7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIGlmIChub2RlLnJlY3RhbmdsZXMubGVuZ3RoID09PSAwIHx8IG5vZGUucmVjdGFuZ2xlc1tub2RlLnJlY3RhbmdsZXMubGVuZ3RoIC0gMV0ubGV2ZWwgPD0gcmVjdGFuZ2xlLmxldmVsKSB7CiAgICAgIG5vZGUucmVjdGFuZ2xlcy5wdXNoKHJlY3RhbmdsZSk7CiAgICB9IGVsc2UgewogICAgICBsZXQgaW5kZXggPSBiaW5hcnlTZWFyY2hfZGVmYXVsdCgKICAgICAgICBub2RlLnJlY3RhbmdsZXMsCiAgICAgICAgcmVjdGFuZ2xlLmxldmVsLAogICAgICAgIHJlY3RhbmdsZUxldmVsQ29tcGFyYXRvcgogICAgICApOwogICAgICBpZiAoaW5kZXggPCAwKSB7CiAgICAgICAgaW5kZXggPSB+aW5kZXg7CiAgICAgIH0KICAgICAgbm9kZS5yZWN0YW5nbGVzLnNwbGljZShpbmRleCwgMCwgcmVjdGFuZ2xlKTsKICAgIH0KICB9CiAgZnVuY3Rpb24gcmVjdGFuZ2xlTGV2ZWxDb21wYXJhdG9yKGEzLCBiKSB7CiAgICByZXR1cm4gYTMubGV2ZWwgLSBiOwogIH0KICBmdW5jdGlvbiByZWN0YW5nbGVGdWxseUNvbnRhaW5zUmVjdGFuZ2xlKHBvdGVudGlhbENvbnRhaW5lciwgcmVjdGFuZ2xlVG9UZXN0KSB7CiAgICByZXR1cm4gcmVjdGFuZ2xlVG9UZXN0Lndlc3QgPj0gcG90ZW50aWFsQ29udGFpbmVyLndlc3QgJiYgcmVjdGFuZ2xlVG9UZXN0LmVhc3QgPD0gcG90ZW50aWFsQ29udGFpbmVyLmVhc3QgJiYgcmVjdGFuZ2xlVG9UZXN0LnNvdXRoID49IHBvdGVudGlhbENvbnRhaW5lci5zb3V0aCAmJiByZWN0YW5nbGVUb1Rlc3Qubm9ydGggPD0gcG90ZW50aWFsQ29udGFpbmVyLm5vcnRoOwogIH0KICBmdW5jdGlvbiByZWN0YW5nbGVDb250YWluc1Bvc2l0aW9uKHBvdGVudGlhbENvbnRhaW5lciwgcG9zaXRpb25Ub1Rlc3QpIHsKICAgIHJldHVybiBwb3NpdGlvblRvVGVzdC5sb25naXR1ZGUgPj0gcG90ZW50aWFsQ29udGFpbmVyLndlc3QgJiYgcG9zaXRpb25Ub1Rlc3QubG9uZ2l0dWRlIDw9IHBvdGVudGlhbENvbnRhaW5lci5lYXN0ICYmIHBvc2l0aW9uVG9UZXN0LmxhdGl0dWRlID49IHBvdGVudGlhbENvbnRhaW5lci5zb3V0aCAmJiBwb3NpdGlvblRvVGVzdC5sYXRpdHVkZSA8PSBwb3RlbnRpYWxDb250YWluZXIubm9ydGg7CiAgfQogIGZ1bmN0aW9uIGZpbmRNYXhMZXZlbEZyb21Ob2RlKHN0b3BOb2RlLCBub2RlLCBwb3NpdGlvbikgewogICAgbGV0IG1heExldmVsID0gMDsKICAgIGxldCBmb3VuZCA9IGZhbHNlOwogICAgd2hpbGUgKCFmb3VuZCkgewogICAgICBjb25zdCBudyA9IG5vZGUuX253ICYmIHJlY3RhbmdsZUNvbnRhaW5zUG9zaXRpb24obm9kZS5fbncuZXh0ZW50LCBwb3NpdGlvbik7CiAgICAgIGNvbnN0IG5lID0gbm9kZS5fbmUgJiYgcmVjdGFuZ2xlQ29udGFpbnNQb3NpdGlvbihub2RlLl9uZS5leHRlbnQsIHBvc2l0aW9uKTsKICAgICAgY29uc3Qgc3cgPSBub2RlLl9zdyAmJiByZWN0YW5nbGVDb250YWluc1Bvc2l0aW9uKG5vZGUuX3N3LmV4dGVudCwgcG9zaXRpb24pOwogICAgICBjb25zdCBzZSA9IG5vZGUuX3NlICYmIHJlY3RhbmdsZUNvbnRhaW5zUG9zaXRpb24obm9kZS5fc2UuZXh0ZW50LCBwb3NpdGlvbik7CiAgICAgIGlmIChudyArIG5lICsgc3cgKyBzZSA+IDEpIHsKICAgICAgICBpZiAobncpIHsKICAgICAgICAgIG1heExldmVsID0gTWF0aC5tYXgoCiAgICAgICAgICAgIG1heExldmVsLAogICAgICAgICAgICBmaW5kTWF4TGV2ZWxGcm9tTm9kZShub2RlLCBub2RlLl9udywgcG9zaXRpb24pCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBpZiAobmUpIHsKICAgICAgICAgIG1heExldmVsID0gTWF0aC5tYXgoCiAgICAgICAgICAgIG1heExldmVsLAogICAgICAgICAgICBmaW5kTWF4TGV2ZWxGcm9tTm9kZShub2RlLCBub2RlLl9uZSwgcG9zaXRpb24pCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBpZiAoc3cpIHsKICAgICAgICAgIG1heExldmVsID0gTWF0aC5tYXgoCiAgICAgICAgICAgIG1heExldmVsLAogICAgICAgICAgICBmaW5kTWF4TGV2ZWxGcm9tTm9kZShub2RlLCBub2RlLl9zdywgcG9zaXRpb24pCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBpZiAoc2UpIHsKICAgICAgICAgIG1heExldmVsID0gTWF0aC5tYXgoCiAgICAgICAgICAgIG1heExldmVsLAogICAgICAgICAgICBmaW5kTWF4TGV2ZWxGcm9tTm9kZShub2RlLCBub2RlLl9zZSwgcG9zaXRpb24pCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgfSBlbHNlIGlmIChudykgewogICAgICAgIG5vZGUgPSBub2RlLl9udzsKICAgICAgfSBlbHNlIGlmIChuZSkgewogICAgICAgIG5vZGUgPSBub2RlLl9uZTsKICAgICAgfSBlbHNlIGlmIChzdykgewogICAgICAgIG5vZGUgPSBub2RlLl9zdzsKICAgICAgfSBlbHNlIGlmIChzZSkgewogICAgICAgIG5vZGUgPSBub2RlLl9zZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgIH0KICAgIH0KICAgIHdoaWxlIChub2RlICE9PSBzdG9wTm9kZSkgewogICAgICBjb25zdCByZWN0YW5nbGVzID0gbm9kZS5yZWN0YW5nbGVzOwogICAgICBmb3IgKGxldCBpID0gcmVjdGFuZ2xlcy5sZW5ndGggLSAxOyBpID49IDAgJiYgcmVjdGFuZ2xlc1tpXS5sZXZlbCA+IG1heExldmVsOyAtLWkpIHsKICAgICAgICBjb25zdCByZWN0YW5nbGUgPSByZWN0YW5nbGVzW2ldOwogICAgICAgIGlmIChyZWN0YW5nbGVDb250YWluc1Bvc2l0aW9uKHJlY3RhbmdsZSwgcG9zaXRpb24pKSB7CiAgICAgICAgICBtYXhMZXZlbCA9IHJlY3RhbmdsZS5sZXZlbDsKICAgICAgICB9CiAgICAgIH0KICAgICAgbm9kZSA9IG5vZGUucGFyZW50OwogICAgfQogICAgcmV0dXJuIG1heExldmVsOwogIH0KICBmdW5jdGlvbiB1cGRhdGVDb3ZlcmFnZVdpdGhOb2RlKHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsLCBub2RlLCByZWN0YW5nbGVzVG9Db3ZlcikgewogICAgaWYgKCFub2RlKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGxldCBpOwogICAgbGV0IGFueU92ZXJsYXAgPSBmYWxzZTsKICAgIGZvciAoaSA9IDA7IGkgPCByZWN0YW5nbGVzVG9Db3Zlci5sZW5ndGg7ICsraSkgewogICAgICBhbnlPdmVybGFwID0gYW55T3ZlcmxhcCB8fCByZWN0YW5nbGVzT3ZlcmxhcChub2RlLmV4dGVudCwgcmVjdGFuZ2xlc1RvQ292ZXJbaV0pOwogICAgfQogICAgaWYgKCFhbnlPdmVybGFwKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IHJlY3RhbmdsZXMgPSBub2RlLnJlY3RhbmdsZXM7CiAgICBmb3IgKGkgPSAwOyBpIDwgcmVjdGFuZ2xlcy5sZW5ndGg7ICsraSkgewogICAgICBjb25zdCByZWN0YW5nbGUgPSByZWN0YW5nbGVzW2ldOwogICAgICBpZiAoIXJlbWFpbmluZ1RvQ292ZXJCeUxldmVsW3JlY3RhbmdsZS5sZXZlbF0pIHsKICAgICAgICByZW1haW5pbmdUb0NvdmVyQnlMZXZlbFtyZWN0YW5nbGUubGV2ZWxdID0gcmVjdGFuZ2xlc1RvQ292ZXI7CiAgICAgIH0KICAgICAgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWxbcmVjdGFuZ2xlLmxldmVsXSA9IHN1YnRyYWN0UmVjdGFuZ2xlKAogICAgICAgIHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsW3JlY3RhbmdsZS5sZXZlbF0sCiAgICAgICAgcmVjdGFuZ2xlCiAgICAgICk7CiAgICB9CiAgICB1cGRhdGVDb3ZlcmFnZVdpdGhOb2RlKHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsLCBub2RlLl9udywgcmVjdGFuZ2xlc1RvQ292ZXIpOwogICAgdXBkYXRlQ292ZXJhZ2VXaXRoTm9kZShyZW1haW5pbmdUb0NvdmVyQnlMZXZlbCwgbm9kZS5fbmUsIHJlY3RhbmdsZXNUb0NvdmVyKTsKICAgIHVwZGF0ZUNvdmVyYWdlV2l0aE5vZGUocmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWwsIG5vZGUuX3N3LCByZWN0YW5nbGVzVG9Db3Zlcik7CiAgICB1cGRhdGVDb3ZlcmFnZVdpdGhOb2RlKHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsLCBub2RlLl9zZSwgcmVjdGFuZ2xlc1RvQ292ZXIpOwogIH0KICBmdW5jdGlvbiBzdWJ0cmFjdFJlY3RhbmdsZShyZWN0YW5nbGVMaXN0LCByZWN0YW5nbGVUb1N1YnRyYWN0KSB7CiAgICBjb25zdCByZXN1bHQgPSBbXTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdGFuZ2xlTGlzdC5sZW5ndGg7ICsraSkgewogICAgICBjb25zdCByZWN0YW5nbGUgPSByZWN0YW5nbGVMaXN0W2ldOwogICAgICBpZiAoIXJlY3RhbmdsZXNPdmVybGFwKHJlY3RhbmdsZSwgcmVjdGFuZ2xlVG9TdWJ0cmFjdCkpIHsKICAgICAgICByZXN1bHQucHVzaChyZWN0YW5nbGUpOwogICAgICB9IGVsc2UgewogICAgICAgIGlmIChyZWN0YW5nbGUud2VzdCA8IHJlY3RhbmdsZVRvU3VidHJhY3Qud2VzdCkgewogICAgICAgICAgcmVzdWx0LnB1c2goCiAgICAgICAgICAgIG5ldyBSZWN0YW5nbGVfZGVmYXVsdCgKICAgICAgICAgICAgICByZWN0YW5nbGUud2VzdCwKICAgICAgICAgICAgICByZWN0YW5nbGUuc291dGgsCiAgICAgICAgICAgICAgcmVjdGFuZ2xlVG9TdWJ0cmFjdC53ZXN0LAogICAgICAgICAgICAgIHJlY3RhbmdsZS5ub3J0aAogICAgICAgICAgICApCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBpZiAocmVjdGFuZ2xlLmVhc3QgPiByZWN0YW5nbGVUb1N1YnRyYWN0LmVhc3QpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKAogICAgICAgICAgICBuZXcgUmVjdGFuZ2xlX2RlZmF1bHQoCiAgICAgICAgICAgICAgcmVjdGFuZ2xlVG9TdWJ0cmFjdC5lYXN0LAogICAgICAgICAgICAgIHJlY3RhbmdsZS5zb3V0aCwKICAgICAgICAgICAgICByZWN0YW5nbGUuZWFzdCwKICAgICAgICAgICAgICByZWN0YW5nbGUubm9ydGgKICAgICAgICAgICAgKQogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgaWYgKHJlY3RhbmdsZS5zb3V0aCA8IHJlY3RhbmdsZVRvU3VidHJhY3Quc291dGgpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKAogICAgICAgICAgICBuZXcgUmVjdGFuZ2xlX2RlZmF1bHQoCiAgICAgICAgICAgICAgTWF0aC5tYXgocmVjdGFuZ2xlVG9TdWJ0cmFjdC53ZXN0LCByZWN0YW5nbGUud2VzdCksCiAgICAgICAgICAgICAgcmVjdGFuZ2xlLnNvdXRoLAogICAgICAgICAgICAgIE1hdGgubWluKHJlY3RhbmdsZVRvU3VidHJhY3QuZWFzdCwgcmVjdGFuZ2xlLmVhc3QpLAogICAgICAgICAgICAgIHJlY3RhbmdsZVRvU3VidHJhY3Quc291dGgKICAgICAgICAgICAgKQogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgaWYgKHJlY3RhbmdsZS5ub3J0aCA+IHJlY3RhbmdsZVRvU3VidHJhY3Qubm9ydGgpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKAogICAgICAgICAgICBuZXcgUmVjdGFuZ2xlX2RlZmF1bHQoCiAgICAgICAgICAgICAgTWF0aC5tYXgocmVjdGFuZ2xlVG9TdWJ0cmFjdC53ZXN0LCByZWN0YW5nbGUud2VzdCksCiAgICAgICAgICAgICAgcmVjdGFuZ2xlVG9TdWJ0cmFjdC5ub3J0aCwKICAgICAgICAgICAgICBNYXRoLm1pbihyZWN0YW5nbGVUb1N1YnRyYWN0LmVhc3QsIHJlY3RhbmdsZS5lYXN0KSwKICAgICAgICAgICAgICByZWN0YW5nbGUubm9ydGgKICAgICAgICAgICAgKQogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBUaWxlQXZhaWxhYmlsaXR5X2RlZmF1bHQgPSBUaWxlQXZhaWxhYmlsaXR5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvZm9ybWF0RXJyb3IuanMKICBmdW5jdGlvbiBmb3JtYXRFcnJvcihvYmplY3QpIHsKICAgIGxldCByZXN1bHQ7CiAgICBjb25zdCBuYW1lID0gb2JqZWN0Lm5hbWU7CiAgICBjb25zdCBtZXNzYWdlID0gb2JqZWN0Lm1lc3NhZ2U7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KG5hbWUpICYmIGRlZmluZWRfZGVmYXVsdChtZXNzYWdlKSkgewogICAgICByZXN1bHQgPSBgJHtuYW1lfTogJHttZXNzYWdlfWA7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQgPSBvYmplY3QudG9TdHJpbmcoKTsKICAgIH0KICAgIGNvbnN0IHN0YWNrID0gb2JqZWN0LnN0YWNrOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChzdGFjaykpIHsKICAgICAgcmVzdWx0ICs9IGAKJHtzdGFja31gOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGZvcm1hdEVycm9yX2RlZmF1bHQgPSBmb3JtYXRFcnJvcjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RpbGVQcm92aWRlckVycm9yLmpzCiAgZnVuY3Rpb24gVGlsZVByb3ZpZGVyRXJyb3IocHJvdmlkZXIsIG1lc3NhZ2UsIHgsIHksIGxldmVsLCB0aW1lc1JldHJpZWQsIGVycm9yKSB7CiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7CiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgdGhpcy54ID0geDsKICAgIHRoaXMueSA9IHk7CiAgICB0aGlzLmxldmVsID0gbGV2ZWw7CiAgICB0aGlzLnRpbWVzUmV0cmllZCA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KHRpbWVzUmV0cmllZCwgMCk7CiAgICB0aGlzLnJldHJ5ID0gZmFsc2U7CiAgICB0aGlzLmVycm9yID0gZXJyb3I7CiAgfQogIFRpbGVQcm92aWRlckVycm9yLnJlcG9ydEVycm9yID0gZnVuY3Rpb24ocHJldmlvdXNFcnJvciwgcHJvdmlkZXIsIGV2ZW50LCBtZXNzYWdlLCB4LCB5LCBsZXZlbCwgZXJyb3JEZXRhaWxzKSB7CiAgICBsZXQgZXJyb3IgPSBwcmV2aW91c0Vycm9yOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocHJldmlvdXNFcnJvcikpIHsKICAgICAgZXJyb3IgPSBuZXcgVGlsZVByb3ZpZGVyRXJyb3IoCiAgICAgICAgcHJvdmlkZXIsCiAgICAgICAgbWVzc2FnZSwKICAgICAgICB4LAogICAgICAgIHksCiAgICAgICAgbGV2ZWwsCiAgICAgICAgMCwKICAgICAgICBlcnJvckRldGFpbHMKICAgICAgKTsKICAgIH0gZWxzZSB7CiAgICAgIGVycm9yLnByb3ZpZGVyID0gcHJvdmlkZXI7CiAgICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICBlcnJvci54ID0geDsKICAgICAgZXJyb3IueSA9IHk7CiAgICAgIGVycm9yLmxldmVsID0gbGV2ZWw7CiAgICAgIGVycm9yLnJldHJ5ID0gZmFsc2U7CiAgICAgIGVycm9yLmVycm9yID0gZXJyb3JEZXRhaWxzOwogICAgICArK2Vycm9yLnRpbWVzUmV0cmllZDsKICAgIH0KICAgIGlmIChldmVudC5udW1iZXJPZkxpc3RlbmVycyA+IDApIHsKICAgICAgZXZlbnQucmFpc2VFdmVudChlcnJvcik7CiAgICB9IGVsc2UgewogICAgICBjb25zb2xlLmxvZygKICAgICAgICBgQW4gZXJyb3Igb2NjdXJyZWQgaW4gIiR7cHJvdmlkZXIuY29uc3RydWN0b3IubmFtZX0iOiAke2Zvcm1hdEVycm9yX2RlZmF1bHQoCiAgICAgICAgICBtZXNzYWdlCiAgICAgICAgKX1gCiAgICAgICk7CiAgICB9CiAgICByZXR1cm4gZXJyb3I7CiAgfTsKICBUaWxlUHJvdmlkZXJFcnJvci5yZXBvcnRTdWNjZXNzID0gZnVuY3Rpb24ocHJldmlvdXNFcnJvcikgewogICAgaWYgKGRlZmluZWRfZGVmYXVsdChwcmV2aW91c0Vycm9yKSkgewogICAgICBwcmV2aW91c0Vycm9yLnRpbWVzUmV0cmllZCA9IC0xOwogICAgfQogIH07CiAgdmFyIFRpbGVQcm92aWRlckVycm9yX2RlZmF1bHQgPSBUaWxlUHJvdmlkZXJFcnJvcjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1dlYk1lcmNhdG9yVGlsaW5nU2NoZW1lLmpzCiAgZnVuY3Rpb24gV2ViTWVyY2F0b3JUaWxpbmdTY2hlbWUob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMsIGRlZmF1bHRWYWx1ZV9kZWZhdWx0LkVNUFRZX09CSkVDVCk7CiAgICB0aGlzLl9lbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLmVsbGlwc29pZCwgRWxsaXBzb2lkX2RlZmF1bHQuV0dTODQpOwogICAgdGhpcy5fbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1ggPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgb3B0aW9ucy5udW1iZXJPZkxldmVsWmVyb1RpbGVzWCwKICAgICAgMQogICAgKTsKICAgIHRoaXMuX251bWJlck9mTGV2ZWxaZXJvVGlsZXNZID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQoCiAgICAgIG9wdGlvbnMubnVtYmVyT2ZMZXZlbFplcm9UaWxlc1ksCiAgICAgIDEKICAgICk7CiAgICB0aGlzLl9wcm9qZWN0aW9uID0gbmV3IFdlYk1lcmNhdG9yUHJvamVjdGlvbl9kZWZhdWx0KHRoaXMuX2VsbGlwc29pZCk7CiAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMucmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnMpICYmIGRlZmluZWRfZGVmYXVsdChvcHRpb25zLnJlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzKSkgewogICAgICB0aGlzLl9yZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVycyA9IG9wdGlvbnMucmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnM7CiAgICAgIHRoaXMuX3JlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzID0gb3B0aW9ucy5yZWN0YW5nbGVOb3J0aGVhc3RJbk1ldGVyczsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IHNlbWltYWpvckF4aXNUaW1lc1BpID0gdGhpcy5fZWxsaXBzb2lkLm1heGltdW1SYWRpdXMgKiBNYXRoLlBJOwogICAgICB0aGlzLl9yZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVycyA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoCiAgICAgICAgLXNlbWltYWpvckF4aXNUaW1lc1BpLAogICAgICAgIC1zZW1pbWFqb3JBeGlzVGltZXNQaQogICAgICApOwogICAgICB0aGlzLl9yZWN0YW5nbGVOb3J0aGVhc3RJbk1ldGVycyA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoCiAgICAgICAgc2VtaW1ham9yQXhpc1RpbWVzUGksCiAgICAgICAgc2VtaW1ham9yQXhpc1RpbWVzUGkKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IHNvdXRod2VzdCA9IHRoaXMuX3Byb2plY3Rpb24udW5wcm9qZWN0KAogICAgICB0aGlzLl9yZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVycwogICAgKTsKICAgIGNvbnN0IG5vcnRoZWFzdCA9IHRoaXMuX3Byb2plY3Rpb24udW5wcm9qZWN0KAogICAgICB0aGlzLl9yZWN0YW5nbGVOb3J0aGVhc3RJbk1ldGVycwogICAgKTsKICAgIHRoaXMuX3JlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGVfZGVmYXVsdCgKICAgICAgc291dGh3ZXN0LmxvbmdpdHVkZSwKICAgICAgc291dGh3ZXN0LmxhdGl0dWRlLAogICAgICBub3J0aGVhc3QubG9uZ2l0dWRlLAogICAgICBub3J0aGVhc3QubGF0aXR1ZGUKICAgICk7CiAgfQogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lLnByb3RvdHlwZSwgewogICAgZWxsaXBzb2lkOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2VsbGlwc29pZDsKICAgICAgfQogICAgfSwKICAgIHJlY3RhbmdsZTogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9yZWN0YW5nbGU7CiAgICAgIH0KICAgIH0sCiAgICBwcm9qZWN0aW9uOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb247CiAgICAgIH0KICAgIH0KICB9KTsKICBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZS5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsID0gZnVuY3Rpb24obGV2ZWwpIHsKICAgIHJldHVybiB0aGlzLl9udW1iZXJPZkxldmVsWmVyb1RpbGVzWCA8PCBsZXZlbDsKICB9OwogIFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lLnByb3RvdHlwZS5nZXROdW1iZXJPZllUaWxlc0F0TGV2ZWwgPSBmdW5jdGlvbihsZXZlbCkgewogICAgcmV0dXJuIHRoaXMuX251bWJlck9mTGV2ZWxaZXJvVGlsZXNZIDw8IGxldmVsOwogIH07CiAgV2ViTWVyY2F0b3JUaWxpbmdTY2hlbWUucHJvdG90eXBlLnJlY3RhbmdsZVRvTmF0aXZlUmVjdGFuZ2xlID0gZnVuY3Rpb24ocmVjdGFuZ2xlLCByZXN1bHQpIHsKICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLl9wcm9qZWN0aW9uOwogICAgY29uc3Qgc291dGh3ZXN0ID0gcHJvamVjdGlvbi5wcm9qZWN0KFJlY3RhbmdsZV9kZWZhdWx0LnNvdXRod2VzdChyZWN0YW5nbGUpKTsKICAgIGNvbnN0IG5vcnRoZWFzdCA9IHByb2plY3Rpb24ucHJvamVjdChSZWN0YW5nbGVfZGVmYXVsdC5ub3J0aGVhc3QocmVjdGFuZ2xlKSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlX2RlZmF1bHQoc291dGh3ZXN0LngsIHNvdXRod2VzdC55LCBub3J0aGVhc3QueCwgbm9ydGhlYXN0LnkpOwogICAgfQogICAgcmVzdWx0Lndlc3QgPSBzb3V0aHdlc3QueDsKICAgIHJlc3VsdC5zb3V0aCA9IHNvdXRod2VzdC55OwogICAgcmVzdWx0LmVhc3QgPSBub3J0aGVhc3QueDsKICAgIHJlc3VsdC5ub3J0aCA9IG5vcnRoZWFzdC55OwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lLnByb3RvdHlwZS50aWxlWFlUb05hdGl2ZVJlY3RhbmdsZSA9IGZ1bmN0aW9uKHgsIHksIGxldmVsLCByZXN1bHQpIHsKICAgIGNvbnN0IHhUaWxlcyA9IHRoaXMuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsKGxldmVsKTsKICAgIGNvbnN0IHlUaWxlcyA9IHRoaXMuZ2V0TnVtYmVyT2ZZVGlsZXNBdExldmVsKGxldmVsKTsKICAgIGNvbnN0IHhUaWxlV2lkdGggPSAodGhpcy5fcmVjdGFuZ2xlTm9ydGhlYXN0SW5NZXRlcnMueCAtIHRoaXMuX3JlY3RhbmdsZVNvdXRod2VzdEluTWV0ZXJzLngpIC8geFRpbGVzOwogICAgY29uc3Qgd2VzdCA9IHRoaXMuX3JlY3RhbmdsZVNvdXRod2VzdEluTWV0ZXJzLnggKyB4ICogeFRpbGVXaWR0aDsKICAgIGNvbnN0IGVhc3QgPSB0aGlzLl9yZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVycy54ICsgKHggKyAxKSAqIHhUaWxlV2lkdGg7CiAgICBjb25zdCB5VGlsZUhlaWdodCA9ICh0aGlzLl9yZWN0YW5nbGVOb3J0aGVhc3RJbk1ldGVycy55IC0gdGhpcy5fcmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnMueSkgLyB5VGlsZXM7CiAgICBjb25zdCBub3J0aCA9IHRoaXMuX3JlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzLnkgLSB5ICogeVRpbGVIZWlnaHQ7CiAgICBjb25zdCBzb3V0aCA9IHRoaXMuX3JlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzLnkgLSAoeSArIDEpICogeVRpbGVIZWlnaHQ7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlX2RlZmF1bHQod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKTsKICAgIH0KICAgIHJlc3VsdC53ZXN0ID0gd2VzdDsKICAgIHJlc3VsdC5zb3V0aCA9IHNvdXRoOwogICAgcmVzdWx0LmVhc3QgPSBlYXN0OwogICAgcmVzdWx0Lm5vcnRoID0gbm9ydGg7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgV2ViTWVyY2F0b3JUaWxpbmdTY2hlbWUucHJvdG90eXBlLnRpbGVYWVRvUmVjdGFuZ2xlID0gZnVuY3Rpb24oeCwgeSwgbGV2ZWwsIHJlc3VsdCkgewogICAgY29uc3QgbmF0aXZlUmVjdGFuZ2xlID0gdGhpcy50aWxlWFlUb05hdGl2ZVJlY3RhbmdsZSh4LCB5LCBsZXZlbCwgcmVzdWx0KTsKICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLl9wcm9qZWN0aW9uOwogICAgY29uc3Qgc291dGh3ZXN0ID0gcHJvamVjdGlvbi51bnByb2plY3QoCiAgICAgIG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQobmF0aXZlUmVjdGFuZ2xlLndlc3QsIG5hdGl2ZVJlY3RhbmdsZS5zb3V0aCkKICAgICk7CiAgICBjb25zdCBub3J0aGVhc3QgPSBwcm9qZWN0aW9uLnVucHJvamVjdCgKICAgICAgbmV3IENhcnRlc2lhbjJfZGVmYXVsdChuYXRpdmVSZWN0YW5nbGUuZWFzdCwgbmF0aXZlUmVjdGFuZ2xlLm5vcnRoKQogICAgKTsKICAgIG5hdGl2ZVJlY3RhbmdsZS53ZXN0ID0gc291dGh3ZXN0LmxvbmdpdHVkZTsKICAgIG5hdGl2ZVJlY3RhbmdsZS5zb3V0aCA9IHNvdXRod2VzdC5sYXRpdHVkZTsKICAgIG5hdGl2ZVJlY3RhbmdsZS5lYXN0ID0gbm9ydGhlYXN0LmxvbmdpdHVkZTsKICAgIG5hdGl2ZVJlY3RhbmdsZS5ub3J0aCA9IG5vcnRoZWFzdC5sYXRpdHVkZTsKICAgIHJldHVybiBuYXRpdmVSZWN0YW5nbGU7CiAgfTsKICBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZS5wcm90b3R5cGUucG9zaXRpb25Ub1RpbGVYWSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBsZXZlbCwgcmVzdWx0KSB7CiAgICBjb25zdCByZWN0YW5nbGUgPSB0aGlzLl9yZWN0YW5nbGU7CiAgICBpZiAoIVJlY3RhbmdsZV9kZWZhdWx0LmNvbnRhaW5zKHJlY3RhbmdsZSwgcG9zaXRpb24pKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjb25zdCB4VGlsZXMgPSB0aGlzLmdldE51bWJlck9mWFRpbGVzQXRMZXZlbChsZXZlbCk7CiAgICBjb25zdCB5VGlsZXMgPSB0aGlzLmdldE51bWJlck9mWVRpbGVzQXRMZXZlbChsZXZlbCk7CiAgICBjb25zdCBvdmVyYWxsV2lkdGggPSB0aGlzLl9yZWN0YW5nbGVOb3J0aGVhc3RJbk1ldGVycy54IC0gdGhpcy5fcmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnMueDsKICAgIGNvbnN0IHhUaWxlV2lkdGggPSBvdmVyYWxsV2lkdGggLyB4VGlsZXM7CiAgICBjb25zdCBvdmVyYWxsSGVpZ2h0ID0gdGhpcy5fcmVjdGFuZ2xlTm9ydGhlYXN0SW5NZXRlcnMueSAtIHRoaXMuX3JlY3RhbmdsZVNvdXRod2VzdEluTWV0ZXJzLnk7CiAgICBjb25zdCB5VGlsZUhlaWdodCA9IG92ZXJhbGxIZWlnaHQgLyB5VGlsZXM7CiAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5fcHJvamVjdGlvbjsKICAgIGNvbnN0IHdlYk1lcmNhdG9yUG9zaXRpb24gPSBwcm9qZWN0aW9uLnByb2plY3QocG9zaXRpb24pOwogICAgY29uc3QgZGlzdGFuY2VGcm9tV2VzdCA9IHdlYk1lcmNhdG9yUG9zaXRpb24ueCAtIHRoaXMuX3JlY3RhbmdsZVNvdXRod2VzdEluTWV0ZXJzLng7CiAgICBjb25zdCBkaXN0YW5jZUZyb21Ob3J0aCA9IHRoaXMuX3JlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzLnkgLSB3ZWJNZXJjYXRvclBvc2l0aW9uLnk7CiAgICBsZXQgeFRpbGVDb29yZGluYXRlID0gZGlzdGFuY2VGcm9tV2VzdCAvIHhUaWxlV2lkdGggfCAwOwogICAgaWYgKHhUaWxlQ29vcmRpbmF0ZSA+PSB4VGlsZXMpIHsKICAgICAgeFRpbGVDb29yZGluYXRlID0geFRpbGVzIC0gMTsKICAgIH0KICAgIGxldCB5VGlsZUNvb3JkaW5hdGUgPSBkaXN0YW5jZUZyb21Ob3J0aCAvIHlUaWxlSGVpZ2h0IHwgMDsKICAgIGlmICh5VGlsZUNvb3JkaW5hdGUgPj0geVRpbGVzKSB7CiAgICAgIHlUaWxlQ29vcmRpbmF0ZSA9IHlUaWxlcyAtIDE7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuMl9kZWZhdWx0KHhUaWxlQ29vcmRpbmF0ZSwgeVRpbGVDb29yZGluYXRlKTsKICAgIH0KICAgIHJlc3VsdC54ID0geFRpbGVDb29yZGluYXRlOwogICAgcmVzdWx0LnkgPSB5VGlsZUNvb3JkaW5hdGU7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CiAgdmFyIFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lX2RlZmF1bHQgPSBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0ludGVyc2VjdGlvbnMyRC5qcwogIHZhciBJbnRlcnNlY3Rpb25zMkQgPSB7fTsKICBJbnRlcnNlY3Rpb25zMkQuY2xpcFRyaWFuZ2xlQXRBeGlzQWxpZ25lZFRocmVzaG9sZCA9IGZ1bmN0aW9uKHRocmVzaG9sZCwga2VlcEFib3ZlLCB1MCwgdTEsIHUyLCByZXN1bHQpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRocmVzaG9sZCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInRocmVzaG9sZCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGtlZXBBYm92ZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImtlZXBBYm92ZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHUwKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidTAgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh1MSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInUxIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodTIpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ1MiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHJlc3VsdCkpIHsKICAgICAgcmVzdWx0ID0gW107CiAgICB9IGVsc2UgewogICAgICByZXN1bHQubGVuZ3RoID0gMDsKICAgIH0KICAgIGxldCB1MEJlaGluZDsKICAgIGxldCB1MUJlaGluZDsKICAgIGxldCB1MkJlaGluZDsKICAgIGlmIChrZWVwQWJvdmUpIHsKICAgICAgdTBCZWhpbmQgPSB1MCA8IHRocmVzaG9sZDsKICAgICAgdTFCZWhpbmQgPSB1MSA8IHRocmVzaG9sZDsKICAgICAgdTJCZWhpbmQgPSB1MiA8IHRocmVzaG9sZDsKICAgIH0gZWxzZSB7CiAgICAgIHUwQmVoaW5kID0gdTAgPiB0aHJlc2hvbGQ7CiAgICAgIHUxQmVoaW5kID0gdTEgPiB0aHJlc2hvbGQ7CiAgICAgIHUyQmVoaW5kID0gdTIgPiB0aHJlc2hvbGQ7CiAgICB9CiAgICBjb25zdCBudW1CZWhpbmQgPSB1MEJlaGluZCArIHUxQmVoaW5kICsgdTJCZWhpbmQ7CiAgICBsZXQgdTAxUmF0aW87CiAgICBsZXQgdTAyUmF0aW87CiAgICBsZXQgdTEyUmF0aW87CiAgICBsZXQgdTEwUmF0aW87CiAgICBsZXQgdTIwUmF0aW87CiAgICBsZXQgdTIxUmF0aW87CiAgICBpZiAobnVtQmVoaW5kID09PSAxKSB7CiAgICAgIGlmICh1MEJlaGluZCkgewogICAgICAgIHUwMVJhdGlvID0gKHRocmVzaG9sZCAtIHUwKSAvICh1MSAtIHUwKTsKICAgICAgICB1MDJSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MCkgLyAodTIgLSB1MCk7CiAgICAgICAgcmVzdWx0LnB1c2goMSk7CiAgICAgICAgcmVzdWx0LnB1c2goMik7CiAgICAgICAgaWYgKHUwMlJhdGlvICE9PSAxKSB7CiAgICAgICAgICByZXN1bHQucHVzaCgtMSk7CiAgICAgICAgICByZXN1bHQucHVzaCgwKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKDIpOwogICAgICAgICAgcmVzdWx0LnB1c2godTAyUmF0aW8pOwogICAgICAgIH0KICAgICAgICBpZiAodTAxUmF0aW8gIT09IDEpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKC0xKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKDApOwogICAgICAgICAgcmVzdWx0LnB1c2goMSk7CiAgICAgICAgICByZXN1bHQucHVzaCh1MDFSYXRpbyk7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKHUxQmVoaW5kKSB7CiAgICAgICAgdTEyUmF0aW8gPSAodGhyZXNob2xkIC0gdTEpIC8gKHUyIC0gdTEpOwogICAgICAgIHUxMFJhdGlvID0gKHRocmVzaG9sZCAtIHUxKSAvICh1MCAtIHUxKTsKICAgICAgICByZXN1bHQucHVzaCgyKTsKICAgICAgICByZXN1bHQucHVzaCgwKTsKICAgICAgICBpZiAodTEwUmF0aW8gIT09IDEpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKC0xKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKDEpOwogICAgICAgICAgcmVzdWx0LnB1c2goMCk7CiAgICAgICAgICByZXN1bHQucHVzaCh1MTBSYXRpbyk7CiAgICAgICAgfQogICAgICAgIGlmICh1MTJSYXRpbyAhPT0gMSkgewogICAgICAgICAgcmVzdWx0LnB1c2goLTEpOwogICAgICAgICAgcmVzdWx0LnB1c2goMSk7CiAgICAgICAgICByZXN1bHQucHVzaCgyKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKHUxMlJhdGlvKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodTJCZWhpbmQpIHsKICAgICAgICB1MjBSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MikgLyAodTAgLSB1Mik7CiAgICAgICAgdTIxUmF0aW8gPSAodGhyZXNob2xkIC0gdTIpIC8gKHUxIC0gdTIpOwogICAgICAgIHJlc3VsdC5wdXNoKDApOwogICAgICAgIHJlc3VsdC5wdXNoKDEpOwogICAgICAgIGlmICh1MjFSYXRpbyAhPT0gMSkgewogICAgICAgICAgcmVzdWx0LnB1c2goLTEpOwogICAgICAgICAgcmVzdWx0LnB1c2goMik7CiAgICAgICAgICByZXN1bHQucHVzaCgxKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKHUyMVJhdGlvKTsKICAgICAgICB9CiAgICAgICAgaWYgKHUyMFJhdGlvICE9PSAxKSB7CiAgICAgICAgICByZXN1bHQucHVzaCgtMSk7CiAgICAgICAgICByZXN1bHQucHVzaCgyKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKDApOwogICAgICAgICAgcmVzdWx0LnB1c2godTIwUmF0aW8pOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIGlmIChudW1CZWhpbmQgPT09IDIpIHsKICAgICAgaWYgKCF1MEJlaGluZCAmJiB1MCAhPT0gdGhyZXNob2xkKSB7CiAgICAgICAgdTEwUmF0aW8gPSAodGhyZXNob2xkIC0gdTEpIC8gKHUwIC0gdTEpOwogICAgICAgIHUyMFJhdGlvID0gKHRocmVzaG9sZCAtIHUyKSAvICh1MCAtIHUyKTsKICAgICAgICByZXN1bHQucHVzaCgwKTsKICAgICAgICByZXN1bHQucHVzaCgtMSk7CiAgICAgICAgcmVzdWx0LnB1c2goMSk7CiAgICAgICAgcmVzdWx0LnB1c2goMCk7CiAgICAgICAgcmVzdWx0LnB1c2godTEwUmF0aW8pOwogICAgICAgIHJlc3VsdC5wdXNoKC0xKTsKICAgICAgICByZXN1bHQucHVzaCgyKTsKICAgICAgICByZXN1bHQucHVzaCgwKTsKICAgICAgICByZXN1bHQucHVzaCh1MjBSYXRpbyk7CiAgICAgIH0gZWxzZSBpZiAoIXUxQmVoaW5kICYmIHUxICE9PSB0aHJlc2hvbGQpIHsKICAgICAgICB1MjFSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MikgLyAodTEgLSB1Mik7CiAgICAgICAgdTAxUmF0aW8gPSAodGhyZXNob2xkIC0gdTApIC8gKHUxIC0gdTApOwogICAgICAgIHJlc3VsdC5wdXNoKDEpOwogICAgICAgIHJlc3VsdC5wdXNoKC0xKTsKICAgICAgICByZXN1bHQucHVzaCgyKTsKICAgICAgICByZXN1bHQucHVzaCgxKTsKICAgICAgICByZXN1bHQucHVzaCh1MjFSYXRpbyk7CiAgICAgICAgcmVzdWx0LnB1c2goLTEpOwogICAgICAgIHJlc3VsdC5wdXNoKDApOwogICAgICAgIHJlc3VsdC5wdXNoKDEpOwogICAgICAgIHJlc3VsdC5wdXNoKHUwMVJhdGlvKTsKICAgICAgfSBlbHNlIGlmICghdTJCZWhpbmQgJiYgdTIgIT09IHRocmVzaG9sZCkgewogICAgICAgIHUwMlJhdGlvID0gKHRocmVzaG9sZCAtIHUwKSAvICh1MiAtIHUwKTsKICAgICAgICB1MTJSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MSkgLyAodTIgLSB1MSk7CiAgICAgICAgcmVzdWx0LnB1c2goMik7CiAgICAgICAgcmVzdWx0LnB1c2goLTEpOwogICAgICAgIHJlc3VsdC5wdXNoKDApOwogICAgICAgIHJlc3VsdC5wdXNoKDIpOwogICAgICAgIHJlc3VsdC5wdXNoKHUwMlJhdGlvKTsKICAgICAgICByZXN1bHQucHVzaCgtMSk7CiAgICAgICAgcmVzdWx0LnB1c2goMSk7CiAgICAgICAgcmVzdWx0LnB1c2goMik7CiAgICAgICAgcmVzdWx0LnB1c2godTEyUmF0aW8pOwogICAgICB9CiAgICB9IGVsc2UgaWYgKG51bUJlaGluZCAhPT0gMykgewogICAgICByZXN1bHQucHVzaCgwKTsKICAgICAgcmVzdWx0LnB1c2goMSk7CiAgICAgIHJlc3VsdC5wdXNoKDIpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9OwogIEludGVyc2VjdGlvbnMyRC5jb21wdXRlQmFyeWNlbnRyaWNDb29yZGluYXRlcyA9IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHJlc3VsdCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoeCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInggaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh5KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgieSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHgxKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgieDEgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh5MSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInkxIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoeDIpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ4MiBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHkyKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgieTIgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh4MykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIngzIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoeTMpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ5MyBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGNvbnN0IHgxbXgzID0geDEgLSB4MzsKICAgIGNvbnN0IHgzbXgyID0geDMgLSB4MjsKICAgIGNvbnN0IHkybXkzID0geTIgLSB5MzsKICAgIGNvbnN0IHkxbXkzID0geTEgLSB5MzsKICAgIGNvbnN0IGludmVyc2VEZXRlcm1pbmFudCA9IDEgLyAoeTJteTMgKiB4MW14MyArIHgzbXgyICogeTFteTMpOwogICAgY29uc3QgeW15MyA9IHkgLSB5MzsKICAgIGNvbnN0IHhteDMgPSB4IC0geDM7CiAgICBjb25zdCBsMSA9ICh5Mm15MyAqIHhteDMgKyB4M214MiAqIHlteTMpICogaW52ZXJzZURldGVybWluYW50OwogICAgY29uc3QgbDIgPSAoLXkxbXkzICogeG14MyArIHgxbXgzICogeW15MykgKiBpbnZlcnNlRGV0ZXJtaW5hbnQ7CiAgICBjb25zdCBsMyA9IDEgLSBsMSAtIGwyOwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdC54ID0gbDE7CiAgICAgIHJlc3VsdC55ID0gbDI7CiAgICAgIHJlc3VsdC56ID0gbDM7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICByZXR1cm4gbmV3IENhcnRlc2lhbjNfZGVmYXVsdChsMSwgbDIsIGwzKTsKICB9OwogIEludGVyc2VjdGlvbnMyRC5jb21wdXRlTGluZVNlZ21lbnRMaW5lU2VnbWVudEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHgwMCwgeTAwLCB4MDEsIHkwMSwgeDEwLCB5MTAsIHgxMSwgeTExLCByZXN1bHQpIHsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieDAwIiwgeDAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieTAwIiwgeTAwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieDAxIiwgeDAxKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieTAxIiwgeTAxKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieDEwIiwgeDEwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieTEwIiwgeTEwKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieDExIiwgeDExKTsKICAgIENoZWNrX2RlZmF1bHQudHlwZU9mLm51bWJlcigieTExIiwgeTExKTsKICAgIGNvbnN0IG51bWVyYXRvcjFBID0gKHgxMSAtIHgxMCkgKiAoeTAwIC0geTEwKSAtICh5MTEgLSB5MTApICogKHgwMCAtIHgxMCk7CiAgICBjb25zdCBudW1lcmF0b3IxQiA9ICh4MDEgLSB4MDApICogKHkwMCAtIHkxMCkgLSAoeTAxIC0geTAwKSAqICh4MDAgLSB4MTApOwogICAgY29uc3QgZGVub21pbmF0b3IxID0gKHkxMSAtIHkxMCkgKiAoeDAxIC0geDAwKSAtICh4MTEgLSB4MTApICogKHkwMSAtIHkwMCk7CiAgICBpZiAoZGVub21pbmF0b3IxID09PSAwKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IHVhMSA9IG51bWVyYXRvcjFBIC8gZGVub21pbmF0b3IxOwogICAgY29uc3QgdWIxID0gbnVtZXJhdG9yMUIgLyBkZW5vbWluYXRvcjE7CiAgICBpZiAodWExID49IDAgJiYgdWExIDw9IDEgJiYgdWIxID49IDAgJiYgdWIxIDw9IDEpIHsKICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocmVzdWx0KSkgewogICAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICAgICAgfQogICAgICByZXN1bHQueCA9IHgwMCArIHVhMSAqICh4MDEgLSB4MDApOwogICAgICByZXN1bHQueSA9IHkwMCArIHVhMSAqICh5MDEgLSB5MDApOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogIH07CiAgdmFyIEludGVyc2VjdGlvbnMyRF9kZWZhdWx0ID0gSW50ZXJzZWN0aW9uczJEOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhLmpzCiAgZnVuY3Rpb24gUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhKG9wdGlvbnMpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMpIHx8ICFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5xdWFudGl6ZWRWZXJ0aWNlcykpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMucXVhbnRpemVkVmVydGljZXMgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLmluZGljZXMpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvcHRpb25zLmluZGljZXMgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLm1pbmltdW1IZWlnaHQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvcHRpb25zLm1pbmltdW1IZWlnaHQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLm1heGltdW1IZWlnaHQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvcHRpb25zLm1heGltdW1IZWlnaHQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLm1heGltdW1IZWlnaHQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvcHRpb25zLm1heGltdW1IZWlnaHQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLmJvdW5kaW5nU3BoZXJlKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib3B0aW9ucy5ib3VuZGluZ1NwaGVyZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMuaG9yaXpvbk9jY2x1c2lvblBvaW50KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib3B0aW9ucy5ob3Jpem9uT2NjbHVzaW9uUG9pbnQgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLndlc3RJbmRpY2VzKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib3B0aW9ucy53ZXN0SW5kaWNlcyBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMuc291dGhJbmRpY2VzKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib3B0aW9ucy5zb3V0aEluZGljZXMgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLmVhc3RJbmRpY2VzKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib3B0aW9ucy5lYXN0SW5kaWNlcyBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMubm9ydGhJbmRpY2VzKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib3B0aW9ucy5ub3J0aEluZGljZXMgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLndlc3RTa2lydEhlaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMud2VzdFNraXJ0SGVpZ2h0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5zb3V0aFNraXJ0SGVpZ2h0KSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgib3B0aW9ucy5zb3V0aFNraXJ0SGVpZ2h0IGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucy5lYXN0U2tpcnRIZWlnaHQpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJvcHRpb25zLmVhc3RTa2lydEhlaWdodCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMubm9ydGhTa2lydEhlaWdodCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMubm9ydGhTa2lydEhlaWdodCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIHRoaXMuX3F1YW50aXplZFZlcnRpY2VzID0gb3B0aW9ucy5xdWFudGl6ZWRWZXJ0aWNlczsKICAgIHRoaXMuX2VuY29kZWROb3JtYWxzID0gb3B0aW9ucy5lbmNvZGVkTm9ybWFsczsKICAgIHRoaXMuX2luZGljZXMgPSBvcHRpb25zLmluZGljZXM7CiAgICB0aGlzLl9taW5pbXVtSGVpZ2h0ID0gb3B0aW9ucy5taW5pbXVtSGVpZ2h0OwogICAgdGhpcy5fbWF4aW11bUhlaWdodCA9IG9wdGlvbnMubWF4aW11bUhlaWdodDsKICAgIHRoaXMuX2JvdW5kaW5nU3BoZXJlID0gb3B0aW9ucy5ib3VuZGluZ1NwaGVyZTsKICAgIHRoaXMuX29yaWVudGVkQm91bmRpbmdCb3ggPSBvcHRpb25zLm9yaWVudGVkQm91bmRpbmdCb3g7CiAgICB0aGlzLl9ob3Jpem9uT2NjbHVzaW9uUG9pbnQgPSBvcHRpb25zLmhvcml6b25PY2NsdXNpb25Qb2ludDsKICAgIHRoaXMuX2NyZWRpdHMgPSBvcHRpb25zLmNyZWRpdHM7CiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IHRoaXMuX3F1YW50aXplZFZlcnRpY2VzLmxlbmd0aCAvIDM7CiAgICBjb25zdCB1VmFsdWVzID0gdGhpcy5fdVZhbHVlcyA9IHRoaXMuX3F1YW50aXplZFZlcnRpY2VzLnN1YmFycmF5KAogICAgICAwLAogICAgICB2ZXJ0ZXhDb3VudAogICAgKTsKICAgIGNvbnN0IHZWYWx1ZXMgPSB0aGlzLl92VmFsdWVzID0gdGhpcy5fcXVhbnRpemVkVmVydGljZXMuc3ViYXJyYXkoCiAgICAgIHZlcnRleENvdW50LAogICAgICAyICogdmVydGV4Q291bnQKICAgICk7CiAgICB0aGlzLl9oZWlnaHRWYWx1ZXMgPSB0aGlzLl9xdWFudGl6ZWRWZXJ0aWNlcy5zdWJhcnJheSgKICAgICAgMiAqIHZlcnRleENvdW50LAogICAgICAzICogdmVydGV4Q291bnQKICAgICk7CiAgICBmdW5jdGlvbiBzb3J0QnlWKGEzLCBiKSB7CiAgICAgIHJldHVybiB2VmFsdWVzW2EzXSAtIHZWYWx1ZXNbYl07CiAgICB9CiAgICBmdW5jdGlvbiBzb3J0QnlVKGEzLCBiKSB7CiAgICAgIHJldHVybiB1VmFsdWVzW2EzXSAtIHVWYWx1ZXNbYl07CiAgICB9CiAgICB0aGlzLl93ZXN0SW5kaWNlcyA9IHNvcnRJbmRpY2VzSWZOZWNlc3NhcnkoCiAgICAgIG9wdGlvbnMud2VzdEluZGljZXMsCiAgICAgIHNvcnRCeVYsCiAgICAgIHZlcnRleENvdW50CiAgICApOwogICAgdGhpcy5fc291dGhJbmRpY2VzID0gc29ydEluZGljZXNJZk5lY2Vzc2FyeSgKICAgICAgb3B0aW9ucy5zb3V0aEluZGljZXMsCiAgICAgIHNvcnRCeVUsCiAgICAgIHZlcnRleENvdW50CiAgICApOwogICAgdGhpcy5fZWFzdEluZGljZXMgPSBzb3J0SW5kaWNlc0lmTmVjZXNzYXJ5KAogICAgICBvcHRpb25zLmVhc3RJbmRpY2VzLAogICAgICBzb3J0QnlWLAogICAgICB2ZXJ0ZXhDb3VudAogICAgKTsKICAgIHRoaXMuX25vcnRoSW5kaWNlcyA9IHNvcnRJbmRpY2VzSWZOZWNlc3NhcnkoCiAgICAgIG9wdGlvbnMubm9ydGhJbmRpY2VzLAogICAgICBzb3J0QnlVLAogICAgICB2ZXJ0ZXhDb3VudAogICAgKTsKICAgIHRoaXMuX3dlc3RTa2lydEhlaWdodCA9IG9wdGlvbnMud2VzdFNraXJ0SGVpZ2h0OwogICAgdGhpcy5fc291dGhTa2lydEhlaWdodCA9IG9wdGlvbnMuc291dGhTa2lydEhlaWdodDsKICAgIHRoaXMuX2Vhc3RTa2lydEhlaWdodCA9IG9wdGlvbnMuZWFzdFNraXJ0SGVpZ2h0OwogICAgdGhpcy5fbm9ydGhTa2lydEhlaWdodCA9IG9wdGlvbnMubm9ydGhTa2lydEhlaWdodDsKICAgIHRoaXMuX2NoaWxkVGlsZU1hc2sgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLmNoaWxkVGlsZU1hc2ssIDE1KTsKICAgIHRoaXMuX2NyZWF0ZWRCeVVwc2FtcGxpbmcgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLmNyZWF0ZWRCeVVwc2FtcGxpbmcsIGZhbHNlKTsKICAgIHRoaXMuX3dhdGVyTWFzayA9IG9wdGlvbnMud2F0ZXJNYXNrOwogICAgdGhpcy5fbWVzaCA9IHZvaWQgMDsKICB9CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhLnByb3RvdHlwZSwgewogICAgY3JlZGl0czogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9jcmVkaXRzOwogICAgICB9CiAgICB9LAogICAgd2F0ZXJNYXNrOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3dhdGVyTWFzazsKICAgICAgfQogICAgfSwKICAgIGNoaWxkVGlsZU1hc2s6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRUaWxlTWFzazsKICAgICAgfQogICAgfSwKICAgIGNhblVwc2FtcGxlOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIGRlZmluZWRfZGVmYXVsdCh0aGlzLl9tZXNoKTsKICAgICAgfQogICAgfQogIH0pOwogIHZhciBhcnJheVNjcmF0Y2ggPSBbXTsKICBmdW5jdGlvbiBzb3J0SW5kaWNlc0lmTmVjZXNzYXJ5KGluZGljZXMsIHNvcnRGdW5jdGlvbiwgdmVydGV4Q291bnQpIHsKICAgIGFycmF5U2NyYXRjaC5sZW5ndGggPSBpbmRpY2VzLmxlbmd0aDsKICAgIGxldCBuZWVkc1NvcnQgPSBmYWxzZTsKICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgIGFycmF5U2NyYXRjaFtpXSA9IGluZGljZXNbaV07CiAgICAgIG5lZWRzU29ydCA9IG5lZWRzU29ydCB8fCBpID4gMCAmJiBzb3J0RnVuY3Rpb24oaW5kaWNlc1tpIC0gMV0sIGluZGljZXNbaV0pID4gMDsKICAgIH0KICAgIGlmIChuZWVkc1NvcnQpIHsKICAgICAgYXJyYXlTY3JhdGNoLnNvcnQoc29ydEZ1bmN0aW9uKTsKICAgICAgcmV0dXJuIEluZGV4RGF0YXR5cGVfZGVmYXVsdC5jcmVhdGVUeXBlZEFycmF5KHZlcnRleENvdW50LCBhcnJheVNjcmF0Y2gpOwogICAgfQogICAgcmV0dXJuIGluZGljZXM7CiAgfQogIHZhciBjcmVhdGVNZXNoVGFza05hbWUyID0gImNyZWF0ZVZlcnRpY2VzRnJvbVF1YW50aXplZFRlcnJhaW5NZXNoIjsKICB2YXIgY3JlYXRlTWVzaFRhc2tQcm9jZXNzb3JOb1Rocm90dGxlMiA9IG5ldyBUYXNrUHJvY2Vzc29yX2RlZmF1bHQoY3JlYXRlTWVzaFRhc2tOYW1lMik7CiAgdmFyIGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yVGhyb3R0bGUyID0gbmV3IFRhc2tQcm9jZXNzb3JfZGVmYXVsdCgKICAgIGNyZWF0ZU1lc2hUYXNrTmFtZTIsCiAgICBUZXJyYWluRGF0YV9kZWZhdWx0Lm1heGltdW1Bc3luY2hyb25vdXNUYXNrcwogICk7CiAgUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhLnByb3RvdHlwZS5jcmVhdGVNZXNoID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMsIGRlZmF1bHRWYWx1ZV9kZWZhdWx0LkVNUFRZX09CSkVDVCk7CiAgICBDaGVja19kZWZhdWx0LnR5cGVPZi5vYmplY3QoIm9wdGlvbnMudGlsaW5nU2NoZW1lIiwgb3B0aW9ucy50aWxpbmdTY2hlbWUpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJvcHRpb25zLngiLCBvcHRpb25zLngpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJvcHRpb25zLnkiLCBvcHRpb25zLnkpOwogICAgQ2hlY2tfZGVmYXVsdC50eXBlT2YubnVtYmVyKCJvcHRpb25zLmxldmVsIiwgb3B0aW9ucy5sZXZlbCk7CiAgICBjb25zdCB0aWxpbmdTY2hlbWUgPSBvcHRpb25zLnRpbGluZ1NjaGVtZTsKICAgIGNvbnN0IHggPSBvcHRpb25zLng7CiAgICBjb25zdCB5ID0gb3B0aW9ucy55OwogICAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsOwogICAgY29uc3QgZXhhZ2dlcmF0aW9uID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5leGFnZ2VyYXRpb24sIDEpOwogICAgY29uc3QgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCgKICAgICAgb3B0aW9ucy5leGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCwKICAgICAgMAogICAgKTsKICAgIGNvbnN0IHRocm90dGxlID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy50aHJvdHRsZSwgdHJ1ZSk7CiAgICBjb25zdCBlbGxpcHNvaWQgPSB0aWxpbmdTY2hlbWUuZWxsaXBzb2lkOwogICAgY29uc3QgcmVjdGFuZ2xlID0gdGlsaW5nU2NoZW1lLnRpbGVYWVRvUmVjdGFuZ2xlKHgsIHksIGxldmVsKTsKICAgIGNvbnN0IGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yID0gdGhyb3R0bGUgPyBjcmVhdGVNZXNoVGFza1Byb2Nlc3NvclRocm90dGxlMiA6IGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yTm9UaHJvdHRsZTI7CiAgICBjb25zdCB2ZXJ0aWNlc1Byb21pc2UgPSBjcmVhdGVNZXNoVGFza1Byb2Nlc3Nvci5zY2hlZHVsZVRhc2soewogICAgICBtaW5pbXVtSGVpZ2h0OiB0aGlzLl9taW5pbXVtSGVpZ2h0LAogICAgICBtYXhpbXVtSGVpZ2h0OiB0aGlzLl9tYXhpbXVtSGVpZ2h0LAogICAgICBxdWFudGl6ZWRWZXJ0aWNlczogdGhpcy5fcXVhbnRpemVkVmVydGljZXMsCiAgICAgIG9jdEVuY29kZWROb3JtYWxzOiB0aGlzLl9lbmNvZGVkTm9ybWFscywKICAgICAgaW5jbHVkZVdlYk1lcmNhdG9yVDogdHJ1ZSwKICAgICAgaW5kaWNlczogdGhpcy5faW5kaWNlcywKICAgICAgd2VzdEluZGljZXM6IHRoaXMuX3dlc3RJbmRpY2VzLAogICAgICBzb3V0aEluZGljZXM6IHRoaXMuX3NvdXRoSW5kaWNlcywKICAgICAgZWFzdEluZGljZXM6IHRoaXMuX2Vhc3RJbmRpY2VzLAogICAgICBub3J0aEluZGljZXM6IHRoaXMuX25vcnRoSW5kaWNlcywKICAgICAgd2VzdFNraXJ0SGVpZ2h0OiB0aGlzLl93ZXN0U2tpcnRIZWlnaHQsCiAgICAgIHNvdXRoU2tpcnRIZWlnaHQ6IHRoaXMuX3NvdXRoU2tpcnRIZWlnaHQsCiAgICAgIGVhc3RTa2lydEhlaWdodDogdGhpcy5fZWFzdFNraXJ0SGVpZ2h0LAogICAgICBub3J0aFNraXJ0SGVpZ2h0OiB0aGlzLl9ub3J0aFNraXJ0SGVpZ2h0LAogICAgICByZWN0YW5nbGUsCiAgICAgIHJlbGF0aXZlVG9DZW50ZXI6IHRoaXMuX2JvdW5kaW5nU3BoZXJlLmNlbnRlciwKICAgICAgZWxsaXBzb2lkLAogICAgICBleGFnZ2VyYXRpb24sCiAgICAgIGV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0CiAgICB9KTsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHZlcnRpY2VzUHJvbWlzZSkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGNvbnN0IHRoYXQgPSB0aGlzOwogICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJ0aWNlc1Byb21pc2UpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7CiAgICAgIGNvbnN0IHZlcnRleENvdW50V2l0aG91dFNraXJ0cyA9IHRoYXQuX3F1YW50aXplZFZlcnRpY2VzLmxlbmd0aCAvIDM7CiAgICAgIGNvbnN0IHZlcnRleENvdW50ID0gdmVydGV4Q291bnRXaXRob3V0U2tpcnRzICsgdGhhdC5fd2VzdEluZGljZXMubGVuZ3RoICsgdGhhdC5fc291dGhJbmRpY2VzLmxlbmd0aCArIHRoYXQuX2Vhc3RJbmRpY2VzLmxlbmd0aCArIHRoYXQuX25vcnRoSW5kaWNlcy5sZW5ndGg7CiAgICAgIGNvbnN0IGluZGljZXNUeXBlZEFycmF5ID0gSW5kZXhEYXRhdHlwZV9kZWZhdWx0LmNyZWF0ZVR5cGVkQXJyYXkoCiAgICAgICAgdmVydGV4Q291bnQsCiAgICAgICAgcmVzdWx0LmluZGljZXMKICAgICAgKTsKICAgICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC52ZXJ0aWNlcyk7CiAgICAgIGNvbnN0IHJ0YyA9IHJlc3VsdC5jZW50ZXI7CiAgICAgIGNvbnN0IG1pbmltdW1IZWlnaHQgPSByZXN1bHQubWluaW11bUhlaWdodDsKICAgICAgY29uc3QgbWF4aW11bUhlaWdodCA9IHJlc3VsdC5tYXhpbXVtSGVpZ2h0OwogICAgICBjb25zdCBib3VuZGluZ1NwaGVyZSA9IHRoYXQuX2JvdW5kaW5nU3BoZXJlOwogICAgICBjb25zdCBvYmIgPSB0aGF0Ll9vcmllbnRlZEJvdW5kaW5nQm94OwogICAgICBjb25zdCBvY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICAgIENhcnRlc2lhbjNfZGVmYXVsdC5jbG9uZShyZXN1bHQub2NjbHVkZWVQb2ludEluU2NhbGVkU3BhY2UpLAogICAgICAgIHRoYXQuX2hvcml6b25PY2NsdXNpb25Qb2ludAogICAgICApOwogICAgICBjb25zdCBzdHJpZGUgPSByZXN1bHQudmVydGV4U3RyaWRlOwogICAgICBjb25zdCB0ZXJyYWluRW5jb2RpbmcgPSBUZXJyYWluRW5jb2RpbmdfZGVmYXVsdC5jbG9uZShyZXN1bHQuZW5jb2RpbmcpOwogICAgICB0aGF0Ll9tZXNoID0gbmV3IFRlcnJhaW5NZXNoX2RlZmF1bHQoCiAgICAgICAgcnRjLAogICAgICAgIHZlcnRpY2VzLAogICAgICAgIGluZGljZXNUeXBlZEFycmF5LAogICAgICAgIHJlc3VsdC5pbmRleENvdW50V2l0aG91dFNraXJ0cywKICAgICAgICB2ZXJ0ZXhDb3VudFdpdGhvdXRTa2lydHMsCiAgICAgICAgbWluaW11bUhlaWdodCwKICAgICAgICBtYXhpbXVtSGVpZ2h0LAogICAgICAgIGJvdW5kaW5nU3BoZXJlLAogICAgICAgIG9jY2x1ZGVlUG9pbnRJblNjYWxlZFNwYWNlLAogICAgICAgIHN0cmlkZSwKICAgICAgICBvYmIsCiAgICAgICAgdGVycmFpbkVuY29kaW5nLAogICAgICAgIHJlc3VsdC53ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aCwKICAgICAgICByZXN1bHQuc291dGhJbmRpY2VzRWFzdFRvV2VzdCwKICAgICAgICByZXN1bHQuZWFzdEluZGljZXNOb3J0aFRvU291dGgsCiAgICAgICAgcmVzdWx0Lm5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QKICAgICAgKTsKICAgICAgdGhhdC5fcXVhbnRpemVkVmVydGljZXMgPSB2b2lkIDA7CiAgICAgIHRoYXQuX2VuY29kZWROb3JtYWxzID0gdm9pZCAwOwogICAgICB0aGF0Ll9pbmRpY2VzID0gdm9pZCAwOwogICAgICB0aGF0Ll91VmFsdWVzID0gdm9pZCAwOwogICAgICB0aGF0Ll92VmFsdWVzID0gdm9pZCAwOwogICAgICB0aGF0Ll9oZWlnaHRWYWx1ZXMgPSB2b2lkIDA7CiAgICAgIHRoYXQuX3dlc3RJbmRpY2VzID0gdm9pZCAwOwogICAgICB0aGF0Ll9zb3V0aEluZGljZXMgPSB2b2lkIDA7CiAgICAgIHRoYXQuX2Vhc3RJbmRpY2VzID0gdm9pZCAwOwogICAgICB0aGF0Ll9ub3J0aEluZGljZXMgPSB2b2lkIDA7CiAgICAgIHJldHVybiB0aGF0Ll9tZXNoOwogICAgfSk7CiAgfTsKICB2YXIgdXBzYW1wbGVUYXNrUHJvY2Vzc29yID0gbmV3IFRhc2tQcm9jZXNzb3JfZGVmYXVsdCgKICAgICJ1cHNhbXBsZVF1YW50aXplZFRlcnJhaW5NZXNoIiwKICAgIFRlcnJhaW5EYXRhX2RlZmF1bHQubWF4aW11bUFzeW5jaHJvbm91c1Rhc2tzCiAgKTsKICBRdWFudGl6ZWRNZXNoVGVycmFpbkRhdGEucHJvdG90eXBlLnVwc2FtcGxlID0gZnVuY3Rpb24odGlsaW5nU2NoZW1lLCB0aGlzWCwgdGhpc1ksIHRoaXNMZXZlbCwgZGVzY2VuZGFudFgsIGRlc2NlbmRhbnRZLCBkZXNjZW5kYW50TGV2ZWwpIHsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRpbGluZ1NjaGVtZSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInRpbGluZ1NjaGVtZSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRoaXNYKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidGhpc1ggaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh0aGlzWSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInRoaXNZIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpc0xldmVsKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgidGhpc0xldmVsIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZGVzY2VuZGFudFgpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkZXNjZW5kYW50WCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGRlc2NlbmRhbnRZKSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgiZGVzY2VuZGFudFkgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChkZXNjZW5kYW50TGV2ZWwpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJkZXNjZW5kYW50TGV2ZWwgaXMgcmVxdWlyZWQuIik7CiAgICB9CiAgICBjb25zdCBsZXZlbERpZmZlcmVuY2UgPSBkZXNjZW5kYW50TGV2ZWwgLSB0aGlzTGV2ZWw7CiAgICBpZiAobGV2ZWxEaWZmZXJlbmNlID4gMSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAiVXBzYW1wbGluZyB0aHJvdWdoIG1vcmUgdGhhbiBvbmUgbGV2ZWwgYXQgYSB0aW1lIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLiIKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IG1lc2ggPSB0aGlzLl9tZXNoOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpcy5fbWVzaCkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGNvbnN0IGlzRWFzdENoaWxkID0gdGhpc1ggKiAyICE9PSBkZXNjZW5kYW50WDsKICAgIGNvbnN0IGlzTm9ydGhDaGlsZCA9IHRoaXNZICogMiA9PT0gZGVzY2VuZGFudFk7CiAgICBjb25zdCBlbGxpcHNvaWQgPSB0aWxpbmdTY2hlbWUuZWxsaXBzb2lkOwogICAgY29uc3QgY2hpbGRSZWN0YW5nbGUgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoCiAgICAgIGRlc2NlbmRhbnRYLAogICAgICBkZXNjZW5kYW50WSwKICAgICAgZGVzY2VuZGFudExldmVsCiAgICApOwogICAgY29uc3QgdXBzYW1wbGVQcm9taXNlID0gdXBzYW1wbGVUYXNrUHJvY2Vzc29yLnNjaGVkdWxlVGFzayh7CiAgICAgIHZlcnRpY2VzOiBtZXNoLnZlcnRpY2VzLAogICAgICB2ZXJ0ZXhDb3VudFdpdGhvdXRTa2lydHM6IG1lc2gudmVydGV4Q291bnRXaXRob3V0U2tpcnRzLAogICAgICBpbmRpY2VzOiBtZXNoLmluZGljZXMsCiAgICAgIGluZGV4Q291bnRXaXRob3V0U2tpcnRzOiBtZXNoLmluZGV4Q291bnRXaXRob3V0U2tpcnRzLAogICAgICBlbmNvZGluZzogbWVzaC5lbmNvZGluZywKICAgICAgbWluaW11bUhlaWdodDogdGhpcy5fbWluaW11bUhlaWdodCwKICAgICAgbWF4aW11bUhlaWdodDogdGhpcy5fbWF4aW11bUhlaWdodCwKICAgICAgaXNFYXN0Q2hpbGQsCiAgICAgIGlzTm9ydGhDaGlsZCwKICAgICAgY2hpbGRSZWN0YW5nbGUsCiAgICAgIGVsbGlwc29pZAogICAgfSk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh1cHNhbXBsZVByb21pc2UpKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBsZXQgc2hvcnRlc3RTa2lydCA9IE1hdGgubWluKHRoaXMuX3dlc3RTa2lydEhlaWdodCwgdGhpcy5fZWFzdFNraXJ0SGVpZ2h0KTsKICAgIHNob3J0ZXN0U2tpcnQgPSBNYXRoLm1pbihzaG9ydGVzdFNraXJ0LCB0aGlzLl9zb3V0aFNraXJ0SGVpZ2h0KTsKICAgIHNob3J0ZXN0U2tpcnQgPSBNYXRoLm1pbihzaG9ydGVzdFNraXJ0LCB0aGlzLl9ub3J0aFNraXJ0SGVpZ2h0KTsKICAgIGNvbnN0IHdlc3RTa2lydEhlaWdodCA9IGlzRWFzdENoaWxkID8gc2hvcnRlc3RTa2lydCAqIDAuNSA6IHRoaXMuX3dlc3RTa2lydEhlaWdodDsKICAgIGNvbnN0IHNvdXRoU2tpcnRIZWlnaHQgPSBpc05vcnRoQ2hpbGQgPyBzaG9ydGVzdFNraXJ0ICogMC41IDogdGhpcy5fc291dGhTa2lydEhlaWdodDsKICAgIGNvbnN0IGVhc3RTa2lydEhlaWdodCA9IGlzRWFzdENoaWxkID8gdGhpcy5fZWFzdFNraXJ0SGVpZ2h0IDogc2hvcnRlc3RTa2lydCAqIDAuNTsKICAgIGNvbnN0IG5vcnRoU2tpcnRIZWlnaHQgPSBpc05vcnRoQ2hpbGQgPyB0aGlzLl9ub3J0aFNraXJ0SGVpZ2h0IDogc2hvcnRlc3RTa2lydCAqIDAuNTsKICAgIGNvbnN0IGNyZWRpdHMgPSB0aGlzLl9jcmVkaXRzOwogICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cHNhbXBsZVByb21pc2UpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7CiAgICAgIGNvbnN0IHF1YW50aXplZFZlcnRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHJlc3VsdC52ZXJ0aWNlcyk7CiAgICAgIGNvbnN0IGluZGljZXNUeXBlZEFycmF5ID0gSW5kZXhEYXRhdHlwZV9kZWZhdWx0LmNyZWF0ZVR5cGVkQXJyYXkoCiAgICAgICAgcXVhbnRpemVkVmVydGljZXMubGVuZ3RoIC8gMywKICAgICAgICByZXN1bHQuaW5kaWNlcwogICAgICApOwogICAgICBsZXQgZW5jb2RlZE5vcm1hbHM7CiAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQocmVzdWx0LmVuY29kZWROb3JtYWxzKSkgewogICAgICAgIGVuY29kZWROb3JtYWxzID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0LmVuY29kZWROb3JtYWxzKTsKICAgICAgfQogICAgICByZXR1cm4gbmV3IFF1YW50aXplZE1lc2hUZXJyYWluRGF0YSh7CiAgICAgICAgcXVhbnRpemVkVmVydGljZXMsCiAgICAgICAgaW5kaWNlczogaW5kaWNlc1R5cGVkQXJyYXksCiAgICAgICAgZW5jb2RlZE5vcm1hbHMsCiAgICAgICAgbWluaW11bUhlaWdodDogcmVzdWx0Lm1pbmltdW1IZWlnaHQsCiAgICAgICAgbWF4aW11bUhlaWdodDogcmVzdWx0Lm1heGltdW1IZWlnaHQsCiAgICAgICAgYm91bmRpbmdTcGhlcmU6IEJvdW5kaW5nU3BoZXJlX2RlZmF1bHQuY2xvbmUocmVzdWx0LmJvdW5kaW5nU3BoZXJlKSwKICAgICAgICBvcmllbnRlZEJvdW5kaW5nQm94OiBPcmllbnRlZEJvdW5kaW5nQm94X2RlZmF1bHQuY2xvbmUoCiAgICAgICAgICByZXN1bHQub3JpZW50ZWRCb3VuZGluZ0JveAogICAgICAgICksCiAgICAgICAgaG9yaXpvbk9jY2x1c2lvblBvaW50OiBDYXJ0ZXNpYW4zX2RlZmF1bHQuY2xvbmUocmVzdWx0Lmhvcml6b25PY2NsdXNpb25Qb2ludCksCiAgICAgICAgd2VzdEluZGljZXM6IHJlc3VsdC53ZXN0SW5kaWNlcywKICAgICAgICBzb3V0aEluZGljZXM6IHJlc3VsdC5zb3V0aEluZGljZXMsCiAgICAgICAgZWFzdEluZGljZXM6IHJlc3VsdC5lYXN0SW5kaWNlcywKICAgICAgICBub3J0aEluZGljZXM6IHJlc3VsdC5ub3J0aEluZGljZXMsCiAgICAgICAgd2VzdFNraXJ0SGVpZ2h0LAogICAgICAgIHNvdXRoU2tpcnRIZWlnaHQsCiAgICAgICAgZWFzdFNraXJ0SGVpZ2h0LAogICAgICAgIG5vcnRoU2tpcnRIZWlnaHQsCiAgICAgICAgY2hpbGRUaWxlTWFzazogMCwKICAgICAgICBjcmVkaXRzLAogICAgICAgIGNyZWF0ZWRCeVVwc2FtcGxpbmc6IHRydWUKICAgICAgfSk7CiAgICB9KTsKICB9OwogIHZhciBtYXhTaG9ydCA9IDMyNzY3OwogIHZhciBiYXJ5Y2VudHJpY0Nvb3JkaW5hdGVTY3JhdGNoID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgpOwogIFF1YW50aXplZE1lc2hUZXJyYWluRGF0YS5wcm90b3R5cGUuaW50ZXJwb2xhdGVIZWlnaHQgPSBmdW5jdGlvbihyZWN0YW5nbGUsIGxvbmdpdHVkZSwgbGF0aXR1ZGUpIHsKICAgIGxldCB1MiA9IE1hdGhfZGVmYXVsdC5jbGFtcCgKICAgICAgKGxvbmdpdHVkZSAtIHJlY3RhbmdsZS53ZXN0KSAvIHJlY3RhbmdsZS53aWR0aCwKICAgICAgMCwKICAgICAgMQogICAgKTsKICAgIHUyICo9IG1heFNob3J0OwogICAgbGV0IHYyID0gTWF0aF9kZWZhdWx0LmNsYW1wKAogICAgICAobGF0aXR1ZGUgLSByZWN0YW5nbGUuc291dGgpIC8gcmVjdGFuZ2xlLmhlaWdodCwKICAgICAgMCwKICAgICAgMQogICAgKTsKICAgIHYyICo9IG1heFNob3J0OwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpcy5fbWVzaCkpIHsKICAgICAgcmV0dXJuIGludGVycG9sYXRlSGVpZ2h0Mih0aGlzLCB1MiwgdjIpOwogICAgfQogICAgcmV0dXJuIGludGVycG9sYXRlTWVzaEhlaWdodDIodGhpcywgdTIsIHYyKTsKICB9OwogIGZ1bmN0aW9uIHBvaW50SW5Cb3VuZGluZ0JveCh1MiwgdjIsIHUwLCB2MCwgdTEsIHYxLCB1MjIsIHYyMikgewogICAgY29uc3QgbWluVSA9IE1hdGgubWluKHUwLCB1MSwgdTIyKTsKICAgIGNvbnN0IG1heFUgPSBNYXRoLm1heCh1MCwgdTEsIHUyMik7CiAgICBjb25zdCBtaW5WID0gTWF0aC5taW4odjAsIHYxLCB2MjIpOwogICAgY29uc3QgbWF4ViA9IE1hdGgubWF4KHYwLCB2MSwgdjIyKTsKICAgIHJldHVybiB1MiA+PSBtaW5VICYmIHUyIDw9IG1heFUgJiYgdjIgPj0gbWluViAmJiB2MiA8PSBtYXhWOwogIH0KICB2YXIgdGV4Q29vcmRTY3JhdGNoMCA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICB2YXIgdGV4Q29vcmRTY3JhdGNoMSA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICB2YXIgdGV4Q29vcmRTY3JhdGNoMiA9IG5ldyBDYXJ0ZXNpYW4yX2RlZmF1bHQoKTsKICBmdW5jdGlvbiBpbnRlcnBvbGF0ZU1lc2hIZWlnaHQyKHRlcnJhaW5EYXRhLCB1MiwgdjIpIHsKICAgIGNvbnN0IG1lc2ggPSB0ZXJyYWluRGF0YS5fbWVzaDsKICAgIGNvbnN0IHZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlczsKICAgIGNvbnN0IGVuY29kaW5nID0gbWVzaC5lbmNvZGluZzsKICAgIGNvbnN0IGluZGljZXMgPSBtZXNoLmluZGljZXM7CiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykgewogICAgICBjb25zdCBpMCA9IGluZGljZXNbaV07CiAgICAgIGNvbnN0IGkxID0gaW5kaWNlc1tpICsgMV07CiAgICAgIGNvbnN0IGkyID0gaW5kaWNlc1tpICsgMl07CiAgICAgIGNvbnN0IHV2MCA9IGVuY29kaW5nLmRlY29kZVRleHR1cmVDb29yZGluYXRlcygKICAgICAgICB2ZXJ0aWNlcywKICAgICAgICBpMCwKICAgICAgICB0ZXhDb29yZFNjcmF0Y2gwCiAgICAgICk7CiAgICAgIGNvbnN0IHV2MSA9IGVuY29kaW5nLmRlY29kZVRleHR1cmVDb29yZGluYXRlcygKICAgICAgICB2ZXJ0aWNlcywKICAgICAgICBpMSwKICAgICAgICB0ZXhDb29yZFNjcmF0Y2gxCiAgICAgICk7CiAgICAgIGNvbnN0IHV2MiA9IGVuY29kaW5nLmRlY29kZVRleHR1cmVDb29yZGluYXRlcygKICAgICAgICB2ZXJ0aWNlcywKICAgICAgICBpMiwKICAgICAgICB0ZXhDb29yZFNjcmF0Y2gyCiAgICAgICk7CiAgICAgIGlmIChwb2ludEluQm91bmRpbmdCb3godTIsIHYyLCB1djAueCwgdXYwLnksIHV2MS54LCB1djEueSwgdXYyLngsIHV2Mi55KSkgewogICAgICAgIGNvbnN0IGJhcnljZW50cmljID0gSW50ZXJzZWN0aW9uczJEX2RlZmF1bHQuY29tcHV0ZUJhcnljZW50cmljQ29vcmRpbmF0ZXMoCiAgICAgICAgICB1MiwKICAgICAgICAgIHYyLAogICAgICAgICAgdXYwLngsCiAgICAgICAgICB1djAueSwKICAgICAgICAgIHV2MS54LAogICAgICAgICAgdXYxLnksCiAgICAgICAgICB1djIueCwKICAgICAgICAgIHV2Mi55LAogICAgICAgICAgYmFyeWNlbnRyaWNDb29yZGluYXRlU2NyYXRjaAogICAgICAgICk7CiAgICAgICAgaWYgKGJhcnljZW50cmljLnggPj0gLTFlLTE1ICYmIGJhcnljZW50cmljLnkgPj0gLTFlLTE1ICYmIGJhcnljZW50cmljLnogPj0gLTFlLTE1KSB7CiAgICAgICAgICBjb25zdCBoMCA9IGVuY29kaW5nLmRlY29kZUhlaWdodCh2ZXJ0aWNlcywgaTApOwogICAgICAgICAgY29uc3QgaDEgPSBlbmNvZGluZy5kZWNvZGVIZWlnaHQodmVydGljZXMsIGkxKTsKICAgICAgICAgIGNvbnN0IGgyID0gZW5jb2RpbmcuZGVjb2RlSGVpZ2h0KHZlcnRpY2VzLCBpMik7CiAgICAgICAgICByZXR1cm4gYmFyeWNlbnRyaWMueCAqIGgwICsgYmFyeWNlbnRyaWMueSAqIGgxICsgYmFyeWNlbnRyaWMueiAqIGgyOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIHZvaWQgMDsKICB9CiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIZWlnaHQyKHRlcnJhaW5EYXRhLCB1MiwgdjIpIHsKICAgIGNvbnN0IHVCdWZmZXIgPSB0ZXJyYWluRGF0YS5fdVZhbHVlczsKICAgIGNvbnN0IHZCdWZmZXIgPSB0ZXJyYWluRGF0YS5fdlZhbHVlczsKICAgIGNvbnN0IGhlaWdodEJ1ZmZlciA9IHRlcnJhaW5EYXRhLl9oZWlnaHRWYWx1ZXM7CiAgICBjb25zdCBpbmRpY2VzID0gdGVycmFpbkRhdGEuX2luZGljZXM7CiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykgewogICAgICBjb25zdCBpMCA9IGluZGljZXNbaV07CiAgICAgIGNvbnN0IGkxID0gaW5kaWNlc1tpICsgMV07CiAgICAgIGNvbnN0IGkyID0gaW5kaWNlc1tpICsgMl07CiAgICAgIGNvbnN0IHUwID0gdUJ1ZmZlcltpMF07CiAgICAgIGNvbnN0IHUxID0gdUJ1ZmZlcltpMV07CiAgICAgIGNvbnN0IHUyMiA9IHVCdWZmZXJbaTJdOwogICAgICBjb25zdCB2MCA9IHZCdWZmZXJbaTBdOwogICAgICBjb25zdCB2MSA9IHZCdWZmZXJbaTFdOwogICAgICBjb25zdCB2MjIgPSB2QnVmZmVyW2kyXTsKICAgICAgaWYgKHBvaW50SW5Cb3VuZGluZ0JveCh1MiwgdjIsIHUwLCB2MCwgdTEsIHYxLCB1MjIsIHYyMikpIHsKICAgICAgICBjb25zdCBiYXJ5Y2VudHJpYyA9IEludGVyc2VjdGlvbnMyRF9kZWZhdWx0LmNvbXB1dGVCYXJ5Y2VudHJpY0Nvb3JkaW5hdGVzKAogICAgICAgICAgdTIsCiAgICAgICAgICB2MiwKICAgICAgICAgIHUwLAogICAgICAgICAgdjAsCiAgICAgICAgICB1MSwKICAgICAgICAgIHYxLAogICAgICAgICAgdTIyLAogICAgICAgICAgdjIyLAogICAgICAgICAgYmFyeWNlbnRyaWNDb29yZGluYXRlU2NyYXRjaAogICAgICAgICk7CiAgICAgICAgaWYgKGJhcnljZW50cmljLnggPj0gLTFlLTE1ICYmIGJhcnljZW50cmljLnkgPj0gLTFlLTE1ICYmIGJhcnljZW50cmljLnogPj0gLTFlLTE1KSB7CiAgICAgICAgICBjb25zdCBxdWFudGl6ZWRIZWlnaHQgPSBiYXJ5Y2VudHJpYy54ICogaGVpZ2h0QnVmZmVyW2kwXSArIGJhcnljZW50cmljLnkgKiBoZWlnaHRCdWZmZXJbaTFdICsgYmFyeWNlbnRyaWMueiAqIGhlaWdodEJ1ZmZlcltpMl07CiAgICAgICAgICByZXR1cm4gTWF0aF9kZWZhdWx0LmxlcnAoCiAgICAgICAgICAgIHRlcnJhaW5EYXRhLl9taW5pbXVtSGVpZ2h0LAogICAgICAgICAgICB0ZXJyYWluRGF0YS5fbWF4aW11bUhlaWdodCwKICAgICAgICAgICAgcXVhbnRpemVkSGVpZ2h0IC8gbWF4U2hvcnQKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gdm9pZCAwOwogIH0KICBRdWFudGl6ZWRNZXNoVGVycmFpbkRhdGEucHJvdG90eXBlLmlzQ2hpbGRBdmFpbGFibGUgPSBmdW5jdGlvbih0aGlzWCwgdGhpc1ksIGNoaWxkWCwgY2hpbGRZKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdCh0aGlzWCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoInRoaXNYIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpc1kpKSB7CiAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KCJ0aGlzWSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNoaWxkWCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImNoaWxkWCBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGNoaWxkWSkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoImNoaWxkWSBpcyByZXF1aXJlZC4iKTsKICAgIH0KICAgIGxldCBiaXROdW1iZXIgPSAyOwogICAgaWYgKGNoaWxkWCAhPT0gdGhpc1ggKiAyKSB7CiAgICAgICsrYml0TnVtYmVyOwogICAgfQogICAgaWYgKGNoaWxkWSAhPT0gdGhpc1kgKiAyKSB7CiAgICAgIGJpdE51bWJlciAtPSAyOwogICAgfQogICAgcmV0dXJuICh0aGlzLl9jaGlsZFRpbGVNYXNrICYgMSA8PCBiaXROdW1iZXIpICE9PSAwOwogIH07CiAgUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhLnByb3RvdHlwZS53YXNDcmVhdGVkQnlVcHNhbXBsaW5nID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdGhpcy5fY3JlYXRlZEJ5VXBzYW1wbGluZzsKICB9OwogIHZhciBRdWFudGl6ZWRNZXNoVGVycmFpbkRhdGFfZGVmYXVsdCA9IFF1YW50aXplZE1lc2hUZXJyYWluRGF0YTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0Nlc2l1bVRlcnJhaW5Qcm92aWRlci5qcwogIGZ1bmN0aW9uIExheWVySW5mb3JtYXRpb24obGF5ZXIpIHsKICAgIHRoaXMucmVzb3VyY2UgPSBsYXllci5yZXNvdXJjZTsKICAgIHRoaXMudmVyc2lvbiA9IGxheWVyLnZlcnNpb247CiAgICB0aGlzLmlzSGVpZ2h0bWFwID0gbGF5ZXIuaXNIZWlnaHRtYXA7CiAgICB0aGlzLnRpbGVVcmxUZW1wbGF0ZXMgPSBsYXllci50aWxlVXJsVGVtcGxhdGVzOwogICAgdGhpcy5hdmFpbGFiaWxpdHkgPSBsYXllci5hdmFpbGFiaWxpdHk7CiAgICB0aGlzLmhhc1ZlcnRleE5vcm1hbHMgPSBsYXllci5oYXNWZXJ0ZXhOb3JtYWxzOwogICAgdGhpcy5oYXNXYXRlck1hc2sgPSBsYXllci5oYXNXYXRlck1hc2s7CiAgICB0aGlzLmhhc01ldGFkYXRhID0gbGF5ZXIuaGFzTWV0YWRhdGE7CiAgICB0aGlzLmF2YWlsYWJpbGl0eUxldmVscyA9IGxheWVyLmF2YWlsYWJpbGl0eUxldmVsczsKICAgIHRoaXMuYXZhaWxhYmlsaXR5VGlsZXNMb2FkZWQgPSBsYXllci5hdmFpbGFiaWxpdHlUaWxlc0xvYWRlZDsKICAgIHRoaXMubGl0dGxlRW5kaWFuRXh0ZW5zaW9uU2l6ZSA9IGxheWVyLmxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemU7CiAgICB0aGlzLmF2YWlsYWJpbGl0eVByb21pc2VDYWNoZSA9IHt9OwogIH0KICBmdW5jdGlvbiBDZXNpdW1UZXJyYWluUHJvdmlkZXIob3B0aW9ucykgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3B0aW9ucykgfHwgIWRlZmluZWRfZGVmYXVsdChvcHRpb25zLnVybCkpIHsKICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yX2RlZmF1bHQoIm9wdGlvbnMudXJsIGlzIHJlcXVpcmVkLiIpOwogICAgfQogICAgdGhpcy5faGVpZ2h0bWFwV2lkdGggPSA2NTsKICAgIHRoaXMuX2hlaWdodG1hcFN0cnVjdHVyZSA9IHZvaWQgMDsKICAgIHRoaXMuX2hhc1dhdGVyTWFzayA9IGZhbHNlOwogICAgdGhpcy5faGFzVmVydGV4Tm9ybWFscyA9IGZhbHNlOwogICAgdGhpcy5fZWxsaXBzb2lkID0gb3B0aW9ucy5lbGxpcHNvaWQ7CiAgICB0aGlzLl9yZXF1ZXN0VmVydGV4Tm9ybWFscyA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KAogICAgICBvcHRpb25zLnJlcXVlc3RWZXJ0ZXhOb3JtYWxzLAogICAgICBmYWxzZQogICAgKTsKICAgIHRoaXMuX3JlcXVlc3RXYXRlck1hc2sgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLnJlcXVlc3RXYXRlck1hc2ssIGZhbHNlKTsKICAgIHRoaXMuX3JlcXVlc3RNZXRhZGF0YSA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMucmVxdWVzdE1ldGFkYXRhLCB0cnVlKTsKICAgIHRoaXMuX2Vycm9yRXZlbnQgPSBuZXcgRXZlbnRfZGVmYXVsdCgpOwogICAgbGV0IGNyZWRpdCA9IG9wdGlvbnMuY3JlZGl0OwogICAgaWYgKHR5cGVvZiBjcmVkaXQgPT09ICJzdHJpbmciKSB7CiAgICAgIGNyZWRpdCA9IG5ldyBDcmVkaXRfZGVmYXVsdChjcmVkaXQpOwogICAgfQogICAgdGhpcy5fY3JlZGl0ID0gY3JlZGl0OwogICAgdGhpcy5fYXZhaWxhYmlsaXR5ID0gdm9pZCAwOwogICAgdGhpcy5fcmVhZHkgPSBmYWxzZTsKICAgIHRoaXMuX3RpbGVDcmVkaXRzID0gdm9pZCAwOwogICAgY29uc3QgdGhhdCA9IHRoaXM7CiAgICBsZXQgbGFzdFJlc291cmNlOwogICAgbGV0IGxheWVySnNvblJlc291cmNlOwogICAgbGV0IG1ldGFkYXRhRXJyb3I7CiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSBbXTsKICAgIGxldCBhdHRyaWJ1dGlvbiA9ICIiOwogICAgY29uc3Qgb3ZlcmFsbEF2YWlsYWJpbGl0eSA9IFtdOwogICAgbGV0IG92ZXJhbGxNYXhab29tID0gMDsKICAgIHRoaXMuX3JlYWR5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShvcHRpb25zLnVybCkudGhlbihmdW5jdGlvbih1cmwpIHsKICAgICAgY29uc3QgcmVzb3VyY2UgPSBSZXNvdXJjZV9kZWZhdWx0LmNyZWF0ZUlmTmVlZGVkKHVybCk7CiAgICAgIHJlc291cmNlLmFwcGVuZEZvcndhcmRTbGFzaCgpOwogICAgICBsYXN0UmVzb3VyY2UgPSByZXNvdXJjZTsKICAgICAgbGF5ZXJKc29uUmVzb3VyY2UgPSBsYXN0UmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHsKICAgICAgICB1cmw6ICJsYXllci5qc29uIgogICAgICB9KTsKICAgICAgdGhhdC5fdGlsZUNyZWRpdHMgPSByZXNvdXJjZS5jcmVkaXRzOwogICAgICByZXR1cm4gcmVxdWVzdExheWVySnNvbigpOwogICAgfSk7CiAgICBmdW5jdGlvbiBwYXJzZU1ldGFkYXRhU3VjY2VzcyhkYXRhKSB7CiAgICAgIGxldCBtZXNzYWdlOwogICAgICBpZiAoIWRhdGEuZm9ybWF0KSB7CiAgICAgICAgbWVzc2FnZSA9ICJUaGUgdGlsZSBmb3JtYXQgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgbGF5ZXIuanNvbiBmaWxlLiI7CiAgICAgICAgbWV0YWRhdGFFcnJvciA9IFRpbGVQcm92aWRlckVycm9yX2RlZmF1bHQucmVwb3J0RXJyb3IoCiAgICAgICAgICBtZXRhZGF0YUVycm9yLAogICAgICAgICAgdGhhdCwKICAgICAgICAgIHRoYXQuX2Vycm9yRXZlbnQsCiAgICAgICAgICBtZXNzYWdlCiAgICAgICAgKTsKICAgICAgICBpZiAobWV0YWRhdGFFcnJvci5yZXRyeSkgewogICAgICAgICAgcmV0dXJuIHJlcXVlc3RMYXllckpzb24oKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBSdW50aW1lRXJyb3JfZGVmYXVsdChtZXNzYWdlKSk7CiAgICAgIH0KICAgICAgaWYgKCFkYXRhLnRpbGVzIHx8IGRhdGEudGlsZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgbWVzc2FnZSA9ICJUaGUgbGF5ZXIuanNvbiBmaWxlIGRvZXMgbm90IHNwZWNpZnkgYW55IHRpbGUgVVJMIHRlbXBsYXRlcy4iOwogICAgICAgIG1ldGFkYXRhRXJyb3IgPSBUaWxlUHJvdmlkZXJFcnJvcl9kZWZhdWx0LnJlcG9ydEVycm9yKAogICAgICAgICAgbWV0YWRhdGFFcnJvciwKICAgICAgICAgIHRoYXQsCiAgICAgICAgICB0aGF0Ll9lcnJvckV2ZW50LAogICAgICAgICAgbWVzc2FnZQogICAgICAgICk7CiAgICAgICAgaWYgKG1ldGFkYXRhRXJyb3IucmV0cnkpIHsKICAgICAgICAgIHJldHVybiByZXF1ZXN0TGF5ZXJKc29uKCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgUnVudGltZUVycm9yX2RlZmF1bHQobWVzc2FnZSkpOwogICAgICB9CiAgICAgIGxldCBoYXNWZXJ0ZXhOb3JtYWxzID0gZmFsc2U7CiAgICAgIGxldCBoYXNXYXRlck1hc2sgPSBmYWxzZTsKICAgICAgbGV0IGhhc01ldGFkYXRhID0gZmFsc2U7CiAgICAgIGxldCBsaXR0bGVFbmRpYW5FeHRlbnNpb25TaXplID0gdHJ1ZTsKICAgICAgbGV0IGlzSGVpZ2h0bWFwID0gZmFsc2U7CiAgICAgIGlmIChkYXRhLmZvcm1hdCA9PT0gImhlaWdodG1hcC0xLjAiKSB7CiAgICAgICAgaXNIZWlnaHRtYXAgPSB0cnVlOwogICAgICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KHRoYXQuX2hlaWdodG1hcFN0cnVjdHVyZSkpIHsKICAgICAgICAgIHRoYXQuX2hlaWdodG1hcFN0cnVjdHVyZSA9IHsKICAgICAgICAgICAgaGVpZ2h0U2NhbGU6IDEgLyA1LAogICAgICAgICAgICBoZWlnaHRPZmZzZXQ6IC0xZTMsCiAgICAgICAgICAgIGVsZW1lbnRzUGVySGVpZ2h0OiAxLAogICAgICAgICAgICBzdHJpZGU6IDEsCiAgICAgICAgICAgIGVsZW1lbnRNdWx0aXBsaWVyOiAyNTYsCiAgICAgICAgICAgIGlzQmlnRW5kaWFuOiBmYWxzZSwKICAgICAgICAgICAgbG93ZXN0RW5jb2RlZEhlaWdodDogMCwKICAgICAgICAgICAgaGlnaGVzdEVuY29kZWRIZWlnaHQ6IDI1NiAqIDI1NiAtIDEKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGhhc1dhdGVyTWFzayA9IHRydWU7CiAgICAgICAgdGhhdC5fcmVxdWVzdFdhdGVyTWFzayA9IHRydWU7CiAgICAgIH0gZWxzZSBpZiAoZGF0YS5mb3JtYXQuaW5kZXhPZigicXVhbnRpemVkLW1lc2gtMS4iKSAhPT0gMCkgewogICAgICAgIG1lc3NhZ2UgPSBgVGhlIHRpbGUgZm9ybWF0ICIke2RhdGEuZm9ybWF0fSIgaXMgaW52YWxpZCBvciBub3Qgc3VwcG9ydGVkLmA7CiAgICAgICAgbWV0YWRhdGFFcnJvciA9IFRpbGVQcm92aWRlckVycm9yX2RlZmF1bHQucmVwb3J0RXJyb3IoCiAgICAgICAgICBtZXRhZGF0YUVycm9yLAogICAgICAgICAgdGhhdCwKICAgICAgICAgIHRoYXQuX2Vycm9yRXZlbnQsCiAgICAgICAgICBtZXNzYWdlCiAgICAgICAgKTsKICAgICAgICBpZiAobWV0YWRhdGFFcnJvci5yZXRyeSkgewogICAgICAgICAgcmV0dXJuIHJlcXVlc3RMYXllckpzb24oKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBSdW50aW1lRXJyb3JfZGVmYXVsdChtZXNzYWdlKSk7CiAgICAgIH0KICAgICAgY29uc3QgdGlsZVVybFRlbXBsYXRlcyA9IGRhdGEudGlsZXM7CiAgICAgIGNvbnN0IG1heFpvb20gPSBkYXRhLm1heHpvb207CiAgICAgIG92ZXJhbGxNYXhab29tID0gTWF0aC5tYXgob3ZlcmFsbE1heFpvb20sIG1heFpvb20pOwogICAgICBpZiAoIWRhdGEucHJvamVjdGlvbiB8fCBkYXRhLnByb2plY3Rpb24gPT09ICJFUFNHOjQzMjYiKSB7CiAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lID0gbmV3IEdlb2dyYXBoaWNUaWxpbmdTY2hlbWVfZGVmYXVsdCh7CiAgICAgICAgICBudW1iZXJPZkxldmVsWmVyb1RpbGVzWDogMiwKICAgICAgICAgIG51bWJlck9mTGV2ZWxaZXJvVGlsZXNZOiAxLAogICAgICAgICAgZWxsaXBzb2lkOiB0aGF0Ll9lbGxpcHNvaWQKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChkYXRhLnByb2plY3Rpb24gPT09ICJFUFNHOjM4NTciKSB7CiAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lID0gbmV3IFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lX2RlZmF1bHQoewogICAgICAgICAgbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1g6IDEsCiAgICAgICAgICBudW1iZXJPZkxldmVsWmVyb1RpbGVzWTogMSwKICAgICAgICAgIGVsbGlwc29pZDogdGhhdC5fZWxsaXBzb2lkCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbWVzc2FnZSA9IGBUaGUgcHJvamVjdGlvbiAiJHtkYXRhLnByb2plY3Rpb259IiBpcyBpbnZhbGlkIG9yIG5vdCBzdXBwb3J0ZWQuYDsKICAgICAgICBtZXRhZGF0YUVycm9yID0gVGlsZVByb3ZpZGVyRXJyb3JfZGVmYXVsdC5yZXBvcnRFcnJvcigKICAgICAgICAgIG1ldGFkYXRhRXJyb3IsCiAgICAgICAgICB0aGF0LAogICAgICAgICAgdGhhdC5fZXJyb3JFdmVudCwKICAgICAgICAgIG1lc3NhZ2UKICAgICAgICApOwogICAgICAgIGlmIChtZXRhZGF0YUVycm9yLnJldHJ5KSB7CiAgICAgICAgICByZXR1cm4gcmVxdWVzdExheWVySnNvbigpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KG1lc3NhZ2UpKTsKICAgICAgfQogICAgICB0aGF0Ll9sZXZlbFplcm9NYXhpbXVtR2VvbWV0cmljRXJyb3IgPSBUZXJyYWluUHJvdmlkZXJfZGVmYXVsdC5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAoCiAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lLmVsbGlwc29pZCwKICAgICAgICB0aGF0Ll9oZWlnaHRtYXBXaWR0aCwKICAgICAgICB0aGF0Ll90aWxpbmdTY2hlbWUuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsKDApCiAgICAgICk7CiAgICAgIGlmICghZGF0YS5zY2hlbWUgfHwgZGF0YS5zY2hlbWUgPT09ICJ0bXMiIHx8IGRhdGEuc2NoZW1lID09PSAic2xpcHB5TWFwIikgewogICAgICAgIHRoYXQuX3NjaGVtZSA9IGRhdGEuc2NoZW1lOwogICAgICB9IGVsc2UgewogICAgICAgIG1lc3NhZ2UgPSBgVGhlIHNjaGVtZSAiJHtkYXRhLnNjaGVtZX0iIGlzIGludmFsaWQgb3Igbm90IHN1cHBvcnRlZC5gOwogICAgICAgIG1ldGFkYXRhRXJyb3IgPSBUaWxlUHJvdmlkZXJFcnJvcl9kZWZhdWx0LnJlcG9ydEVycm9yKAogICAgICAgICAgbWV0YWRhdGFFcnJvciwKICAgICAgICAgIHRoYXQsCiAgICAgICAgICB0aGF0Ll9lcnJvckV2ZW50LAogICAgICAgICAgbWVzc2FnZQogICAgICAgICk7CiAgICAgICAgaWYgKG1ldGFkYXRhRXJyb3IucmV0cnkpIHsKICAgICAgICAgIHJldHVybiByZXF1ZXN0TGF5ZXJKc29uKCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgUnVudGltZUVycm9yX2RlZmF1bHQobWVzc2FnZSkpOwogICAgICB9CiAgICAgIGxldCBhdmFpbGFiaWxpdHlUaWxlc0xvYWRlZDsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChkYXRhLmV4dGVuc2lvbnMpICYmIGRhdGEuZXh0ZW5zaW9ucy5pbmRleE9mKCJvY3R2ZXJ0ZXhub3JtYWxzIikgIT09IC0xKSB7CiAgICAgICAgaGFzVmVydGV4Tm9ybWFscyA9IHRydWU7CiAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZF9kZWZhdWx0KGRhdGEuZXh0ZW5zaW9ucykgJiYgZGF0YS5leHRlbnNpb25zLmluZGV4T2YoInZlcnRleG5vcm1hbHMiKSAhPT0gLTEpIHsKICAgICAgICBoYXNWZXJ0ZXhOb3JtYWxzID0gdHJ1ZTsKICAgICAgICBsaXR0bGVFbmRpYW5FeHRlbnNpb25TaXplID0gZmFsc2U7CiAgICAgIH0KICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChkYXRhLmV4dGVuc2lvbnMpICYmIGRhdGEuZXh0ZW5zaW9ucy5pbmRleE9mKCJ3YXRlcm1hc2siKSAhPT0gLTEpIHsKICAgICAgICBoYXNXYXRlck1hc2sgPSB0cnVlOwogICAgICB9CiAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoZGF0YS5leHRlbnNpb25zKSAmJiBkYXRhLmV4dGVuc2lvbnMuaW5kZXhPZigibWV0YWRhdGEiKSAhPT0gLTEpIHsKICAgICAgICBoYXNNZXRhZGF0YSA9IHRydWU7CiAgICAgIH0KICAgICAgY29uc3QgYXZhaWxhYmlsaXR5TGV2ZWxzID0gZGF0YS5tZXRhZGF0YUF2YWlsYWJpbGl0eTsKICAgICAgY29uc3QgYXZhaWxhYmxlVGlsZXMgPSBkYXRhLmF2YWlsYWJsZTsKICAgICAgbGV0IGF2YWlsYWJpbGl0eTsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChhdmFpbGFibGVUaWxlcykgJiYgIWRlZmluZWRfZGVmYXVsdChhdmFpbGFiaWxpdHlMZXZlbHMpKSB7CiAgICAgICAgYXZhaWxhYmlsaXR5ID0gbmV3IFRpbGVBdmFpbGFiaWxpdHlfZGVmYXVsdCgKICAgICAgICAgIHRoYXQuX3RpbGluZ1NjaGVtZSwKICAgICAgICAgIGF2YWlsYWJsZVRpbGVzLmxlbmd0aAogICAgICAgICk7CiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGF2YWlsYWJsZVRpbGVzLmxlbmd0aDsgKytsZXZlbCkgewogICAgICAgICAgY29uc3QgcmFuZ2VzQXRMZXZlbCA9IGF2YWlsYWJsZVRpbGVzW2xldmVsXTsKICAgICAgICAgIGNvbnN0IHlUaWxlcyA9IHRoYXQuX3RpbGluZ1NjaGVtZS5nZXROdW1iZXJPZllUaWxlc0F0TGV2ZWwobGV2ZWwpOwogICAgICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQob3ZlcmFsbEF2YWlsYWJpbGl0eVtsZXZlbF0pKSB7CiAgICAgICAgICAgIG92ZXJhbGxBdmFpbGFiaWxpdHlbbGV2ZWxdID0gW107CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGxldCByYW5nZUluZGV4ID0gMDsgcmFuZ2VJbmRleCA8IHJhbmdlc0F0TGV2ZWwubGVuZ3RoOyArK3JhbmdlSW5kZXgpIHsKICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZXNBdExldmVsW3JhbmdlSW5kZXhdOwogICAgICAgICAgICBjb25zdCB5U3RhcnQgPSB5VGlsZXMgLSByYW5nZS5lbmRZIC0gMTsKICAgICAgICAgICAgY29uc3QgeUVuZCA9IHlUaWxlcyAtIHJhbmdlLnN0YXJ0WSAtIDE7CiAgICAgICAgICAgIG92ZXJhbGxBdmFpbGFiaWxpdHlbbGV2ZWxdLnB1c2goWwogICAgICAgICAgICAgIHJhbmdlLnN0YXJ0WCwKICAgICAgICAgICAgICB5U3RhcnQsCiAgICAgICAgICAgICAgcmFuZ2UuZW5kWCwKICAgICAgICAgICAgICB5RW5kCiAgICAgICAgICAgIF0pOwogICAgICAgICAgICBhdmFpbGFiaWxpdHkuYWRkQXZhaWxhYmxlVGlsZVJhbmdlKAogICAgICAgICAgICAgIGxldmVsLAogICAgICAgICAgICAgIHJhbmdlLnN0YXJ0WCwKICAgICAgICAgICAgICB5U3RhcnQsCiAgICAgICAgICAgICAgcmFuZ2UuZW5kWCwKICAgICAgICAgICAgICB5RW5kCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGRlZmluZWRfZGVmYXVsdChhdmFpbGFiaWxpdHlMZXZlbHMpKSB7CiAgICAgICAgYXZhaWxhYmlsaXR5VGlsZXNMb2FkZWQgPSBuZXcgVGlsZUF2YWlsYWJpbGl0eV9kZWZhdWx0KAogICAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lLAogICAgICAgICAgbWF4Wm9vbQogICAgICAgICk7CiAgICAgICAgYXZhaWxhYmlsaXR5ID0gbmV3IFRpbGVBdmFpbGFiaWxpdHlfZGVmYXVsdCh0aGF0Ll90aWxpbmdTY2hlbWUsIG1heFpvb20pOwogICAgICAgIG92ZXJhbGxBdmFpbGFiaWxpdHlbMF0gPSBbWzAsIDAsIDEsIDBdXTsKICAgICAgICBhdmFpbGFiaWxpdHkuYWRkQXZhaWxhYmxlVGlsZVJhbmdlKDAsIDAsIDAsIDEsIDApOwogICAgICB9CiAgICAgIHRoYXQuX2hhc1dhdGVyTWFzayA9IHRoYXQuX2hhc1dhdGVyTWFzayB8fCBoYXNXYXRlck1hc2s7CiAgICAgIHRoYXQuX2hhc1ZlcnRleE5vcm1hbHMgPSB0aGF0Ll9oYXNWZXJ0ZXhOb3JtYWxzIHx8IGhhc1ZlcnRleE5vcm1hbHM7CiAgICAgIHRoYXQuX2hhc01ldGFkYXRhID0gdGhhdC5faGFzTWV0YWRhdGEgfHwgaGFzTWV0YWRhdGE7CiAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoZGF0YS5hdHRyaWJ1dGlvbikpIHsKICAgICAgICBpZiAoYXR0cmlidXRpb24ubGVuZ3RoID4gMCkgewogICAgICAgICAgYXR0cmlidXRpb24gKz0gIiAiOwogICAgICAgIH0KICAgICAgICBhdHRyaWJ1dGlvbiArPSBkYXRhLmF0dHJpYnV0aW9uOwogICAgICB9CiAgICAgIGxheWVycy5wdXNoKAogICAgICAgIG5ldyBMYXllckluZm9ybWF0aW9uKHsKICAgICAgICAgIHJlc291cmNlOiBsYXN0UmVzb3VyY2UsCiAgICAgICAgICB2ZXJzaW9uOiBkYXRhLnZlcnNpb24sCiAgICAgICAgICBpc0hlaWdodG1hcCwKICAgICAgICAgIHRpbGVVcmxUZW1wbGF0ZXMsCiAgICAgICAgICBhdmFpbGFiaWxpdHksCiAgICAgICAgICBoYXNWZXJ0ZXhOb3JtYWxzLAogICAgICAgICAgaGFzV2F0ZXJNYXNrLAogICAgICAgICAgaGFzTWV0YWRhdGEsCiAgICAgICAgICBhdmFpbGFiaWxpdHlMZXZlbHMsCiAgICAgICAgICBhdmFpbGFiaWxpdHlUaWxlc0xvYWRlZCwKICAgICAgICAgIGxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemUKICAgICAgICB9KQogICAgICApOwogICAgICBjb25zdCBwYXJlbnRVcmwgPSBkYXRhLnBhcmVudFVybDsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChwYXJlbnRVcmwpKSB7CiAgICAgICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoYXZhaWxhYmlsaXR5KSkgewogICAgICAgICAgY29uc29sZS5sb2coCiAgICAgICAgICAgICJBIGxheWVyLmpzb24gY2FuJ3QgaGF2ZSBhIHBhcmVudFVybCBpZiBpdCBkb2VzJ3QgaGF2ZSBhbiBhdmFpbGFibGUgYXJyYXkuIgogICAgICAgICAgKTsKICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7CiAgICAgICAgfQogICAgICAgIGxhc3RSZXNvdXJjZSA9IGxhc3RSZXNvdXJjZS5nZXREZXJpdmVkUmVzb3VyY2UoewogICAgICAgICAgdXJsOiBwYXJlbnRVcmwKICAgICAgICB9KTsKICAgICAgICBsYXN0UmVzb3VyY2UuYXBwZW5kRm9yd2FyZFNsYXNoKCk7CiAgICAgICAgbGF5ZXJKc29uUmVzb3VyY2UgPSBsYXN0UmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHsKICAgICAgICAgIHVybDogImxheWVyLmpzb24iCiAgICAgICAgfSk7CiAgICAgICAgY29uc3QgcGFyZW50TWV0YWRhdGEgPSBsYXllckpzb25SZXNvdXJjZS5mZXRjaEpzb24oKTsKICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhcmVudE1ldGFkYXRhKS50aGVuKHBhcnNlTWV0YWRhdGFTdWNjZXNzKS5jYXRjaChwYXJzZU1ldGFkYXRhRmFpbHVyZSk7CiAgICAgIH0KICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsKICAgIH0KICAgIGZ1bmN0aW9uIHBhcnNlTWV0YWRhdGFGYWlsdXJlKGRhdGEpIHsKICAgICAgY29uc3QgbWVzc2FnZSA9IGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhY2Nlc3NpbmcgJHtsYXllckpzb25SZXNvdXJjZS51cmx9LmA7CiAgICAgIG1ldGFkYXRhRXJyb3IgPSBUaWxlUHJvdmlkZXJFcnJvcl9kZWZhdWx0LnJlcG9ydEVycm9yKAogICAgICAgIG1ldGFkYXRhRXJyb3IsCiAgICAgICAgdGhhdCwKICAgICAgICB0aGF0Ll9lcnJvckV2ZW50LAogICAgICAgIG1lc3NhZ2UKICAgICAgKTsKICAgICAgaWYgKG1ldGFkYXRhRXJyb3IucmV0cnkpIHsKICAgICAgICByZXR1cm4gcmVxdWVzdExheWVySnNvbigpOwogICAgICB9CiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgUnVudGltZUVycm9yX2RlZmF1bHQobWVzc2FnZSkpOwogICAgfQogICAgZnVuY3Rpb24gbWV0YWRhdGFTdWNjZXNzKGRhdGEpIHsKICAgICAgcmV0dXJuIHBhcnNlTWV0YWRhdGFTdWNjZXNzKGRhdGEpLnRoZW4oZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChtZXRhZGF0YUVycm9yKSkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW5ndGggPSBvdmVyYWxsQXZhaWxhYmlsaXR5Lmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID4gMCkgewogICAgICAgICAgY29uc3QgYXZhaWxhYmlsaXR5ID0gdGhhdC5fYXZhaWxhYmlsaXR5ID0gbmV3IFRpbGVBdmFpbGFiaWxpdHlfZGVmYXVsdCgKICAgICAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lLAogICAgICAgICAgICBvdmVyYWxsTWF4Wm9vbQogICAgICAgICAgKTsKICAgICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBsZW5ndGg7ICsrbGV2ZWwpIHsKICAgICAgICAgICAgY29uc3QgbGV2ZWxSYW5nZXMgPSBvdmVyYWxsQXZhaWxhYmlsaXR5W2xldmVsXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbFJhbmdlcy5sZW5ndGg7ICsraSkgewogICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbGV2ZWxSYW5nZXNbaV07CiAgICAgICAgICAgICAgYXZhaWxhYmlsaXR5LmFkZEF2YWlsYWJsZVRpbGVSYW5nZSgKICAgICAgICAgICAgICAgIGxldmVsLAogICAgICAgICAgICAgICAgcmFuZ2VbMF0sCiAgICAgICAgICAgICAgICByYW5nZVsxXSwKICAgICAgICAgICAgICAgIHJhbmdlWzJdLAogICAgICAgICAgICAgICAgcmFuZ2VbM10KICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChhdHRyaWJ1dGlvbi5sZW5ndGggPiAwKSB7CiAgICAgICAgICBjb25zdCBsYXllckpzb25DcmVkaXQgPSBuZXcgQ3JlZGl0X2RlZmF1bHQoYXR0cmlidXRpb24pOwogICAgICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdCh0aGF0Ll90aWxlQ3JlZGl0cykpIHsKICAgICAgICAgICAgdGhhdC5fdGlsZUNyZWRpdHMucHVzaChsYXllckpzb25DcmVkaXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhhdC5fdGlsZUNyZWRpdHMgPSBbbGF5ZXJKc29uQ3JlZGl0XTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhhdC5fcmVhZHkgPSB0cnVlOwogICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7CiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gbWV0YWRhdGFGYWlsdXJlKGRhdGEpIHsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChkYXRhKSAmJiBkYXRhLnN0YXR1c0NvZGUgPT09IDQwNCkgewogICAgICAgIHJldHVybiBtZXRhZGF0YVN1Y2Nlc3MoewogICAgICAgICAgdGlsZWpzb246ICIyLjEuMCIsCiAgICAgICAgICBmb3JtYXQ6ICJoZWlnaHRtYXAtMS4wIiwKICAgICAgICAgIHZlcnNpb246ICIxLjAuMCIsCiAgICAgICAgICBzY2hlbWU6ICJ0bXMiLAogICAgICAgICAgdGlsZXM6IFsie3p9L3t4fS97eX0udGVycmFpbj92PXt2ZXJzaW9ufSJdCiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHBhcnNlTWV0YWRhdGFGYWlsdXJlKGRhdGEpOwogICAgfQogICAgZnVuY3Rpb24gcmVxdWVzdExheWVySnNvbigpIHsKICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsYXllckpzb25SZXNvdXJjZS5mZXRjaEpzb24oKSkudGhlbihtZXRhZGF0YVN1Y2Nlc3MpLmNhdGNoKG1ldGFkYXRhRmFpbHVyZSk7CiAgICB9CiAgfQogIHZhciBRdWFudGl6ZWRNZXNoRXh0ZW5zaW9uSWRzID0gewogICAgT0NUX1ZFUlRFWF9OT1JNQUxTOiAxLAogICAgV0FURVJfTUFTSzogMiwKICAgIE1FVEFEQVRBOiA0CiAgfTsKICBmdW5jdGlvbiBnZXRSZXF1ZXN0SGVhZGVyKGV4dGVuc2lvbnNMaXN0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChleHRlbnNpb25zTGlzdCkgfHwgZXh0ZW5zaW9uc0xpc3QubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgQWNjZXB0OiAiYXBwbGljYXRpb24vdm5kLnF1YW50aXplZC1tZXNoLGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtxPTAuOSwqLyo7cT0wLjAxIgogICAgICB9OwogICAgfQogICAgY29uc3QgZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnNMaXN0LmpvaW4oIi0iKTsKICAgIHJldHVybiB7CiAgICAgIEFjY2VwdDogYGFwcGxpY2F0aW9uL3ZuZC5xdWFudGl6ZWQtbWVzaDtleHRlbnNpb25zPSR7ZXh0ZW5zaW9uc30sYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO3E9MC45LCovKjtxPTAuMDFgCiAgICB9OwogIH0KICBmdW5jdGlvbiBjcmVhdGVIZWlnaHRtYXBUZXJyYWluRGF0YShwcm92aWRlciwgYnVmZmVyLCBsZXZlbCwgeCwgeSkgewogICAgY29uc3QgaGVpZ2h0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KAogICAgICBidWZmZXIsCiAgICAgIDAsCiAgICAgIHByb3ZpZGVyLl9oZWlnaHRtYXBXaWR0aCAqIHByb3ZpZGVyLl9oZWlnaHRtYXBXaWR0aAogICAgKTsKICAgIHJldHVybiBuZXcgSGVpZ2h0bWFwVGVycmFpbkRhdGFfZGVmYXVsdCh7CiAgICAgIGJ1ZmZlcjogaGVpZ2h0QnVmZmVyLAogICAgICBjaGlsZFRpbGVNYXNrOiBuZXcgVWludDhBcnJheShidWZmZXIsIGhlaWdodEJ1ZmZlci5ieXRlTGVuZ3RoLCAxKVswXSwKICAgICAgd2F0ZXJNYXNrOiBuZXcgVWludDhBcnJheSgKICAgICAgICBidWZmZXIsCiAgICAgICAgaGVpZ2h0QnVmZmVyLmJ5dGVMZW5ndGggKyAxLAogICAgICAgIGJ1ZmZlci5ieXRlTGVuZ3RoIC0gaGVpZ2h0QnVmZmVyLmJ5dGVMZW5ndGggLSAxCiAgICAgICksCiAgICAgIHdpZHRoOiBwcm92aWRlci5faGVpZ2h0bWFwV2lkdGgsCiAgICAgIGhlaWdodDogcHJvdmlkZXIuX2hlaWdodG1hcFdpZHRoLAogICAgICBzdHJ1Y3R1cmU6IHByb3ZpZGVyLl9oZWlnaHRtYXBTdHJ1Y3R1cmUsCiAgICAgIGNyZWRpdHM6IHByb3ZpZGVyLl90aWxlQ3JlZGl0cwogICAgfSk7CiAgfQogIGZ1bmN0aW9uIGNyZWF0ZVF1YW50aXplZE1lc2hUZXJyYWluRGF0YShwcm92aWRlciwgYnVmZmVyLCBsZXZlbCwgeCwgeSwgbGF5ZXIpIHsKICAgIGNvbnN0IGxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemUgPSBsYXllci5saXR0bGVFbmRpYW5FeHRlbnNpb25TaXplOwogICAgbGV0IHBvcyA9IDA7CiAgICBjb25zdCBjYXJ0ZXNpYW4zRWxlbWVudHMgPSAzOwogICAgY29uc3QgYm91bmRpbmdTcGhlcmVFbGVtZW50cyA9IGNhcnRlc2lhbjNFbGVtZW50cyArIDE7CiAgICBjb25zdCBjYXJ0ZXNpYW4zTGVuZ3RoID0gRmxvYXQ2NEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogY2FydGVzaWFuM0VsZW1lbnRzOwogICAgY29uc3QgYm91bmRpbmdTcGhlcmVMZW5ndGggPSBGbG9hdDY0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiBib3VuZGluZ1NwaGVyZUVsZW1lbnRzOwogICAgY29uc3QgZW5jb2RlZFZlcnRleEVsZW1lbnRzID0gMzsKICAgIGNvbnN0IGVuY29kZWRWZXJ0ZXhMZW5ndGggPSBVaW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIGVuY29kZWRWZXJ0ZXhFbGVtZW50czsKICAgIGNvbnN0IHRyaWFuZ2xlRWxlbWVudHMgPSAzOwogICAgbGV0IGJ5dGVzUGVySW5kZXggPSBVaW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgIGxldCB0cmlhbmdsZUxlbmd0aCA9IGJ5dGVzUGVySW5kZXggKiB0cmlhbmdsZUVsZW1lbnRzOwogICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpOwogICAgY29uc3QgY2VudGVyID0gbmV3IENhcnRlc2lhbjNfZGVmYXVsdCgKICAgICAgdmlldy5nZXRGbG9hdDY0KHBvcywgdHJ1ZSksCiAgICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MgKyA4LCB0cnVlKSwKICAgICAgdmlldy5nZXRGbG9hdDY0KHBvcyArIDE2LCB0cnVlKQogICAgKTsKICAgIHBvcyArPSBjYXJ0ZXNpYW4zTGVuZ3RoOwogICAgY29uc3QgbWluaW11bUhlaWdodCA9IHZpZXcuZ2V0RmxvYXQzMihwb3MsIHRydWUpOwogICAgcG9zICs9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgIGNvbnN0IG1heGltdW1IZWlnaHQgPSB2aWV3LmdldEZsb2F0MzIocG9zLCB0cnVlKTsKICAgIHBvcyArPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICBjb25zdCBib3VuZGluZ1NwaGVyZSA9IG5ldyBCb3VuZGluZ1NwaGVyZV9kZWZhdWx0KAogICAgICBuZXcgQ2FydGVzaWFuM19kZWZhdWx0KAogICAgICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MsIHRydWUpLAogICAgICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MgKyA4LCB0cnVlKSwKICAgICAgICB2aWV3LmdldEZsb2F0NjQocG9zICsgMTYsIHRydWUpCiAgICAgICksCiAgICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MgKyBjYXJ0ZXNpYW4zTGVuZ3RoLCB0cnVlKQogICAgKTsKICAgIHBvcyArPSBib3VuZGluZ1NwaGVyZUxlbmd0aDsKICAgIGNvbnN0IGhvcml6b25PY2NsdXNpb25Qb2ludCA9IG5ldyBDYXJ0ZXNpYW4zX2RlZmF1bHQoCiAgICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MsIHRydWUpLAogICAgICB2aWV3LmdldEZsb2F0NjQocG9zICsgOCwgdHJ1ZSksCiAgICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MgKyAxNiwgdHJ1ZSkKICAgICk7CiAgICBwb3MgKz0gY2FydGVzaWFuM0xlbmd0aDsKICAgIGNvbnN0IHZlcnRleENvdW50ID0gdmlldy5nZXRVaW50MzIocG9zLCB0cnVlKTsKICAgIHBvcyArPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgIGNvbnN0IGVuY29kZWRWZXJ0ZXhCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBwb3MsIHZlcnRleENvdW50ICogMyk7CiAgICBwb3MgKz0gdmVydGV4Q291bnQgKiBlbmNvZGVkVmVydGV4TGVuZ3RoOwogICAgaWYgKHZlcnRleENvdW50ID4gNjQgKiAxMDI0KSB7CiAgICAgIGJ5dGVzUGVySW5kZXggPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgdHJpYW5nbGVMZW5ndGggPSBieXRlc1BlckluZGV4ICogdHJpYW5nbGVFbGVtZW50czsKICAgIH0KICAgIGNvbnN0IHVCdWZmZXIgPSBlbmNvZGVkVmVydGV4QnVmZmVyLnN1YmFycmF5KDAsIHZlcnRleENvdW50KTsKICAgIGNvbnN0IHZCdWZmZXIgPSBlbmNvZGVkVmVydGV4QnVmZmVyLnN1YmFycmF5KHZlcnRleENvdW50LCAyICogdmVydGV4Q291bnQpOwogICAgY29uc3QgaGVpZ2h0QnVmZmVyID0gZW5jb2RlZFZlcnRleEJ1ZmZlci5zdWJhcnJheSgKICAgICAgdmVydGV4Q291bnQgKiAyLAogICAgICAzICogdmVydGV4Q291bnQKICAgICk7CiAgICBBdHRyaWJ1dGVDb21wcmVzc2lvbl9kZWZhdWx0LnppZ1phZ0RlbHRhRGVjb2RlKHVCdWZmZXIsIHZCdWZmZXIsIGhlaWdodEJ1ZmZlcik7CiAgICBpZiAocG9zICUgYnl0ZXNQZXJJbmRleCAhPT0gMCkgewogICAgICBwb3MgKz0gYnl0ZXNQZXJJbmRleCAtIHBvcyAlIGJ5dGVzUGVySW5kZXg7CiAgICB9CiAgICBjb25zdCB0cmlhbmdsZUNvdW50ID0gdmlldy5nZXRVaW50MzIocG9zLCB0cnVlKTsKICAgIHBvcyArPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgIGNvbnN0IGluZGljZXMgPSBJbmRleERhdGF0eXBlX2RlZmF1bHQuY3JlYXRlVHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcigKICAgICAgdmVydGV4Q291bnQsCiAgICAgIGJ1ZmZlciwKICAgICAgcG9zLAogICAgICB0cmlhbmdsZUNvdW50ICogdHJpYW5nbGVFbGVtZW50cwogICAgKTsKICAgIHBvcyArPSB0cmlhbmdsZUNvdW50ICogdHJpYW5nbGVMZW5ndGg7CiAgICBsZXQgaGlnaGVzdCA9IDA7CiAgICBjb25zdCBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgY29uc3QgY29kZSA9IGluZGljZXNbaV07CiAgICAgIGluZGljZXNbaV0gPSBoaWdoZXN0IC0gY29kZTsKICAgICAgaWYgKGNvZGUgPT09IDApIHsKICAgICAgICArK2hpZ2hlc3Q7CiAgICAgIH0KICAgIH0KICAgIGNvbnN0IHdlc3RWZXJ0ZXhDb3VudCA9IHZpZXcuZ2V0VWludDMyKHBvcywgdHJ1ZSk7CiAgICBwb3MgKz0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICBjb25zdCB3ZXN0SW5kaWNlcyA9IEluZGV4RGF0YXR5cGVfZGVmYXVsdC5jcmVhdGVUeXBlZEFycmF5RnJvbUFycmF5QnVmZmVyKAogICAgICB2ZXJ0ZXhDb3VudCwKICAgICAgYnVmZmVyLAogICAgICBwb3MsCiAgICAgIHdlc3RWZXJ0ZXhDb3VudAogICAgKTsKICAgIHBvcyArPSB3ZXN0VmVydGV4Q291bnQgKiBieXRlc1BlckluZGV4OwogICAgY29uc3Qgc291dGhWZXJ0ZXhDb3VudCA9IHZpZXcuZ2V0VWludDMyKHBvcywgdHJ1ZSk7CiAgICBwb3MgKz0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICBjb25zdCBzb3V0aEluZGljZXMgPSBJbmRleERhdGF0eXBlX2RlZmF1bHQuY3JlYXRlVHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcigKICAgICAgdmVydGV4Q291bnQsCiAgICAgIGJ1ZmZlciwKICAgICAgcG9zLAogICAgICBzb3V0aFZlcnRleENvdW50CiAgICApOwogICAgcG9zICs9IHNvdXRoVmVydGV4Q291bnQgKiBieXRlc1BlckluZGV4OwogICAgY29uc3QgZWFzdFZlcnRleENvdW50ID0gdmlldy5nZXRVaW50MzIocG9zLCB0cnVlKTsKICAgIHBvcyArPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgIGNvbnN0IGVhc3RJbmRpY2VzID0gSW5kZXhEYXRhdHlwZV9kZWZhdWx0LmNyZWF0ZVR5cGVkQXJyYXlGcm9tQXJyYXlCdWZmZXIoCiAgICAgIHZlcnRleENvdW50LAogICAgICBidWZmZXIsCiAgICAgIHBvcywKICAgICAgZWFzdFZlcnRleENvdW50CiAgICApOwogICAgcG9zICs9IGVhc3RWZXJ0ZXhDb3VudCAqIGJ5dGVzUGVySW5kZXg7CiAgICBjb25zdCBub3J0aFZlcnRleENvdW50ID0gdmlldy5nZXRVaW50MzIocG9zLCB0cnVlKTsKICAgIHBvcyArPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgIGNvbnN0IG5vcnRoSW5kaWNlcyA9IEluZGV4RGF0YXR5cGVfZGVmYXVsdC5jcmVhdGVUeXBlZEFycmF5RnJvbUFycmF5QnVmZmVyKAogICAgICB2ZXJ0ZXhDb3VudCwKICAgICAgYnVmZmVyLAogICAgICBwb3MsCiAgICAgIG5vcnRoVmVydGV4Q291bnQKICAgICk7CiAgICBwb3MgKz0gbm9ydGhWZXJ0ZXhDb3VudCAqIGJ5dGVzUGVySW5kZXg7CiAgICBsZXQgZW5jb2RlZE5vcm1hbEJ1ZmZlcjsKICAgIGxldCB3YXRlck1hc2tCdWZmZXI7CiAgICB3aGlsZSAocG9zIDwgdmlldy5ieXRlTGVuZ3RoKSB7CiAgICAgIGNvbnN0IGV4dGVuc2lvbklkID0gdmlldy5nZXRVaW50OChwb3MsIHRydWUpOwogICAgICBwb3MgKz0gVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgICAgY29uc3QgZXh0ZW5zaW9uTGVuZ3RoID0gdmlldy5nZXRVaW50MzIocG9zLCBsaXR0bGVFbmRpYW5FeHRlbnNpb25TaXplKTsKICAgICAgcG9zICs9IFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOwogICAgICBpZiAoZXh0ZW5zaW9uSWQgPT09IFF1YW50aXplZE1lc2hFeHRlbnNpb25JZHMuT0NUX1ZFUlRFWF9OT1JNQUxTICYmIHByb3ZpZGVyLl9yZXF1ZXN0VmVydGV4Tm9ybWFscykgewogICAgICAgIGVuY29kZWROb3JtYWxCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIsIHBvcywgdmVydGV4Q291bnQgKiAyKTsKICAgICAgfSBlbHNlIGlmIChleHRlbnNpb25JZCA9PT0gUXVhbnRpemVkTWVzaEV4dGVuc2lvbklkcy5XQVRFUl9NQVNLICYmIHByb3ZpZGVyLl9yZXF1ZXN0V2F0ZXJNYXNrKSB7CiAgICAgICAgd2F0ZXJNYXNrQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBwb3MsIGV4dGVuc2lvbkxlbmd0aCk7CiAgICAgIH0gZWxzZSBpZiAoZXh0ZW5zaW9uSWQgPT09IFF1YW50aXplZE1lc2hFeHRlbnNpb25JZHMuTUVUQURBVEEgJiYgcHJvdmlkZXIuX3JlcXVlc3RNZXRhZGF0YSkgewogICAgICAgIGNvbnN0IHN0cmluZ0xlbmd0aCA9IHZpZXcuZ2V0VWludDMyKHBvcywgdHJ1ZSk7CiAgICAgICAgaWYgKHN0cmluZ0xlbmd0aCA+IDApIHsKICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0SnNvbkZyb21UeXBlZEFycmF5X2RlZmF1bHQoCiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlciksCiAgICAgICAgICAgIHBvcyArIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULAogICAgICAgICAgICBzdHJpbmdMZW5ndGgKICAgICAgICAgICk7CiAgICAgICAgICBjb25zdCBhdmFpbGFibGVUaWxlcyA9IG1ldGFkYXRhLmF2YWlsYWJsZTsKICAgICAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoYXZhaWxhYmxlVGlsZXMpKSB7CiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGF2YWlsYWJsZVRpbGVzLmxlbmd0aDsgKytvZmZzZXQpIHsKICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGVMZXZlbCA9IGxldmVsICsgb2Zmc2V0ICsgMTsKICAgICAgICAgICAgICBjb25zdCByYW5nZXNBdExldmVsID0gYXZhaWxhYmxlVGlsZXNbb2Zmc2V0XTsKICAgICAgICAgICAgICBjb25zdCB5VGlsZXMgPSBwcm92aWRlci5fdGlsaW5nU2NoZW1lLmdldE51bWJlck9mWVRpbGVzQXRMZXZlbCgKICAgICAgICAgICAgICAgIGF2YWlsYWJsZUxldmVsCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICBmb3IgKGxldCByYW5nZUluZGV4ID0gMDsgcmFuZ2VJbmRleCA8IHJhbmdlc0F0TGV2ZWwubGVuZ3RoOyArK3JhbmdlSW5kZXgpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzQXRMZXZlbFtyYW5nZUluZGV4XTsKICAgICAgICAgICAgICAgIGNvbnN0IHlTdGFydCA9IHlUaWxlcyAtIHJhbmdlLmVuZFkgLSAxOwogICAgICAgICAgICAgICAgY29uc3QgeUVuZCA9IHlUaWxlcyAtIHJhbmdlLnN0YXJ0WSAtIDE7CiAgICAgICAgICAgICAgICBwcm92aWRlci5hdmFpbGFiaWxpdHkuYWRkQXZhaWxhYmxlVGlsZVJhbmdlKAogICAgICAgICAgICAgICAgICBhdmFpbGFibGVMZXZlbCwKICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRYLAogICAgICAgICAgICAgICAgICB5U3RhcnQsCiAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZFgsCiAgICAgICAgICAgICAgICAgIHlFbmQKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBsYXllci5hdmFpbGFiaWxpdHkuYWRkQXZhaWxhYmxlVGlsZVJhbmdlKAogICAgICAgICAgICAgICAgICBhdmFpbGFibGVMZXZlbCwKICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRYLAogICAgICAgICAgICAgICAgICB5U3RhcnQsCiAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZFgsCiAgICAgICAgICAgICAgICAgIHlFbmQKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGxheWVyLmF2YWlsYWJpbGl0eVRpbGVzTG9hZGVkLmFkZEF2YWlsYWJsZVRpbGVSYW5nZShsZXZlbCwgeCwgeSwgeCwgeSk7CiAgICAgIH0KICAgICAgcG9zICs9IGV4dGVuc2lvbkxlbmd0aDsKICAgIH0KICAgIGNvbnN0IHNraXJ0SGVpZ2h0ID0gcHJvdmlkZXIuZ2V0TGV2ZWxNYXhpbXVtR2VvbWV0cmljRXJyb3IobGV2ZWwpICogNTsKICAgIGNvbnN0IHJlY3RhbmdsZSA9IHByb3ZpZGVyLl90aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwpOwogICAgY29uc3Qgb3JpZW50ZWRCb3VuZGluZ0JveCA9IE9yaWVudGVkQm91bmRpbmdCb3hfZGVmYXVsdC5mcm9tUmVjdGFuZ2xlKAogICAgICByZWN0YW5nbGUsCiAgICAgIG1pbmltdW1IZWlnaHQsCiAgICAgIG1heGltdW1IZWlnaHQsCiAgICAgIHByb3ZpZGVyLl90aWxpbmdTY2hlbWUuZWxsaXBzb2lkCiAgICApOwogICAgcmV0dXJuIG5ldyBRdWFudGl6ZWRNZXNoVGVycmFpbkRhdGFfZGVmYXVsdCh7CiAgICAgIGNlbnRlciwKICAgICAgbWluaW11bUhlaWdodCwKICAgICAgbWF4aW11bUhlaWdodCwKICAgICAgYm91bmRpbmdTcGhlcmUsCiAgICAgIG9yaWVudGVkQm91bmRpbmdCb3gsCiAgICAgIGhvcml6b25PY2NsdXNpb25Qb2ludCwKICAgICAgcXVhbnRpemVkVmVydGljZXM6IGVuY29kZWRWZXJ0ZXhCdWZmZXIsCiAgICAgIGVuY29kZWROb3JtYWxzOiBlbmNvZGVkTm9ybWFsQnVmZmVyLAogICAgICBpbmRpY2VzLAogICAgICB3ZXN0SW5kaWNlcywKICAgICAgc291dGhJbmRpY2VzLAogICAgICBlYXN0SW5kaWNlcywKICAgICAgbm9ydGhJbmRpY2VzLAogICAgICB3ZXN0U2tpcnRIZWlnaHQ6IHNraXJ0SGVpZ2h0LAogICAgICBzb3V0aFNraXJ0SGVpZ2h0OiBza2lydEhlaWdodCwKICAgICAgZWFzdFNraXJ0SGVpZ2h0OiBza2lydEhlaWdodCwKICAgICAgbm9ydGhTa2lydEhlaWdodDogc2tpcnRIZWlnaHQsCiAgICAgIGNoaWxkVGlsZU1hc2s6IHByb3ZpZGVyLmF2YWlsYWJpbGl0eS5jb21wdXRlQ2hpbGRNYXNrRm9yVGlsZShsZXZlbCwgeCwgeSksCiAgICAgIHdhdGVyTWFzazogd2F0ZXJNYXNrQnVmZmVyLAogICAgICBjcmVkaXRzOiBwcm92aWRlci5fdGlsZUNyZWRpdHMKICAgIH0pOwogIH0KICBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLnJlcXVlc3RUaWxlR2VvbWV0cnkgPSBmdW5jdGlvbih4LCB5LCBsZXZlbCwgcmVxdWVzdCkgewogICAgaWYgKCF0aGlzLl9yZWFkeSkgewogICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAicmVxdWVzdFRpbGVHZW9tZXRyeSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSB0ZXJyYWluIHByb3ZpZGVyIGlzIHJlYWR5LiIKICAgICAgKTsKICAgIH0KICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVyczsKICAgIGxldCBsYXllclRvVXNlOwogICAgY29uc3QgbGF5ZXJDb3VudCA9IGxheWVycy5sZW5ndGg7CiAgICBpZiAobGF5ZXJDb3VudCA9PT0gMSkgewogICAgICBsYXllclRvVXNlID0gbGF5ZXJzWzBdOwogICAgfSBlbHNlIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllckNvdW50OyArK2kpIHsKICAgICAgICBjb25zdCBsYXllciA9IGxheWVyc1tpXTsKICAgICAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsYXllci5hdmFpbGFiaWxpdHkpIHx8IGxheWVyLmF2YWlsYWJpbGl0eS5pc1RpbGVBdmFpbGFibGUobGV2ZWwsIHgsIHkpKSB7CiAgICAgICAgICBsYXllclRvVXNlID0gbGF5ZXI7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXF1ZXN0VGlsZUdlb21ldHJ5KHRoaXMsIHgsIHksIGxldmVsLCBsYXllclRvVXNlLCByZXF1ZXN0KTsKICB9OwogIGZ1bmN0aW9uIHJlcXVlc3RUaWxlR2VvbWV0cnkocHJvdmlkZXIsIHgsIHksIGxldmVsLCBsYXllclRvVXNlLCByZXF1ZXN0KSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsYXllclRvVXNlKSkgewogICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KCJUZXJyYWluIHRpbGUgZG9lc24ndCBleGlzdCIpKTsKICAgIH0KICAgIGNvbnN0IHVybFRlbXBsYXRlcyA9IGxheWVyVG9Vc2UudGlsZVVybFRlbXBsYXRlczsKICAgIGlmICh1cmxUZW1wbGF0ZXMubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBsZXQgdGVycmFpblk7CiAgICBpZiAoIXByb3ZpZGVyLl9zY2hlbWUgfHwgcHJvdmlkZXIuX3NjaGVtZSA9PT0gInRtcyIpIHsKICAgICAgY29uc3QgeVRpbGVzID0gcHJvdmlkZXIuX3RpbGluZ1NjaGVtZS5nZXROdW1iZXJPZllUaWxlc0F0TGV2ZWwobGV2ZWwpOwogICAgICB0ZXJyYWluWSA9IHlUaWxlcyAtIHkgLSAxOwogICAgfSBlbHNlIHsKICAgICAgdGVycmFpblkgPSB5OwogICAgfQogICAgY29uc3QgZXh0ZW5zaW9uTGlzdCA9IFtdOwogICAgaWYgKHByb3ZpZGVyLl9yZXF1ZXN0VmVydGV4Tm9ybWFscyAmJiBsYXllclRvVXNlLmhhc1ZlcnRleE5vcm1hbHMpIHsKICAgICAgZXh0ZW5zaW9uTGlzdC5wdXNoKAogICAgICAgIGxheWVyVG9Vc2UubGl0dGxlRW5kaWFuRXh0ZW5zaW9uU2l6ZSA/ICJvY3R2ZXJ0ZXhub3JtYWxzIiA6ICJ2ZXJ0ZXhub3JtYWxzIgogICAgICApOwogICAgfQogICAgaWYgKHByb3ZpZGVyLl9yZXF1ZXN0V2F0ZXJNYXNrICYmIGxheWVyVG9Vc2UuaGFzV2F0ZXJNYXNrKSB7CiAgICAgIGV4dGVuc2lvbkxpc3QucHVzaCgid2F0ZXJtYXNrIik7CiAgICB9CiAgICBpZiAocHJvdmlkZXIuX3JlcXVlc3RNZXRhZGF0YSAmJiBsYXllclRvVXNlLmhhc01ldGFkYXRhKSB7CiAgICAgIGV4dGVuc2lvbkxpc3QucHVzaCgibWV0YWRhdGEiKTsKICAgIH0KICAgIGxldCBoZWFkZXJzOwogICAgbGV0IHF1ZXJ5OwogICAgY29uc3QgdXJsID0gdXJsVGVtcGxhdGVzWyh4ICsgdGVycmFpblkgKyBsZXZlbCkgJSB1cmxUZW1wbGF0ZXMubGVuZ3RoXTsKICAgIGNvbnN0IHJlc291cmNlID0gbGF5ZXJUb1VzZS5yZXNvdXJjZTsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQocmVzb3VyY2UuX2lvbkVuZHBvaW50KSAmJiAhZGVmaW5lZF9kZWZhdWx0KHJlc291cmNlLl9pb25FbmRwb2ludC5leHRlcm5hbFR5cGUpKSB7CiAgICAgIGlmIChleHRlbnNpb25MaXN0Lmxlbmd0aCAhPT0gMCkgewogICAgICAgIHF1ZXJ5ID0geyBleHRlbnNpb25zOiBleHRlbnNpb25MaXN0LmpvaW4oIi0iKSB9OwogICAgICB9CiAgICAgIGhlYWRlcnMgPSBnZXRSZXF1ZXN0SGVhZGVyKHZvaWQgMCk7CiAgICB9IGVsc2UgewogICAgICBoZWFkZXJzID0gZ2V0UmVxdWVzdEhlYWRlcihleHRlbnNpb25MaXN0KTsKICAgIH0KICAgIGNvbnN0IHByb21pc2UgPSByZXNvdXJjZS5nZXREZXJpdmVkUmVzb3VyY2UoewogICAgICB1cmwsCiAgICAgIHRlbXBsYXRlVmFsdWVzOiB7CiAgICAgICAgdmVyc2lvbjogbGF5ZXJUb1VzZS52ZXJzaW9uLAogICAgICAgIHo6IGxldmVsLAogICAgICAgIHgsCiAgICAgICAgeTogdGVycmFpblkKICAgICAgfSwKICAgICAgcXVlcnlQYXJhbWV0ZXJzOiBxdWVyeSwKICAgICAgaGVhZGVycywKICAgICAgcmVxdWVzdAogICAgfSkuZmV0Y2hBcnJheUJ1ZmZlcigpOwogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQocHJvbWlzZSkpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYnVmZmVyKSB7CiAgICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGJ1ZmZlcikpIHsKICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFJ1bnRpbWVFcnJvcl9kZWZhdWx0KCJNZXNoIGJ1ZmZlciBkb2Vzbid0IGV4aXN0LiIpKTsKICAgICAgfQogICAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KHByb3ZpZGVyLl9oZWlnaHRtYXBTdHJ1Y3R1cmUpKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUhlaWdodG1hcFRlcnJhaW5EYXRhKHByb3ZpZGVyLCBidWZmZXIsIGxldmVsLCB4LCB5KTsKICAgICAgfQogICAgICByZXR1cm4gY3JlYXRlUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhKAogICAgICAgIHByb3ZpZGVyLAogICAgICAgIGJ1ZmZlciwKICAgICAgICBsZXZlbCwKICAgICAgICB4LAogICAgICAgIHksCiAgICAgICAgbGF5ZXJUb1VzZQogICAgICApOwogICAgfSk7CiAgfQogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENlc2l1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUsIHsKICAgIGVycm9yRXZlbnQ6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3JFdmVudDsKICAgICAgfQogICAgfSwKICAgIGNyZWRpdDogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHsKICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICAgICAiY3JlZGl0IG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHRlcnJhaW4gcHJvdmlkZXIgaXMgcmVhZHkuIgogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWRpdDsKICAgICAgfQogICAgfSwKICAgIHRpbGluZ1NjaGVtZTogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHsKICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICAgICAidGlsaW5nU2NoZW1lIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHRlcnJhaW4gcHJvdmlkZXIgaXMgcmVhZHkuIgogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGluZ1NjaGVtZTsKICAgICAgfQogICAgfSwKICAgIHJlYWR5OiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5OwogICAgICB9CiAgICB9LAogICAgcmVhZHlQcm9taXNlOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTsKICAgICAgfQogICAgfSwKICAgIGhhc1dhdGVyTWFzazogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHsKICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICAgICAiaGFzV2F0ZXJNYXNrIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHRlcnJhaW4gcHJvdmlkZXIgaXMgcmVhZHkuIgogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1dhdGVyTWFzayAmJiB0aGlzLl9yZXF1ZXN0V2F0ZXJNYXNrOwogICAgICB9CiAgICB9LAogICAgaGFzVmVydGV4Tm9ybWFsczogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHsKICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICAgICAiaGFzVmVydGV4Tm9ybWFscyBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSB0ZXJyYWluIHByb3ZpZGVyIGlzIHJlYWR5LiIKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzLl9oYXNWZXJ0ZXhOb3JtYWxzICYmIHRoaXMuX3JlcXVlc3RWZXJ0ZXhOb3JtYWxzOwogICAgICB9CiAgICB9LAogICAgaGFzTWV0YWRhdGE6IHsKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICBpZiAoIXRoaXMuX3JlYWR5KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3JfZGVmYXVsdCgKICAgICAgICAgICAgImhhc01ldGFkYXRhIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHRlcnJhaW4gcHJvdmlkZXIgaXMgcmVhZHkuIgogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01ldGFkYXRhICYmIHRoaXMuX3JlcXVlc3RNZXRhZGF0YTsKICAgICAgfQogICAgfSwKICAgIHJlcXVlc3RWZXJ0ZXhOb3JtYWxzOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RWZXJ0ZXhOb3JtYWxzOwogICAgICB9CiAgICB9LAogICAgcmVxdWVzdFdhdGVyTWFzazogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0V2F0ZXJNYXNrOwogICAgICB9CiAgICB9LAogICAgcmVxdWVzdE1ldGFkYXRhOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RNZXRhZGF0YTsKICAgICAgfQogICAgfSwKICAgIGF2YWlsYWJpbGl0eTogewogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHsKICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcl9kZWZhdWx0KAogICAgICAgICAgICAiYXZhaWxhYmlsaXR5IG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHRlcnJhaW4gcHJvdmlkZXIgaXMgcmVhZHkuIgogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX2F2YWlsYWJpbGl0eTsKICAgICAgfQogICAgfQogIH0pOwogIENlc2l1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0TGV2ZWxNYXhpbXVtR2VvbWV0cmljRXJyb3IgPSBmdW5jdGlvbihsZXZlbCkgewogICAgcmV0dXJuIHRoaXMuX2xldmVsWmVyb01heGltdW1HZW9tZXRyaWNFcnJvciAvICgxIDw8IGxldmVsKTsKICB9OwogIENlc2l1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZURhdGFBdmFpbGFibGUgPSBmdW5jdGlvbih4LCB5LCBsZXZlbCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpcy5fYXZhaWxhYmlsaXR5KSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKGxldmVsID4gdGhpcy5fYXZhaWxhYmlsaXR5Ll9tYXhpbXVtTGV2ZWwpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgaWYgKHRoaXMuX2F2YWlsYWJpbGl0eS5pc1RpbGVBdmFpbGFibGUobGV2ZWwsIHgsIHkpKSB7CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgaWYgKCF0aGlzLl9oYXNNZXRhZGF0YSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7CiAgICBjb25zdCBjb3VudCA9IGxheWVycy5sZW5ndGg7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHsKICAgICAgY29uc3QgbGF5ZXJSZXN1bHQgPSBjaGVja0xheWVyKHRoaXMsIHgsIHksIGxldmVsLCBsYXllcnNbaV0sIGkgPT09IDApOwogICAgICBpZiAobGF5ZXJSZXN1bHQucmVzdWx0KSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH07CiAgQ2VzaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5sb2FkVGlsZURhdGFBdmFpbGFiaWxpdHkgPSBmdW5jdGlvbih4LCB5LCBsZXZlbCkgewogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQodGhpcy5fYXZhaWxhYmlsaXR5KSB8fCBsZXZlbCA+IHRoaXMuX2F2YWlsYWJpbGl0eS5fbWF4aW11bUxldmVsIHx8IHRoaXMuX2F2YWlsYWJpbGl0eS5pc1RpbGVBdmFpbGFibGUobGV2ZWwsIHgsIHkpIHx8ICF0aGlzLl9oYXNNZXRhZGF0YSkgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzOwogICAgY29uc3QgY291bnQgPSBsYXllcnMubGVuZ3RoOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7CiAgICAgIGNvbnN0IGxheWVyUmVzdWx0ID0gY2hlY2tMYXllcih0aGlzLCB4LCB5LCBsZXZlbCwgbGF5ZXJzW2ldLCBpID09PSAwKTsKICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdChsYXllclJlc3VsdC5wcm9taXNlKSkgewogICAgICAgIHJldHVybiBsYXllclJlc3VsdC5wcm9taXNlOwogICAgICB9CiAgICB9CiAgfTsKICBmdW5jdGlvbiBnZXRBdmFpbGFiaWxpdHlUaWxlKGxheWVyLCB4LCB5LCBsZXZlbCkgewogICAgaWYgKGxldmVsID09PSAwKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGF2YWlsYWJpbGl0eUxldmVscyA9IGxheWVyLmF2YWlsYWJpbGl0eUxldmVsczsKICAgIGNvbnN0IHBhcmVudExldmVsID0gbGV2ZWwgJSBhdmFpbGFiaWxpdHlMZXZlbHMgPT09IDAgPyBsZXZlbCAtIGF2YWlsYWJpbGl0eUxldmVscyA6IChsZXZlbCAvIGF2YWlsYWJpbGl0eUxldmVscyB8IDApICogYXZhaWxhYmlsaXR5TGV2ZWxzOwogICAgY29uc3QgZGl2aXNvciA9IDEgPDwgbGV2ZWwgLSBwYXJlbnRMZXZlbDsKICAgIGNvbnN0IHBhcmVudFggPSB4IC8gZGl2aXNvciB8IDA7CiAgICBjb25zdCBwYXJlbnRZID0geSAvIGRpdmlzb3IgfCAwOwogICAgcmV0dXJuIHsKICAgICAgbGV2ZWw6IHBhcmVudExldmVsLAogICAgICB4OiBwYXJlbnRYLAogICAgICB5OiBwYXJlbnRZCiAgICB9OwogIH0KICBmdW5jdGlvbiBjaGVja0xheWVyKHByb3ZpZGVyLCB4LCB5LCBsZXZlbCwgbGF5ZXIsIHRvcExheWVyKSB7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChsYXllci5hdmFpbGFiaWxpdHlMZXZlbHMpKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgcmVzdWx0OiBmYWxzZQogICAgICB9OwogICAgfQogICAgbGV0IGNhY2hlS2V5OwogICAgY29uc3QgZGVsZXRlRnJvbUNhY2hlID0gZnVuY3Rpb24oKSB7CiAgICAgIGRlbGV0ZSBsYXllci5hdmFpbGFiaWxpdHlQcm9taXNlQ2FjaGVbY2FjaGVLZXldOwogICAgfTsKICAgIGNvbnN0IGF2YWlsYWJpbGl0eVRpbGVzTG9hZGVkID0gbGF5ZXIuYXZhaWxhYmlsaXR5VGlsZXNMb2FkZWQ7CiAgICBjb25zdCBhdmFpbGFiaWxpdHkgPSBsYXllci5hdmFpbGFiaWxpdHk7CiAgICBsZXQgdGlsZSA9IGdldEF2YWlsYWJpbGl0eVRpbGUobGF5ZXIsIHgsIHksIGxldmVsKTsKICAgIHdoaWxlIChkZWZpbmVkX2RlZmF1bHQodGlsZSkpIHsKICAgICAgaWYgKGF2YWlsYWJpbGl0eS5pc1RpbGVBdmFpbGFibGUodGlsZS5sZXZlbCwgdGlsZS54LCB0aWxlLnkpICYmICFhdmFpbGFiaWxpdHlUaWxlc0xvYWRlZC5pc1RpbGVBdmFpbGFibGUodGlsZS5sZXZlbCwgdGlsZS54LCB0aWxlLnkpKSB7CiAgICAgICAgbGV0IHJlcXVlc3RQcm9taXNlOwogICAgICAgIGlmICghdG9wTGF5ZXIpIHsKICAgICAgICAgIGNhY2hlS2V5ID0gYCR7dGlsZS5sZXZlbH0tJHt0aWxlLnh9LSR7dGlsZS55fWA7CiAgICAgICAgICByZXF1ZXN0UHJvbWlzZSA9IGxheWVyLmF2YWlsYWJpbGl0eVByb21pc2VDYWNoZVtjYWNoZUtleV07CiAgICAgICAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXF1ZXN0UHJvbWlzZSkpIHsKICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0X2RlZmF1bHQoewogICAgICAgICAgICAgIHRocm90dGxlOiBmYWxzZSwKICAgICAgICAgICAgICB0aHJvdHRsZUJ5U2VydmVyOiB0cnVlLAogICAgICAgICAgICAgIHR5cGU6IFJlcXVlc3RUeXBlX2RlZmF1bHQuVEVSUkFJTgogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmVxdWVzdFByb21pc2UgPSByZXF1ZXN0VGlsZUdlb21ldHJ5KAogICAgICAgICAgICAgIHByb3ZpZGVyLAogICAgICAgICAgICAgIHRpbGUueCwKICAgICAgICAgICAgICB0aWxlLnksCiAgICAgICAgICAgICAgdGlsZS5sZXZlbCwKICAgICAgICAgICAgICBsYXllciwKICAgICAgICAgICAgICByZXF1ZXN0CiAgICAgICAgICAgICk7CiAgICAgICAgICAgIGlmIChkZWZpbmVkX2RlZmF1bHQocmVxdWVzdFByb21pc2UpKSB7CiAgICAgICAgICAgICAgbGF5ZXIuYXZhaWxhYmlsaXR5UHJvbWlzZUNhY2hlW2NhY2hlS2V5XSA9IHJlcXVlc3RQcm9taXNlOwogICAgICAgICAgICAgIHJlcXVlc3RQcm9taXNlLnRoZW4oZGVsZXRlRnJvbUNhY2hlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gewogICAgICAgICAgcmVzdWx0OiB0cnVlLAogICAgICAgICAgcHJvbWlzZTogcmVxdWVzdFByb21pc2UKICAgICAgICB9OwogICAgICB9CiAgICAgIHRpbGUgPSBnZXRBdmFpbGFiaWxpdHlUaWxlKGxheWVyLCB0aWxlLngsIHRpbGUueSwgdGlsZS5sZXZlbCk7CiAgICB9CiAgICByZXR1cm4gewogICAgICByZXN1bHQ6IGZhbHNlCiAgICB9OwogIH0KICBDZXNpdW1UZXJyYWluUHJvdmlkZXIuX2dldEF2YWlsYWJpbGl0eVRpbGUgPSBnZXRBdmFpbGFiaWxpdHlUaWxlOwogIHZhciBDZXNpdW1UZXJyYWluUHJvdmlkZXJfZGVmYXVsdCA9IENlc2l1bVRlcnJhaW5Qcm92aWRlcjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0lvbi5qcwogIHZhciBkZWZhdWx0VG9rZW5DcmVkaXQ7CiAgdmFyIGRlZmF1bHRBY2Nlc3NUb2tlbiA9ICJleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKcWRHa2lPaUk0TlRGaFpUVXpZeTFpTURZMUxUUTNPR010WW1Vek1TMHpaamt6WXpBMU9UY3dNemdpTENKcFpDSTZNalU1TENKcFlYUWlPakUyTmpjek1EZzJPVE45LjE5ZXZqWW40WVp5QjFPb1VWXzc3cUwySk9Kci1aYzFNcWpwM3dZaXNDek0iOwogIHZhciBJb24gPSB7fTsKICBJb24uZGVmYXVsdEFjY2Vzc1Rva2VuID0gZGVmYXVsdEFjY2Vzc1Rva2VuOwogIElvbi5kZWZhdWx0U2VydmVyID0gbmV3IFJlc291cmNlX2RlZmF1bHQoeyB1cmw6ICJodHRwczovL2FwaS5jZXNpdW0uY29tLyIgfSk7CiAgSW9uLmdldERlZmF1bHRUb2tlbkNyZWRpdCA9IGZ1bmN0aW9uKHByb3ZpZGVkS2V5KSB7CiAgICBpZiAocHJvdmlkZWRLZXkgIT09IGRlZmF1bHRBY2Nlc3NUb2tlbikgewogICAgICByZXR1cm4gdm9pZCAwOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoZGVmYXVsdFRva2VuQ3JlZGl0KSkgewogICAgICBjb25zdCBkZWZhdWx0VG9rZW5NZXNzYWdlID0gYDxiPiAgICAgICAgICAgICBUaGlzIGFwcGxpY2F0aW9uIGlzIHVzaW5nIENlc2l1bSdzIGRlZmF1bHQgaW9uIGFjY2VzcyB0b2tlbi4gUGxlYXNlIGFzc2lnbiA8aT5DZXNpdW0uSW9uLmRlZmF1bHRBY2Nlc3NUb2tlbjwvaT4gICAgICAgICAgICAgd2l0aCBhbiBhY2Nlc3MgdG9rZW4gZnJvbSB5b3VyIGlvbiBhY2NvdW50IGJlZm9yZSBtYWtpbmcgYW55IENlc2l1bSBBUEkgY2FsbHMuICAgICAgICAgICAgIFlvdSBjYW4gc2lnbiB1cCBmb3IgYSBmcmVlIGlvbiBhY2NvdW50IGF0IDxhIGhyZWY9Imh0dHBzOi8vY2VzaXVtLmNvbSI+aHR0cHM6Ly9jZXNpdW0uY29tPC9hPi48L2I+YDsKICAgICAgZGVmYXVsdFRva2VuQ3JlZGl0ID0gbmV3IENyZWRpdF9kZWZhdWx0KGRlZmF1bHRUb2tlbk1lc3NhZ2UsIHRydWUpOwogICAgfQogICAgcmV0dXJuIGRlZmF1bHRUb2tlbkNyZWRpdDsKICB9OwogIHZhciBJb25fZGVmYXVsdCA9IElvbjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0lvblJlc291cmNlLmpzCiAgdmFyIGltcG9ydF91cmlqczggPSBfX3RvRVNNKHJlcXVpcmVfVVJJKCksIDEpOwogIGZ1bmN0aW9uIElvblJlc291cmNlKGVuZHBvaW50LCBlbmRwb2ludFJlc291cmNlKSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImVuZHBvaW50IiwgZW5kcG9pbnQpOwogICAgQ2hlY2tfZGVmYXVsdC5kZWZpbmVkKCJlbmRwb2ludFJlc291cmNlIiwgZW5kcG9pbnRSZXNvdXJjZSk7CiAgICBsZXQgb3B0aW9uczsKICAgIGNvbnN0IGV4dGVybmFsVHlwZSA9IGVuZHBvaW50LmV4dGVybmFsVHlwZTsKICAgIGNvbnN0IGlzRXh0ZXJuYWwgPSBkZWZpbmVkX2RlZmF1bHQoZXh0ZXJuYWxUeXBlKTsKICAgIGlmICghaXNFeHRlcm5hbCkgewogICAgICBvcHRpb25zID0gewogICAgICAgIHVybDogZW5kcG9pbnQudXJsLAogICAgICAgIHJldHJ5QXR0ZW1wdHM6IDEsCiAgICAgICAgcmV0cnlDYWxsYmFjawogICAgICB9OwogICAgfSBlbHNlIGlmIChleHRlcm5hbFR5cGUgPT09ICIzRFRJTEVTIiB8fCBleHRlcm5hbFR5cGUgPT09ICJTVEtfVEVSUkFJTl9TRVJWRVIiKSB7CiAgICAgIG9wdGlvbnMgPSB7IHVybDogZW5kcG9pbnQub3B0aW9ucy51cmwgfTsKICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3JfZGVmYXVsdCgKICAgICAgICAiSW9uLmNyZWF0ZVJlc291cmNlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZXJuYWwgaW1hZ2VyeSBhc3NldHM7IHVzZSBJb25JbWFnZXJ5UHJvdmlkZXIgaW5zdGVhZC4iCiAgICAgICk7CiAgICB9CiAgICBSZXNvdXJjZV9kZWZhdWx0LmNhbGwodGhpcywgb3B0aW9ucyk7CiAgICB0aGlzLl9pb25FbmRwb2ludCA9IGVuZHBvaW50OwogICAgdGhpcy5faW9uRW5kcG9pbnREb21haW4gPSBpc0V4dGVybmFsID8gdm9pZCAwIDogbmV3IGltcG9ydF91cmlqczguZGVmYXVsdChlbmRwb2ludC51cmwpLmF1dGhvcml0eSgpOwogICAgdGhpcy5faW9uRW5kcG9pbnRSZXNvdXJjZSA9IGVuZHBvaW50UmVzb3VyY2U7CiAgICB0aGlzLl9pb25Sb290ID0gdm9pZCAwOwogICAgdGhpcy5fcGVuZGluZ1Byb21pc2UgPSB2b2lkIDA7CiAgICB0aGlzLl9jcmVkaXRzID0gdm9pZCAwOwogICAgdGhpcy5faXNFeHRlcm5hbCA9IGlzRXh0ZXJuYWw7CiAgfQogIGlmIChkZWZpbmVkX2RlZmF1bHQoT2JqZWN0LmNyZWF0ZSkpIHsKICAgIElvblJlc291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVzb3VyY2VfZGVmYXVsdC5wcm90b3R5cGUpOwogICAgSW9uUmVzb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW9uUmVzb3VyY2U7CiAgfQogIElvblJlc291cmNlLmZyb21Bc3NldElkID0gZnVuY3Rpb24oYXNzZXRJZCwgb3B0aW9ucykgewogICAgY29uc3QgZW5kcG9pbnRSZXNvdXJjZSA9IElvblJlc291cmNlLl9jcmVhdGVFbmRwb2ludFJlc291cmNlKAogICAgICBhc3NldElkLAogICAgICBvcHRpb25zCiAgICApOwogICAgcmV0dXJuIGVuZHBvaW50UmVzb3VyY2UuZmV0Y2hKc29uKCkudGhlbihmdW5jdGlvbihlbmRwb2ludCkgewogICAgICByZXR1cm4gbmV3IElvblJlc291cmNlKGVuZHBvaW50LCBlbmRwb2ludFJlc291cmNlKTsKICAgIH0pOwogIH07CiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSW9uUmVzb3VyY2UucHJvdG90eXBlLCB7CiAgICBjcmVkaXRzOiB7CiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdCh0aGlzLl9pb25Sb290KSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2lvblJvb3QuY3JlZGl0czsKICAgICAgICB9CiAgICAgICAgaWYgKGRlZmluZWRfZGVmYXVsdCh0aGlzLl9jcmVkaXRzKSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWRpdHM7CiAgICAgICAgfQogICAgICAgIHRoaXMuX2NyZWRpdHMgPSBJb25SZXNvdXJjZS5nZXRDcmVkaXRzRnJvbUVuZHBvaW50KAogICAgICAgICAgdGhpcy5faW9uRW5kcG9pbnQsCiAgICAgICAgICB0aGlzLl9pb25FbmRwb2ludFJlc291cmNlCiAgICAgICAgKTsKICAgICAgICByZXR1cm4gdGhpcy5fY3JlZGl0czsKICAgICAgfQogICAgfQogIH0pOwogIElvblJlc291cmNlLmdldENyZWRpdHNGcm9tRW5kcG9pbnQgPSBmdW5jdGlvbihlbmRwb2ludCwgZW5kcG9pbnRSZXNvdXJjZSkgewogICAgY29uc3QgY3JlZGl0cyA9IGVuZHBvaW50LmF0dHJpYnV0aW9ucy5tYXAoQ3JlZGl0X2RlZmF1bHQuZ2V0SW9uQ3JlZGl0KTsKICAgIGNvbnN0IGRlZmF1bHRUb2tlbkNyZWRpdDIgPSBJb25fZGVmYXVsdC5nZXREZWZhdWx0VG9rZW5DcmVkaXQoCiAgICAgIGVuZHBvaW50UmVzb3VyY2UucXVlcnlQYXJhbWV0ZXJzLmFjY2Vzc190b2tlbgogICAgKTsKICAgIGlmIChkZWZpbmVkX2RlZmF1bHQoZGVmYXVsdFRva2VuQ3JlZGl0MikpIHsKICAgICAgY3JlZGl0cy5wdXNoKENyZWRpdF9kZWZhdWx0LmNsb25lKGRlZmF1bHRUb2tlbkNyZWRpdDIpKTsKICAgIH0KICAgIHJldHVybiBjcmVkaXRzOwogIH07CiAgSW9uUmVzb3VyY2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7CiAgICBjb25zdCBpb25Sb290ID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQodGhpcy5faW9uUm9vdCwgdGhpcyk7CiAgICBpZiAoIWRlZmluZWRfZGVmYXVsdChyZXN1bHQpKSB7CiAgICAgIHJlc3VsdCA9IG5ldyBJb25SZXNvdXJjZSgKICAgICAgICBpb25Sb290Ll9pb25FbmRwb2ludCwKICAgICAgICBpb25Sb290Ll9pb25FbmRwb2ludFJlc291cmNlCiAgICAgICk7CiAgICB9CiAgICByZXN1bHQgPSBSZXNvdXJjZV9kZWZhdWx0LnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIHJlc3VsdCk7CiAgICByZXN1bHQuX2lvblJvb3QgPSBpb25Sb290OwogICAgcmVzdWx0Ll9pc0V4dGVybmFsID0gdGhpcy5faXNFeHRlcm5hbDsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKICBJb25SZXNvdXJjZS5wcm90b3R5cGUuZmV0Y2hJbWFnZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgIGlmICghdGhpcy5faXNFeHRlcm5hbCkgewogICAgICBjb25zdCB1c2VyT3B0aW9ucyA9IG9wdGlvbnM7CiAgICAgIG9wdGlvbnMgPSB7CiAgICAgICAgcHJlZmVyQmxvYjogdHJ1ZQogICAgICB9OwogICAgICBpZiAoZGVmaW5lZF9kZWZhdWx0KHVzZXJPcHRpb25zKSkgewogICAgICAgIG9wdGlvbnMuZmxpcFkgPSB1c2VyT3B0aW9ucy5mbGlwWTsKICAgICAgICBvcHRpb25zLnByZWZlckltYWdlQml0bWFwID0gdXNlck9wdGlvbnMucHJlZmVySW1hZ2VCaXRtYXA7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBSZXNvdXJjZV9kZWZhdWx0LnByb3RvdHlwZS5mZXRjaEltYWdlLmNhbGwodGhpcywgb3B0aW9ucyk7CiAgfTsKICBJb25SZXNvdXJjZS5wcm90b3R5cGUuX21ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ob3B0aW9ucykgewogICAgaWYgKHRoaXMuX2lzRXh0ZXJuYWwgfHwgbmV3IGltcG9ydF91cmlqczguZGVmYXVsdCh0aGlzLnVybCkuYXV0aG9yaXR5KCkgIT09IHRoaXMuX2lvbkVuZHBvaW50RG9tYWluKSB7CiAgICAgIHJldHVybiBSZXNvdXJjZV9kZWZhdWx0LnByb3RvdHlwZS5fbWFrZVJlcXVlc3QuY2FsbCh0aGlzLCBvcHRpb25zKTsKICAgIH0KICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KG9wdGlvbnMuaGVhZGVycykpIHsKICAgICAgb3B0aW9ucy5oZWFkZXJzID0ge307CiAgICB9CiAgICBvcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0aGlzLl9pb25FbmRwb2ludC5hY2Nlc3NUb2tlbn1gOwogICAgcmV0dXJuIFJlc291cmNlX2RlZmF1bHQucHJvdG90eXBlLl9tYWtlUmVxdWVzdC5jYWxsKHRoaXMsIG9wdGlvbnMpOwogIH07CiAgSW9uUmVzb3VyY2UuX2NyZWF0ZUVuZHBvaW50UmVzb3VyY2UgPSBmdW5jdGlvbihhc3NldElkLCBvcHRpb25zKSB7CiAgICBDaGVja19kZWZhdWx0LmRlZmluZWQoImFzc2V0SWQiLCBhc3NldElkKTsKICAgIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLCBkZWZhdWx0VmFsdWVfZGVmYXVsdC5FTVBUWV9PQkpFQ1QpOwogICAgbGV0IHNlcnZlciA9IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMuc2VydmVyLCBJb25fZGVmYXVsdC5kZWZhdWx0U2VydmVyKTsKICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucy5hY2Nlc3NUb2tlbiwgSW9uX2RlZmF1bHQuZGVmYXVsdEFjY2Vzc1Rva2VuKTsKICAgIHNlcnZlciA9IFJlc291cmNlX2RlZmF1bHQuY3JlYXRlSWZOZWVkZWQoc2VydmVyKTsKICAgIGNvbnN0IHJlc291cmNlT3B0aW9ucyA9IHsKICAgICAgdXJsOiBgdjEvYXNzZXRzLyR7YXNzZXRJZH0vZW5kcG9pbnRgCiAgICB9OwogICAgaWYgKGRlZmluZWRfZGVmYXVsdChhY2Nlc3NUb2tlbikpIHsKICAgICAgcmVzb3VyY2VPcHRpb25zLnF1ZXJ5UGFyYW1ldGVycyA9IHsgYWNjZXNzX3Rva2VuOiBhY2Nlc3NUb2tlbiB9OwogICAgfQogICAgcmV0dXJuIHNlcnZlci5nZXREZXJpdmVkUmVzb3VyY2UocmVzb3VyY2VPcHRpb25zKTsKICB9OwogIGZ1bmN0aW9uIHJldHJ5Q2FsbGJhY2sodGhhdCwgZXJyb3IpIHsKICAgIGNvbnN0IGlvblJvb3QgPSBkZWZhdWx0VmFsdWVfZGVmYXVsdCh0aGF0Ll9pb25Sb290LCB0aGF0KTsKICAgIGNvbnN0IGVuZHBvaW50UmVzb3VyY2UgPSBpb25Sb290Ll9pb25FbmRwb2ludFJlc291cmNlOwogICAgY29uc3QgaW1hZ2VEZWZpbmVkID0gdHlwZW9mIEltYWdlICE9PSAidW5kZWZpbmVkIjsKICAgIGlmICghZGVmaW5lZF9kZWZhdWx0KGVycm9yKSB8fCBlcnJvci5zdGF0dXNDb2RlICE9PSA0MDEgJiYgIShpbWFnZURlZmluZWQgJiYgZXJyb3IudGFyZ2V0IGluc3RhbmNlb2YgSW1hZ2UpKSB7CiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpOwogICAgfQogICAgaWYgKCFkZWZpbmVkX2RlZmF1bHQoaW9uUm9vdC5fcGVuZGluZ1Byb21pc2UpKSB7CiAgICAgIGlvblJvb3QuX3BlbmRpbmdQcm9taXNlID0gZW5kcG9pbnRSZXNvdXJjZS5mZXRjaEpzb24oKS50aGVuKGZ1bmN0aW9uKG5ld0VuZHBvaW50KSB7CiAgICAgICAgaW9uUm9vdC5faW9uRW5kcG9pbnQgPSBuZXdFbmRwb2ludDsKICAgICAgICByZXR1cm4gbmV3RW5kcG9pbnQ7CiAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24obmV3RW5kcG9pbnQpIHsKICAgICAgICBpb25Sb290Ll9wZW5kaW5nUHJvbWlzZSA9IHZvaWQgMDsKICAgICAgICByZXR1cm4gbmV3RW5kcG9pbnQ7CiAgICAgIH0pOwogICAgfQogICAgcmV0dXJuIGlvblJvb3QuX3BlbmRpbmdQcm9taXNlLnRoZW4oZnVuY3Rpb24obmV3RW5kcG9pbnQpIHsKICAgICAgdGhhdC5faW9uRW5kcG9pbnQgPSBuZXdFbmRwb2ludDsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9KTsKICB9CiAgdmFyIElvblJlc291cmNlX2RlZmF1bHQgPSBJb25SZXNvdXJjZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL2NyZWF0ZVdvcmxkVGVycmFpbi5qcwogIGZ1bmN0aW9uIGNyZWF0ZVdvcmxkVGVycmFpbihvcHRpb25zKSB7CiAgICBvcHRpb25zID0gZGVmYXVsdFZhbHVlX2RlZmF1bHQob3B0aW9ucywgZGVmYXVsdFZhbHVlX2RlZmF1bHQuRU1QVFlfT0JKRUNUKTsKICAgIHJldHVybiBuZXcgQ2VzaXVtVGVycmFpblByb3ZpZGVyX2RlZmF1bHQoewogICAgICB1cmw6IElvblJlc291cmNlX2RlZmF1bHQuZnJvbUFzc2V0SWQoMSksCiAgICAgIHJlcXVlc3RWZXJ0ZXhOb3JtYWxzOiBkZWZhdWx0VmFsdWVfZGVmYXVsdChvcHRpb25zLnJlcXVlc3RWZXJ0ZXhOb3JtYWxzLCBmYWxzZSksCiAgICAgIHJlcXVlc3RXYXRlck1hc2s6IGRlZmF1bHRWYWx1ZV9kZWZhdWx0KG9wdGlvbnMucmVxdWVzdFdhdGVyTWFzaywgZmFsc2UpCiAgICB9KTsKICB9CiAgdmFyIGNyZWF0ZVdvcmxkVGVycmFpbl9kZWZhdWx0ID0gY3JlYXRlV29ybGRUZXJyYWluOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1RoaXJkUGFydHkva25vY2tvdXQtMy41LjEuanMKICB2YXIgb2xkVmFsdWU7CiAgaWYgKHR5cGVvZiBrbyAhPT0gInVuZGVmaW5lZCIpIHsKICAgIG9sZFZhbHVlID0ga287CiAgfQogIChmdW5jdGlvbigpIHsKICAgIChmdW5jdGlvbigpIHsKICAgICAgKGZ1bmN0aW9uKG4pIHsKICAgICAgICB2YXIgQSA9IHRoaXMgfHwgKDAsIGV2YWwpKCJ0aGlzIiksIHcgPSBBLmRvY3VtZW50LCBSID0gQS5uYXZpZ2F0b3IsIHYyID0gQS5qUXVlcnksIEggPSBBLkpTT047CiAgICAgICAgdjIgfHwgInVuZGVmaW5lZCIgPT09IHR5cGVvZiBqUXVlcnkgfHwgKHYyID0galF1ZXJ5KTsKICAgICAgICAoZnVuY3Rpb24objIpIHsKICAgICAgICAgIG4yKEEua28gPSB7fSk7CiAgICAgICAgfSkoZnVuY3Rpb24oUywgVCkgewogICAgICAgICAgZnVuY3Rpb24gSyhhNCwgYykgewogICAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gYTQgfHwgdHlwZW9mIGE0IGluIFcgPyBhNCA9PT0gYyA6IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gWChiLCBjKSB7CiAgICAgICAgICAgIHZhciBkOwogICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgZCB8fCAoZCA9IGEzLmEuc2V0VGltZW91dChmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGQgPSBuOwogICAgICAgICAgICAgICAgYigpOwogICAgICAgICAgICAgIH0sIGMpKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIFkoYiwgYykgewogICAgICAgICAgICB2YXIgZDsKICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIGNsZWFyVGltZW91dChkKTsKICAgICAgICAgICAgICBkID0gYTMuYS5zZXRUaW1lb3V0KGIsIGMpOwogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gWihhNCwgYykgewogICAgICAgICAgICBjICYmICJjaGFuZ2UiICE9PSBjID8gImJlZm9yZUNoYW5nZSIgPT09IGMgPyB0aGlzLnBjKGE0KSA6IHRoaXMuZ2IoYTQsIGMpIDogdGhpcy5xYyhhNCk7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBhYShhNCwgYykgewogICAgICAgICAgICBudWxsICE9PSBjICYmIGMucyAmJiBjLnMoKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGJhKGE0LCBjKSB7CiAgICAgICAgICAgIHZhciBkID0gdGhpcy5xZCwgZSA9IGRbcl07CiAgICAgICAgICAgIGUucmEgfHwgKHRoaXMuUWIgJiYgdGhpcy5tYltjXSA/IChkLnVjKGMsIGE0LCB0aGlzLm1iW2NdKSwgdGhpcy5tYltjXSA9IG51bGwsIC0tdGhpcy5RYikgOiBlLklbY10gfHwgZC51YyhjLCBhNCwgZS5KID8geyBkYTogYTQgfSA6IGQuJGMoYTQpKSwgYTQuSmEgJiYgYTQuZ2QoKSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgYTMgPSAidW5kZWZpbmVkIiAhPT0gdHlwZW9mIFMgPyBTIDoge307CiAgICAgICAgICBhMy5iID0gZnVuY3Rpb24oYiwgYykgewogICAgICAgICAgICBmb3IgKHZhciBkID0gYi5zcGxpdCgiLiIpLCBlID0gYTMsIGYgPSAwOyBmIDwgZC5sZW5ndGggLSAxOyBmKyspCiAgICAgICAgICAgICAgZSA9IGVbZFtmXV07CiAgICAgICAgICAgIGVbZFtkLmxlbmd0aCAtIDFdXSA9IGM7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuTCA9IGZ1bmN0aW9uKGE0LCBjLCBkKSB7CiAgICAgICAgICAgIGE0W2NdID0gZDsKICAgICAgICAgIH07CiAgICAgICAgICBhMy52ZXJzaW9uID0gIjMuNS4xIjsKICAgICAgICAgIGEzLmIoCiAgICAgICAgICAgICJ2ZXJzaW9uIiwKICAgICAgICAgICAgYTMudmVyc2lvbgogICAgICAgICAgKTsKICAgICAgICAgIGEzLm9wdGlvbnMgPSB7IGRlZmVyVXBkYXRlczogZmFsc2UsIHVzZU9ubHlOYXRpdmVFdmVudHM6IGZhbHNlLCBmb3JlYWNoSGlkZXNEZXN0cm95ZWQ6IGZhbHNlIH07CiAgICAgICAgICBhMy5hID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYTQsIGIyKSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgYzIgaW4gYTQpCiAgICAgICAgICAgICAgICBmLmNhbGwoYTQsIGMyKSAmJiBiMihjMiwgYTRbYzJdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBjKGE0LCBiMikgewogICAgICAgICAgICAgIGlmIChiMikKICAgICAgICAgICAgICAgIGZvciAodmFyIGMyIGluIGIyKQogICAgICAgICAgICAgICAgICBmLmNhbGwoYjIsIGMyKSAmJiAoYTRbYzJdID0gYjJbYzJdKTsKICAgICAgICAgICAgICByZXR1cm4gYTQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZChhNCwgYjIpIHsKICAgICAgICAgICAgICBhNC5fX3Byb3RvX18gPSBiMjsKICAgICAgICAgICAgICByZXR1cm4gYTQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZShiMiwgYzIsIGQyLCBlMikgewogICAgICAgICAgICAgIHZhciBsMiA9IGIyW2MyXS5tYXRjaChxKSB8fCBbXTsKICAgICAgICAgICAgICBhMy5hLkQoZDIubWF0Y2gocSksIGZ1bmN0aW9uKGIzKSB7CiAgICAgICAgICAgICAgICBhMy5hLk5hKGwyLCBiMywgZTIpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGIyW2MyXSA9IGwyLmpvaW4oIiAiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgZiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGcgPSB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5LCBoID0gImZ1bmN0aW9uIiA9PT0gdHlwZW9mIFN5bWJvbCwgbSA9IHt9LCBrID0ge307CiAgICAgICAgICAgIG1bUiAmJiAvRmlyZWZveFwvMi9pLnRlc3QoUi51c2VyQWdlbnQpID8gIktleWJvYXJkRXZlbnQiIDogIlVJRXZlbnRzIl0gPSBbImtleXVwIiwgImtleWRvd24iLCAia2V5cHJlc3MiXTsKICAgICAgICAgICAgbS5Nb3VzZUV2ZW50cyA9ICJjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSIuc3BsaXQoIiAiKTsKICAgICAgICAgICAgYihtLCBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICBpZiAoYjIubGVuZ3RoKQogICAgICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAwLCBkMiA9IGIyLmxlbmd0aDsgYzIgPCBkMjsgYzIrKykKICAgICAgICAgICAgICAgICAga1tiMltjMl1dID0gYTQ7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICB2YXIgbCA9IHsgcHJvcGVydHljaGFuZ2U6IHRydWUgfSwgcCA9IHcgJiYgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgYTQgPSAzLCBiMiA9IHcuY3JlYXRlRWxlbWVudCgiZGl2IiksIGMyID0gYjIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImkiKTsgYjIuaW5uZXJIVE1MID0gIjwhLS1baWYgZ3QgSUUgIiArICsrYTQgKyAiXT48aT48L2k+PCFbZW5kaWZdLS0+IiwgYzJbMF07ICkKICAgICAgICAgICAgICAgIDsKICAgICAgICAgICAgICByZXR1cm4gNCA8IGE0ID8gYTQgOiBuOwogICAgICAgICAgICB9KCksIHEgPSAvXFMrL2csIHQ7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgSmM6IFsiYXV0aGVudGljaXR5X3Rva2VuIiwgL15fX1JlcXVlc3RWZXJpZmljYXRpb25Ub2tlbihfLiopPyQvXSwKICAgICAgICAgICAgICBEOiBmdW5jdGlvbihhNCwgYjIsIGMyKSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMiA9IDAsIGUyID0gYTQubGVuZ3RoOyBkMiA8IGUyOyBkMisrKQogICAgICAgICAgICAgICAgICBiMi5jYWxsKGMyLCBhNFtkMl0sIGQyLCBhNCk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBBOiAiZnVuY3Rpb24iID09IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA/IGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYTQsIGIyKTsKICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oYTQsIGIyKSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBjMiA9IDAsIGQyID0gYTQubGVuZ3RoOyBjMiA8IGQyOyBjMisrKQogICAgICAgICAgICAgICAgICBpZiAoYTRbYzJdID09PSBiMikKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYzI7CiAgICAgICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBMYjogZnVuY3Rpb24oYTQsIGIyLCBjMikgewogICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwLCBlMiA9IGE0Lmxlbmd0aDsgZDIgPCBlMjsgZDIrKykKICAgICAgICAgICAgICAgICAgaWYgKGIyLmNhbGwoYzIsIGE0W2QyXSwgZDIsIGE0KSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTRbZDJdOwogICAgICAgICAgICAgICAgcmV0dXJuIG47CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBQYTogZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgICB2YXIgZDIgPSBhMy5hLkEoYjIsIGMyKTsKICAgICAgICAgICAgICAgIDAgPCBkMiA/IGIyLnNwbGljZShkMiwgMSkgOiAwID09PSBkMiAmJiBiMi5zaGlmdCgpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgd2M6IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgICB2YXIgYzIgPSBbXTsKICAgICAgICAgICAgICAgIGIyICYmIGEzLmEuRChiMiwgZnVuY3Rpb24oYjMpIHsKICAgICAgICAgICAgICAgICAgMCA+IGEzLmEuQShjMiwgYjMpICYmIGMyLnB1c2goYjMpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICByZXR1cm4gYzI7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBNYjogZnVuY3Rpb24oYTQsIGIyLCBjMikgewogICAgICAgICAgICAgICAgdmFyIGQyID0gW107CiAgICAgICAgICAgICAgICBpZiAoYTQpCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUyID0gMCwgbDIgPSBhNC5sZW5ndGg7IGUyIDwgbDI7IGUyKyspCiAgICAgICAgICAgICAgICAgICAgZDIucHVzaChiMi5jYWxsKGMyLCBhNFtlMl0sIGUyKSk7CiAgICAgICAgICAgICAgICByZXR1cm4gZDI7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBqYjogZnVuY3Rpb24oYTQsIGIyLCBjMikgewogICAgICAgICAgICAgICAgdmFyIGQyID0gW107CiAgICAgICAgICAgICAgICBpZiAoYTQpCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUyID0gMCwgbDIgPSBhNC5sZW5ndGg7IGUyIDwgbDI7IGUyKyspCiAgICAgICAgICAgICAgICAgICAgYjIuY2FsbChjMiwgYTRbZTJdLCBlMikgJiYgZDIucHVzaChhNFtlMl0pOwogICAgICAgICAgICAgICAgcmV0dXJuIGQyOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgTmI6IGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgICAgaWYgKGIyIGluc3RhbmNlb2YgQXJyYXkpCiAgICAgICAgICAgICAgICAgIGE0LnB1c2guYXBwbHkoYTQsIGIyKTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAwLCBkMiA9IGIyLmxlbmd0aDsgYzIgPCBkMjsgYzIrKykKICAgICAgICAgICAgICAgICAgICBhNC5wdXNoKGIyW2MyXSk7CiAgICAgICAgICAgICAgICByZXR1cm4gYTQ7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBOYTogZnVuY3Rpb24oYjIsIGMyLCBkMikgewogICAgICAgICAgICAgICAgdmFyIGUyID0gYTMuYS5BKGEzLmEuYmMoYjIpLCBjMik7CiAgICAgICAgICAgICAgICAwID4gZTIgPyBkMiAmJiBiMi5wdXNoKGMyKSA6IGQyIHx8IGIyLnNwbGljZShlMiwgMSk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBCYTogZywKICAgICAgICAgICAgICBleHRlbmQ6IGMsCiAgICAgICAgICAgICAgc2V0UHJvdG90eXBlT2Y6IGQsCiAgICAgICAgICAgICAgQWI6IGcgPyBkIDogYywKICAgICAgICAgICAgICBQOiBiLAogICAgICAgICAgICAgIEdhOiBmdW5jdGlvbihhNCwgYjIsIGMyKSB7CiAgICAgICAgICAgICAgICBpZiAoIWE0KQogICAgICAgICAgICAgICAgICByZXR1cm4gYTQ7CiAgICAgICAgICAgICAgICB2YXIgZDIgPSB7fSwgZTI7CiAgICAgICAgICAgICAgICBmb3IgKGUyIGluIGE0KQogICAgICAgICAgICAgICAgICBmLmNhbGwoYTQsIGUyKSAmJiAoZDJbZTJdID0gYjIuY2FsbChjMiwgYTRbZTJdLCBlMiwgYTQpKTsKICAgICAgICAgICAgICAgIHJldHVybiBkMjsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIFRiOiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgICAgZm9yICg7IGIyLmZpcnN0Q2hpbGQ7ICkKICAgICAgICAgICAgICAgICAgYTMucmVtb3ZlTm9kZShiMi5maXJzdENoaWxkKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIFliOiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgICAgYjIgPSBhMy5hLmxhKGIyKTsKICAgICAgICAgICAgICAgIGZvciAodmFyIGMyID0gKGIyWzBdICYmIGIyWzBdLm93bmVyRG9jdW1lbnQgfHwgdykuY3JlYXRlRWxlbWVudCgiZGl2IiksIGQyID0gMCwgZTIgPSBiMi5sZW5ndGg7IGQyIDwgZTI7IGQyKyspCiAgICAgICAgICAgICAgICAgIGMyLmFwcGVuZENoaWxkKGEzLm9hKGIyW2QyXSkpOwogICAgICAgICAgICAgICAgcmV0dXJuIGMyOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgQ2E6IGZ1bmN0aW9uKGIyLCBjMikgewogICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwLCBlMiA9IGIyLmxlbmd0aCwgbDIgPSBbXTsgZDIgPCBlMjsgZDIrKykgewogICAgICAgICAgICAgICAgICB2YXIgazIgPSBiMltkMl0uY2xvbmVOb2RlKHRydWUpOwogICAgICAgICAgICAgICAgICBsMi5wdXNoKGMyID8gYTMub2EoazIpIDogazIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGwyOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgdmE6IGZ1bmN0aW9uKGIyLCBjMikgewogICAgICAgICAgICAgICAgYTMuYS5UYihiMik7CiAgICAgICAgICAgICAgICBpZiAoYzIpCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMCwgZTIgPSBjMi5sZW5ndGg7IGQyIDwgZTI7IGQyKyspCiAgICAgICAgICAgICAgICAgICAgYjIuYXBwZW5kQ2hpbGQoYzJbZDJdKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIFhjOiBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICAgIHZhciBkMiA9IGIyLm5vZGVUeXBlID8gW2IyXSA6IGIyOwogICAgICAgICAgICAgICAgaWYgKDAgPCBkMi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZTIgPSBkMlswXSwgbDIgPSBlMi5wYXJlbnROb2RlLCBrMiA9IDAsIGYyID0gYzIubGVuZ3RoOyBrMiA8IGYyOyBrMisrKQogICAgICAgICAgICAgICAgICAgIGwyLmluc2VydEJlZm9yZShjMltrMl0sIGUyKTsKICAgICAgICAgICAgICAgICAgazIgPSAwOwogICAgICAgICAgICAgICAgICBmb3IgKGYyID0gZDIubGVuZ3RoOyBrMiA8IGYyOyBrMisrKQogICAgICAgICAgICAgICAgICAgIGEzLnJlbW92ZU5vZGUoZDJbazJdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIFVhOiBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICAgIGlmIChhNC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgZm9yIChiMiA9IDggPT09IGIyLm5vZGVUeXBlICYmIGIyLnBhcmVudE5vZGUgfHwgYjI7IGE0Lmxlbmd0aCAmJiBhNFswXS5wYXJlbnROb2RlICE9PSBiMjsgKQogICAgICAgICAgICAgICAgICAgIGE0LnNwbGljZSgwLCAxKTsKICAgICAgICAgICAgICAgICAgZm9yICg7IDEgPCBhNC5sZW5ndGggJiYgYTRbYTQubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gYjI7ICkKICAgICAgICAgICAgICAgICAgICBhNC5sZW5ndGgtLTsKICAgICAgICAgICAgICAgICAgaWYgKDEgPCBhNC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSBhNFswXSwgZDIgPSBhNFthNC5sZW5ndGggLSAxXTsKICAgICAgICAgICAgICAgICAgICBmb3IgKGE0Lmxlbmd0aCA9IDA7IGMyICE9PSBkMjsgKQogICAgICAgICAgICAgICAgICAgICAgYTQucHVzaChjMiksIGMyID0gYzIubmV4dFNpYmxpbmc7CiAgICAgICAgICAgICAgICAgICAgYTQucHVzaChkMik7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBhNDsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIFpjOiBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICAgIDcgPiBwID8gYTQuc2V0QXR0cmlidXRlKCJzZWxlY3RlZCIsIGIyKSA6IGE0LnNlbGVjdGVkID0gYjI7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBEYjogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09PSBhNCB8fCBhNCA9PT0gbiA/ICIiIDogYTQudHJpbSA/IGE0LnRyaW0oKSA6IGE0LnRvU3RyaW5nKCkucmVwbGFjZSgvXltcc1x4YTBdK3xbXHNceGEwXSskL2csICIiKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIFVkOiBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICAgIGE0ID0gYTQgfHwgIiI7CiAgICAgICAgICAgICAgICByZXR1cm4gYjIubGVuZ3RoID4gYTQubGVuZ3RoID8gZmFsc2UgOiBhNC5zdWJzdHJpbmcoMCwgYjIubGVuZ3RoKSA9PT0gYjI7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB2ZDogZnVuY3Rpb24oYTQsIGIyKSB7CiAgICAgICAgICAgICAgICBpZiAoYTQgPT09IGIyKQogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgIGlmICgxMSA9PT0gYTQubm9kZVR5cGUpCiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgIGlmIChiMi5jb250YWlucykKICAgICAgICAgICAgICAgICAgcmV0dXJuIGIyLmNvbnRhaW5zKDEgIT09IGE0Lm5vZGVUeXBlID8gYTQucGFyZW50Tm9kZSA6IGE0KTsKICAgICAgICAgICAgICAgIGlmIChiMi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikKICAgICAgICAgICAgICAgICAgcmV0dXJuIDE2ID09IChiMi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhNCkgJiAxNik7CiAgICAgICAgICAgICAgICBmb3IgKDsgYTQgJiYgYTQgIT0gYjI7ICkKICAgICAgICAgICAgICAgICAgYTQgPSBhNC5wYXJlbnROb2RlOwogICAgICAgICAgICAgICAgcmV0dXJuICEhYTQ7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBTYjogZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBhMy5hLnZkKGIyLCBiMi5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBrZDogZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICAgIHJldHVybiAhIWEzLmEuTGIoYjIsIGEzLmEuU2IpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgUjogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIHJldHVybiBhNCAmJiBhNC50YWdOYW1lICYmIGE0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIEFjOiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgICAgcmV0dXJuIGEzLm9uRXJyb3IgPyBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoYzIpIHsKICAgICAgICAgICAgICAgICAgICB0aHJvdyBhMy5vbkVycm9yICYmIGEzLm9uRXJyb3IoYzIpLCBjMjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSA6IGIyOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgc2V0VGltZW91dDogZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChhMy5hLkFjKGIyKSwgYzIpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgR2M6IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICBhMy5vbkVycm9yICYmIGEzLm9uRXJyb3IoYjIpOwogICAgICAgICAgICAgICAgICB0aHJvdyBiMjsKICAgICAgICAgICAgICAgIH0sIDApOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgQjogZnVuY3Rpb24oYjIsIGMyLCBkMikgewogICAgICAgICAgICAgICAgdmFyIGUyID0gYTMuYS5BYyhkMik7CiAgICAgICAgICAgICAgICBkMiA9IGxbYzJdOwogICAgICAgICAgICAgICAgaWYgKGEzLm9wdGlvbnMudXNlT25seU5hdGl2ZUV2ZW50cyB8fCBkMiB8fCAhdjIpCiAgICAgICAgICAgICAgICAgIGlmIChkMiB8fCAiZnVuY3Rpb24iICE9IHR5cGVvZiBiMi5hZGRFdmVudExpc3RlbmVyKQogICAgICAgICAgICAgICAgICAgIGlmICgidW5kZWZpbmVkIiAhPSB0eXBlb2YgYjIuYXR0YWNoRXZlbnQpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBrMiA9IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGUyLmNhbGwoYjIsIGE0KTsKICAgICAgICAgICAgICAgICAgICAgIH0sIGYyID0gIm9uIiArIGMyOwogICAgICAgICAgICAgICAgICAgICAgYjIuYXR0YWNoRXZlbnQoCiAgICAgICAgICAgICAgICAgICAgICAgIGYyLAogICAgICAgICAgICAgICAgICAgICAgICBrMgogICAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgICAgIGEzLmEuSy56YShiMiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyLmRldGFjaEV2ZW50KGYyLCBrMik7CiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJCcm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyIG9yIGF0dGFjaEV2ZW50Iik7CiAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBiMi5hZGRFdmVudExpc3RlbmVyKGMyLCBlMiwgZmFsc2UpOwogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICB0IHx8ICh0ID0gImZ1bmN0aW9uIiA9PSB0eXBlb2YgdjIoYjIpLm9uID8gIm9uIiA6ICJiaW5kIiksIHYyKGIyKVt0XShjMiwgZTIpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgRmI6IGZ1bmN0aW9uKGIyLCBjMikgewogICAgICAgICAgICAgICAgaWYgKCFiMiB8fCAhYjIubm9kZVR5cGUpCiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJlbGVtZW50IG11c3QgYmUgYSBET00gbm9kZSB3aGVuIGNhbGxpbmcgdHJpZ2dlckV2ZW50Iik7CiAgICAgICAgICAgICAgICB2YXIgZDI7CiAgICAgICAgICAgICAgICAiaW5wdXQiID09PSBhMy5hLlIoYjIpICYmIGIyLnR5cGUgJiYgImNsaWNrIiA9PSBjMi50b0xvd2VyQ2FzZSgpID8gKGQyID0gYjIudHlwZSwgZDIgPSAiY2hlY2tib3giID09IGQyIHx8ICJyYWRpbyIgPT0gZDIpIDogZDIgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGlmIChhMy5vcHRpb25zLnVzZU9ubHlOYXRpdmVFdmVudHMgfHwgIXYyIHx8IGQyKQogICAgICAgICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiA9PSB0eXBlb2Ygdy5jcmVhdGVFdmVudCkKICAgICAgICAgICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiA9PSB0eXBlb2YgYjIuZGlzcGF0Y2hFdmVudCkKICAgICAgICAgICAgICAgICAgICAgIGQyID0gdy5jcmVhdGVFdmVudChrW2MyXSB8fCAiSFRNTEV2ZW50cyIpLCBkMi5pbml0RXZlbnQoYzIsIHRydWUsIHRydWUsIEEsIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBiMiksIGIyLmRpc3BhdGNoRXZlbnQoZDIpOwogICAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJUaGUgc3VwcGxpZWQgZWxlbWVudCBkb2Vzbid0IHN1cHBvcnQgZGlzcGF0Y2hFdmVudCIpOwogICAgICAgICAgICAgICAgICBlbHNlIGlmIChkMiAmJiBiMi5jbGljaykKICAgICAgICAgICAgICAgICAgICBiMi5jbGljaygpOwogICAgICAgICAgICAgICAgICBlbHNlIGlmICgidW5kZWZpbmVkIiAhPSB0eXBlb2YgYjIuZmlyZUV2ZW50KQogICAgICAgICAgICAgICAgICAgIGIyLmZpcmVFdmVudCgib24iICsgYzIpOwogICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRyaWdnZXJpbmcgZXZlbnRzIik7CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIHYyKGIyKS50cmlnZ2VyKGMyKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIGY6IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gYTMuTyhiMikgPyBiMigpIDogYjI7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBiYzogZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBhMy5PKGIyKSA/IGIyLnYoKSA6IGIyOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgRWI6IGZ1bmN0aW9uKGIyLCBjMiwgZDIpIHsKICAgICAgICAgICAgICAgIHZhciBsMjsKICAgICAgICAgICAgICAgIGMyICYmICgib2JqZWN0IiA9PT0gdHlwZW9mIGIyLmNsYXNzTGlzdCA/IChsMiA9IGIyLmNsYXNzTGlzdFtkMiA/ICJhZGQiIDogInJlbW92ZSJdLCBhMy5hLkQoYzIubWF0Y2gocSksIGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICAgIGwyLmNhbGwoYjIuY2xhc3NMaXN0LCBhNCk7CiAgICAgICAgICAgICAgICB9KSkgOiAic3RyaW5nIiA9PT0gdHlwZW9mIGIyLmNsYXNzTmFtZS5iYXNlVmFsID8gZShiMi5jbGFzc05hbWUsICJiYXNlVmFsIiwgYzIsIGQyKSA6IGUoYjIsICJjbGFzc05hbWUiLCBjMiwgZDIpKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIEJiOiBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICAgIHZhciBkMiA9IGEzLmEuZihjMik7CiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gZDIgfHwgZDIgPT09IG4pCiAgICAgICAgICAgICAgICAgIGQyID0gIiI7CiAgICAgICAgICAgICAgICB2YXIgZTIgPSBhMy5oLmZpcnN0Q2hpbGQoYjIpOwogICAgICAgICAgICAgICAgIWUyIHx8IDMgIT0gZTIubm9kZVR5cGUgfHwgYTMuaC5uZXh0U2libGluZyhlMikgPyBhMy5oLnZhKGIyLCBbYjIub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkMildKSA6IGUyLmRhdGEgPSBkMjsKICAgICAgICAgICAgICAgIGEzLmEuQWQoYjIpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgWWM6IGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgICAgYTQubmFtZSA9IGIyOwogICAgICAgICAgICAgICAgaWYgKDcgPj0gcCkKICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSBhNC5uYW1lLnJlcGxhY2UoL1smPD4nIl0vZywgZnVuY3Rpb24oYTUpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAiJiMiICsgYTUuY2hhckNvZGVBdCgwKSArICI7IjsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICBhNC5tZXJnZUF0dHJpYnV0ZXMody5jcmVhdGVFbGVtZW50KCI8aW5wdXQgbmFtZT0nIiArIGMyICsgIicvPiIpLCBmYWxzZSk7CiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGQyKSB7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIEFkOiBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgOSA8PSBwICYmIChhNCA9IDEgPT0gYTQubm9kZVR5cGUgPyBhNCA6IGE0LnBhcmVudE5vZGUsIGE0LnN0eWxlICYmIChhNC5zdHlsZS56b29tID0gYTQuc3R5bGUuem9vbSkpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgd2Q6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICBpZiAocCkgewogICAgICAgICAgICAgICAgICB2YXIgYjIgPSBhNC5zdHlsZS53aWR0aDsKICAgICAgICAgICAgICAgICAgYTQuc3R5bGUud2lkdGggPSAwOwogICAgICAgICAgICAgICAgICBhNC5zdHlsZS53aWR0aCA9IGIyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgUGQ6IGZ1bmN0aW9uKGIyLCBjMikgewogICAgICAgICAgICAgICAgYjIgPSBhMy5hLmYoYjIpOwogICAgICAgICAgICAgICAgYzIgPSBhMy5hLmYoYzIpOwogICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSBbXSwgZTIgPSBiMjsgZTIgPD0gYzI7IGUyKyspCiAgICAgICAgICAgICAgICAgIGQyLnB1c2goZTIpOwogICAgICAgICAgICAgICAgcmV0dXJuIGQyOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgbGE6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBiMiA9IFtdLCBjMiA9IDAsIGQyID0gYTQubGVuZ3RoOyBjMiA8IGQyOyBjMisrKQogICAgICAgICAgICAgICAgICBiMi5wdXNoKGE0W2MyXSk7CiAgICAgICAgICAgICAgICByZXR1cm4gYjI7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBEYTogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIHJldHVybiBoID8gU3ltYm9sKGE0KSA6IGE0OwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgWmQ6IDYgPT09IHAsCiAgICAgICAgICAgICAgJGQ6IDcgPT09IHAsCiAgICAgICAgICAgICAgVzogcCwKICAgICAgICAgICAgICBMYzogZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMiA9IGEzLmEubGEoYjIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImlucHV0IikpLmNvbmNhdChhMy5hLmxhKGIyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJ0ZXh0YXJlYSIpKSksIGUyID0gInN0cmluZyIgPT0gdHlwZW9mIGMyID8gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGE0Lm5hbWUgPT09IGMyOwogICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjMi50ZXN0KGE0Lm5hbWUpOwogICAgICAgICAgICAgICAgfSwgbDIgPSBbXSwgazIgPSBkMi5sZW5ndGggLSAxOyAwIDw9IGsyOyBrMi0tKQogICAgICAgICAgICAgICAgICBlMihkMltrMl0pICYmIGwyLnB1c2goZDJbazJdKTsKICAgICAgICAgICAgICAgIHJldHVybiBsMjsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIE5kOiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgICAgcmV0dXJuICJzdHJpbmciID09IHR5cGVvZiBiMiAmJiAoYjIgPSBhMy5hLkRiKGIyKSkgPyBIICYmIEgucGFyc2UgPyBILnBhcnNlKGIyKSA6IG5ldyBGdW5jdGlvbigicmV0dXJuICIgKyBiMikoKSA6IG51bGw7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBoYzogZnVuY3Rpb24oYjIsIGMyLCBkMikgewogICAgICAgICAgICAgICAgaWYgKCFIIHx8ICFILnN0cmluZ2lmeSkKICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkNhbm5vdCBmaW5kIEpTT04uc3RyaW5naWZ5KCkuIFNvbWUgYnJvd3NlcnMgKGUuZy4sIElFIDwgOCkgZG9uJ3Qgc3VwcG9ydCBpdCBuYXRpdmVseSwgYnV0IHlvdSBjYW4gb3ZlcmNvbWUgdGhpcyBieSBhZGRpbmcgYSBzY3JpcHQgcmVmZXJlbmNlIHRvIGpzb24yLmpzLCBkb3dubG9hZGFibGUgZnJvbSBodHRwOi8vd3d3Lmpzb24ub3JnL2pzb24yLmpzIik7CiAgICAgICAgICAgICAgICByZXR1cm4gSC5zdHJpbmdpZnkoYTMuYS5mKGIyKSwgYzIsIGQyKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIE9kOiBmdW5jdGlvbihjMiwgZDIsIGUyKSB7CiAgICAgICAgICAgICAgICBlMiA9IGUyIHx8IHt9OwogICAgICAgICAgICAgICAgdmFyIGwyID0gZTIucGFyYW1zIHx8IHt9LCBrMiA9IGUyLmluY2x1ZGVGaWVsZHMgfHwgdGhpcy5KYywgZjIgPSBjMjsKICAgICAgICAgICAgICAgIGlmICgib2JqZWN0IiA9PSB0eXBlb2YgYzIgJiYgImZvcm0iID09PSBhMy5hLlIoYzIpKQogICAgICAgICAgICAgICAgICBmb3IgKHZhciBmMiA9IGMyLmFjdGlvbiwgaDIgPSBrMi5sZW5ndGggLSAxOyAwIDw9IGgyOyBoMi0tKQogICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGcyID0gYTMuYS5MYyhjMiwgazJbaDJdKSwgbTIgPSBnMi5sZW5ndGggLSAxOyAwIDw9IG0yOyBtMi0tKQogICAgICAgICAgICAgICAgICAgICAgbDJbZzJbbTJdLm5hbWVdID0gZzJbbTJdLnZhbHVlOwogICAgICAgICAgICAgICAgZDIgPSBhMy5hLmYoZDIpOwogICAgICAgICAgICAgICAgdmFyIHAyID0gdy5jcmVhdGVFbGVtZW50KCJmb3JtIik7CiAgICAgICAgICAgICAgICBwMi5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwogICAgICAgICAgICAgICAgcDIuYWN0aW9uID0gZjI7CiAgICAgICAgICAgICAgICBwMi5tZXRob2QgPSAicG9zdCI7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBxMiBpbiBkMikKICAgICAgICAgICAgICAgICAgYzIgPSB3LmNyZWF0ZUVsZW1lbnQoImlucHV0IiksIGMyLnR5cGUgPSAiaGlkZGVuIiwgYzIubmFtZSA9IHEyLCBjMi52YWx1ZSA9IGEzLmEuaGMoYTMuYS5mKGQyW3EyXSkpLCBwMi5hcHBlbmRDaGlsZChjMik7CiAgICAgICAgICAgICAgICBiKGwyLCBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICAgICAgdmFyIGMzID0gdy5jcmVhdGVFbGVtZW50KCJpbnB1dCIpOwogICAgICAgICAgICAgICAgICBjMy50eXBlID0gImhpZGRlbiI7CiAgICAgICAgICAgICAgICAgIGMzLm5hbWUgPSBhNDsKICAgICAgICAgICAgICAgICAgYzMudmFsdWUgPSBiMjsKICAgICAgICAgICAgICAgICAgcDIuYXBwZW5kQ2hpbGQoYzMpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB3LmJvZHkuYXBwZW5kQ2hpbGQocDIpOwogICAgICAgICAgICAgICAgZTIuc3VibWl0dGVyID8gZTIuc3VibWl0dGVyKHAyKSA6IHAyLnN1Ym1pdCgpOwogICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgcDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwMik7CiAgICAgICAgICAgICAgICB9LCAwKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH07CiAgICAgICAgICB9KCk7CiAgICAgICAgICBhMy5iKCJ1dGlscyIsIGEzLmEpOwogICAgICAgICAgYTMuYigidXRpbHMuYXJyYXlGb3JFYWNoIiwgYTMuYS5EKTsKICAgICAgICAgIGEzLmIoInV0aWxzLmFycmF5Rmlyc3QiLCBhMy5hLkxiKTsKICAgICAgICAgIGEzLmIoInV0aWxzLmFycmF5RmlsdGVyIiwgYTMuYS5qYik7CiAgICAgICAgICBhMy5iKCJ1dGlscy5hcnJheUdldERpc3RpbmN0VmFsdWVzIiwgYTMuYS53Yyk7CiAgICAgICAgICBhMy5iKCJ1dGlscy5hcnJheUluZGV4T2YiLCBhMy5hLkEpOwogICAgICAgICAgYTMuYigidXRpbHMuYXJyYXlNYXAiLCBhMy5hLk1iKTsKICAgICAgICAgIGEzLmIoInV0aWxzLmFycmF5UHVzaEFsbCIsIGEzLmEuTmIpOwogICAgICAgICAgYTMuYigidXRpbHMuYXJyYXlSZW1vdmVJdGVtIiwgYTMuYS5QYSk7CiAgICAgICAgICBhMy5iKCJ1dGlscy5jbG9uZU5vZGVzIiwgYTMuYS5DYSk7CiAgICAgICAgICBhMy5iKAogICAgICAgICAgICAidXRpbHMuY3JlYXRlU3ltYm9sT3JTdHJpbmciLAogICAgICAgICAgICBhMy5hLkRhCiAgICAgICAgICApOwogICAgICAgICAgYTMuYigidXRpbHMuZXh0ZW5kIiwgYTMuYS5leHRlbmQpOwogICAgICAgICAgYTMuYigidXRpbHMuZmllbGRzSW5jbHVkZWRXaXRoSnNvblBvc3QiLCBhMy5hLkpjKTsKICAgICAgICAgIGEzLmIoInV0aWxzLmdldEZvcm1GaWVsZHMiLCBhMy5hLkxjKTsKICAgICAgICAgIGEzLmIoInV0aWxzLm9iamVjdE1hcCIsIGEzLmEuR2EpOwogICAgICAgICAgYTMuYigidXRpbHMucGVla09ic2VydmFibGUiLCBhMy5hLmJjKTsKICAgICAgICAgIGEzLmIoInV0aWxzLnBvc3RKc29uIiwgYTMuYS5PZCk7CiAgICAgICAgICBhMy5iKCJ1dGlscy5wYXJzZUpzb24iLCBhMy5hLk5kKTsKICAgICAgICAgIGEzLmIoInV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyIiwgYTMuYS5CKTsKICAgICAgICAgIGEzLmIoInV0aWxzLnN0cmluZ2lmeUpzb24iLCBhMy5hLmhjKTsKICAgICAgICAgIGEzLmIoInV0aWxzLnJhbmdlIiwgYTMuYS5QZCk7CiAgICAgICAgICBhMy5iKCJ1dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3MiLCBhMy5hLkViKTsKICAgICAgICAgIGEzLmIoInV0aWxzLnRyaWdnZXJFdmVudCIsIGEzLmEuRmIpOwogICAgICAgICAgYTMuYigidXRpbHMudW53cmFwT2JzZXJ2YWJsZSIsIGEzLmEuZik7CiAgICAgICAgICBhMy5iKCJ1dGlscy5vYmplY3RGb3JFYWNoIiwgYTMuYS5QKTsKICAgICAgICAgIGEzLmIoCiAgICAgICAgICAgICJ1dGlscy5hZGRPclJlbW92ZUl0ZW0iLAogICAgICAgICAgICBhMy5hLk5hCiAgICAgICAgICApOwogICAgICAgICAgYTMuYigidXRpbHMuc2V0VGV4dENvbnRlbnQiLCBhMy5hLkJiKTsKICAgICAgICAgIGEzLmIoInVud3JhcCIsIGEzLmEuZik7CiAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICB2YXIgYyA9IHRoaXM7CiAgICAgICAgICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKQogICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjLmFwcGx5KGE0LCBhcmd1bWVudHMpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIHZhciBkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHZhciBlID0gZC5zbGljZSgwKTsKICAgICAgICAgICAgICBlLnB1c2guYXBwbHkoZSwgYXJndW1lbnRzKTsKICAgICAgICAgICAgICByZXR1cm4gYy5hcHBseShhNCwgZSk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9KTsKICAgICAgICAgIGEzLmEuZyA9IG5ldyBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGIgPSAwLCBjID0gIl9fa29fXyIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSwgZCA9IHt9LCBlLCBmOwogICAgICAgICAgICBhMy5hLlcgPyAoZSA9IGZ1bmN0aW9uKGE0LCBlMikgewogICAgICAgICAgICAgIHZhciBmMiA9IGE0W2NdOwogICAgICAgICAgICAgIGlmICghZjIgfHwgIm51bGwiID09PSBmMiB8fCAhZFtmMl0pIHsKICAgICAgICAgICAgICAgIGlmICghZTIpCiAgICAgICAgICAgICAgICAgIHJldHVybiBuOwogICAgICAgICAgICAgICAgZjIgPSBhNFtjXSA9ICJrbyIgKyBiKys7CiAgICAgICAgICAgICAgICBkW2YyXSA9IHt9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gZFtmMl07CiAgICAgICAgICAgIH0sIGYgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgIHZhciBiMiA9IGE0W2NdOwogICAgICAgICAgICAgIHJldHVybiBiMiA/IChkZWxldGUgZFtiMl0sIGE0W2NdID0gbnVsbCwgdHJ1ZSkgOiBmYWxzZTsKICAgICAgICAgICAgfSkgOiAoZSA9IGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgIHZhciBkMiA9IGE0W2NdOwogICAgICAgICAgICAgICFkMiAmJiBiMiAmJiAoZDIgPSBhNFtjXSA9IHt9KTsKICAgICAgICAgICAgICByZXR1cm4gZDI7CiAgICAgICAgICAgIH0sIGYgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgIHJldHVybiBhNFtjXSA/IChkZWxldGUgYTRbY10sIHRydWUpIDogZmFsc2U7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4geyBnZXQ6IGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgIHZhciBjMiA9IGUoYTQsIGZhbHNlKTsKICAgICAgICAgICAgICByZXR1cm4gYzIgJiYgYzJbYjJdOwogICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uKGE0LCBiMiwgYzIpIHsKICAgICAgICAgICAgICAoYTQgPSBlKGE0LCBjMiAhPT0gbikpICYmIChhNFtiMl0gPSBjMik7CiAgICAgICAgICAgIH0sIFViOiBmdW5jdGlvbihhNCwgYjIsIGMyKSB7CiAgICAgICAgICAgICAgYTQgPSBlKGE0LCB0cnVlKTsKICAgICAgICAgICAgICByZXR1cm4gYTRbYjJdIHx8IChhNFtiMl0gPSBjMik7CiAgICAgICAgICAgIH0sIGNsZWFyOiBmLCBaOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICByZXR1cm4gYisrICsgYzsKICAgICAgICAgICAgfSB9OwogICAgICAgICAgfSgpOwogICAgICAgICAgYTMuYigidXRpbHMuZG9tRGF0YSIsIGEzLmEuZyk7CiAgICAgICAgICBhMy5iKCJ1dGlscy5kb21EYXRhLmNsZWFyIiwgYTMuYS5nLmNsZWFyKTsKICAgICAgICAgIGEzLmEuSyA9IG5ldyBmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihiMiwgYzIpIHsKICAgICAgICAgICAgICB2YXIgZDIgPSBhMy5hLmcuZ2V0KGIyLCBlKTsKICAgICAgICAgICAgICBkMiA9PT0gbiAmJiBjMiAmJiAoZDIgPSBbXSwgYTMuYS5nLnNldChiMiwgZSwgZDIpKTsKICAgICAgICAgICAgICByZXR1cm4gZDI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYyhjMikgewogICAgICAgICAgICAgIHZhciBlMiA9IGIoYzIsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAoZTIpCiAgICAgICAgICAgICAgICBmb3IgKHZhciBlMiA9IGUyLnNsaWNlKDApLCBrID0gMDsgayA8IGUyLmxlbmd0aDsgaysrKQogICAgICAgICAgICAgICAgICBlMltrXShjMik7CiAgICAgICAgICAgICAgYTMuYS5nLmNsZWFyKGMyKTsKICAgICAgICAgICAgICBhMy5hLksuY2xlYW5FeHRlcm5hbERhdGEoYzIpOwogICAgICAgICAgICAgIGdbYzIubm9kZVR5cGVdICYmIGQoYzIuY2hpbGROb2RlcywgdHJ1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZChiMiwgZDIpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBlMiA9IFtdLCBsLCBmMiA9IDA7IGYyIDwgYjIubGVuZ3RoOyBmMisrKQogICAgICAgICAgICAgICAgaWYgKCFkMiB8fCA4ID09PSBiMltmMl0ubm9kZVR5cGUpIHsKICAgICAgICAgICAgICAgICAgaWYgKGMoZTJbZTIubGVuZ3RoXSA9IGwgPSBiMltmMl0pLCBiMltmMl0gIT09IGwpCiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGYyLS0gJiYgLTEgPT0gYTMuYS5BKGUyLCBiMltmMl0pOyApCiAgICAgICAgICAgICAgICAgICAgICA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGUgPSBhMy5hLmcuWigpLCBmID0geyAxOiB0cnVlLCA4OiB0cnVlLCA5OiB0cnVlIH0sIGcgPSB7IDE6IHRydWUsIDk6IHRydWUgfTsKICAgICAgICAgICAgcmV0dXJuIHsgemE6IGZ1bmN0aW9uKGE0LCBjMikgewogICAgICAgICAgICAgIGlmICgiZnVuY3Rpb24iICE9IHR5cGVvZiBjMikKICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24iKTsKICAgICAgICAgICAgICBiKGE0LCB0cnVlKS5wdXNoKGMyKTsKICAgICAgICAgICAgfSwgeWI6IGZ1bmN0aW9uKGMyLCBkMikgewogICAgICAgICAgICAgIHZhciBmMiA9IGIoYzIsIGZhbHNlKTsKICAgICAgICAgICAgICBmMiAmJiAoYTMuYS5QYShmMiwgZDIpLCAwID09IGYyLmxlbmd0aCAmJiBhMy5hLmcuc2V0KGMyLCBlLCBuKSk7CiAgICAgICAgICAgIH0sIG9hOiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIGEzLnUuRyhmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGZbYjIubm9kZVR5cGVdICYmIChjKGIyKSwgZ1tiMi5ub2RlVHlwZV0gJiYgZChiMi5nZXRFbGVtZW50c0J5VGFnTmFtZSgiKiIpKSk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgcmV0dXJuIGIyOwogICAgICAgICAgICB9LCByZW1vdmVOb2RlOiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIGEzLm9hKGIyKTsKICAgICAgICAgICAgICBiMi5wYXJlbnROb2RlICYmIGIyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYjIpOwogICAgICAgICAgICB9LCBjbGVhbkV4dGVybmFsRGF0YTogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICB2MiAmJiAiZnVuY3Rpb24iID09IHR5cGVvZiB2Mi5jbGVhbkRhdGEgJiYgdjIuY2xlYW5EYXRhKFthNF0pOwogICAgICAgICAgICB9IH07CiAgICAgICAgICB9KCk7CiAgICAgICAgICBhMy5vYSA9IGEzLmEuSy5vYTsKICAgICAgICAgIGEzLnJlbW92ZU5vZGUgPSBhMy5hLksucmVtb3ZlTm9kZTsKICAgICAgICAgIGEzLmIoImNsZWFuTm9kZSIsIGEzLm9hKTsKICAgICAgICAgIGEzLmIoInJlbW92ZU5vZGUiLCBhMy5yZW1vdmVOb2RlKTsKICAgICAgICAgIGEzLmIoInV0aWxzLmRvbU5vZGVEaXNwb3NhbCIsIGEzLmEuSyk7CiAgICAgICAgICBhMy5iKAogICAgICAgICAgICAidXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayIsCiAgICAgICAgICAgIGEzLmEuSy56YQogICAgICAgICAgKTsKICAgICAgICAgIGEzLmIoInV0aWxzLmRvbU5vZGVEaXNwb3NhbC5yZW1vdmVEaXNwb3NlQ2FsbGJhY2siLCBhMy5hLksueWIpOwogICAgICAgICAgKGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgYiA9IFswLCAiIiwgIiJdLCBjID0gWzEsICI8dGFibGU+IiwgIjwvdGFibGU+Il0sIGQgPSBbMywgIjx0YWJsZT48dGJvZHk+PHRyPiIsICI8L3RyPjwvdGJvZHk+PC90YWJsZT4iXSwgZSA9IFsxLCAiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPiIsICI8L3NlbGVjdD4iXSwgZiA9IHsgdGhlYWQ6IGMsIHRib2R5OiBjLCB0Zm9vdDogYywgdHI6IFsyLCAiPHRhYmxlPjx0Ym9keT4iLCAiPC90Ym9keT48L3RhYmxlPiJdLCB0ZDogZCwgdGg6IGQsIG9wdGlvbjogZSwgb3B0Z3JvdXA6IGUgfSwgZyA9IDggPj0gYTMuYS5XOwogICAgICAgICAgICBhMy5hLnVhID0gZnVuY3Rpb24oYzIsIGQyKSB7CiAgICAgICAgICAgICAgdmFyIGUyOwogICAgICAgICAgICAgIGlmICh2MikKICAgICAgICAgICAgICAgIGlmICh2Mi5wYXJzZUhUTUwpCiAgICAgICAgICAgICAgICAgIGUyID0gdjIucGFyc2VIVE1MKGMyLCBkMikgfHwgW107CiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgaWYgKChlMiA9IHYyLmNsZWFuKFtjMl0sIGQyKSkgJiYgZTJbMF0pIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gZTJbMF07IGwucGFyZW50Tm9kZSAmJiAxMSAhPT0gbC5wYXJlbnROb2RlLm5vZGVUeXBlOyApCiAgICAgICAgICAgICAgICAgICAgICBsID0gbC5wYXJlbnROb2RlOwogICAgICAgICAgICAgICAgICAgIGwucGFyZW50Tm9kZSAmJiBsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIChlMiA9IGQyKSB8fCAoZTIgPSB3KTsKICAgICAgICAgICAgICAgIHZhciBsID0gZTIucGFyZW50V2luZG93IHx8IGUyLmRlZmF1bHRWaWV3IHx8IEEsIHAgPSBhMy5hLkRiKGMyKS50b0xvd2VyQ2FzZSgpLCBxID0gZTIuY3JlYXRlRWxlbWVudCgiZGl2IiksIHQ7CiAgICAgICAgICAgICAgICB0ID0gKHAgPSBwLm1hdGNoKC9eKD86XHgzYyEtLS4qPy0tXHgzZVxzKj8pKj88KFthLXpdKylbXHM+XS8pKSAmJiBmW3BbMV1dIHx8IGI7CiAgICAgICAgICAgICAgICBwID0gdFswXTsKICAgICAgICAgICAgICAgIHQgPSAiaWdub3JlZDxkaXY+IiArIHRbMV0gKyBjMiArIHRbMl0gKyAiPC9kaXY+IjsKICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIGwuaW5uZXJTaGl2ID8gcS5hcHBlbmRDaGlsZChsLmlubmVyU2hpdih0KSkgOiAoZyAmJiBlMi5ib2R5LmFwcGVuZENoaWxkKHEpLCBxLmlubmVySFRNTCA9IHQsIGcgJiYgcS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHEpKTsKICAgICAgICAgICAgICAgIGZvciAoOyBwLS07ICkKICAgICAgICAgICAgICAgICAgcSA9IHEubGFzdENoaWxkOwogICAgICAgICAgICAgICAgZTIgPSBhMy5hLmxhKHEubGFzdENoaWxkLmNoaWxkTm9kZXMpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gZTI7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLmEuTWQgPSBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICB2YXIgZDIgPSBhMy5hLnVhKAogICAgICAgICAgICAgICAgYjIsCiAgICAgICAgICAgICAgICBjMgogICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgcmV0dXJuIGQyLmxlbmd0aCAmJiBkMlswXS5wYXJlbnRFbGVtZW50IHx8IGEzLmEuWWIoZDIpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5hLmZjID0gZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgYTMuYS5UYihiMik7CiAgICAgICAgICAgICAgYzIgPSBhMy5hLmYoYzIpOwogICAgICAgICAgICAgIGlmIChudWxsICE9PSBjMiAmJiBjMiAhPT0gbikKICAgICAgICAgICAgICAgIGlmICgic3RyaW5nIiAhPSB0eXBlb2YgYzIgJiYgKGMyID0gYzIudG9TdHJpbmcoKSksIHYyKQogICAgICAgICAgICAgICAgICB2MihiMikuaHRtbChjMik7CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gYTMuYS51YShjMiwgYjIub3duZXJEb2N1bWVudCksIGUyID0gMDsgZTIgPCBkMi5sZW5ndGg7IGUyKyspCiAgICAgICAgICAgICAgICAgICAgYjIuYXBwZW5kQ2hpbGQoZDJbZTJdKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0pKCk7CiAgICAgICAgICBhMy5iKCJ1dGlscy5wYXJzZUh0bWxGcmFnbWVudCIsIGEzLmEudWEpOwogICAgICAgICAgYTMuYigidXRpbHMuc2V0SHRtbCIsIGEzLmEuZmMpOwogICAgICAgICAgYTMuYWEgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihjMiwgZSkgewogICAgICAgICAgICAgIGlmIChjMikgewogICAgICAgICAgICAgICAgaWYgKDggPT0gYzIubm9kZVR5cGUpIHsKICAgICAgICAgICAgICAgICAgdmFyIGYgPSBhMy5hYS5VYyhjMi5ub2RlVmFsdWUpOwogICAgICAgICAgICAgICAgICBudWxsICE9IGYgJiYgZS5wdXNoKHsgdWQ6IGMyLCBLZDogZiB9KTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMSA9PSBjMi5ub2RlVHlwZSkKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDAsIGcgPSBjMi5jaGlsZE5vZGVzLCBoID0gZy5sZW5ndGg7IGYgPCBoOyBmKyspCiAgICAgICAgICAgICAgICAgICAgYigKICAgICAgICAgICAgICAgICAgICAgIGdbZl0sCiAgICAgICAgICAgICAgICAgICAgICBlCiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGMgPSB7fTsKICAgICAgICAgICAgcmV0dXJuIHsgWGI6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgaWYgKCJmdW5jdGlvbiIgIT0gdHlwZW9mIGE0KQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIllvdSBjYW4gb25seSBwYXNzIGEgZnVuY3Rpb24gdG8ga28ubWVtb2l6YXRpb24ubWVtb2l6ZSgpIik7CiAgICAgICAgICAgICAgdmFyIGIyID0gKDQyOTQ5NjcyOTYgKiAoMSArIE1hdGgucmFuZG9tKCkpIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKSArICg0Mjk0OTY3Mjk2ICogKDEgKyBNYXRoLnJhbmRvbSgpKSB8IDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7CiAgICAgICAgICAgICAgY1tiMl0gPSBhNDsKICAgICAgICAgICAgICByZXR1cm4gIjwhLS1ba29fbWVtbzoiICsgYjIgKyAiXS0tPiI7CiAgICAgICAgICAgIH0sIGJkOiBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICB2YXIgZiA9IGNbYTRdOwogICAgICAgICAgICAgIGlmIChmID09PSBuKQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkNvdWxkbid0IGZpbmQgYW55IG1lbW8gd2l0aCBJRCAiICsgYTQgKyAiLiBQZXJoYXBzIGl0J3MgYWxyZWFkeSBiZWVuIHVubWVtb2l6ZWQuIik7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGIyIHx8IFtdKSwgdHJ1ZTsKICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgZGVsZXRlIGNbYTRdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgY2Q6IGZ1bmN0aW9uKGMyLCBlKSB7CiAgICAgICAgICAgICAgdmFyIGYgPSBbXTsKICAgICAgICAgICAgICBiKGMyLCBmKTsKICAgICAgICAgICAgICBmb3IgKHZhciBnID0gMCwgaCA9IGYubGVuZ3RoOyBnIDwgaDsgZysrKSB7CiAgICAgICAgICAgICAgICB2YXIgbSA9IGZbZ10udWQsIGsgPSBbbV07CiAgICAgICAgICAgICAgICBlICYmIGEzLmEuTmIoaywgZSk7CiAgICAgICAgICAgICAgICBhMy5hYS5iZChmW2ddLktkLCBrKTsKICAgICAgICAgICAgICAgIG0ubm9kZVZhbHVlID0gIiI7CiAgICAgICAgICAgICAgICBtLnBhcmVudE5vZGUgJiYgbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgVWM6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIChhNCA9IGE0Lm1hdGNoKC9eXFtrb19tZW1vXDooLio/KVxdJC8pKSA/IGE0WzFdIDogbnVsbDsKICAgICAgICAgICAgfSB9OwogICAgICAgICAgfSgpOwogICAgICAgICAgYTMuYigibWVtb2l6YXRpb24iLCBhMy5hYSk7CiAgICAgICAgICBhMy5iKCJtZW1vaXphdGlvbi5tZW1vaXplIiwgYTMuYWEuWGIpOwogICAgICAgICAgYTMuYigibWVtb2l6YXRpb24udW5tZW1vaXplIiwgYTMuYWEuYmQpOwogICAgICAgICAgYTMuYigibWVtb2l6YXRpb24ucGFyc2VNZW1vVGV4dCIsIGEzLmFhLlVjKTsKICAgICAgICAgIGEzLmIoIm1lbW9pemF0aW9uLnVubWVtb2l6ZURvbU5vZGVBbmREZXNjZW5kYW50cyIsIGEzLmFhLmNkKTsKICAgICAgICAgIGEzLm5hID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGIoKSB7CiAgICAgICAgICAgICAgaWYgKGYpIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGIyID0gZiwgYzIgPSAwLCBkMjsgaCA8IGY7ICkKICAgICAgICAgICAgICAgICAgaWYgKGQyID0gZVtoKytdKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGggPiBiMikgewogICAgICAgICAgICAgICAgICAgICAgaWYgKDVlMyA8PSArK2MyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBmOwogICAgICAgICAgICAgICAgICAgICAgICBhMy5hLkdjKEVycm9yKCInVG9vIG11Y2ggcmVjdXJzaW9uJyBhZnRlciBwcm9jZXNzaW5nICIgKyBjMiArICIgdGFzayBncm91cHMuIikpOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGIyID0gZjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAgIGQyKCk7CiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAocCkgewogICAgICAgICAgICAgICAgICAgICAgYTMuYS5HYyhwKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYygpIHsKICAgICAgICAgICAgICBiKCk7CiAgICAgICAgICAgICAgaCA9IGYgPSBlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGQsIGUgPSBbXSwgZiA9IDAsIGcgPSAxLCBoID0gMDsKICAgICAgICAgICAgQS5NdXRhdGlvbk9ic2VydmVyID8gZCA9IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgdmFyIGIyID0gdy5jcmVhdGVFbGVtZW50KCJkaXYiKTsKICAgICAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihhNCkub2JzZXJ2ZShiMiwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pOwogICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGIyLmNsYXNzTGlzdC50b2dnbGUoImZvbyIpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0oYykgOiBkID0gdyAmJiAib25yZWFkeXN0YXRlY2hhbmdlIiBpbiB3LmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpID8gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICB2YXIgYjIgPSB3LmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpOwogICAgICAgICAgICAgIGIyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgYjIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDsKICAgICAgICAgICAgICAgIHcuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKGIyKTsKICAgICAgICAgICAgICAgIGIyID0gbnVsbDsKICAgICAgICAgICAgICAgIGE0KCk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB3LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChiMik7CiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgIHNldFRpbWVvdXQoYTQsIDApOwogICAgICAgICAgICB9OwogICAgICAgICAgICByZXR1cm4geyBzY2hlZHVsZXI6IGQsIHpiOiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIGYgfHwgYTMubmEuc2NoZWR1bGVyKGMpOwogICAgICAgICAgICAgIGVbZisrXSA9IGIyOwogICAgICAgICAgICAgIHJldHVybiBnKys7CiAgICAgICAgICAgIH0sIGNhbmNlbDogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICBhNCA9IGE0IC0gKGcgLSBmKTsKICAgICAgICAgICAgICBhNCA+PSBoICYmIGE0IDwgZiAmJiAoZVthNF0gPSBudWxsKTsKICAgICAgICAgICAgfSwgcmVzZXRGb3JUZXN0aW5nOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB2YXIgYTQgPSBmIC0gaDsKICAgICAgICAgICAgICBoID0gZiA9IGUubGVuZ3RoID0gMDsKICAgICAgICAgICAgICByZXR1cm4gYTQ7CiAgICAgICAgICAgIH0sIFNkOiBiIH07CiAgICAgICAgICB9KCk7CiAgICAgICAgICBhMy5iKCJ0YXNrcyIsIGEzLm5hKTsKICAgICAgICAgIGEzLmIoInRhc2tzLnNjaGVkdWxlIiwgYTMubmEuemIpOwogICAgICAgICAgYTMuYigidGFza3MucnVuRWFybHkiLCBhMy5uYS5TZCk7CiAgICAgICAgICBhMy5UYSA9IHsgdGhyb3R0bGU6IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgYi50aHJvdHRsZUV2YWx1YXRpb24gPSBjOwogICAgICAgICAgICB2YXIgZCA9IG51bGw7CiAgICAgICAgICAgIHJldHVybiBhMy4kKHsgcmVhZDogYiwgd3JpdGU6IGZ1bmN0aW9uKGUpIHsKICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZCk7CiAgICAgICAgICAgICAgZCA9IGEzLmEuc2V0VGltZW91dCgKICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICBiKGUpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIGMKICAgICAgICAgICAgICApOwogICAgICAgICAgICB9IH0pOwogICAgICAgICAgfSwgcmF0ZUxpbWl0OiBmdW5jdGlvbihhNCwgYykgewogICAgICAgICAgICB2YXIgZCwgZSwgZjsKICAgICAgICAgICAgIm51bWJlciIgPT0gdHlwZW9mIGMgPyBkID0gYyA6IChkID0gYy50aW1lb3V0LCBlID0gYy5tZXRob2QpOwogICAgICAgICAgICBhNC5IYiA9IGZhbHNlOwogICAgICAgICAgICBmID0gImZ1bmN0aW9uIiA9PSB0eXBlb2YgZSA/IGUgOiAibm90aWZ5V2hlbkNoYW5nZXNTdG9wIiA9PSBlID8gWSA6IFg7CiAgICAgICAgICAgIGE0LnViKGZ1bmN0aW9uKGE1KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGYoYTUsIGQsIGMpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0sIGRlZmVycmVkOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgIGlmICh0cnVlICE9PSBjKQogICAgICAgICAgICAgIHRocm93IEVycm9yKCJUaGUgJ2RlZmVycmVkJyBleHRlbmRlciBvbmx5IGFjY2VwdHMgdGhlIHZhbHVlICd0cnVlJywgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHR1cm4gZGVmZXJyYWwgb2ZmIG9uY2UgZW5hYmxlZC4iKTsKICAgICAgICAgICAgYi5IYiB8fCAoYi5IYiA9IHRydWUsIGIudWIoZnVuY3Rpb24oYzIpIHsKICAgICAgICAgICAgICB2YXIgZSwgZiA9IGZhbHNlOwogICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGlmICghZikgewogICAgICAgICAgICAgICAgICBhMy5uYS5jYW5jZWwoZSk7CiAgICAgICAgICAgICAgICAgIGUgPSBhMy5uYS56YihjMik7CiAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgZiA9IHRydWUsIGIubm90aWZ5U3Vic2NyaWJlcnMobiwgImRpcnR5Iik7CiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICAgICAgZiA9IGZhbHNlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgfSwgbm90aWZ5OiBmdW5jdGlvbihhNCwgYykgewogICAgICAgICAgICBhNC5lcXVhbGl0eUNvbXBhcmVyID0gImFsd2F5cyIgPT0gYyA/IG51bGwgOiBLOwogICAgICAgICAgfSB9OwogICAgICAgICAgdmFyIFcgPSB7IHVuZGVmaW5lZDogMSwgImJvb2xlYW4iOiAxLCBudW1iZXI6IDEsIHN0cmluZzogMSB9OwogICAgICAgICAgYTMuYigiZXh0ZW5kZXJzIiwgYTMuVGEpOwogICAgICAgICAgYTMuaWMgPSBmdW5jdGlvbihiLCBjLCBkKSB7CiAgICAgICAgICAgIHRoaXMuZGEgPSBiOwogICAgICAgICAgICB0aGlzLmxjID0gYzsKICAgICAgICAgICAgdGhpcy5tYyA9IGQ7CiAgICAgICAgICAgIHRoaXMuSWIgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5mYiA9IHRoaXMuSmIgPSBudWxsOwogICAgICAgICAgICBhMy5MKHRoaXMsICJkaXNwb3NlIiwgdGhpcy5zKTsKICAgICAgICAgICAgYTMuTCh0aGlzLCAiZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkIiwgdGhpcy5sKTsKICAgICAgICAgIH07CiAgICAgICAgICBhMy5pYy5wcm90b3R5cGUucyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0aGlzLkliIHx8ICh0aGlzLmZiICYmIGEzLmEuSy55Yih0aGlzLkpiLCB0aGlzLmZiKSwgdGhpcy5JYiA9IHRydWUsIHRoaXMubWMoKSwgdGhpcy5kYSA9IHRoaXMubGMgPSB0aGlzLm1jID0gdGhpcy5KYiA9IHRoaXMuZmIgPSBudWxsKTsKICAgICAgICAgIH07CiAgICAgICAgICBhMy5pYy5wcm90b3R5cGUubCA9IGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgdGhpcy5KYiA9IGI7CiAgICAgICAgICAgIGEzLmEuSy56YShiLCB0aGlzLmZiID0gdGhpcy5zLmJpbmQodGhpcykpOwogICAgICAgICAgfTsKICAgICAgICAgIGEzLlQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgYTMuYS5BYih0aGlzLCBEKTsKICAgICAgICAgICAgRC5xYih0aGlzKTsKICAgICAgICAgIH07CiAgICAgICAgICB2YXIgRCA9IHsKICAgICAgICAgICAgcWI6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgYTQuVSA9IHsgY2hhbmdlOiBbXSB9OwogICAgICAgICAgICAgIGE0LnNjID0gMTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbihiLCBjLCBkKSB7CiAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzOwogICAgICAgICAgICAgIGQgPSBkIHx8ICJjaGFuZ2UiOwogICAgICAgICAgICAgIHZhciBmID0gbmV3IGEzLmljKGUsIGMgPyBiLmJpbmQoYykgOiBiLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGEzLmEuUGEoZS5VW2RdLCBmKTsKICAgICAgICAgICAgICAgIGUuaGIgJiYgZS5oYihkKTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBlLlFhICYmIGUuUWEoZCk7CiAgICAgICAgICAgICAgZS5VW2RdIHx8IChlLlVbZF0gPSBbXSk7CiAgICAgICAgICAgICAgZS5VW2RdLnB1c2goZik7CiAgICAgICAgICAgICAgcmV0dXJuIGY7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG5vdGlmeVN1YnNjcmliZXJzOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgICAgYyA9IGMgfHwgImNoYW5nZSI7CiAgICAgICAgICAgICAgImNoYW5nZSIgPT09IGMgJiYgdGhpcy5HYigpOwogICAgICAgICAgICAgIGlmICh0aGlzLldhKGMpKSB7CiAgICAgICAgICAgICAgICB2YXIgZCA9ICJjaGFuZ2UiID09PSBjICYmIHRoaXMuZWQgfHwgdGhpcy5VW2NdLnNsaWNlKDApOwogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgYTMudS54YygpOwogICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMCwgZjsgZiA9IGRbZV07ICsrZSkKICAgICAgICAgICAgICAgICAgICBmLkliIHx8IGYubGMoYik7CiAgICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgICBhMy51LmVuZCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgb2I6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjOwogICAgICAgICAgICB9LAogICAgICAgICAgICBEZDogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYigpICE9PSBhNDsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgR2I6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICsrdGhpcy5zYzsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdWI6IGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMsIGQgPSBhMy5PKGMpLCBlLCBmLCBnLCBoLCBtOwogICAgICAgICAgICAgIGMuZ2IgfHwgKGMuZ2IgPSBjLm5vdGlmeVN1YnNjcmliZXJzLCBjLm5vdGlmeVN1YnNjcmliZXJzID0gWik7CiAgICAgICAgICAgICAgdmFyIGsgPSBiKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgYy5KYSA9IGZhbHNlOwogICAgICAgICAgICAgICAgZCAmJiBoID09PSBjICYmIChoID0gYy5uYyA/IGMubmMoKSA6IGMoKSk7CiAgICAgICAgICAgICAgICB2YXIgYTQgPSBmIHx8IG0gJiYgYy5zYihnLCBoKTsKICAgICAgICAgICAgICAgIG0gPSBmID0gZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgYTQgJiYgYy5nYihnID0gaCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgYy5xYyA9IGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgICAgYjIgJiYgYy5KYSB8fCAobSA9ICFiMik7CiAgICAgICAgICAgICAgICBjLmVkID0gYy5VLmNoYW5nZS5zbGljZSgwKTsKICAgICAgICAgICAgICAgIGMuSmEgPSBlID0gdHJ1ZTsKICAgICAgICAgICAgICAgIGggPSBhNDsKICAgICAgICAgICAgICAgIGsoKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIGMucGMgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgZSB8fCAoZyA9IGE0LCBjLmdiKGE0LCAiYmVmb3JlQ2hhbmdlIikpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgYy5yYyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgbSA9IHRydWU7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBjLmdkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBjLnNiKGcsIGMudih0cnVlKSkgJiYgKGYgPSB0cnVlKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9LAogICAgICAgICAgICBXYTogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VW2E0XSAmJiB0aGlzLlVbYTRdLmxlbmd0aDsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgQmQ6IGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgICBpZiAoYikKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVbYl0gJiYgdGhpcy5VW2JdLmxlbmd0aCB8fCAwOwogICAgICAgICAgICAgIHZhciBjID0gMDsKICAgICAgICAgICAgICBhMy5hLlAodGhpcy5VLCBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICAgICJkaXJ0eSIgIT09IGE0ICYmIChjICs9IGIyLmxlbmd0aCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgcmV0dXJuIGM7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNiOiBmdW5jdGlvbihhNCwgYykgewogICAgICAgICAgICAgIHJldHVybiAhdGhpcy5lcXVhbGl0eUNvbXBhcmVyIHx8ICF0aGlzLmVxdWFsaXR5Q29tcGFyZXIoYTQsIGMpOwogICAgICAgICAgICB9LAogICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuICJbb2JqZWN0IE9iamVjdF0iOwogICAgICAgICAgICB9LAogICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgICB2YXIgYyA9IHRoaXM7CiAgICAgICAgICAgICAgYiAmJiBhMy5hLlAoYiwgZnVuY3Rpb24oYjIsIGUpIHsKICAgICAgICAgICAgICAgIHZhciBmID0gYTMuVGFbYjJdOwogICAgICAgICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgZiAmJiAoYyA9IGYoYywgZSkgfHwgYyk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgcmV0dXJuIGM7CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBhMy5MKEQsICJpbml0IiwgRC5xYik7CiAgICAgICAgICBhMy5MKEQsICJzdWJzY3JpYmUiLCBELnN1YnNjcmliZSk7CiAgICAgICAgICBhMy5MKEQsICJleHRlbmQiLCBELmV4dGVuZCk7CiAgICAgICAgICBhMy5MKEQsICJnZXRTdWJzY3JpcHRpb25zQ291bnQiLCBELkJkKTsKICAgICAgICAgIGEzLmEuQmEgJiYgYTMuYS5zZXRQcm90b3R5cGVPZigKICAgICAgICAgICAgRCwKICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlCiAgICAgICAgICApOwogICAgICAgICAgYTMuVC5mbiA9IEQ7CiAgICAgICAgICBhMy5RYyA9IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgIHJldHVybiBudWxsICE9IGE0ICYmICJmdW5jdGlvbiIgPT0gdHlwZW9mIGE0LnN1YnNjcmliZSAmJiAiZnVuY3Rpb24iID09IHR5cGVvZiBhNC5ub3RpZnlTdWJzY3JpYmVyczsKICAgICAgICAgIH07CiAgICAgICAgICBhMy5iKCJzdWJzY3JpYmFibGUiLCBhMy5UKTsKICAgICAgICAgIGEzLmIoImlzU3Vic2NyaWJhYmxlIiwgYTMuUWMpOwogICAgICAgICAgYTMuUyA9IGEzLnUgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihhNCkgewogICAgICAgICAgICAgIGQucHVzaChlKTsKICAgICAgICAgICAgICBlID0gYTQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYygpIHsKICAgICAgICAgICAgICBlID0gZC5wb3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgZCA9IFtdLCBlLCBmID0gMDsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICB4YzogYiwKICAgICAgICAgICAgICBlbmQ6IGMsCiAgICAgICAgICAgICAgY2M6IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgICBpZiAoZSkgewogICAgICAgICAgICAgICAgICBpZiAoIWEzLlFjKGIyKSkKICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiT25seSBzdWJzY3JpYmFibGUgdGhpbmdzIGNhbiBhY3QgYXMgZGVwZW5kZW5jaWVzIik7CiAgICAgICAgICAgICAgICAgIGUub2QuY2FsbChlLnBkLCBiMiwgYjIuZmQgfHwgKGIyLmZkID0gKytmKSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBHOiBmdW5jdGlvbihhNCwgZDIsIGUyKSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICByZXR1cm4gYigpLCBhNC5hcHBseShkMiwgZTIgfHwgW10pOwogICAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgICAgYygpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgcWE6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgaWYgKGUpCiAgICAgICAgICAgICAgICAgIHJldHVybiBlLm8ucWEoKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIFZhOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGlmIChlKQogICAgICAgICAgICAgICAgICByZXR1cm4gZS5vLlZhKCk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBZYTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBpZiAoZSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuWWE7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBvOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGlmIChlKQogICAgICAgICAgICAgICAgICByZXR1cm4gZS5vOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICAgIH0oKTsKICAgICAgICAgIGEzLmIoImNvbXB1dGVkQ29udGV4dCIsIGEzLlMpOwogICAgICAgICAgYTMuYigiY29tcHV0ZWRDb250ZXh0LmdldERlcGVuZGVuY2llc0NvdW50IiwgYTMuUy5xYSk7CiAgICAgICAgICBhMy5iKCJjb21wdXRlZENvbnRleHQuZ2V0RGVwZW5kZW5jaWVzIiwgYTMuUy5WYSk7CiAgICAgICAgICBhMy5iKCJjb21wdXRlZENvbnRleHQuaXNJbml0aWFsIiwgYTMuUy5ZYSk7CiAgICAgICAgICBhMy5iKCJjb21wdXRlZENvbnRleHQucmVnaXN0ZXJEZXBlbmRlbmN5IiwgYTMuUy5jYyk7CiAgICAgICAgICBhMy5iKCJpZ25vcmVEZXBlbmRlbmNpZXMiLCBhMy5ZZCA9IGEzLnUuRyk7CiAgICAgICAgICB2YXIgSSA9IGEzLmEuRGEoIl9sYXRlc3RWYWx1ZSIpOwogICAgICAgICAgYTMudGEgPSBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGMoKSB7CiAgICAgICAgICAgICAgaWYgKDAgPCBhcmd1bWVudHMubGVuZ3RoKQogICAgICAgICAgICAgICAgcmV0dXJuIGMuc2IoY1tJXSwgYXJndW1lbnRzWzBdKSAmJiAoYy55YSgpLCBjW0ldID0gYXJndW1lbnRzWzBdLCBjLnhhKCkpLCB0aGlzOwogICAgICAgICAgICAgIGEzLnUuY2MoYyk7CiAgICAgICAgICAgICAgcmV0dXJuIGNbSV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY1tJXSA9IGI7CiAgICAgICAgICAgIGEzLmEuQmEgfHwgYTMuYS5leHRlbmQoYywgYTMuVC5mbik7CiAgICAgICAgICAgIGEzLlQuZm4ucWIoYyk7CiAgICAgICAgICAgIGEzLmEuQWIoYywgRik7CiAgICAgICAgICAgIGEzLm9wdGlvbnMuZGVmZXJVcGRhdGVzICYmIGEzLlRhLmRlZmVycmVkKGMsIHRydWUpOwogICAgICAgICAgICByZXR1cm4gYzsKICAgICAgICAgIH07CiAgICAgICAgICB2YXIgRiA9IHsgZXF1YWxpdHlDb21wYXJlcjogSywgdjogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzW0ldOwogICAgICAgICAgfSwgeGE6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXNbSV0sICJzcGVjdGF0ZSIpOwogICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXNbSV0pOwogICAgICAgICAgfSwgeWE6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXNbSV0sICJiZWZvcmVDaGFuZ2UiKTsKICAgICAgICAgIH0gfTsKICAgICAgICAgIGEzLmEuQmEgJiYgYTMuYS5zZXRQcm90b3R5cGVPZihGLCBhMy5ULmZuKTsKICAgICAgICAgIHZhciBHID0gYTMudGEuTWEgPSAiX19rb19wcm90b19fIjsKICAgICAgICAgIEZbR10gPSBhMy50YTsKICAgICAgICAgIGEzLk8gPSBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIGlmICgoYiA9ICJmdW5jdGlvbiIgPT0gdHlwZW9mIGIgJiYgYltHXSkgJiYgYiAhPT0gRltHXSAmJiBiICE9PSBhMy5vLmZuW0ddKQogICAgICAgICAgICAgIHRocm93IEVycm9yKCJJbnZhbGlkIG9iamVjdCB0aGF0IGxvb2tzIGxpa2UgYW4gb2JzZXJ2YWJsZTsgcG9zc2libHkgZnJvbSBhbm90aGVyIEtub2Nrb3V0IGluc3RhbmNlIik7CiAgICAgICAgICAgIHJldHVybiAhIWI7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuWmEgPSBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIHJldHVybiAiZnVuY3Rpb24iID09IHR5cGVvZiBiICYmIChiW0ddID09PSBGW0ddIHx8IGJbR10gPT09IGEzLm8uZm5bR10gJiYgYi5OYyk7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuYigib2JzZXJ2YWJsZSIsIGEzLnRhKTsKICAgICAgICAgIGEzLmIoImlzT2JzZXJ2YWJsZSIsIGEzLk8pOwogICAgICAgICAgYTMuYigiaXNXcml0ZWFibGVPYnNlcnZhYmxlIiwgYTMuWmEpOwogICAgICAgICAgYTMuYigiaXNXcml0YWJsZU9ic2VydmFibGUiLCBhMy5aYSk7CiAgICAgICAgICBhMy5iKCJvYnNlcnZhYmxlLmZuIiwgRik7CiAgICAgICAgICBhMy5MKEYsICJwZWVrIiwgRi52KTsKICAgICAgICAgIGEzLkwoRiwgInZhbHVlSGFzTXV0YXRlZCIsIEYueGEpOwogICAgICAgICAgYTMuTChGLCAidmFsdWVXaWxsTXV0YXRlIiwgRi55YSk7CiAgICAgICAgICBhMy5IYSA9IGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgYiA9IGIgfHwgW107CiAgICAgICAgICAgIGlmICgib2JqZWN0IiAhPSB0eXBlb2YgYiB8fCAhKCJsZW5ndGgiIGluIGIpKQogICAgICAgICAgICAgIHRocm93IEVycm9yKCJUaGUgYXJndW1lbnQgcGFzc2VkIHdoZW4gaW5pdGlhbGl6aW5nIGFuIG9ic2VydmFibGUgYXJyYXkgbXVzdCBiZSBhbiBhcnJheSwgb3IgbnVsbCwgb3IgdW5kZWZpbmVkLiIpOwogICAgICAgICAgICBiID0gYTMudGEoYik7CiAgICAgICAgICAgIGEzLmEuQWIoCiAgICAgICAgICAgICAgYiwKICAgICAgICAgICAgICBhMy5IYS5mbgogICAgICAgICAgICApOwogICAgICAgICAgICByZXR1cm4gYi5leHRlbmQoeyB0cmFja0FycmF5Q2hhbmdlczogdHJ1ZSB9KTsKICAgICAgICAgIH07CiAgICAgICAgICBhMy5IYS5mbiA9IHsgcmVtb3ZlOiBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIGZvciAodmFyIGMgPSB0aGlzLnYoKSwgZCA9IFtdLCBlID0gImZ1bmN0aW9uIiAhPSB0eXBlb2YgYiB8fCBhMy5PKGIpID8gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICByZXR1cm4gYTQgPT09IGI7CiAgICAgICAgICAgIH0gOiBiLCBmID0gMDsgZiA8IGMubGVuZ3RoOyBmKyspIHsKICAgICAgICAgICAgICB2YXIgZyA9IGNbZl07CiAgICAgICAgICAgICAgaWYgKGUoZykpIHsKICAgICAgICAgICAgICAgIDAgPT09IGQubGVuZ3RoICYmIHRoaXMueWEoKTsKICAgICAgICAgICAgICAgIGlmIChjW2ZdICE9PSBnKQogICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiQXJyYXkgbW9kaWZpZWQgZHVyaW5nIHJlbW92ZTsgY2Fubm90IHJlbW92ZSBpdGVtIik7CiAgICAgICAgICAgICAgICBkLnB1c2goZyk7CiAgICAgICAgICAgICAgICBjLnNwbGljZShmLCAxKTsKICAgICAgICAgICAgICAgIGYtLTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZC5sZW5ndGggJiYgdGhpcy54YSgpOwogICAgICAgICAgICByZXR1cm4gZDsKICAgICAgICAgIH0sIHJlbW92ZUFsbDogZnVuY3Rpb24oYikgewogICAgICAgICAgICBpZiAoYiA9PT0gbikgewogICAgICAgICAgICAgIHZhciBjID0gdGhpcy52KCksIGQgPSBjLnNsaWNlKDApOwogICAgICAgICAgICAgIHRoaXMueWEoKTsKICAgICAgICAgICAgICBjLnNwbGljZSgwLCBjLmxlbmd0aCk7CiAgICAgICAgICAgICAgdGhpcy54YSgpOwogICAgICAgICAgICAgIHJldHVybiBkOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBiID8gdGhpcy5yZW1vdmUoZnVuY3Rpb24oYzIpIHsKICAgICAgICAgICAgICByZXR1cm4gMCA8PSBhMy5hLkEoYiwgYzIpOwogICAgICAgICAgICB9KSA6IFtdOwogICAgICAgICAgfSwgZGVzdHJveTogZnVuY3Rpb24oYikgewogICAgICAgICAgICB2YXIgYyA9IHRoaXMudigpLCBkID0gImZ1bmN0aW9uIiAhPSB0eXBlb2YgYiB8fCBhMy5PKGIpID8gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICByZXR1cm4gYTQgPT09IGI7CiAgICAgICAgICAgIH0gOiBiOwogICAgICAgICAgICB0aGlzLnlhKCk7CiAgICAgICAgICAgIGZvciAodmFyIGUgPSBjLmxlbmd0aCAtIDE7IDAgPD0gZTsgZS0tKSB7CiAgICAgICAgICAgICAgdmFyIGYgPSBjW2VdOwogICAgICAgICAgICAgIGQoZikgJiYgKGYuX2Rlc3Ryb3kgPSB0cnVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnhhKCk7CiAgICAgICAgICB9LCBkZXN0cm95QWxsOiBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIHJldHVybiBiID09PSBuID8gdGhpcy5kZXN0cm95KGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9KSA6IGIgPyB0aGlzLmRlc3Ryb3koZnVuY3Rpb24oYykgewogICAgICAgICAgICAgIHJldHVybiAwIDw9IGEzLmEuQShiLCBjKTsKICAgICAgICAgICAgfSkgOiBbXTsKICAgICAgICAgIH0sIGluZGV4T2Y6IGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgdmFyIGMgPSB0aGlzKCk7CiAgICAgICAgICAgIHJldHVybiBhMy5hLkEoYywgYik7CiAgICAgICAgICB9LCByZXBsYWNlOiBmdW5jdGlvbihhNCwgYykgewogICAgICAgICAgICB2YXIgZCA9IHRoaXMuaW5kZXhPZihhNCk7CiAgICAgICAgICAgIDAgPD0gZCAmJiAodGhpcy55YSgpLCB0aGlzLnYoKVtkXSA9IGMsIHRoaXMueGEoKSk7CiAgICAgICAgICB9LCBzb3J0ZWQ6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgIHZhciBjID0gdGhpcygpLnNsaWNlKDApOwogICAgICAgICAgICByZXR1cm4gYTQgPyBjLnNvcnQoYTQpIDogYy5zb3J0KCk7CiAgICAgICAgICB9LCByZXZlcnNlZDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzKCkuc2xpY2UoMCkucmV2ZXJzZSgpOwogICAgICAgICAgfSB9OwogICAgICAgICAgYTMuYS5CYSAmJiBhMy5hLnNldFByb3RvdHlwZU9mKGEzLkhhLmZuLCBhMy50YS5mbik7CiAgICAgICAgICBhMy5hLkQoInBvcCBwdXNoIHJldmVyc2Ugc2hpZnQgc29ydCBzcGxpY2UgdW5zaGlmdCIuc3BsaXQoIiAiKSwgZnVuY3Rpb24oYikgewogICAgICAgICAgICBhMy5IYS5mbltiXSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHZhciBhNCA9IHRoaXMudigpOwogICAgICAgICAgICAgIHRoaXMueWEoKTsKICAgICAgICAgICAgICB0aGlzLnpjKGE0LCBiLCBhcmd1bWVudHMpOwogICAgICAgICAgICAgIHZhciBkID0gYTRbYl0uYXBwbHkoYTQsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgdGhpcy54YSgpOwogICAgICAgICAgICAgIHJldHVybiBkID09PSBhNCA/IHRoaXMgOiBkOwogICAgICAgICAgICB9OwogICAgICAgICAgfSk7CiAgICAgICAgICBhMy5hLkQoWyJzbGljZSJdLCBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIGEzLkhhLmZuW2JdID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdmFyIGE0ID0gdGhpcygpOwogICAgICAgICAgICAgIHJldHVybiBhNFtiXS5hcHBseShhNCwgYXJndW1lbnRzKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0pOwogICAgICAgICAgYTMuUGMgPSBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIHJldHVybiBhMy5PKGIpICYmICJmdW5jdGlvbiIgPT0gdHlwZW9mIGIucmVtb3ZlICYmICJmdW5jdGlvbiIgPT0gdHlwZW9mIGIucHVzaDsKICAgICAgICAgIH07CiAgICAgICAgICBhMy5iKCJvYnNlcnZhYmxlQXJyYXkiLCBhMy5IYSk7CiAgICAgICAgICBhMy5iKCJpc09ic2VydmFibGVBcnJheSIsIGEzLlBjKTsKICAgICAgICAgIGEzLlRhLnRyYWNrQXJyYXlDaGFuZ2VzID0gZnVuY3Rpb24oYiwgYykgewogICAgICAgICAgICBmdW5jdGlvbiBkKCkgewogICAgICAgICAgICAgIGZ1bmN0aW9uIGMyKCkgewogICAgICAgICAgICAgICAgaWYgKG0pIHsKICAgICAgICAgICAgICAgICAgdmFyIGQyID0gW10uY29uY2F0KGIudigpIHx8IFtdKSwgZTI7CiAgICAgICAgICAgICAgICAgIGlmIChiLldhKCJhcnJheUNoYW5nZSIpKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFmIHx8IDEgPCBtKQogICAgICAgICAgICAgICAgICAgICAgZiA9IGEzLmEuUGIoaywgZDIsIGIuT2IpOwogICAgICAgICAgICAgICAgICAgIGUyID0gZjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBrID0gZDI7CiAgICAgICAgICAgICAgICAgIGYgPSBudWxsOwogICAgICAgICAgICAgICAgICBtID0gMDsKICAgICAgICAgICAgICAgICAgZTIgJiYgZTIubGVuZ3RoICYmIGIubm90aWZ5U3Vic2NyaWJlcnMoZTIsICJhcnJheUNoYW5nZSIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlID8gYzIoKSA6IChlID0gdHJ1ZSwgaCA9IGIuc3Vic2NyaWJlKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgKyttOwogICAgICAgICAgICAgIH0sIG51bGwsICJzcGVjdGF0ZSIpLCBrID0gW10uY29uY2F0KGIudigpIHx8IFtdKSwgZiA9IG51bGwsIGcgPSBiLnN1YnNjcmliZShjMikpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGIuT2IgPSB7fTsKICAgICAgICAgICAgYyAmJiAib2JqZWN0IiA9PSB0eXBlb2YgYyAmJiBhMy5hLmV4dGVuZChiLk9iLCBjKTsKICAgICAgICAgICAgYi5PYi5zcGFyc2UgPSB0cnVlOwogICAgICAgICAgICBpZiAoIWIuemMpIHsKICAgICAgICAgICAgICB2YXIgZSA9IGZhbHNlLCBmID0gbnVsbCwgZywgaCwgbSA9IDAsIGssIGwgPSBiLlFhLCBwID0gYi5oYjsKICAgICAgICAgICAgICBiLlFhID0gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIGwgJiYgbC5jYWxsKGIsIGE0KTsKICAgICAgICAgICAgICAgICJhcnJheUNoYW5nZSIgPT09IGE0ICYmIGQoKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIGIuaGIgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgcCAmJiBwLmNhbGwoYiwgYTQpOwogICAgICAgICAgICAgICAgImFycmF5Q2hhbmdlIiAhPT0gYTQgfHwgYi5XYSgiYXJyYXlDaGFuZ2UiKSB8fCAoZyAmJiBnLnMoKSwgaCAmJiBoLnMoKSwgaCA9IGcgPSBudWxsLCBlID0gZmFsc2UsIGsgPSBuKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIGIuemMgPSBmdW5jdGlvbihiMiwgYzIsIGQyKSB7CiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsMihhNCwgYjMsIGMzKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBrMltrMi5sZW5ndGhdID0geyBzdGF0dXM6IGE0LCB2YWx1ZTogYjMsIGluZGV4OiBjMyB9OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGUgJiYgIW0pIHsKICAgICAgICAgICAgICAgICAgdmFyIGsyID0gW10sIHAyID0gYjIubGVuZ3RoLCBnMiA9IGQyLmxlbmd0aCwgaDIgPSAwOwogICAgICAgICAgICAgICAgICBzd2l0Y2ggKGMyKSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAicHVzaCI6CiAgICAgICAgICAgICAgICAgICAgICBoMiA9IHAyOwogICAgICAgICAgICAgICAgICAgIGNhc2UgInVuc2hpZnQiOgogICAgICAgICAgICAgICAgICAgICAgZm9yIChjMiA9IDA7IGMyIDwgZzI7IGMyKyspCiAgICAgICAgICAgICAgICAgICAgICAgIGwyKCJhZGRlZCIsIGQyW2MyXSwgaDIgKyBjMik7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlICJwb3AiOgogICAgICAgICAgICAgICAgICAgICAgaDIgPSBwMiAtIDE7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAic2hpZnQiOgogICAgICAgICAgICAgICAgICAgICAgcDIgJiYgbDIoImRlbGV0ZWQiLCBiMltoMl0sIGgyKTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgInNwbGljZSI6CiAgICAgICAgICAgICAgICAgICAgICBjMiA9IE1hdGgubWluKE1hdGgubWF4KDAsIDAgPiBkMlswXSA/IHAyICsgZDJbMF0gOiBkMlswXSksIHAyKTsKICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAyID0gMSA9PT0gZzIgPyBwMiA6IE1hdGgubWluKGMyICsgKGQyWzFdIHx8IDApLCBwMiksIGcyID0gYzIgKyBnMiAtIDIsIGgyID0gTWF0aC5tYXgocDIsIGcyKSwgVSA9IFtdLCBMID0gW10sIG4yID0gMjsgYzIgPCBoMjsgKytjMiwgKytuMikKICAgICAgICAgICAgICAgICAgICAgICAgYzIgPCBwMiAmJiBMLnB1c2gobDIoImRlbGV0ZWQiLCBiMltjMl0sIGMyKSksIGMyIDwgZzIgJiYgVS5wdXNoKGwyKCJhZGRlZCIsIGQyW24yXSwgYzIpKTsKICAgICAgICAgICAgICAgICAgICAgIGEzLmEuS2MoTCwgVSk7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGYgPSBrMjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIHIgPSBhMy5hLkRhKCJfc3RhdGUiKTsKICAgICAgICAgIGEzLm8gPSBhMy4kID0gZnVuY3Rpb24oYiwgYywgZCkgewogICAgICAgICAgICBmdW5jdGlvbiBlKCkgewogICAgICAgICAgICAgIGlmICgwIDwgYXJndW1lbnRzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgaWYgKCJmdW5jdGlvbiIgPT09IHR5cGVvZiBmKQogICAgICAgICAgICAgICAgICBmLmFwcGx5KGcubmIsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJDYW5ub3Qgd3JpdGUgYSB2YWx1ZSB0byBhIGtvLmNvbXB1dGVkIHVubGVzcyB5b3Ugc3BlY2lmeSBhICd3cml0ZScgb3B0aW9uLiBJZiB5b3Ugd2lzaCB0byByZWFkIHRoZSBjdXJyZW50IHZhbHVlLCBkb24ndCBwYXNzIGFueSBwYXJhbWV0ZXJzLiIpOwogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGcucmEgfHwgYTMudS5jYyhlKTsKICAgICAgICAgICAgICAoZy5rYSB8fCBnLkogJiYgZS5YYSgpKSAmJiBlLmhhKCk7CiAgICAgICAgICAgICAgcmV0dXJuIGcuWDsKICAgICAgICAgICAgfQogICAgICAgICAgICAib2JqZWN0IiA9PT0gdHlwZW9mIGIgPyBkID0gYiA6IChkID0gZCB8fCB7fSwgYiAmJiAoZC5yZWFkID0gYikpOwogICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZC5yZWFkKQogICAgICAgICAgICAgIHRocm93IEVycm9yKCJQYXNzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUga28uY29tcHV0ZWQiKTsKICAgICAgICAgICAgdmFyIGYgPSBkLndyaXRlLCBnID0geyBYOiBuLCBzYTogdHJ1ZSwga2E6IHRydWUsIHJiOiBmYWxzZSwgamM6IGZhbHNlLCByYTogZmFsc2UsIHdiOiBmYWxzZSwgSjogZmFsc2UsIFdjOiBkLnJlYWQsIG5iOiBjIHx8IGQub3duZXIsIGw6IGQuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkIHx8IGQubCB8fCBudWxsLCBTYTogZC5kaXNwb3NlV2hlbiB8fCBkLlNhLCBSYjogbnVsbCwgSToge30sIFY6IDAsIEljOiBudWxsIH07CiAgICAgICAgICAgIGVbcl0gPSBnOwogICAgICAgICAgICBlLk5jID0gImZ1bmN0aW9uIiA9PT0gdHlwZW9mIGY7CiAgICAgICAgICAgIGEzLmEuQmEgfHwgYTMuYS5leHRlbmQoZSwgYTMuVC5mbik7CiAgICAgICAgICAgIGEzLlQuZm4ucWIoZSk7CiAgICAgICAgICAgIGEzLmEuQWIoZSwgQyk7CiAgICAgICAgICAgIGQucHVyZSA/IChnLndiID0gdHJ1ZSwgZy5KID0gdHJ1ZSwgYTMuYS5leHRlbmQoZSwgZGEpKSA6IGQuZGVmZXJFdmFsdWF0aW9uICYmIGEzLmEuZXh0ZW5kKGUsIGVhKTsKICAgICAgICAgICAgYTMub3B0aW9ucy5kZWZlclVwZGF0ZXMgJiYgYTMuVGEuZGVmZXJyZWQoZSwgdHJ1ZSk7CiAgICAgICAgICAgIGcubCAmJiAoZy5qYyA9IHRydWUsIGcubC5ub2RlVHlwZSB8fCAoZy5sID0gbnVsbCkpOwogICAgICAgICAgICBnLkogfHwgZC5kZWZlckV2YWx1YXRpb24gfHwgZS5oYSgpOwogICAgICAgICAgICBnLmwgJiYgZS5qYSgpICYmIGEzLmEuSy56YShnLmwsIGcuUmIgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICBlLnMoKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBlOwogICAgICAgICAgfTsKICAgICAgICAgIHZhciBDID0gewogICAgICAgICAgICBlcXVhbGl0eUNvbXBhcmVyOiBLLAogICAgICAgICAgICBxYTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbcl0uVjsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgVmE6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHZhciBiID0gW107CiAgICAgICAgICAgICAgYTMuYS5QKHRoaXNbcl0uSSwgZnVuY3Rpb24oYTQsIGQpIHsKICAgICAgICAgICAgICAgIGJbZC5LYV0gPSBkLmRhOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIHJldHVybiBiOwogICAgICAgICAgICB9LAogICAgICAgICAgICBWYjogZnVuY3Rpb24oYikgewogICAgICAgICAgICAgIGlmICghdGhpc1tyXS5WKQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIHZhciBjID0gdGhpcy5WYSgpOwogICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gYTMuYS5BKGMsIGIpID8gdHJ1ZSA6ICEhYTMuYS5MYihjLCBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGE0LlZiICYmIGE0LlZiKGIpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9LAogICAgICAgICAgICB1YzogZnVuY3Rpb24oYTQsIGMsIGQpIHsKICAgICAgICAgICAgICBpZiAodGhpc1tyXS53YiAmJiBjID09PSB0aGlzKQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkEgJ3B1cmUnIGNvbXB1dGVkIG11c3Qgbm90IGJlIGNhbGxlZCByZWN1cnNpdmVseSIpOwogICAgICAgICAgICAgIHRoaXNbcl0uSVthNF0gPSBkOwogICAgICAgICAgICAgIGQuS2EgPSB0aGlzW3JdLlYrKzsKICAgICAgICAgICAgICBkLkxhID0gYy5vYigpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBYYTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdmFyIGE0LCBjLCBkID0gdGhpc1tyXS5JOwogICAgICAgICAgICAgIGZvciAoYTQgaW4gZCkKICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCwgYTQpICYmIChjID0gZFthNF0sIHRoaXMuSWEgJiYgYy5kYS5KYSB8fCBjLmRhLkRkKGMuTGEpKSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIEpkOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB0aGlzLklhICYmICF0aGlzW3JdLnJiICYmIHRoaXMuSWEoZmFsc2UpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBqYTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdmFyIGE0ID0gdGhpc1tyXTsKICAgICAgICAgICAgICByZXR1cm4gYTQua2EgfHwgMCA8IGE0LlY7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIFJkOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB0aGlzLkphID8gdGhpc1tyXS5rYSAmJiAodGhpc1tyXS5zYSA9IHRydWUpIDogdGhpcy5IYygpOwogICAgICAgICAgICB9LAogICAgICAgICAgICAkYzogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICBpZiAoYTQuSGIpIHsKICAgICAgICAgICAgICAgIHZhciBjID0gYTQuc3Vic2NyaWJlKHRoaXMuSmQsIHRoaXMsICJkaXJ0eSIpLCBkID0gYTQuc3Vic2NyaWJlKAogICAgICAgICAgICAgICAgICB0aGlzLlJkLAogICAgICAgICAgICAgICAgICB0aGlzCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgcmV0dXJuIHsgZGE6IGE0LCBzOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgYy5zKCk7CiAgICAgICAgICAgICAgICAgIGQucygpOwogICAgICAgICAgICAgICAgfSB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gYTQuc3Vic2NyaWJlKHRoaXMuSGMsIHRoaXMpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBIYzogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLCBjID0gYi50aHJvdHRsZUV2YWx1YXRpb247CiAgICAgICAgICAgICAgYyAmJiAwIDw9IGMgPyAoY2xlYXJUaW1lb3V0KHRoaXNbcl0uSWMpLCB0aGlzW3JdLkljID0gYTMuYS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgYi5oYSh0cnVlKTsKICAgICAgICAgICAgICB9LCBjKSkgOiBiLklhID8gYi5JYSh0cnVlKSA6IGIuaGEodHJ1ZSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhOiBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzW3JdLCBkID0gYy5TYSwgZSA9IGZhbHNlOwogICAgICAgICAgICAgIGlmICghYy5yYiAmJiAhYy5yYSkgewogICAgICAgICAgICAgICAgaWYgKGMubCAmJiAhYTMuYS5TYihjLmwpIHx8IGQgJiYgZCgpKSB7CiAgICAgICAgICAgICAgICAgIGlmICghYy5qYykgewogICAgICAgICAgICAgICAgICAgIHRoaXMucygpOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgIGMuamMgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGMucmIgPSB0cnVlOwogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuemQoYik7CiAgICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgICBjLnJiID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHpkOiBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzW3JdLCBkID0gZmFsc2UsIGUgPSBjLndiID8gbiA6ICFjLlYsIGQgPSB7IHFkOiB0aGlzLCBtYjogYy5JLCBRYjogYy5WIH07CiAgICAgICAgICAgICAgYTMudS54Yyh7CiAgICAgICAgICAgICAgICBwZDogZCwKICAgICAgICAgICAgICAgIG9kOiBiYSwKICAgICAgICAgICAgICAgIG86IHRoaXMsCiAgICAgICAgICAgICAgICBZYTogZQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGMuSSA9IHt9OwogICAgICAgICAgICAgIGMuViA9IDA7CiAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLnlkKGMsIGQpOwogICAgICAgICAgICAgIGMuViA/IGQgPSB0aGlzLnNiKGMuWCwgZikgOiAodGhpcy5zKCksIGQgPSB0cnVlKTsKICAgICAgICAgICAgICBkICYmIChjLkogPyB0aGlzLkdiKCkgOiB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKGMuWCwgImJlZm9yZUNoYW5nZSIpLCBjLlggPSBmLCB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKGMuWCwgInNwZWN0YXRlIiksICFjLkogJiYgYiAmJiB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKGMuWCksIHRoaXMucmMgJiYgdGhpcy5yYygpKTsKICAgICAgICAgICAgICBlICYmIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoYy5YLCAiYXdha2UiKTsKICAgICAgICAgICAgICByZXR1cm4gZDsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgeWQ6IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgdmFyIGQgPSBiLldjOwogICAgICAgICAgICAgICAgcmV0dXJuIGIubmIgPyBkLmNhbGwoYi5uYikgOiBkKCk7CiAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIGEzLnUuZW5kKCksIGMuUWIgJiYgIWIuSiAmJiBhMy5hLlAoYy5tYiwgYWEpLCBiLnNhID0gYi5rYSA9IGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgdjogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICB2YXIgYyA9IHRoaXNbcl07CiAgICAgICAgICAgICAgKGMua2EgJiYgKGE0IHx8ICFjLlYpIHx8IGMuSiAmJiB0aGlzLlhhKCkpICYmIHRoaXMuaGEoKTsKICAgICAgICAgICAgICByZXR1cm4gYy5YOwogICAgICAgICAgICB9LAogICAgICAgICAgICB1YjogZnVuY3Rpb24oYikgewogICAgICAgICAgICAgIGEzLlQuZm4udWIuY2FsbCh0aGlzLCBiKTsKICAgICAgICAgICAgICB0aGlzLm5jID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICB0aGlzW3JdLkogfHwgKHRoaXNbcl0uc2EgPyB0aGlzLmhhKCkgOiB0aGlzW3JdLmthID0gZmFsc2UpOwogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbcl0uWDsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHRoaXMuSWEgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgdGhpcy5wYyh0aGlzW3JdLlgpOwogICAgICAgICAgICAgICAgdGhpc1tyXS5rYSA9IHRydWU7CiAgICAgICAgICAgICAgICBhNCAmJiAodGhpc1tyXS5zYSA9IHRydWUpOwogICAgICAgICAgICAgICAgdGhpcy5xYyh0aGlzLCAhYTQpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHM6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHZhciBiID0gdGhpc1tyXTsKICAgICAgICAgICAgICAhYi5KICYmIGIuSSAmJiBhMy5hLlAoYi5JLCBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICAgIGIyLnMgJiYgYjIucygpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGIubCAmJiBiLlJiICYmIGEzLmEuSy55YihiLmwsIGIuUmIpOwogICAgICAgICAgICAgIGIuSSA9IG47CiAgICAgICAgICAgICAgYi5WID0gMDsKICAgICAgICAgICAgICBiLnJhID0gdHJ1ZTsKICAgICAgICAgICAgICBiLnNhID0gZmFsc2U7CiAgICAgICAgICAgICAgYi5rYSA9IGZhbHNlOwogICAgICAgICAgICAgIGIuSiA9IGZhbHNlOwogICAgICAgICAgICAgIGIubCA9IG47CiAgICAgICAgICAgICAgYi5TYSA9IG47CiAgICAgICAgICAgICAgYi5XYyA9IG47CiAgICAgICAgICAgICAgdGhpcy5OYyB8fCAoYi5uYiA9IG4pOwogICAgICAgICAgICB9CiAgICAgICAgICB9LCBkYSA9IHsgUWE6IGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgdmFyIGMgPSB0aGlzLCBkID0gY1tyXTsKICAgICAgICAgICAgaWYgKCFkLnJhICYmIGQuSiAmJiAiY2hhbmdlIiA9PSBiKSB7CiAgICAgICAgICAgICAgZC5KID0gZmFsc2U7CiAgICAgICAgICAgICAgaWYgKGQuc2EgfHwgYy5YYSgpKQogICAgICAgICAgICAgICAgZC5JID0gbnVsbCwgZC5WID0gMCwgYy5oYSgpICYmIGMuR2IoKTsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHZhciBlID0gW107CiAgICAgICAgICAgICAgICBhMy5hLlAoZC5JLCBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICAgICAgZVtiMi5LYV0gPSBhNDsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgYTMuYS5EKGUsIGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgICAgICB2YXIgZTIgPSBkLklbYTRdLCBtID0gYy4kYyhlMi5kYSk7CiAgICAgICAgICAgICAgICAgIG0uS2EgPSBiMjsKICAgICAgICAgICAgICAgICAgbS5MYSA9IGUyLkxhOwogICAgICAgICAgICAgICAgICBkLklbYTRdID0gbTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgYy5YYSgpICYmIGMuaGEoKSAmJiBjLkdiKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGQucmEgfHwgYy5ub3RpZnlTdWJzY3JpYmVycyhkLlgsICJhd2FrZSIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9LCBoYjogZnVuY3Rpb24oYikgewogICAgICAgICAgICB2YXIgYyA9IHRoaXNbcl07CiAgICAgICAgICAgIGMucmEgfHwgImNoYW5nZSIgIT0gYiB8fCB0aGlzLldhKCJjaGFuZ2UiKSB8fCAoYTMuYS5QKGMuSSwgZnVuY3Rpb24oYTQsIGIyKSB7CiAgICAgICAgICAgICAgYjIucyAmJiAoYy5JW2E0XSA9IHsgZGE6IGIyLmRhLCBLYTogYjIuS2EsIExhOiBiMi5MYSB9LCBiMi5zKCkpOwogICAgICAgICAgICB9KSwgYy5KID0gdHJ1ZSwgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyhuLCAiYXNsZWVwIikpOwogICAgICAgICAgfSwgb2I6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgYiA9IHRoaXNbcl07CiAgICAgICAgICAgIGIuSiAmJiAoYi5zYSB8fCB0aGlzLlhhKCkpICYmIHRoaXMuaGEoKTsKICAgICAgICAgICAgcmV0dXJuIGEzLlQuZm4ub2IuY2FsbCh0aGlzKTsKICAgICAgICAgIH0gfSwgZWEgPSB7IFFhOiBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAiY2hhbmdlIiAhPSBhNCAmJiAiYmVmb3JlQ2hhbmdlIiAhPSBhNCB8fCB0aGlzLnYoKTsKICAgICAgICAgIH0gfTsKICAgICAgICAgIGEzLmEuQmEgJiYgYTMuYS5zZXRQcm90b3R5cGVPZihDLCBhMy5ULmZuKTsKICAgICAgICAgIHZhciBOID0gYTMudGEuTWE7CiAgICAgICAgICBDW05dID0gYTMubzsKICAgICAgICAgIGEzLk9jID0gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgcmV0dXJuICJmdW5jdGlvbiIgPT0gdHlwZW9mIGE0ICYmIGE0W05dID09PSBDW05dOwogICAgICAgICAgfTsKICAgICAgICAgIGEzLkZkID0gZnVuY3Rpb24oYikgewogICAgICAgICAgICByZXR1cm4gYTMuT2MoYikgJiYgYltyXSAmJiBiW3JdLndiOwogICAgICAgICAgfTsKICAgICAgICAgIGEzLmIoImNvbXB1dGVkIiwgYTMubyk7CiAgICAgICAgICBhMy5iKCJkZXBlbmRlbnRPYnNlcnZhYmxlIiwgYTMubyk7CiAgICAgICAgICBhMy5iKCJpc0NvbXB1dGVkIiwgYTMuT2MpOwogICAgICAgICAgYTMuYigiaXNQdXJlQ29tcHV0ZWQiLCBhMy5GZCk7CiAgICAgICAgICBhMy5iKCJjb21wdXRlZC5mbiIsIEMpOwogICAgICAgICAgYTMuTChDLCAicGVlayIsIEMudik7CiAgICAgICAgICBhMy5MKEMsICJkaXNwb3NlIiwgQy5zKTsKICAgICAgICAgIGEzLkwoQywgImlzQWN0aXZlIiwgQy5qYSk7CiAgICAgICAgICBhMy5MKEMsICJnZXREZXBlbmRlbmNpZXNDb3VudCIsIEMucWEpOwogICAgICAgICAgYTMuTChDLCAiZ2V0RGVwZW5kZW5jaWVzIiwgQy5WYSk7CiAgICAgICAgICBhMy54YiA9IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgaWYgKCJmdW5jdGlvbiIgPT09IHR5cGVvZiBiKQogICAgICAgICAgICAgIHJldHVybiBhMy5vKAogICAgICAgICAgICAgICAgYiwKICAgICAgICAgICAgICAgIGMsCiAgICAgICAgICAgICAgICB7IHB1cmU6IHRydWUgfQogICAgICAgICAgICAgICk7CiAgICAgICAgICAgIGIgPSBhMy5hLmV4dGVuZCh7fSwgYik7CiAgICAgICAgICAgIGIucHVyZSA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBhMy5vKGIsIGMpOwogICAgICAgICAgfTsKICAgICAgICAgIGEzLmIoInB1cmVDb21wdXRlZCIsIGEzLnhiKTsKICAgICAgICAgIChmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihhNCwgZiwgZykgewogICAgICAgICAgICAgIGcgPSBnIHx8IG5ldyBkKCk7CiAgICAgICAgICAgICAgYTQgPSBmKGE0KTsKICAgICAgICAgICAgICBpZiAoIm9iamVjdCIgIT0gdHlwZW9mIGE0IHx8IG51bGwgPT09IGE0IHx8IGE0ID09PSBuIHx8IGE0IGluc3RhbmNlb2YgUmVnRXhwIHx8IGE0IGluc3RhbmNlb2YgRGF0ZSB8fCBhNCBpbnN0YW5jZW9mIFN0cmluZyB8fCBhNCBpbnN0YW5jZW9mIE51bWJlciB8fCBhNCBpbnN0YW5jZW9mIEJvb2xlYW4pCiAgICAgICAgICAgICAgICByZXR1cm4gYTQ7CiAgICAgICAgICAgICAgdmFyIGggPSBhNCBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fTsKICAgICAgICAgICAgICBnLnNhdmUoYTQsIGgpOwogICAgICAgICAgICAgIGMoYTQsIGZ1bmN0aW9uKGMyKSB7CiAgICAgICAgICAgICAgICB2YXIgZDIgPSBmKGE0W2MyXSk7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBkMikgewogICAgICAgICAgICAgICAgICBjYXNlICJib29sZWFuIjoKICAgICAgICAgICAgICAgICAgY2FzZSAibnVtYmVyIjoKICAgICAgICAgICAgICAgICAgY2FzZSAic3RyaW5nIjoKICAgICAgICAgICAgICAgICAgY2FzZSAiZnVuY3Rpb24iOgogICAgICAgICAgICAgICAgICAgIGhbYzJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgIm9iamVjdCI6CiAgICAgICAgICAgICAgICAgIGNhc2UgInVuZGVmaW5lZCI6CiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBnLmdldChkMik7CiAgICAgICAgICAgICAgICAgICAgaFtjMl0gPSBsICE9PSBuID8gbCA6IGIoZDIsIGYsIGcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIHJldHVybiBoOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGMoYTQsIGIyKSB7CiAgICAgICAgICAgICAgaWYgKGE0IGluc3RhbmNlb2YgQXJyYXkpIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGMyID0gMDsgYzIgPCBhNC5sZW5ndGg7IGMyKyspCiAgICAgICAgICAgICAgICAgIGIyKGMyKTsKICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIGE0LnRvSlNPTiAmJiBiMigidG9KU09OIik7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBmb3IgKGMyIGluIGE0KQogICAgICAgICAgICAgICAgICBiMihjMik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZCgpIHsKICAgICAgICAgICAgICB0aGlzLmtleXMgPSBbXTsKICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGEzLmFkID0gZnVuY3Rpb24oYzIpIHsKICAgICAgICAgICAgICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIldoZW4gY2FsbGluZyBrby50b0pTLCBwYXNzIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gY29udmVydC4iKTsKICAgICAgICAgICAgICByZXR1cm4gYihjMiwgZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGMzID0gMDsgYTMuTyhiMikgJiYgMTAgPiBjMzsgYzMrKykKICAgICAgICAgICAgICAgICAgYjIgPSBiMigpOwogICAgICAgICAgICAgICAgcmV0dXJuIGIyOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy50b0pTT04gPSBmdW5jdGlvbihiMiwgYzIsIGQyKSB7CiAgICAgICAgICAgICAgYjIgPSBhMy5hZChiMik7CiAgICAgICAgICAgICAgcmV0dXJuIGEzLmEuaGMoYjIsIGMyLCBkMik7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogZCwgc2F2ZTogZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgdmFyIGQyID0gYTMuYS5BKAogICAgICAgICAgICAgICAgdGhpcy5rZXlzLAogICAgICAgICAgICAgICAgYjIKICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIDAgPD0gZDIgPyB0aGlzLnZhbHVlc1tkMl0gPSBjMiA6ICh0aGlzLmtleXMucHVzaChiMiksIHRoaXMudmFsdWVzLnB1c2goYzIpKTsKICAgICAgICAgICAgfSwgZ2V0OiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIGIyID0gYTMuYS5BKHRoaXMua2V5cywgYjIpOwogICAgICAgICAgICAgIHJldHVybiAwIDw9IGIyID8gdGhpcy52YWx1ZXNbYjJdIDogbjsKICAgICAgICAgICAgfSB9OwogICAgICAgICAgfSkoKTsKICAgICAgICAgIGEzLmIoInRvSlMiLCBhMy5hZCk7CiAgICAgICAgICBhMy5iKCJ0b0pTT04iLCBhMy50b0pTT04pOwogICAgICAgICAgYTMuV2QgPSBmdW5jdGlvbihiLCBjLCBkKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGUoYzIpIHsKICAgICAgICAgICAgICB2YXIgZTIgPSBhMy54YihiLCBkKS5leHRlbmQoeyBtYTogImFsd2F5cyIgfSksIGggPSBlMi5zdWJzY3JpYmUoZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIGE0ICYmIChoLnMoKSwgYzIoYTQpKTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBlMi5ub3RpZnlTdWJzY3JpYmVycyhlMi52KCkpOwogICAgICAgICAgICAgIHJldHVybiBoOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAiZnVuY3Rpb24iICE9PSB0eXBlb2YgUHJvbWlzZSB8fCBjID8gZShjLmJpbmQoZCkpIDogbmV3IFByb21pc2UoZSk7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuYigid2hlbiIsIGEzLldkKTsKICAgICAgICAgIChmdW5jdGlvbigpIHsKICAgICAgICAgICAgYTMudyA9IHsgTTogZnVuY3Rpb24oYikgewogICAgICAgICAgICAgIHN3aXRjaCAoYTMuYS5SKGIpKSB7CiAgICAgICAgICAgICAgICBjYXNlICJvcHRpb24iOgogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZSA9PT0gYi5fX2tvX19oYXNEb21EYXRhT3B0aW9uVmFsdWVfXyA/IGEzLmEuZy5nZXQoYiwgYTMuYy5vcHRpb25zLiRiKSA6IDcgPj0gYTMuYS5XID8gYi5nZXRBdHRyaWJ1dGVOb2RlKCJ2YWx1ZSIpICYmIGIuZ2V0QXR0cmlidXRlTm9kZSgidmFsdWUiKS5zcGVjaWZpZWQgPyBiLnZhbHVlIDogYi50ZXh0IDogYi52YWx1ZTsKICAgICAgICAgICAgICAgIGNhc2UgInNlbGVjdCI6CiAgICAgICAgICAgICAgICAgIHJldHVybiAwIDw9IGIuc2VsZWN0ZWRJbmRleCA/IGEzLncuTShiLm9wdGlvbnNbYi5zZWxlY3RlZEluZGV4XSkgOiBuOwogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgcmV0dXJuIGIudmFsdWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBjYjogZnVuY3Rpb24oYiwgYywgZCkgewogICAgICAgICAgICAgIHN3aXRjaCAoYTMuYS5SKGIpKSB7CiAgICAgICAgICAgICAgICBjYXNlICJvcHRpb24iOgogICAgICAgICAgICAgICAgICAic3RyaW5nIiA9PT0gdHlwZW9mIGMgPyAoYTMuYS5nLnNldChiLCBhMy5jLm9wdGlvbnMuJGIsIG4pLCAiX19rb19faGFzRG9tRGF0YU9wdGlvblZhbHVlX18iIGluIGIgJiYgZGVsZXRlIGIuX19rb19faGFzRG9tRGF0YU9wdGlvblZhbHVlX18sIGIudmFsdWUgPSBjKSA6IChhMy5hLmcuc2V0KGIsIGEzLmMub3B0aW9ucy4kYiwgYyksIGIuX19rb19faGFzRG9tRGF0YU9wdGlvblZhbHVlX18gPSB0cnVlLCBiLnZhbHVlID0gIm51bWJlciIgPT09IHR5cGVvZiBjID8gYyA6ICIiKTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlICJzZWxlY3QiOgogICAgICAgICAgICAgICAgICBpZiAoIiIgPT09IGMgfHwgbnVsbCA9PT0gYykKICAgICAgICAgICAgICAgICAgICBjID0gbjsKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IC0xLCBmID0gMCwgZyA9IGIub3B0aW9ucy5sZW5ndGgsIGg7IGYgPCBnOyArK2YpCiAgICAgICAgICAgICAgICAgICAgaWYgKGggPSBhMy53Lk0oYi5vcHRpb25zW2ZdKSwgaCA9PSBjIHx8ICIiID09PSBoICYmIGMgPT09IG4pIHsKICAgICAgICAgICAgICAgICAgICAgIGUgPSBmOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoZCB8fCAwIDw9IGUgfHwgYyA9PT0gbiAmJiAxIDwgYi5zaXplKQogICAgICAgICAgICAgICAgICAgIGIuc2VsZWN0ZWRJbmRleCA9IGUsIDYgPT09IGEzLmEuVyAmJiBhMy5hLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgICBiLnNlbGVjdGVkSW5kZXggPSBlOwogICAgICAgICAgICAgICAgICAgIH0sIDApOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBjIHx8IGMgPT09IG4pCiAgICAgICAgICAgICAgICAgICAgYyA9ICIiOwogICAgICAgICAgICAgICAgICBiLnZhbHVlID0gYzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gfTsKICAgICAgICAgIH0pKCk7CiAgICAgICAgICBhMy5iKCJzZWxlY3RFeHRlbnNpb25zIiwgYTMudyk7CiAgICAgICAgICBhMy5iKCJzZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZSIsIGEzLncuTSk7CiAgICAgICAgICBhMy5iKCJzZWxlY3RFeHRlbnNpb25zLndyaXRlVmFsdWUiLCBhMy53LmNiKTsKICAgICAgICAgIGEzLm0gPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihiMikgewogICAgICAgICAgICAgIGIyID0gYTMuYS5EYihiMik7CiAgICAgICAgICAgICAgMTIzID09PSBiMi5jaGFyQ29kZUF0KDApICYmIChiMiA9IGIyLnNsaWNlKAogICAgICAgICAgICAgICAgMSwKICAgICAgICAgICAgICAgIC0xCiAgICAgICAgICAgICAgKSk7CiAgICAgICAgICAgICAgYjIgKz0gIlxuLCI7CiAgICAgICAgICAgICAgdmFyIGMyID0gW10sIGQyID0gYjIubWF0Y2goZSksIHAsIHEgPSBbXSwgaDIgPSAwOwogICAgICAgICAgICAgIGlmICgxIDwgZDIubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgQjsgQiA9IGQyW3hdOyArK3gpIHsKICAgICAgICAgICAgICAgICAgdmFyIHUyID0gQi5jaGFyQ29kZUF0KDApOwogICAgICAgICAgICAgICAgICBpZiAoNDQgPT09IHUyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPj0gaDIpIHsKICAgICAgICAgICAgICAgICAgICAgIGMyLnB1c2gocCAmJiBxLmxlbmd0aCA/IHsga2V5OiBwLCB2YWx1ZTogcS5qb2luKCIiKSB9IDogeyB1bmtub3duOiBwIHx8IHEuam9pbigiIikgfSk7CiAgICAgICAgICAgICAgICAgICAgICBwID0gaDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgcSA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDU4ID09PSB1MikgewogICAgICAgICAgICAgICAgICAgIGlmICghaDIgJiYgIXAgJiYgMSA9PT0gcS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgIHAgPSBxLnBvcCgpOwogICAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDQ3ID09PSB1MiAmJiAxIDwgQi5sZW5ndGggJiYgKDQ3ID09PSBCLmNoYXJDb2RlQXQoMSkgfHwgNDIgPT09IEIuY2hhckNvZGVBdCgxKSkpCiAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICA0NyA9PT0gdTIgJiYgeCAmJiAxIDwgQi5sZW5ndGggPyAodTIgPSBkMlt4IC0gMV0ubWF0Y2goZikpICYmICFnW3UyWzBdXSAmJiAoYjIgPSBiMi5zdWJzdHIoYjIuaW5kZXhPZihCKSArIDEpLCBkMiA9IGIyLm1hdGNoKGUpLCB4ID0gLTEsIEIgPSAiLyIpIDogNDAgPT09IHUyIHx8IDEyMyA9PT0gdTIgfHwgOTEgPT09IHUyID8gKytoMiA6IDQxID09PSB1MiB8fCAxMjUgPT09IHUyIHx8IDkzID09PSB1MiA/IC0taDIgOiBwIHx8IHEubGVuZ3RoIHx8IDM0ICE9PSB1MiAmJiAzOSAhPT0gdTIgfHwgKEIgPSBCLnNsaWNlKDEsIC0xKSk7CiAgICAgICAgICAgICAgICAgIHEucHVzaChCKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgwIDwgaDIpCiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJVbmJhbGFuY2VkIHBhcmVudGhlc2VzLCBicmFjZXMsIG9yIGJyYWNrZXRzIik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBjMjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgYyA9IFsidHJ1ZSIsICJmYWxzZSIsICJudWxsIiwgInVuZGVmaW5lZCJdLCBkID0gL14oPzpbJF9hLXpdWyRcd10qfCguKykoXC5ccypbJF9hLXpdWyRcd10qfFxbLitcXSkpJC9pLCBlID0gUmVnRXhwKCJcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xgKD86XFxcXC58W15gXSkqYHwvXFwqKD86W14qXXxcXCorW14qL10pKlxcKisvfC8vLipcbnwvKD86XFxcXC58W14vXSkrL3cqfFteXFxzOiwvXVteLFwiJ2B7fSgpLzpbXFxdXSpbXlxccyxcIidge30oKS86W1xcXV18W15cXHNdIiwgImciKSwgZiA9IC9bXF0pIidBLVphLXowLTlfJF0rJC8sIGcgPSB7ICJpbiI6IDEsICJyZXR1cm4iOiAxLCAidHlwZW9mIjogMSB9LCBoID0ge307CiAgICAgICAgICAgIHJldHVybiB7IFJhOiBbXSwgd2E6IGgsIGFjOiBiLCB2YjogZnVuY3Rpb24oZTIsIGYyKSB7CiAgICAgICAgICAgICAgZnVuY3Rpb24gbChiMiwgZTMpIHsKICAgICAgICAgICAgICAgIHZhciBmMzsKICAgICAgICAgICAgICAgIGlmICgheCkgewogICAgICAgICAgICAgICAgICB2YXIgayA9IGEzLmdldEJpbmRpbmdIYW5kbGVyKGIyKTsKICAgICAgICAgICAgICAgICAgaWYgKGsgJiYgay5wcmVwcm9jZXNzICYmICEoZTMgPSBrLnByZXByb2Nlc3MoZTMsIGIyLCBsKSkpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgICBpZiAoayA9IGhbYjJdKQogICAgICAgICAgICAgICAgICAgIGYzID0gZTMsIDAgPD0gYTMuYS5BKGMsIGYzKSA/IGYzID0gZmFsc2UgOiAoayA9IGYzLm1hdGNoKGQpLCBmMyA9IG51bGwgPT09IGsgPyBmYWxzZSA6IGtbMV0gPyAiT2JqZWN0KCIgKyBrWzFdICsgIikiICsga1syXSA6IGYzKSwgayA9IGYzOwogICAgICAgICAgICAgICAgICBrICYmIHEucHVzaCgiJyIgKyAoInN0cmluZyIgPT0gdHlwZW9mIGhbYjJdID8gaFtiMl0gOiBiMikgKyAiJzpmdW5jdGlvbihfeil7IiArIGYzICsgIj1fen0iKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGcyICYmIChlMyA9ICJmdW5jdGlvbigpe3JldHVybiAiICsgZTMgKyAiIH0iKTsKICAgICAgICAgICAgICAgIHAucHVzaCgiJyIgKyBiMiArICInOiIgKyBlMyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGYyID0gZjIgfHwge307CiAgICAgICAgICAgICAgdmFyIHAgPSBbXSwgcSA9IFtdLCBnMiA9IGYyLnZhbHVlQWNjZXNzb3JzLCB4ID0gZjIuYmluZGluZ1BhcmFtcywgQiA9ICJzdHJpbmciID09PSB0eXBlb2YgZTIgPyBiKGUyKSA6IGUyOwogICAgICAgICAgICAgIGEzLmEuRChCLCBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgbCgKICAgICAgICAgICAgICAgICAgYTQua2V5IHx8IGE0LnVua25vd24sCiAgICAgICAgICAgICAgICAgIGE0LnZhbHVlCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIHEubGVuZ3RoICYmIGwoIl9rb19wcm9wZXJ0eV93cml0ZXJzIiwgInsiICsgcS5qb2luKCIsIikgKyAiIH0iKTsKICAgICAgICAgICAgICByZXR1cm4gcC5qb2luKCIsIik7CiAgICAgICAgICAgIH0sIElkOiBmdW5jdGlvbihhNCwgYjIpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBjMiA9IDA7IGMyIDwgYTQubGVuZ3RoOyBjMisrKQogICAgICAgICAgICAgICAgaWYgKGE0W2MyXS5rZXkgPT0gYjIpCiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfSwgZWI6IGZ1bmN0aW9uKGIyLCBjMiwgZDIsIGUyLCBmMikgewogICAgICAgICAgICAgIGlmIChiMiAmJiBhMy5PKGIyKSkKICAgICAgICAgICAgICAgICFhMy5aYShiMikgfHwgZjIgJiYgYjIudigpID09PSBlMiB8fCBiMihlMik7CiAgICAgICAgICAgICAgZWxzZSBpZiAoKGIyID0gYzIuZ2V0KCJfa29fcHJvcGVydHlfd3JpdGVycyIpKSAmJiBiMltkMl0pCiAgICAgICAgICAgICAgICBiMltkMl0oZTIpOwogICAgICAgICAgICB9IH07CiAgICAgICAgICB9KCk7CiAgICAgICAgICBhMy5iKCJleHByZXNzaW9uUmV3cml0aW5nIiwgYTMubSk7CiAgICAgICAgICBhMy5iKCJleHByZXNzaW9uUmV3cml0aW5nLmJpbmRpbmdSZXdyaXRlVmFsaWRhdG9ycyIsIGEzLm0uUmEpOwogICAgICAgICAgYTMuYigiZXhwcmVzc2lvblJld3JpdGluZy5wYXJzZU9iamVjdExpdGVyYWwiLCBhMy5tLmFjKTsKICAgICAgICAgIGEzLmIoImV4cHJlc3Npb25SZXdyaXRpbmcucHJlUHJvY2Vzc0JpbmRpbmdzIiwgYTMubS52Yik7CiAgICAgICAgICBhMy5iKAogICAgICAgICAgICAiZXhwcmVzc2lvblJld3JpdGluZy5fdHdvV2F5QmluZGluZ3MiLAogICAgICAgICAgICBhMy5tLndhCiAgICAgICAgICApOwogICAgICAgICAgYTMuYigianNvbkV4cHJlc3Npb25SZXdyaXRpbmciLCBhMy5tKTsKICAgICAgICAgIGEzLmIoImpzb25FeHByZXNzaW9uUmV3cml0aW5nLmluc2VydFByb3BlcnR5QWNjZXNzb3JzSW50b0pzb24iLCBhMy5tLnZiKTsKICAgICAgICAgIChmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihhNCkgewogICAgICAgICAgICAgIHJldHVybiA4ID09IGE0Lm5vZGVUeXBlICYmIGcudGVzdChmID8gYTQudGV4dCA6IGE0Lm5vZGVWYWx1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYyhhNCkgewogICAgICAgICAgICAgIHJldHVybiA4ID09IGE0Lm5vZGVUeXBlICYmIGgudGVzdChmID8gYTQudGV4dCA6IGE0Lm5vZGVWYWx1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZChkMiwgZTIpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBmMiA9IGQyLCBoMiA9IDEsIGcyID0gW107IGYyID0gZjIubmV4dFNpYmxpbmc7ICkgewogICAgICAgICAgICAgICAgaWYgKGMoZjIpICYmIChhMy5hLmcuc2V0KGYyLCBrLCB0cnVlKSwgaDItLSwgMCA9PT0gaDIpKQogICAgICAgICAgICAgICAgICByZXR1cm4gZzI7CiAgICAgICAgICAgICAgICBnMi5wdXNoKGYyKTsKICAgICAgICAgICAgICAgIGIoZjIpICYmIGgyKys7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghZTIpCiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiQ2Fubm90IGZpbmQgY2xvc2luZyBjb21tZW50IHRhZyB0byBtYXRjaDogIiArIGQyLm5vZGVWYWx1ZSk7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZShhNCwgYjIpIHsKICAgICAgICAgICAgICB2YXIgYzIgPSBkKGE0LCBiMik7CiAgICAgICAgICAgICAgcmV0dXJuIGMyID8gMCA8IGMyLmxlbmd0aCA/IGMyW2MyLmxlbmd0aCAtIDFdLm5leHRTaWJsaW5nIDogYTQubmV4dFNpYmxpbmcgOiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBmID0gdyAmJiAiPCEtLXRlc3QtLT4iID09PSB3LmNyZWF0ZUNvbW1lbnQoInRlc3QiKS50ZXh0LCBnID0gZiA/IC9eXHgzYyEtLVxzKmtvKD86XHMrKFtcc1xTXSspKT9ccyotLVx4M2UkLyA6IC9eXHMqa28oPzpccysoW1xzXFNdKykpP1xzKiQvLCBoID0gZiA/IC9eXHgzYyEtLVxzKlwva29ccyotLVx4M2UkLyA6IC9eXHMqXC9rb1xzKiQvLCBtID0geyB1bDogdHJ1ZSwgb2w6IHRydWUgfSwgayA9ICJfX2tvX21hdGNoZWRFbmRDb21tZW50X18iOwogICAgICAgICAgICBhMy5oID0geyBlYToge30sIGNoaWxkTm9kZXM6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGIoYTQpID8gZChhNCkgOiBhNC5jaGlsZE5vZGVzOwogICAgICAgICAgICB9LCBFYTogZnVuY3Rpb24oYzIpIHsKICAgICAgICAgICAgICBpZiAoYihjMikpIHsKICAgICAgICAgICAgICAgIGMyID0gYTMuaC5jaGlsZE5vZGVzKGMyKTsKICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMCwgZTIgPSBjMi5sZW5ndGg7IGQyIDwgZTI7IGQyKyspCiAgICAgICAgICAgICAgICAgIGEzLnJlbW92ZU5vZGUoYzJbZDJdKTsKICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgIGEzLmEuVGIoYzIpOwogICAgICAgICAgICB9LCB2YTogZnVuY3Rpb24oYzIsIGQyKSB7CiAgICAgICAgICAgICAgaWYgKGIoYzIpKSB7CiAgICAgICAgICAgICAgICBhMy5oLkVhKGMyKTsKICAgICAgICAgICAgICAgIGZvciAodmFyIGUyID0gYzIubmV4dFNpYmxpbmcsIGYyID0gMCwgazIgPSBkMi5sZW5ndGg7IGYyIDwgazI7IGYyKyspCiAgICAgICAgICAgICAgICAgIGUyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGQyW2YyXSwgZTIpOwogICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgYTMuYS52YShjMiwgZDIpOwogICAgICAgICAgICB9LCBWYzogZnVuY3Rpb24oYTQsIGMyKSB7CiAgICAgICAgICAgICAgdmFyIGQyOwogICAgICAgICAgICAgIGIoYTQpID8gKGQyID0gYTQubmV4dFNpYmxpbmcsIGE0ID0gYTQucGFyZW50Tm9kZSkgOiBkMiA9IGE0LmZpcnN0Q2hpbGQ7CiAgICAgICAgICAgICAgZDIgPyBjMiAhPT0gZDIgJiYgYTQuaW5zZXJ0QmVmb3JlKGMyLCBkMikgOiBhNC5hcHBlbmRDaGlsZChjMik7CiAgICAgICAgICAgIH0sIFdiOiBmdW5jdGlvbihjMiwgZDIsIGUyKSB7CiAgICAgICAgICAgICAgZTIgPyAoZTIgPSBlMi5uZXh0U2libGluZywgYihjMikgJiYgKGMyID0gYzIucGFyZW50Tm9kZSksIGUyID8gZDIgIT09IGUyICYmIGMyLmluc2VydEJlZm9yZShkMiwgZTIpIDogYzIuYXBwZW5kQ2hpbGQoZDIpKSA6IGEzLmguVmMoYzIsIGQyKTsKICAgICAgICAgICAgfSwgZmlyc3RDaGlsZDogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICBpZiAoYihhNCkpCiAgICAgICAgICAgICAgICByZXR1cm4gIWE0Lm5leHRTaWJsaW5nIHx8IGMoYTQubmV4dFNpYmxpbmcpID8gbnVsbCA6IGE0Lm5leHRTaWJsaW5nOwogICAgICAgICAgICAgIGlmIChhNC5maXJzdENoaWxkICYmIGMoYTQuZmlyc3RDaGlsZCkpCiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiRm91bmQgaW52YWxpZCBlbmQgY29tbWVudCwgYXMgdGhlIGZpcnN0IGNoaWxkIG9mICIgKyBhNCk7CiAgICAgICAgICAgICAgcmV0dXJuIGE0LmZpcnN0Q2hpbGQ7CiAgICAgICAgICAgIH0sIG5leHRTaWJsaW5nOiBmdW5jdGlvbihkMikgewogICAgICAgICAgICAgIGIoZDIpICYmIChkMiA9IGUoZDIpKTsKICAgICAgICAgICAgICBpZiAoZDIubmV4dFNpYmxpbmcgJiYgYyhkMi5uZXh0U2libGluZykpIHsKICAgICAgICAgICAgICAgIHZhciBmMiA9IGQyLm5leHRTaWJsaW5nOwogICAgICAgICAgICAgICAgaWYgKGMoZjIpICYmICFhMy5hLmcuZ2V0KGYyLCBrKSkKICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkZvdW5kIGVuZCBjb21tZW50IHdpdGhvdXQgYSBtYXRjaGluZyBvcGVuaW5nIGNvbW1lbnQsIGFzIGNoaWxkIG9mICIgKyBkMik7CiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGQyLm5leHRTaWJsaW5nOwogICAgICAgICAgICB9LCBDZDogYiwgVmQ6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIChhNCA9IChmID8gYTQudGV4dCA6IGE0Lm5vZGVWYWx1ZSkubWF0Y2goZykpID8gYTRbMV0gOiBudWxsOwogICAgICAgICAgICB9LCBTYzogZnVuY3Rpb24oZDIpIHsKICAgICAgICAgICAgICBpZiAobVthMy5hLlIoZDIpXSkgewogICAgICAgICAgICAgICAgdmFyIGYyID0gZDIuZmlyc3RDaGlsZDsKICAgICAgICAgICAgICAgIGlmIChmMikgewogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBmMi5ub2RlVHlwZSkgewogICAgICAgICAgICAgICAgICAgICAgdmFyIGsyOwogICAgICAgICAgICAgICAgICAgICAgazIgPSBmMi5maXJzdENoaWxkOwogICAgICAgICAgICAgICAgICAgICAgdmFyIGgyID0gbnVsbDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChrMikgewogICAgICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyLnB1c2goazIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIoazIpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZzIgPSBlKGsyLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcyID8gazIgPSBnMiA6IGgyID0gW2syXTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMoazIpICYmIChoMiA9IFtrMl0pOwogICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoazIgPSBrMi5uZXh0U2libGluZyk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAoazIgPSBoMikKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChoMiA9IGYyLm5leHRTaWJsaW5nLCBnMiA9IDA7IGcyIDwgazIubGVuZ3RoOyBnMisrKQogICAgICAgICAgICAgICAgICAgICAgICAgIGgyID8gZDIuaW5zZXJ0QmVmb3JlKGsyW2cyXSwgaDIpIDogZDIuYXBwZW5kQ2hpbGQoazJbZzJdKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHdoaWxlIChmMiA9IGYyLm5leHRTaWJsaW5nKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gfTsKICAgICAgICAgIH0pKCk7CiAgICAgICAgICBhMy5iKCJ2aXJ0dWFsRWxlbWVudHMiLCBhMy5oKTsKICAgICAgICAgIGEzLmIoInZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3MiLCBhMy5oLmVhKTsKICAgICAgICAgIGEzLmIoInZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGUiLCBhMy5oLkVhKTsKICAgICAgICAgIGEzLmIoInZpcnR1YWxFbGVtZW50cy5pbnNlcnRBZnRlciIsIGEzLmguV2IpOwogICAgICAgICAgYTMuYigidmlydHVhbEVsZW1lbnRzLnByZXBlbmQiLCBhMy5oLlZjKTsKICAgICAgICAgIGEzLmIoInZpcnR1YWxFbGVtZW50cy5zZXREb21Ob2RlQ2hpbGRyZW4iLCBhMy5oLnZhKTsKICAgICAgICAgIChmdW5jdGlvbigpIHsKICAgICAgICAgICAgYTMuZ2EgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB0aGlzLm5kID0ge307CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLmEuZXh0ZW5kKGEzLmdhLnByb3RvdHlwZSwgewogICAgICAgICAgICAgIG5vZGVIYXNCaW5kaW5nczogZnVuY3Rpb24oYikgewogICAgICAgICAgICAgICAgc3dpdGNoIChiLm5vZGVUeXBlKSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPSBiLmdldEF0dHJpYnV0ZSgiZGF0YS1iaW5kIikgfHwgYTMuai5nZXRDb21wb25lbnROYW1lRm9yTm9kZShiKTsKICAgICAgICAgICAgICAgICAgY2FzZSA4OgogICAgICAgICAgICAgICAgICAgIHJldHVybiBhMy5oLkNkKGIpOwogICAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIGdldEJpbmRpbmdzOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuZ2V0QmluZGluZ3NTdHJpbmcoYiwgYyksIGQgPSBkID8gdGhpcy5wYXJzZUJpbmRpbmdzU3RyaW5nKGQsIGMsIGIpIDogbnVsbDsKICAgICAgICAgICAgICAgIHJldHVybiBhMy5qLnRjKGQsIGIsIGMsIGZhbHNlKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIGdldEJpbmRpbmdBY2Nlc3NvcnM6IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5nZXRCaW5kaW5nc1N0cmluZyhiLCBjKSwgZCA9IGQgPyB0aGlzLnBhcnNlQmluZGluZ3NTdHJpbmcoZCwgYywgYiwgeyB2YWx1ZUFjY2Vzc29yczogdHJ1ZSB9KSA6IG51bGw7CiAgICAgICAgICAgICAgICByZXR1cm4gYTMuai50YyhkLCBiLCBjLCB0cnVlKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIGdldEJpbmRpbmdzU3RyaW5nOiBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKGIubm9kZVR5cGUpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmdldEF0dHJpYnV0ZSgiZGF0YS1iaW5kIik7CiAgICAgICAgICAgICAgICAgIGNhc2UgODoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTMuaC5WZChiKTsKICAgICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHBhcnNlQmluZGluZ3NTdHJpbmc6IGZ1bmN0aW9uKGIsIGMsIGQsIGUpIHsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5uZCwgZyA9IGIgKyAoZSAmJiBlLnZhbHVlQWNjZXNzb3JzIHx8ICIiKSwgaDsKICAgICAgICAgICAgICAgICAgaWYgKCEoaCA9IGZbZ10pKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIG0sIGsgPSAid2l0aCgkY29udGV4dCl7d2l0aCgkZGF0YXx8e30pe3JldHVybnsiICsgYTMubS52YihiLCBlKSArICJ9fX0iOwogICAgICAgICAgICAgICAgICAgIG0gPSBuZXcgRnVuY3Rpb24oIiRjb250ZXh0IiwgIiRlbGVtZW50Iiwgayk7CiAgICAgICAgICAgICAgICAgICAgaCA9IGZbZ10gPSBtOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiBoKGMsIGQpOwogICAgICAgICAgICAgICAgfSBjYXRjaCAobCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBsLm1lc3NhZ2UgPSAiVW5hYmxlIHRvIHBhcnNlIGJpbmRpbmdzLlxuQmluZGluZ3MgdmFsdWU6ICIgKyBiICsgIlxuTWVzc2FnZTogIiArIGwubWVzc2FnZSwgbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBhMy5nYS5pbnN0YW5jZSA9IG5ldyBhMy5nYSgpOwogICAgICAgICAgfSkoKTsKICAgICAgICAgIGEzLmIoImJpbmRpbmdQcm92aWRlciIsIGEzLmdhKTsKICAgICAgICAgIChmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihiMikgewogICAgICAgICAgICAgIHZhciBjMiA9IChiMiA9IGEzLmEuZy5nZXQoYjIsIHopKSAmJiBiMi5OOwogICAgICAgICAgICAgIGMyICYmIChiMi5OID0gbnVsbCwgYzIuVGMoKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYyhjMiwgZDIsIGUyKSB7CiAgICAgICAgICAgICAgdGhpcy5ub2RlID0gYzI7CiAgICAgICAgICAgICAgdGhpcy55YyA9IGQyOwogICAgICAgICAgICAgIHRoaXMua2IgPSBbXTsKICAgICAgICAgICAgICB0aGlzLkggPSBmYWxzZTsKICAgICAgICAgICAgICBkMi5OIHx8IGEzLmEuSy56YShjMiwgYik7CiAgICAgICAgICAgICAgZTIgJiYgZTIuTiAmJiAoZTIuTi5rYi5wdXNoKGMyKSwgdGhpcy5LYiA9IGUyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBkKGE0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGE0OwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZShhNCkgewogICAgICAgICAgICAgIHJldHVybiBhNCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGYoYjIpIHsKICAgICAgICAgICAgICByZXR1cm4gYTMuYS5HYShhMy51LkcoYjIpLCBmdW5jdGlvbihhNCwgYzIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGIyKClbYzJdOwogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBnKGIyLCBjMiwgZTIpIHsKICAgICAgICAgICAgICByZXR1cm4gImZ1bmN0aW9uIiA9PT0gdHlwZW9mIGIyID8gZihiMi5iaW5kKG51bGwsIGMyLCBlMikpIDogYTMuYS5HYShiMiwgZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gaChhNCwgYjIpIHsKICAgICAgICAgICAgICByZXR1cm4gZih0aGlzLmdldEJpbmRpbmdzLmJpbmQodGhpcywgYTQsIGIyKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gbShiMiwgYzIpIHsKICAgICAgICAgICAgICB2YXIgZDIgPSBhMy5oLmZpcnN0Q2hpbGQoYzIpOwogICAgICAgICAgICAgIGlmIChkMikgewogICAgICAgICAgICAgICAgdmFyIGUyLCBmMiA9IGEzLmdhLmluc3RhbmNlLCBsMiA9IGYyLnByZXByb2Nlc3NOb2RlOwogICAgICAgICAgICAgICAgaWYgKGwyKSB7CiAgICAgICAgICAgICAgICAgIGZvciAoOyBlMiA9IGQyOyApCiAgICAgICAgICAgICAgICAgICAgZDIgPSBhMy5oLm5leHRTaWJsaW5nKGUyKSwgbDIuY2FsbChmMiwgZTIpOwogICAgICAgICAgICAgICAgICBkMiA9IGEzLmguZmlyc3RDaGlsZChjMik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmb3IgKDsgZTIgPSBkMjsgKQogICAgICAgICAgICAgICAgICBkMiA9IGEzLmgubmV4dFNpYmxpbmcoZTIpLCBrKGIyLCBlMik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGEzLmkubWEoYzIsIGEzLmkuSCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gayhiMiwgYzIpIHsKICAgICAgICAgICAgICB2YXIgZDIgPSBiMiwgZTIgPSAxID09PSBjMi5ub2RlVHlwZTsKICAgICAgICAgICAgICBlMiAmJiBhMy5oLlNjKGMyKTsKICAgICAgICAgICAgICBpZiAoZTIgfHwgYTMuZ2EuaW5zdGFuY2Uubm9kZUhhc0JpbmRpbmdzKGMyKSkKICAgICAgICAgICAgICAgIGQyID0gcChjMiwgbnVsbCwgYjIpLmJpbmRpbmdDb250ZXh0Rm9yRGVzY2VuZGFudHM7CiAgICAgICAgICAgICAgZDIgJiYgIXUyW2EzLmEuUihjMildICYmIG0oZDIsIGMyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBsKGIyKSB7CiAgICAgICAgICAgICAgdmFyIGMyID0gW10sIGQyID0ge30sIGUyID0gW107CiAgICAgICAgICAgICAgYTMuYS5QKGIyLCBmdW5jdGlvbiBjYShmMikgewogICAgICAgICAgICAgICAgaWYgKCFkMltmMl0pIHsKICAgICAgICAgICAgICAgICAgdmFyIGsyID0gYTMuZ2V0QmluZGluZ0hhbmRsZXIoZjIpOwogICAgICAgICAgICAgICAgICBrMiAmJiAoazIuYWZ0ZXIgJiYgKGUyLnB1c2goZjIpLCBhMy5hLkQoazIuYWZ0ZXIsIGZ1bmN0aW9uKGMzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGIyW2MzXSkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBhMy5hLkEoZTIsIGMzKSkKICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkNhbm5vdCBjb21iaW5lIHRoZSBmb2xsb3dpbmcgYmluZGluZ3MsIGJlY2F1c2UgdGhleSBoYXZlIGEgY3ljbGljIGRlcGVuZGVuY3k6ICIgKyBlMi5qb2luKCIsICIpKTsKICAgICAgICAgICAgICAgICAgICAgIGNhKGMzKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0pLCBlMi5sZW5ndGgtLSksIGMyLnB1c2goeyBrZXk6IGYyLCBNYzogazIgfSkpOwogICAgICAgICAgICAgICAgICBkMltmMl0gPSB0cnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIHJldHVybiBjMjsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBwKGIyLCBjMiwgZDIpIHsKICAgICAgICAgICAgICB2YXIgZjIgPSBhMy5hLmcuVWIoYjIsIHosIHt9KSwgazIgPSBmMi5oZDsKICAgICAgICAgICAgICBpZiAoIWMyKSB7CiAgICAgICAgICAgICAgICBpZiAoazIpCiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJZb3UgY2Fubm90IGFwcGx5IGJpbmRpbmdzIG11bHRpcGxlIHRpbWVzIHRvIHRoZSBzYW1lIGVsZW1lbnQuIik7CiAgICAgICAgICAgICAgICBmMi5oZCA9IHRydWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGsyIHx8IChmMi5jb250ZXh0ID0gZDIpOwogICAgICAgICAgICAgIGYyLlpiIHx8IChmMi5aYiA9IHt9KTsKICAgICAgICAgICAgICB2YXIgZzI7CiAgICAgICAgICAgICAgaWYgKGMyICYmICJmdW5jdGlvbiIgIT09IHR5cGVvZiBjMikKICAgICAgICAgICAgICAgIGcyID0gYzI7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB2YXIgcDIgPSBhMy5nYS5pbnN0YW5jZSwgcTIgPSBwMi5nZXRCaW5kaW5nQWNjZXNzb3JzIHx8IGgsIG0yID0gYTMuJChmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgaWYgKGcyID0gYzIgPyBjMihkMiwgYjIpIDogcTIuY2FsbChwMiwgYjIsIGQyKSkgewogICAgICAgICAgICAgICAgICAgIGlmIChkMlt0XSkKICAgICAgICAgICAgICAgICAgICAgIGQyW3RdKCk7CiAgICAgICAgICAgICAgICAgICAgaWYgKGQyW0JdKQogICAgICAgICAgICAgICAgICAgICAgZDJbQl0oKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByZXR1cm4gZzI7CiAgICAgICAgICAgICAgICB9LCBudWxsLCB7IGw6IGIyIH0pOwogICAgICAgICAgICAgICAgZzIgJiYgbTIuamEoKSB8fCAobTIgPSBudWxsKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHgyID0gZDIsIHUzOwogICAgICAgICAgICAgIGlmIChnMikgewogICAgICAgICAgICAgICAgdmFyIEoyID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBhMy5hLkdhKG0yID8gbTIoKSA6IGcyLCBlKTsKICAgICAgICAgICAgICAgIH0sIHIyID0gbTIgPyBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUobTIoKVthNF0pOwogICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBnMlthNF07CiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgSjIuZ2V0ID0gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGcyW2E0XSAmJiBlKHIyKGE0KSk7CiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgSjIuaGFzID0gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGE0IGluIGcyOwogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIGEzLmkuSCBpbiBnMiAmJiBhMy5pLnN1YnNjcmliZShiMiwgYTMuaS5ILCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgdmFyIGMzID0gKDAsIGcyW2EzLmkuSF0pKCk7CiAgICAgICAgICAgICAgICAgIGlmIChjMykgewogICAgICAgICAgICAgICAgICAgIHZhciBkMyA9IGEzLmguY2hpbGROb2RlcyhiMik7CiAgICAgICAgICAgICAgICAgICAgZDMubGVuZ3RoICYmIGMzKGQzLCBhMy5FYyhkM1swXSkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIGEzLmkucGEgaW4gZzIgJiYgKHgyID0gYTMuaS5DYihiMiwgZDIpLCBhMy5pLnN1YnNjcmliZShiMiwgYTMuaS5wYSwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIHZhciBjMyA9ICgwLCBnMlthMy5pLnBhXSkoKTsKICAgICAgICAgICAgICAgICAgYzMgJiYgYTMuaC5maXJzdENoaWxkKGIyKSAmJiBjMyhiMik7CiAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgICBmMiA9IGwoZzIpOwogICAgICAgICAgICAgICAgYTMuYS5EKGYyLCBmdW5jdGlvbihjMykgewogICAgICAgICAgICAgICAgICB2YXIgZDMgPSBjMy5NYy5pbml0LCBlMiA9IGMzLk1jLnVwZGF0ZSwgZjMgPSBjMy5rZXk7CiAgICAgICAgICAgICAgICAgIGlmICg4ID09PSBiMi5ub2RlVHlwZSAmJiAhYTMuaC5lYVtmM10pCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIlRoZSBiaW5kaW5nICciICsgZjMgKyAiJyBjYW5ub3QgYmUgdXNlZCB3aXRoIHZpcnR1YWwgZWxlbWVudHMiKTsKICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBkMyAmJiBhMy51LkcoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgYTQgPSBkMyhiMiwgcjIoZjMpLCBKMiwgeDIuJGRhdGEsIHgyKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChhNCAmJiBhNC5jb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncykgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAodTMgIT09IG4pCiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIk11bHRpcGxlIGJpbmRpbmdzICgiICsgdTMgKyAiIGFuZCAiICsgZjMgKyAiKSBhcmUgdHJ5aW5nIHRvIGNvbnRyb2wgZGVzY2VuZGFudCBiaW5kaW5ncyBvZiB0aGUgc2FtZSBlbGVtZW50LiBZb3UgY2Fubm90IHVzZSB0aGVzZSBiaW5kaW5ncyB0b2dldGhlciBvbiB0aGUgc2FtZSBlbGVtZW50LiIpOwogICAgICAgICAgICAgICAgICAgICAgICB1MyA9IGYzOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pLCAiZnVuY3Rpb24iID09IHR5cGVvZiBlMiAmJiBhMy4kKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgICAgZTIoYjIsIHIyKGYzKSwgSjIsIHgyLiRkYXRhLCB4Mik7CiAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgeyBsOiBiMiB9KTsKICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoazMpIHsKICAgICAgICAgICAgICAgICAgICB0aHJvdyBrMy5tZXNzYWdlID0gJ1VuYWJsZSB0byBwcm9jZXNzIGJpbmRpbmcgIicgKyBmMyArICI6ICIgKyBnMltmM10gKyAnIlxuTWVzc2FnZTogJyArIGszLm1lc3NhZ2UsIGszOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZjIgPSB1MyA9PT0gbjsKICAgICAgICAgICAgICByZXR1cm4geyBzaG91bGRCaW5kRGVzY2VuZGFudHM6IGYyLCBiaW5kaW5nQ29udGV4dEZvckRlc2NlbmRhbnRzOiBmMiAmJiB4MiB9OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHEoYjIsIGMyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGIyICYmIGIyIGluc3RhbmNlb2YgYTMuZmEgPyBiMiA6IG5ldyBhMy5mYShiMiwgbiwgbiwgYzIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciB0ID0gYTMuYS5EYSgiX3N1YnNjcmliYWJsZSIpLCB4ID0gYTMuYS5EYSgiX2FuY2VzdG9yQmluZGluZ0luZm8iKSwgQiA9IGEzLmEuRGEoIl9kYXRhRGVwZW5kZW5jeSIpOwogICAgICAgICAgICBhMy5jID0ge307CiAgICAgICAgICAgIHZhciB1MiA9IHsgc2NyaXB0OiB0cnVlLCB0ZXh0YXJlYTogdHJ1ZSwgdGVtcGxhdGU6IHRydWUgfTsKICAgICAgICAgICAgYTMuZ2V0QmluZGluZ0hhbmRsZXIgPSBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIHJldHVybiBhMy5jW2IyXTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgdmFyIEogPSB7fTsKICAgICAgICAgICAgYTMuZmEgPSBmdW5jdGlvbihiMiwgYzIsIGQyLCBlMiwgZjIpIHsKICAgICAgICAgICAgICBmdW5jdGlvbiBrMigpIHsKICAgICAgICAgICAgICAgIHZhciBiMyA9IHAyID8gaDIoKSA6IGgyLCBmMyA9IGEzLmEuZihiMyk7CiAgICAgICAgICAgICAgICBjMiA/IChhMy5hLmV4dGVuZChsMiwgYzIpLCB4IGluIGMyICYmIChsMlt4XSA9IGMyW3hdKSkgOiAobDIuJHBhcmVudHMgPSBbXSwgbDIuJHJvb3QgPSBmMywgbDIua28gPSBhMyk7CiAgICAgICAgICAgICAgICBsMlt0XSA9IHEyOwogICAgICAgICAgICAgICAgZzIgPyBmMyA9IGwyLiRkYXRhIDogKGwyLiRyYXdEYXRhID0gYjMsIGwyLiRkYXRhID0gZjMpOwogICAgICAgICAgICAgICAgZDIgJiYgKGwyW2QyXSA9IGYzKTsKICAgICAgICAgICAgICAgIGUyICYmIGUyKGwyLCBjMiwgZjMpOwogICAgICAgICAgICAgICAgaWYgKGMyICYmIGMyW3RdICYmICFhMy5TLm8oKS5WYihjMlt0XSkpCiAgICAgICAgICAgICAgICAgIGMyW3RdKCk7CiAgICAgICAgICAgICAgICBtMiAmJiAobDJbQl0gPSBtMik7CiAgICAgICAgICAgICAgICByZXR1cm4gbDIuJGRhdGE7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBsMiA9IHRoaXMsIGcyID0gYjIgPT09IEosIGgyID0gZzIgPyBuIDogYjIsIHAyID0gImZ1bmN0aW9uIiA9PSB0eXBlb2YgaDIgJiYgIWEzLk8oaDIpLCBxMiwgbTIgPSBmMiAmJiBmMi5kYXRhRGVwZW5kZW5jeTsKICAgICAgICAgICAgICBmMiAmJiBmMi5leHBvcnREZXBlbmRlbmNpZXMgPyBrMigpIDogKHEyID0gYTMueGIoazIpLCBxMi52KCksIHEyLmphKCkgPyBxMi5lcXVhbGl0eUNvbXBhcmVyID0gbnVsbCA6IGwyW3RdID0gbik7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLmZhLnByb3RvdHlwZS5jcmVhdGVDaGlsZENvbnRleHQgPSBmdW5jdGlvbihiMiwgYzIsIGQyLCBlMikgewogICAgICAgICAgICAgICFlMiAmJiBjMiAmJiAib2JqZWN0IiA9PSB0eXBlb2YgYzIgJiYgKGUyID0gYzIsIGMyID0gZTIuYXMsIGQyID0gZTIuZXh0ZW5kKTsKICAgICAgICAgICAgICBpZiAoYzIgJiYgZTIgJiYgZTIubm9DaGlsZENvbnRleHQpIHsKICAgICAgICAgICAgICAgIHZhciBmMiA9ICJmdW5jdGlvbiIgPT0gdHlwZW9mIGIyICYmICFhMy5PKGIyKTsKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYTMuZmEoSiwgdGhpcywgbnVsbCwgZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgICAgZDIgJiYgZDIoYTQpOwogICAgICAgICAgICAgICAgICBhNFtjMl0gPSBmMiA/IGIyKCkgOiBiMjsKICAgICAgICAgICAgICAgIH0sIGUyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhMy5mYSgKICAgICAgICAgICAgICAgIGIyLAogICAgICAgICAgICAgICAgdGhpcywKICAgICAgICAgICAgICAgIGMyLAogICAgICAgICAgICAgICAgZnVuY3Rpb24oYTQsIGIzKSB7CiAgICAgICAgICAgICAgICAgIGE0LiRwYXJlbnRDb250ZXh0ID0gYjM7CiAgICAgICAgICAgICAgICAgIGE0LiRwYXJlbnQgPSBiMy4kZGF0YTsKICAgICAgICAgICAgICAgICAgYTQuJHBhcmVudHMgPSAoYjMuJHBhcmVudHMgfHwgW10pLnNsaWNlKDApOwogICAgICAgICAgICAgICAgICBhNC4kcGFyZW50cy51bnNoaWZ0KGE0LiRwYXJlbnQpOwogICAgICAgICAgICAgICAgICBkMiAmJiBkMihhNCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZTIKICAgICAgICAgICAgICApOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5mYS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhMy5mYShKLCB0aGlzLCBudWxsLCBmdW5jdGlvbihjMykgewogICAgICAgICAgICAgICAgYTMuYS5leHRlbmQoYzMsICJmdW5jdGlvbiIgPT0gdHlwZW9mIGIyID8gYjIoYzMpIDogYjIpOwogICAgICAgICAgICAgIH0sIGMyKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgdmFyIHogPSBhMy5hLmcuWigpOwogICAgICAgICAgICBjLnByb3RvdHlwZS5UYyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHRoaXMuS2IgJiYgdGhpcy5LYi5OICYmIHRoaXMuS2IuTi5zZCh0aGlzLm5vZGUpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBjLnByb3RvdHlwZS5zZCA9IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgYTMuYS5QYSh0aGlzLmtiLCBiMik7CiAgICAgICAgICAgICAgIXRoaXMua2IubGVuZ3RoICYmIHRoaXMuSCAmJiB0aGlzLkNjKCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGMucHJvdG90eXBlLkNjID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdGhpcy5IID0gdHJ1ZTsKICAgICAgICAgICAgICB0aGlzLnljLk4gJiYgIXRoaXMua2IubGVuZ3RoICYmICh0aGlzLnljLk4gPSBudWxsLCBhMy5hLksueWIodGhpcy5ub2RlLCBiKSwgYTMuaS5tYSh0aGlzLm5vZGUsIGEzLmkucGEpLCB0aGlzLlRjKCkpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5pID0geyBIOiAiY2hpbGRyZW5Db21wbGV0ZSIsIHBhOiAiZGVzY2VuZGFudHNDb21wbGV0ZSIsIHN1YnNjcmliZTogZnVuY3Rpb24oYjIsIGMyLCBkMiwgZTIsIGYyKSB7CiAgICAgICAgICAgICAgdmFyIGsyID0gYTMuYS5nLlViKGIyLCB6LCB7fSk7CiAgICAgICAgICAgICAgazIuRmEgfHwgKGsyLkZhID0gbmV3IGEzLlQoKSk7CiAgICAgICAgICAgICAgZjIgJiYgZjIubm90aWZ5SW1tZWRpYXRlbHkgJiYgazIuWmJbYzJdICYmIGEzLnUuRyhkMiwgZTIsIFtiMl0pOwogICAgICAgICAgICAgIHJldHVybiBrMi5GYS5zdWJzY3JpYmUoZDIsIGUyLCBjMik7CiAgICAgICAgICAgIH0sIG1hOiBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICB2YXIgZDIgPSBhMy5hLmcuZ2V0KGIyLCB6KTsKICAgICAgICAgICAgICBpZiAoZDIgJiYgKGQyLlpiW2MyXSA9IHRydWUsIGQyLkZhICYmIGQyLkZhLm5vdGlmeVN1YnNjcmliZXJzKGIyLCBjMiksIGMyID09IGEzLmkuSCkpIHsKICAgICAgICAgICAgICAgIGlmIChkMi5OKQogICAgICAgICAgICAgICAgICBkMi5OLkNjKCk7CiAgICAgICAgICAgICAgICBlbHNlIGlmIChkMi5OID09PSBuICYmIGQyLkZhICYmIGQyLkZhLldhKGEzLmkucGEpKQogICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiZGVzY2VuZGFudHNDb21wbGV0ZSBldmVudCBub3Qgc3VwcG9ydGVkIGZvciBiaW5kaW5ncyBvbiB0aGlzIG5vZGUiKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIENiOiBmdW5jdGlvbihiMiwgZDIpIHsKICAgICAgICAgICAgICB2YXIgZTIgPSBhMy5hLmcuVWIoYjIsIHosIHt9KTsKICAgICAgICAgICAgICBlMi5OIHx8IChlMi5OID0gbmV3IGMoYjIsIGUyLCBkMlt4XSkpOwogICAgICAgICAgICAgIHJldHVybiBkMlt4XSA9PSBlMiA/IGQyIDogZDIuZXh0ZW5kKGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICBhNFt4XSA9IGUyOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9IH07CiAgICAgICAgICAgIGEzLlRkID0gZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICByZXR1cm4gKGIyID0gYTMuYS5nLmdldChiMiwgeikpICYmIGIyLmNvbnRleHQ7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLmliID0gZnVuY3Rpb24oYjIsIGMyLCBkMikgewogICAgICAgICAgICAgIDEgPT09IGIyLm5vZGVUeXBlICYmIGEzLmguU2MoYjIpOwogICAgICAgICAgICAgIHJldHVybiBwKGIyLCBjMiwgcShkMikpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5sZCA9IGZ1bmN0aW9uKGIyLCBjMiwgZDIpIHsKICAgICAgICAgICAgICBkMiA9IHEoZDIpOwogICAgICAgICAgICAgIHJldHVybiBhMy5pYihiMiwgZyhjMiwgZDIsIGIyKSwgZDIpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5PYSA9IGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgIDEgIT09IGIyLm5vZGVUeXBlICYmIDggIT09IGIyLm5vZGVUeXBlIHx8IG0ocShhNCksIGIyKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgYTMudmMgPSBmdW5jdGlvbihhNCwgYjIsIGMyKSB7CiAgICAgICAgICAgICAgIXYyICYmIEEualF1ZXJ5ICYmICh2MiA9IEEualF1ZXJ5KTsKICAgICAgICAgICAgICBpZiAoMiA+IGFyZ3VtZW50cy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIGlmIChiMiA9IHcuYm9keSwgIWIyKQogICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigia28uYXBwbHlCaW5kaW5nczogY291bGQgbm90IGZpbmQgZG9jdW1lbnQuYm9keTsgaGFzIHRoZSBkb2N1bWVudCBiZWVuIGxvYWRlZD8iKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiMiB8fCAxICE9PSBiMi5ub2RlVHlwZSAmJiA4ICE9PSBiMi5ub2RlVHlwZSkKICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJrby5hcHBseUJpbmRpbmdzOiBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIHlvdXIgdmlldyBtb2RlbDsgc2Vjb25kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBET00gbm9kZSIpOwogICAgICAgICAgICAgIGsocShhNCwgYzIpLCBiMik7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLkRjID0gZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICByZXR1cm4gIWIyIHx8IDEgIT09IGIyLm5vZGVUeXBlICYmIDggIT09IGIyLm5vZGVUeXBlID8gbiA6IGEzLlRkKGIyKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgYTMuRWMgPSBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIHJldHVybiAoYjIgPSBhMy5EYyhiMikpID8gYjIuJGRhdGEgOiBuOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5iKCJiaW5kaW5nSGFuZGxlcnMiLCBhMy5jKTsKICAgICAgICAgICAgYTMuYigiYmluZGluZ0V2ZW50IiwgYTMuaSk7CiAgICAgICAgICAgIGEzLmIoImJpbmRpbmdFdmVudC5zdWJzY3JpYmUiLCBhMy5pLnN1YnNjcmliZSk7CiAgICAgICAgICAgIGEzLmIoImJpbmRpbmdFdmVudC5zdGFydFBvc3NpYmx5QXN5bmNDb250ZW50QmluZGluZyIsIGEzLmkuQ2IpOwogICAgICAgICAgICBhMy5iKCJhcHBseUJpbmRpbmdzIiwgYTMudmMpOwogICAgICAgICAgICBhMy5iKCJhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyIsIGEzLk9hKTsKICAgICAgICAgICAgYTMuYigiYXBwbHlCaW5kaW5nQWNjZXNzb3JzVG9Ob2RlIiwgYTMuaWIpOwogICAgICAgICAgICBhMy5iKCJhcHBseUJpbmRpbmdzVG9Ob2RlIiwgYTMubGQpOwogICAgICAgICAgICBhMy5iKCJjb250ZXh0Rm9yIiwgYTMuRGMpOwogICAgICAgICAgICBhMy5iKCJkYXRhRm9yIiwgYTMuRWMpOwogICAgICAgICAgfSkoKTsKICAgICAgICAgIChmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGMoYzIsIGUyKSB7CiAgICAgICAgICAgICAgdmFyIGsgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgYzIpID8gZltjMl0gOiBiLCBsOwogICAgICAgICAgICAgIGsgPyBrLnN1YnNjcmliZShlMikgOiAoayA9IGZbYzJdID0gbmV3IGEzLlQoKSwgay5zdWJzY3JpYmUoZTIpLCBkKGMyLCBmdW5jdGlvbihiMiwgZDIpIHsKICAgICAgICAgICAgICAgIHZhciBlMyA9ICEoIWQyIHx8ICFkMi5zeW5jaHJvbm91cyk7CiAgICAgICAgICAgICAgICBnW2MyXSA9IHsgZGVmaW5pdGlvbjogYjIsIEdkOiBlMyB9OwogICAgICAgICAgICAgICAgZGVsZXRlIGZbYzJdOwogICAgICAgICAgICAgICAgbCB8fCBlMyA/IGsubm90aWZ5U3Vic2NyaWJlcnMoYjIpIDogYTMubmEuemIoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIGsubm90aWZ5U3Vic2NyaWJlcnMoYjIpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfSksIGwgPSB0cnVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBkKGE0LCBiMikgewogICAgICAgICAgICAgIGUoImdldENvbmZpZyIsIFthNF0sIGZ1bmN0aW9uKGMyKSB7CiAgICAgICAgICAgICAgICBjMiA/IGUoImxvYWRDb21wb25lbnQiLCBbYTQsIGMyXSwgZnVuY3Rpb24oYTUpIHsKICAgICAgICAgICAgICAgICAgYjIoCiAgICAgICAgICAgICAgICAgICAgYTUsCiAgICAgICAgICAgICAgICAgICAgYzIKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0pIDogYjIobnVsbCwgbnVsbCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZShjMiwgZDIsIGYyLCBsKSB7CiAgICAgICAgICAgICAgbCB8fCAobCA9IGEzLmoubG9hZGVycy5zbGljZSgwKSk7CiAgICAgICAgICAgICAgdmFyIGcyID0gbC5zaGlmdCgpOwogICAgICAgICAgICAgIGlmIChnMikgewogICAgICAgICAgICAgICAgdmFyIHEgPSBnMltjMl07CiAgICAgICAgICAgICAgICBpZiAocSkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICBpZiAocS5hcHBseShnMiwgZDIuY29uY2F0KGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICAgICAgdCA/IGYyKG51bGwpIDogbnVsbCAhPT0gYTQgPyBmMihhNCkgOiBlKGMyLCBkMiwgZjIsIGwpOwogICAgICAgICAgICAgICAgICB9KSkgIT09IGIgJiYgKHQgPSB0cnVlLCAhZzIuc3VwcHJlc3NMb2FkZXJFeGNlcHRpb25zKSkKICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiQ29tcG9uZW50IGxvYWRlcnMgbXVzdCBzdXBwbHkgdmFsdWVzIGJ5IGludm9raW5nIHRoZSBjYWxsYmFjaywgbm90IGJ5IHJldHVybmluZyB2YWx1ZXMgc3luY2hyb25vdXNseS4iKTsKICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICBlKGMyLCBkMiwgZjIsIGwpOwogICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgZjIobnVsbCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGYgPSB7fSwgZyA9IHt9OwogICAgICAgICAgICBhMy5qID0geyBnZXQ6IGZ1bmN0aW9uKGQyLCBlMikgewogICAgICAgICAgICAgIHZhciBmMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnLCBkMikgPyBnW2QyXSA6IGI7CiAgICAgICAgICAgICAgZjIgPyBmMi5HZCA/IGEzLnUuRyhmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGUyKGYyLmRlZmluaXRpb24pOwogICAgICAgICAgICAgIH0pIDogYTMubmEuemIoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBlMihmMi5kZWZpbml0aW9uKTsKICAgICAgICAgICAgICB9KSA6IGMoZDIsIGUyKTsKICAgICAgICAgICAgfSwgQmM6IGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgZGVsZXRlIGdbYTRdOwogICAgICAgICAgICB9LCBvYzogZSB9OwogICAgICAgICAgICBhMy5qLmxvYWRlcnMgPSBbXTsKICAgICAgICAgICAgYTMuYigiY29tcG9uZW50cyIsIGEzLmopOwogICAgICAgICAgICBhMy5iKCJjb21wb25lbnRzLmdldCIsIGEzLmouZ2V0KTsKICAgICAgICAgICAgYTMuYigiY29tcG9uZW50cy5jbGVhckNhY2hlZERlZmluaXRpb24iLCBhMy5qLkJjKTsKICAgICAgICAgIH0pKCk7CiAgICAgICAgICAoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYjIsIGMyLCBkMiwgZTIpIHsKICAgICAgICAgICAgICBmdW5jdGlvbiBnMigpIHsKICAgICAgICAgICAgICAgIDAgPT09IC0tQiAmJiBlMihoMik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBoMiA9IHt9LCBCID0gMiwgdTIgPSBkMi50ZW1wbGF0ZTsKICAgICAgICAgICAgICBkMiA9IGQyLnZpZXdNb2RlbDsKICAgICAgICAgICAgICB1MiA/IGYoYzIsIHUyLCBmdW5jdGlvbihjMykgewogICAgICAgICAgICAgICAgYTMuai5vYygibG9hZFRlbXBsYXRlIiwgW2IyLCBjM10sIGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICAgIGgyLnRlbXBsYXRlID0gYTQ7CiAgICAgICAgICAgICAgICAgIGcyKCk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9KSA6IGcyKCk7CiAgICAgICAgICAgICAgZDIgPyBmKGMyLCBkMiwgZnVuY3Rpb24oYzMpIHsKICAgICAgICAgICAgICAgIGEzLmoub2MoImxvYWRWaWV3TW9kZWwiLCBbYjIsIGMzXSwgZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgICAgaDJbbV0gPSBhNDsKICAgICAgICAgICAgICAgICAgZzIoKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0pIDogZzIoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBjKGE0LCBiMiwgZDIpIHsKICAgICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiA9PT0gdHlwZW9mIGIyKQogICAgICAgICAgICAgICAgZDIoZnVuY3Rpb24oYTUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBiMihhNSk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBlbHNlIGlmICgiZnVuY3Rpb24iID09PSB0eXBlb2YgYjJbbV0pCiAgICAgICAgICAgICAgICBkMihiMlttXSk7CiAgICAgICAgICAgICAgZWxzZSBpZiAoImluc3RhbmNlIiBpbiBiMikgewogICAgICAgICAgICAgICAgdmFyIGUyID0gYjIuaW5zdGFuY2U7CiAgICAgICAgICAgICAgICBkMihmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAidmlld01vZGVsIiBpbiBiMiA/IGMoYTQsIGIyLnZpZXdNb2RlbCwgZDIpIDogYTQoIlVua25vd24gdmlld01vZGVsIHZhbHVlOiAiICsgYjIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGQoYjIpIHsKICAgICAgICAgICAgICBzd2l0Y2ggKGEzLmEuUihiMikpIHsKICAgICAgICAgICAgICAgIGNhc2UgInNjcmlwdCI6CiAgICAgICAgICAgICAgICAgIHJldHVybiBhMy5hLnVhKGIyLnRleHQpOwogICAgICAgICAgICAgICAgY2FzZSAidGV4dGFyZWEiOgogICAgICAgICAgICAgICAgICByZXR1cm4gYTMuYS51YShiMi52YWx1ZSk7CiAgICAgICAgICAgICAgICBjYXNlICJ0ZW1wbGF0ZSI6CiAgICAgICAgICAgICAgICAgIGlmIChlKGIyLmNvbnRlbnQpKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBhMy5hLkNhKGIyLmNvbnRlbnQuY2hpbGROb2Rlcyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBhMy5hLkNhKGIyLmNoaWxkTm9kZXMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGUoYTQpIHsKICAgICAgICAgICAgICByZXR1cm4gQS5Eb2N1bWVudEZyYWdtZW50ID8gYTQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IDogYTQgJiYgMTEgPT09IGE0Lm5vZGVUeXBlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGYoYTQsIGIyLCBjMikgewogICAgICAgICAgICAgICJzdHJpbmciID09PSB0eXBlb2YgYjIucmVxdWlyZSA/IFQgfHwgQS5yZXF1aXJlID8gKFQgfHwgQS5yZXF1aXJlKShbYjIucmVxdWlyZV0sIGZ1bmN0aW9uKGE1KSB7CiAgICAgICAgICAgICAgICBhNSAmJiAib2JqZWN0IiA9PT0gdHlwZW9mIGE1ICYmIGE1LlhkICYmIGE1WyJkZWZhdWx0Il0gJiYgKGE1ID0gYTVbImRlZmF1bHQiXSk7CiAgICAgICAgICAgICAgICBjMihhNSk7CiAgICAgICAgICAgICAgfSkgOiBhNCgiVXNlcyByZXF1aXJlLCBidXQgbm8gQU1EIGxvYWRlciBpcyBwcmVzZW50IikgOiBjMihiMik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZyhhNCkgewogICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkNvbXBvbmVudCAnIiArIGE0ICsgIic6ICIgKyBiMik7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgaCA9IHt9OwogICAgICAgICAgICBhMy5qLnJlZ2lzdGVyID0gZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgaWYgKCFjMikKICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gZm9yICIgKyBiMik7CiAgICAgICAgICAgICAgaWYgKGEzLmoudGIoYjIpKQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkNvbXBvbmVudCAiICsgYjIgKyAiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCIpOwogICAgICAgICAgICAgIGhbYjJdID0gYzI7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLmoudGIgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaCwgYTQpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5qLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIGRlbGV0ZSBoW2IyXTsKICAgICAgICAgICAgICBhMy5qLkJjKGIyKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgYTMuai5GYyA9IHsgZ2V0Q29uZmlnOiBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICBjMihhMy5qLnRiKGIyKSA/IGhbYjJdIDogbnVsbCk7CiAgICAgICAgICAgIH0sIGxvYWRDb21wb25lbnQ6IGZ1bmN0aW9uKGE0LCBjMiwgZDIpIHsKICAgICAgICAgICAgICB2YXIgZTIgPSBnKGE0KTsKICAgICAgICAgICAgICBmKGUyLCBjMiwgZnVuY3Rpb24oYzMpIHsKICAgICAgICAgICAgICAgIGIoYTQsIGUyLCBjMywgZDIpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9LCBsb2FkVGVtcGxhdGU6IGZ1bmN0aW9uKGIyLCBjMiwgZjIpIHsKICAgICAgICAgICAgICBiMiA9IGcoYjIpOwogICAgICAgICAgICAgIGlmICgic3RyaW5nIiA9PT0gdHlwZW9mIGMyKQogICAgICAgICAgICAgICAgZjIoYTMuYS51YShjMikpOwogICAgICAgICAgICAgIGVsc2UgaWYgKGMyIGluc3RhbmNlb2YgQXJyYXkpCiAgICAgICAgICAgICAgICBmMihjMik7CiAgICAgICAgICAgICAgZWxzZSBpZiAoZShjMikpCiAgICAgICAgICAgICAgICBmMihhMy5hLmxhKGMyLmNoaWxkTm9kZXMpKTsKICAgICAgICAgICAgICBlbHNlIGlmIChjMi5lbGVtZW50KQogICAgICAgICAgICAgICAgaWYgKGMyID0gYzIuZWxlbWVudCwgQS5IVE1MRWxlbWVudCA/IGMyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiBjMiAmJiBjMi50YWdOYW1lICYmIDEgPT09IGMyLm5vZGVUeXBlKQogICAgICAgICAgICAgICAgICBmMihkKGMyKSk7CiAgICAgICAgICAgICAgICBlbHNlIGlmICgic3RyaW5nIiA9PT0gdHlwZW9mIGMyKSB7CiAgICAgICAgICAgICAgICAgIHZhciBoMiA9IHcuZ2V0RWxlbWVudEJ5SWQoYzIpOwogICAgICAgICAgICAgICAgICBoMiA/IGYyKGQoaDIpKSA6IGIyKCJDYW5ub3QgZmluZCBlbGVtZW50IHdpdGggSUQgIiArIGMyKTsKICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICBiMigiVW5rbm93biBlbGVtZW50IHR5cGU6ICIgKyBjMik7CiAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgYjIoIlVua25vd24gdGVtcGxhdGUgdmFsdWU6ICIgKyBjMik7CiAgICAgICAgICAgIH0sIGxvYWRWaWV3TW9kZWw6IGZ1bmN0aW9uKGE0LCBiMiwgZDIpIHsKICAgICAgICAgICAgICBjKGcoYTQpLCBiMiwgZDIpOwogICAgICAgICAgICB9IH07CiAgICAgICAgICAgIHZhciBtID0gImNyZWF0ZVZpZXdNb2RlbCI7CiAgICAgICAgICAgIGEzLmIoImNvbXBvbmVudHMucmVnaXN0ZXIiLCBhMy5qLnJlZ2lzdGVyKTsKICAgICAgICAgICAgYTMuYigiY29tcG9uZW50cy5pc1JlZ2lzdGVyZWQiLCBhMy5qLnRiKTsKICAgICAgICAgICAgYTMuYigiY29tcG9uZW50cy51bnJlZ2lzdGVyIiwgYTMuai51bnJlZ2lzdGVyKTsKICAgICAgICAgICAgYTMuYigiY29tcG9uZW50cy5kZWZhdWx0TG9hZGVyIiwgYTMuai5GYyk7CiAgICAgICAgICAgIGEzLmoubG9hZGVycy5wdXNoKGEzLmouRmMpOwogICAgICAgICAgICBhMy5qLmRkID0gaDsKICAgICAgICAgIH0pKCk7CiAgICAgICAgICAoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYjIsIGUpIHsKICAgICAgICAgICAgICB2YXIgZiA9IGIyLmdldEF0dHJpYnV0ZSgicGFyYW1zIik7CiAgICAgICAgICAgICAgaWYgKGYpIHsKICAgICAgICAgICAgICAgIHZhciBmID0gYy5wYXJzZUJpbmRpbmdzU3RyaW5nKGYsIGUsIGIyLCB7IHZhbHVlQWNjZXNzb3JzOiB0cnVlLCBiaW5kaW5nUGFyYW1zOiB0cnVlIH0pLCBmID0gYTMuYS5HYShmLCBmdW5jdGlvbihjMikgewogICAgICAgICAgICAgICAgICByZXR1cm4gYTMubyhjMiwgbnVsbCwgeyBsOiBiMiB9KTsKICAgICAgICAgICAgICAgIH0pLCBnID0gYTMuYS5HYSgKICAgICAgICAgICAgICAgICAgZiwKICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oYzIpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgZTIgPSBjMi52KCk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMyLmphKCkgPyBhMy5vKHsgcmVhZDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTMuYS5mKGMyKCkpOwogICAgICAgICAgICAgICAgICAgIH0sIHdyaXRlOiBhMy5aYShlMikgJiYgZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgICAgICAgIGMyKCkoYTQpOwogICAgICAgICAgICAgICAgICAgIH0sIGw6IGIyIH0pIDogZTI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZywgIiRyYXciKSB8fCAoZy4kcmF3ID0gZik7CiAgICAgICAgICAgICAgICByZXR1cm4gZzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHsgJHJhdzoge30gfTsKICAgICAgICAgICAgfQogICAgICAgICAgICBhMy5qLmdldENvbXBvbmVudE5hbWVGb3JOb2RlID0gZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICB2YXIgYzIgPSBhMy5hLlIoYjIpOwogICAgICAgICAgICAgIGlmIChhMy5qLnRiKGMyKSAmJiAoLTEgIT0gYzIuaW5kZXhPZigiLSIpIHx8ICJbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0iID09ICIiICsgYjIgfHwgOCA+PSBhMy5hLlcgJiYgYjIudGFnTmFtZSA9PT0gYzIpKQogICAgICAgICAgICAgICAgcmV0dXJuIGMyOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5qLnRjID0gZnVuY3Rpb24oYzIsIGUsIGYsIGcpIHsKICAgICAgICAgICAgICBpZiAoMSA9PT0gZS5ub2RlVHlwZSkgewogICAgICAgICAgICAgICAgdmFyIGggPSBhMy5qLmdldENvbXBvbmVudE5hbWVGb3JOb2RlKGUpOwogICAgICAgICAgICAgICAgaWYgKGgpIHsKICAgICAgICAgICAgICAgICAgYzIgPSBjMiB8fCB7fTsKICAgICAgICAgICAgICAgICAgaWYgKGMyLmNvbXBvbmVudCkKICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHVzZSB0aGUgImNvbXBvbmVudCIgYmluZGluZyBvbiBhIGN1c3RvbSBlbGVtZW50IG1hdGNoaW5nIGEgY29tcG9uZW50Jyk7CiAgICAgICAgICAgICAgICAgIHZhciBtID0geyBuYW1lOiBoLCBwYXJhbXM6IGIoZSwgZikgfTsKICAgICAgICAgICAgICAgICAgYzIuY29tcG9uZW50ID0gZyA/IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBtOwogICAgICAgICAgICAgICAgICB9IDogbTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGMyOwogICAgICAgICAgICB9OwogICAgICAgICAgICB2YXIgYyA9IG5ldyBhMy5nYSgpOwogICAgICAgICAgICA5ID4gYTMuYS5XICYmIChhMy5qLnJlZ2lzdGVyID0gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBhNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0oYTMuai5yZWdpc3RlciksIHcuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgdmFyIGMyID0gYjIoKSwgZiA9IGEzLmouZGQsIGc7CiAgICAgICAgICAgICAgICBmb3IgKGcgaW4gZikKICAgICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgICAgcmV0dXJuIGMyOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0ody5jcmVhdGVEb2N1bWVudEZyYWdtZW50KSk7CiAgICAgICAgICB9KSgpOwogICAgICAgICAgKGZ1bmN0aW9uKCkgewogICAgICAgICAgICBmdW5jdGlvbiBiKGIyLCBjMiwgZDIpIHsKICAgICAgICAgICAgICBjMiA9IGMyLnRlbXBsYXRlOwogICAgICAgICAgICAgIGlmICghYzIpCiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiQ29tcG9uZW50ICciICsgYjIgKyAiJyBoYXMgbm8gdGVtcGxhdGUiKTsKICAgICAgICAgICAgICBiMiA9IGEzLmEuQ2EoYzIpOwogICAgICAgICAgICAgIGEzLmgudmEoZDIsIGIyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBjKGE0LCBiMiwgYzIpIHsKICAgICAgICAgICAgICB2YXIgZDIgPSBhNC5jcmVhdGVWaWV3TW9kZWw7CiAgICAgICAgICAgICAgcmV0dXJuIGQyID8gZDIuY2FsbCgKICAgICAgICAgICAgICAgIGE0LAogICAgICAgICAgICAgICAgYjIsCiAgICAgICAgICAgICAgICBjMgogICAgICAgICAgICAgICkgOiBiMjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgZCA9IDA7CiAgICAgICAgICAgIGEzLmMuY29tcG9uZW50ID0geyBpbml0OiBmdW5jdGlvbihlLCBmLCBnLCBoLCBtKSB7CiAgICAgICAgICAgICAgZnVuY3Rpb24gaygpIHsKICAgICAgICAgICAgICAgIHZhciBhNCA9IGwgJiYgbC5kaXNwb3NlOwogICAgICAgICAgICAgICAgImZ1bmN0aW9uIiA9PT0gdHlwZW9mIGE0ICYmIGE0LmNhbGwobCk7CiAgICAgICAgICAgICAgICBxICYmIHEucygpOwogICAgICAgICAgICAgICAgcCA9IGwgPSBxID0gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIGwsIHAsIHEsIHQgPSBhMy5hLmxhKGEzLmguY2hpbGROb2RlcyhlKSk7CiAgICAgICAgICAgICAgYTMuaC5FYShlKTsKICAgICAgICAgICAgICBhMy5hLksuemEoZSwgayk7CiAgICAgICAgICAgICAgYTMubyhmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHZhciBnMiA9IGEzLmEuZihmKCkpLCBoMiwgdTI7CiAgICAgICAgICAgICAgICAic3RyaW5nIiA9PT0gdHlwZW9mIGcyID8gaDIgPSBnMiA6IChoMiA9IGEzLmEuZihnMi5uYW1lKSwgdTIgPSBhMy5hLmYoZzIucGFyYW1zKSk7CiAgICAgICAgICAgICAgICBpZiAoIWgyKQogICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiTm8gY29tcG9uZW50IG5hbWUgc3BlY2lmaWVkIik7CiAgICAgICAgICAgICAgICB2YXIgbjIgPSBhMy5pLkNiKGUsIG0pLCB6ID0gcCA9ICsrZDsKICAgICAgICAgICAgICAgIGEzLmouZ2V0KGgyLCBmdW5jdGlvbihkMikgewogICAgICAgICAgICAgICAgICBpZiAocCA9PT0geikgewogICAgICAgICAgICAgICAgICAgIGsoKTsKICAgICAgICAgICAgICAgICAgICBpZiAoIWQyKQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIlVua25vd24gY29tcG9uZW50ICciICsgaDIgKyAiJyIpOwogICAgICAgICAgICAgICAgICAgIGIoaDIsIGQyLCBlKTsKICAgICAgICAgICAgICAgICAgICB2YXIgZjIgPSBjKGQyLCB1MiwgeyBlbGVtZW50OiBlLCB0ZW1wbGF0ZU5vZGVzOiB0IH0pOwogICAgICAgICAgICAgICAgICAgIGQyID0gbjIuY3JlYXRlQ2hpbGRDb250ZXh0KGYyLCB7IGV4dGVuZDogZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgICAgICAgIGE0LiRjb21wb25lbnQgPSBmMjsKICAgICAgICAgICAgICAgICAgICAgIGE0LiRjb21wb25lbnRUZW1wbGF0ZU5vZGVzID0gdDsKICAgICAgICAgICAgICAgICAgICB9IH0pOwogICAgICAgICAgICAgICAgICAgIGYyICYmIGYyLmtvRGVzY2VuZGFudHNDb21wbGV0ZSAmJiAocSA9IGEzLmkuc3Vic2NyaWJlKGUsIGEzLmkucGEsIGYyLmtvRGVzY2VuZGFudHNDb21wbGV0ZSwgZjIpKTsKICAgICAgICAgICAgICAgICAgICBsID0gZjI7CiAgICAgICAgICAgICAgICAgICAgYTMuT2EoZDIsIGUpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9LCBudWxsLCB7IGw6IGUgfSk7CiAgICAgICAgICAgICAgcmV0dXJuIHsgY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWUgfTsKICAgICAgICAgICAgfSB9OwogICAgICAgICAgICBhMy5oLmVhLmNvbXBvbmVudCA9IHRydWU7CiAgICAgICAgICB9KSgpOwogICAgICAgICAgdmFyIFYgPSB7ICJjbGFzcyI6ICJjbGFzc05hbWUiLCAiZm9yIjogImh0bWxGb3IiIH07CiAgICAgICAgICBhMy5jLmF0dHIgPSB7IHVwZGF0ZTogZnVuY3Rpb24oYiwgYykgewogICAgICAgICAgICB2YXIgZCA9IGEzLmEuZihjKCkpIHx8IHt9OwogICAgICAgICAgICBhMy5hLlAoZCwgZnVuY3Rpb24oYzIsIGQyKSB7CiAgICAgICAgICAgICAgZDIgPSBhMy5hLmYoZDIpOwogICAgICAgICAgICAgIHZhciBnID0gYzIuaW5kZXhPZigiOiIpLCBnID0gImxvb2t1cE5hbWVzcGFjZVVSSSIgaW4gYiAmJiAwIDwgZyAmJiBiLmxvb2t1cE5hbWVzcGFjZVVSSShjMi5zdWJzdHIoMCwgZykpLCBoID0gZmFsc2UgPT09IGQyIHx8IG51bGwgPT09IGQyIHx8IGQyID09PSBuOwogICAgICAgICAgICAgIGggPyBnID8gYi5yZW1vdmVBdHRyaWJ1dGVOUyhnLCBjMikgOiBiLnJlbW92ZUF0dHJpYnV0ZShjMikgOiBkMiA9IGQyLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgOCA+PSBhMy5hLlcgJiYgYzIgaW4gViA/IChjMiA9IFZbYzJdLCBoID8gYi5yZW1vdmVBdHRyaWJ1dGUoYzIpIDogYltjMl0gPSBkMikgOiBoIHx8IChnID8gYi5zZXRBdHRyaWJ1dGVOUyhnLCBjMiwgZDIpIDogYi5zZXRBdHRyaWJ1dGUoYzIsIGQyKSk7CiAgICAgICAgICAgICAgIm5hbWUiID09PSBjMiAmJiBhMy5hLlljKGIsIGggPyAiIiA6IGQyKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IH07CiAgICAgICAgICAoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGEzLmMuY2hlY2tlZCA9IHsgYWZ0ZXI6IFsidmFsdWUiLCAiYXR0ciJdLCBpbml0OiBmdW5jdGlvbihiLCBjLCBkKSB7CiAgICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHsKICAgICAgICAgICAgICAgIHZhciBlMiA9IGIuY2hlY2tlZCwgZjIgPSBnKCk7CiAgICAgICAgICAgICAgICBpZiAoIWEzLlMuWWEoKSAmJiAoZTIgfHwgIW0gJiYgIWEzLlMucWEoKSkpIHsKICAgICAgICAgICAgICAgICAgdmFyIGsyID0gYTMudS5HKGMpOwogICAgICAgICAgICAgICAgICBpZiAobCkgewogICAgICAgICAgICAgICAgICAgIHZhciBxMiA9IHAgPyBrMi52KCkgOiBrMiwgeiA9IHQ7CiAgICAgICAgICAgICAgICAgICAgdCA9IGYyOwogICAgICAgICAgICAgICAgICAgIHogIT09IGYyID8gZTIgJiYgKGEzLmEuTmEocTIsIGYyLCB0cnVlKSwgYTMuYS5OYShxMiwgeiwgZmFsc2UpKSA6IGEzLmEuTmEocTIsIGYyLCBlMik7CiAgICAgICAgICAgICAgICAgICAgcCAmJiBhMy5aYShrMikgJiYgazIocTIpOwogICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICBoICYmIChmMiA9PT0gbiA/IGYyID0gZTIgOiBlMiB8fCAoZjIgPSBuKSksIGEzLm0uZWIoCiAgICAgICAgICAgICAgICAgICAgICBrMiwKICAgICAgICAgICAgICAgICAgICAgIGQsCiAgICAgICAgICAgICAgICAgICAgICAiY2hlY2tlZCIsCiAgICAgICAgICAgICAgICAgICAgICBmMiwKICAgICAgICAgICAgICAgICAgICAgIHRydWUKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmdW5jdGlvbiBmKCkgewogICAgICAgICAgICAgICAgdmFyIGQyID0gYTMuYS5mKGMoKSksIGUyID0gZygpOwogICAgICAgICAgICAgICAgbCA/IChiLmNoZWNrZWQgPSAwIDw9IGEzLmEuQShkMiwgZTIpLCB0ID0gZTIpIDogYi5jaGVja2VkID0gaCAmJiBlMiA9PT0gbiA/ICEhZDIgOiBnKCkgPT09IGQyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgZyA9IGEzLnhiKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgaWYgKGQuaGFzKCJjaGVja2VkVmFsdWUiKSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIGEzLmEuZihkLmdldCgiY2hlY2tlZFZhbHVlIikpOwogICAgICAgICAgICAgICAgaWYgKHEpCiAgICAgICAgICAgICAgICAgIHJldHVybiBkLmhhcygidmFsdWUiKSA/IGEzLmEuZihkLmdldCgidmFsdWUiKSkgOiBiLnZhbHVlOwogICAgICAgICAgICAgIH0pLCBoID0gImNoZWNrYm94IiA9PSBiLnR5cGUsIG0gPSAicmFkaW8iID09IGIudHlwZTsKICAgICAgICAgICAgICBpZiAoaCB8fCBtKSB7CiAgICAgICAgICAgICAgICB2YXIgayA9IGMoKSwgbCA9IGggJiYgYTMuYS5mKGspIGluc3RhbmNlb2YgQXJyYXksIHAgPSAhKGwgJiYgay5wdXNoICYmIGsuc3BsaWNlKSwgcSA9IG0gfHwgbCwgdCA9IGwgPyBnKCkgOiBuOwogICAgICAgICAgICAgICAgbSAmJiAhYi5uYW1lICYmIGEzLmMudW5pcXVlTmFtZS5pbml0KGIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgYTMubyhlLCBudWxsLCB7IGw6IGIgfSk7CiAgICAgICAgICAgICAgICBhMy5hLkIoYiwgImNsaWNrIiwgZSk7CiAgICAgICAgICAgICAgICBhMy5vKGYsIG51bGwsIHsgbDogYiB9KTsKICAgICAgICAgICAgICAgIGsgPSBuOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSB9OwogICAgICAgICAgICBhMy5tLndhLmNoZWNrZWQgPSB0cnVlOwogICAgICAgICAgICBhMy5jLmNoZWNrZWRWYWx1ZSA9IHsgdXBkYXRlOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgICAgYi52YWx1ZSA9IGEzLmEuZihjKCkpOwogICAgICAgICAgICB9IH07CiAgICAgICAgICB9KSgpOwogICAgICAgICAgYTMuY1siY2xhc3MiXSA9IHsgdXBkYXRlOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgIHZhciBkID0gYTMuYS5EYihhMy5hLmYoYygpKSk7CiAgICAgICAgICAgIGEzLmEuRWIoYiwgYi5fX2tvX19jc3NWYWx1ZSwgZmFsc2UpOwogICAgICAgICAgICBiLl9fa29fX2Nzc1ZhbHVlID0gZDsKICAgICAgICAgICAgYTMuYS5FYihiLCBkLCB0cnVlKTsKICAgICAgICAgIH0gfTsKICAgICAgICAgIGEzLmMuY3NzID0geyB1cGRhdGU6IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgdmFyIGQgPSBhMy5hLmYoYygpKTsKICAgICAgICAgICAgbnVsbCAhPT0gZCAmJiAib2JqZWN0IiA9PSB0eXBlb2YgZCA/IGEzLmEuUChkLCBmdW5jdGlvbihjMiwgZDIpIHsKICAgICAgICAgICAgICBkMiA9IGEzLmEuZihkMik7CiAgICAgICAgICAgICAgYTMuYS5FYihiLCBjMiwgZDIpOwogICAgICAgICAgICB9KSA6IGEzLmNbImNsYXNzIl0udXBkYXRlKGIsIGMpOwogICAgICAgICAgfSB9OwogICAgICAgICAgYTMuYy5lbmFibGUgPSB7IHVwZGF0ZTogZnVuY3Rpb24oYiwgYykgewogICAgICAgICAgICB2YXIgZCA9IGEzLmEuZihjKCkpOwogICAgICAgICAgICBkICYmIGIuZGlzYWJsZWQgPyBiLnJlbW92ZUF0dHJpYnV0ZSgiZGlzYWJsZWQiKSA6IGQgfHwgYi5kaXNhYmxlZCB8fCAoYi5kaXNhYmxlZCA9IHRydWUpOwogICAgICAgICAgfSB9OwogICAgICAgICAgYTMuYy5kaXNhYmxlID0geyB1cGRhdGU6IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgYTMuYy5lbmFibGUudXBkYXRlKGIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiAhYTMuYS5mKGMoKSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSB9OwogICAgICAgICAgYTMuYy5ldmVudCA9IHsgaW5pdDogZnVuY3Rpb24oYiwgYywgZCwgZSwgZikgewogICAgICAgICAgICB2YXIgZyA9IGMoKSB8fCB7fTsKICAgICAgICAgICAgYTMuYS5QKGcsIGZ1bmN0aW9uKGcyKSB7CiAgICAgICAgICAgICAgInN0cmluZyIgPT0gdHlwZW9mIGcyICYmIGEzLmEuQihiLCBnMiwgZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICAgIHZhciBrLCBsID0gYygpW2cyXTsKICAgICAgICAgICAgICAgIGlmIChsKSB7CiAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBhMy5hLmxhKGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgICAgICAgZSA9IGYuJGRhdGE7CiAgICAgICAgICAgICAgICAgICAgcC51bnNoaWZ0KGUpOwogICAgICAgICAgICAgICAgICAgIGsgPSBsLmFwcGx5KGUsIHApOwogICAgICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgICAgIHRydWUgIT09IGsgJiYgKGIyLnByZXZlbnREZWZhdWx0ID8gYjIucHJldmVudERlZmF1bHQoKSA6IGIyLnJldHVyblZhbHVlID0gZmFsc2UpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBkLmdldChnMiArICJCdWJibGUiKSAmJiAoYjIuY2FuY2VsQnViYmxlID0gdHJ1ZSwgYjIuc3RvcFByb3BhZ2F0aW9uICYmIGIyLnN0b3BQcm9wYWdhdGlvbigpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IH07CiAgICAgICAgICBhMy5jLmZvcmVhY2ggPSB7IFJjOiBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB2YXIgYyA9IGIoKSwgZCA9IGEzLmEuYmMoYyk7CiAgICAgICAgICAgICAgaWYgKCFkIHx8ICJudW1iZXIiID09IHR5cGVvZiBkLmxlbmd0aCkKICAgICAgICAgICAgICAgIHJldHVybiB7IGZvcmVhY2g6IGMsIHRlbXBsYXRlRW5naW5lOiBhMy5iYS5NYSB9OwogICAgICAgICAgICAgIGEzLmEuZihjKTsKICAgICAgICAgICAgICByZXR1cm4geyBmb3JlYWNoOiBkLmRhdGEsIGFzOiBkLmFzLCBub0NoaWxkQ29udGV4dDogZC5ub0NoaWxkQ29udGV4dCwgaW5jbHVkZURlc3Ryb3llZDogZC5pbmNsdWRlRGVzdHJveWVkLCBhZnRlckFkZDogZC5hZnRlckFkZCwgYmVmb3JlUmVtb3ZlOiBkLmJlZm9yZVJlbW92ZSwgYWZ0ZXJSZW5kZXI6IGQuYWZ0ZXJSZW5kZXIsIGJlZm9yZU1vdmU6IGQuYmVmb3JlTW92ZSwgYWZ0ZXJNb3ZlOiBkLmFmdGVyTW92ZSwgdGVtcGxhdGVFbmdpbmU6IGEzLmJhLk1hIH07CiAgICAgICAgICAgIH07CiAgICAgICAgICB9LCBpbml0OiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgIHJldHVybiBhMy5jLnRlbXBsYXRlLmluaXQoYiwgYTMuYy5mb3JlYWNoLlJjKGMpKTsKICAgICAgICAgIH0sIHVwZGF0ZTogZnVuY3Rpb24oYiwgYywgZCwgZSwgZikgewogICAgICAgICAgICByZXR1cm4gYTMuYy50ZW1wbGF0ZS51cGRhdGUoYiwgYTMuYy5mb3JlYWNoLlJjKGMpLCBkLCBlLCBmKTsKICAgICAgICAgIH0gfTsKICAgICAgICAgIGEzLm0uUmEuZm9yZWFjaCA9IGZhbHNlOwogICAgICAgICAgYTMuaC5lYS5mb3JlYWNoID0gdHJ1ZTsKICAgICAgICAgIGEzLmMuaGFzZm9jdXMgPSB7IGluaXQ6IGZ1bmN0aW9uKGIsIGMsIGQpIHsKICAgICAgICAgICAgZnVuY3Rpb24gZShlMikgewogICAgICAgICAgICAgIGIuX19rb19oYXNmb2N1c1VwZGF0aW5nID0gdHJ1ZTsKICAgICAgICAgICAgICB2YXIgZjIgPSBiLm93bmVyRG9jdW1lbnQ7CiAgICAgICAgICAgICAgaWYgKCJhY3RpdmVFbGVtZW50IiBpbiBmMikgewogICAgICAgICAgICAgICAgdmFyIGcyOwogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgZzIgPSBmMi5hY3RpdmVFbGVtZW50OwogICAgICAgICAgICAgICAgfSBjYXRjaCAobCkgewogICAgICAgICAgICAgICAgICBnMiA9IGYyLmJvZHk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlMiA9IGcyID09PSBiOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmMiA9IGMoKTsKICAgICAgICAgICAgICBhMy5tLmViKGYyLCBkLCAiaGFzZm9jdXMiLCBlMiwgdHJ1ZSk7CiAgICAgICAgICAgICAgYi5fX2tvX2hhc2ZvY3VzTGFzdFZhbHVlID0gZTI7CiAgICAgICAgICAgICAgYi5fX2tvX2hhc2ZvY3VzVXBkYXRpbmcgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgZiA9IGUuYmluZChudWxsLCB0cnVlKSwgZyA9IGUuYmluZChudWxsLCBmYWxzZSk7CiAgICAgICAgICAgIGEzLmEuQihiLCAiZm9jdXMiLCBmKTsKICAgICAgICAgICAgYTMuYS5CKGIsICJmb2N1c2luIiwgZik7CiAgICAgICAgICAgIGEzLmEuQihiLCAiYmx1ciIsIGcpOwogICAgICAgICAgICBhMy5hLkIoYiwgImZvY3Vzb3V0IiwgZyk7CiAgICAgICAgICAgIGIuX19rb19oYXNmb2N1c0xhc3RWYWx1ZSA9IGZhbHNlOwogICAgICAgICAgfSwgdXBkYXRlOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgIHZhciBkID0gISFhMy5hLmYoYygpKTsKICAgICAgICAgICAgYi5fX2tvX2hhc2ZvY3VzVXBkYXRpbmcgfHwgYi5fX2tvX2hhc2ZvY3VzTGFzdFZhbHVlID09PSBkIHx8IChkID8gYi5mb2N1cygpIDogYi5ibHVyKCksICFkICYmIGIuX19rb19oYXNmb2N1c0xhc3RWYWx1ZSAmJiBiLm93bmVyRG9jdW1lbnQuYm9keS5mb2N1cygpLCBhMy51LkcoYTMuYS5GYiwgbnVsbCwgW2IsIGQgPyAiZm9jdXNpbiIgOiAiZm9jdXNvdXQiXSkpOwogICAgICAgICAgfSB9OwogICAgICAgICAgYTMubS53YS5oYXNmb2N1cyA9IHRydWU7CiAgICAgICAgICBhMy5jLmhhc0ZvY3VzID0gYTMuYy5oYXNmb2N1czsKICAgICAgICAgIGEzLm0ud2EuaGFzRm9jdXMgPSAiaGFzZm9jdXMiOwogICAgICAgICAgYTMuYy5odG1sID0geyBpbml0OiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIHsgY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWUgfTsKICAgICAgICAgIH0sIHVwZGF0ZTogZnVuY3Rpb24oYiwgYykgewogICAgICAgICAgICBhMy5hLmZjKGIsIGMoKSk7CiAgICAgICAgICB9IH07CiAgICAgICAgICAoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYjIsIGQsIGUpIHsKICAgICAgICAgICAgICBhMy5jW2IyXSA9IHsgaW5pdDogZnVuY3Rpb24oYjMsIGMsIGgsIG0sIGspIHsKICAgICAgICAgICAgICAgIHZhciBsLCBwLCBxID0ge30sIHQsIHgsIG4yOwogICAgICAgICAgICAgICAgaWYgKGQpIHsKICAgICAgICAgICAgICAgICAgbSA9IGguZ2V0KCJhcyIpOwogICAgICAgICAgICAgICAgICB2YXIgdTIgPSBoLmdldCgibm9DaGlsZENvbnRleHQiKTsKICAgICAgICAgICAgICAgICAgbjIgPSAhKG0gJiYgdTIpOwogICAgICAgICAgICAgICAgICBxID0geyBhczogbSwgbm9DaGlsZENvbnRleHQ6IHUyLCBleHBvcnREZXBlbmRlbmNpZXM6IG4yIH07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB4ID0gKHQgPSAicmVuZGVyIiA9PSBoLmdldCgiY29tcGxldGVPbiIpKSB8fCBoLmhhcyhhMy5pLnBhKTsKICAgICAgICAgICAgICAgIGEzLm8oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIHZhciBoMiA9IGEzLmEuZihjKCkpLCBtMiA9ICFlICE9PSAhaDIsIHUzID0gIXAsIHIyOwogICAgICAgICAgICAgICAgICBpZiAobjIgfHwgbTIgIT09IGwpIHsKICAgICAgICAgICAgICAgICAgICB4ICYmIChrID0gYTMuaS5DYihiMywgaykpOwogICAgICAgICAgICAgICAgICAgIGlmIChtMikgewogICAgICAgICAgICAgICAgICAgICAgaWYgKCFkIHx8IG4yKQogICAgICAgICAgICAgICAgICAgICAgICBxLmRhdGFEZXBlbmRlbmN5ID0gYTMuUy5vKCk7CiAgICAgICAgICAgICAgICAgICAgICByMiA9IGQgPyBrLmNyZWF0ZUNoaWxkQ29udGV4dCgiZnVuY3Rpb24iID09IHR5cGVvZiBoMiA/IGgyIDogYywgcSkgOiBhMy5TLnFhKCkgPyBrLmV4dGVuZChudWxsLCBxKSA6IGs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHUzICYmIGEzLlMucWEoKSAmJiAocCA9IGEzLmEuQ2EoYTMuaC5jaGlsZE5vZGVzKGIzKSwgdHJ1ZSkpOwogICAgICAgICAgICAgICAgICAgIG0yID8gKHUzIHx8IGEzLmgudmEoYjMsIGEzLmEuQ2EocCkpLCBhMy5PYShyMiwgYjMpKSA6IChhMy5oLkVhKGIzKSwgdCB8fCBhMy5pLm1hKGIzLCBhMy5pLkgpKTsKICAgICAgICAgICAgICAgICAgICBsID0gbTI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0sIG51bGwsIHsgbDogYjMgfSk7CiAgICAgICAgICAgICAgICByZXR1cm4geyBjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczogdHJ1ZSB9OwogICAgICAgICAgICAgIH0gfTsKICAgICAgICAgICAgICBhMy5tLlJhW2IyXSA9IGZhbHNlOwogICAgICAgICAgICAgIGEzLmguZWFbYjJdID0gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBiKCJpZiIpOwogICAgICAgICAgICBiKCJpZm5vdCIsIGZhbHNlLCB0cnVlKTsKICAgICAgICAgICAgYigid2l0aCIsIHRydWUpOwogICAgICAgICAgfSkoKTsKICAgICAgICAgIGEzLmMubGV0ID0geyBpbml0OiBmdW5jdGlvbihiLCBjLCBkLCBlLCBmKSB7CiAgICAgICAgICAgIGMgPSBmLmV4dGVuZChjKTsKICAgICAgICAgICAgYTMuT2EoYywgYik7CiAgICAgICAgICAgIHJldHVybiB7IGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlIH07CiAgICAgICAgICB9IH07CiAgICAgICAgICBhMy5oLmVhLmxldCA9IHRydWU7CiAgICAgICAgICB2YXIgUSA9IHt9OwogICAgICAgICAgYTMuYy5vcHRpb25zID0geyBpbml0OiBmdW5jdGlvbihiKSB7CiAgICAgICAgICAgIGlmICgic2VsZWN0IiAhPT0gYTMuYS5SKGIpKQogICAgICAgICAgICAgIHRocm93IEVycm9yKCJvcHRpb25zIGJpbmRpbmcgYXBwbGllcyBvbmx5IHRvIFNFTEVDVCBlbGVtZW50cyIpOwogICAgICAgICAgICBmb3IgKDsgMCA8IGIubGVuZ3RoOyApCiAgICAgICAgICAgICAgYi5yZW1vdmUoMCk7CiAgICAgICAgICAgIHJldHVybiB7IGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlIH07CiAgICAgICAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uKGIsIGMsIGQpIHsKICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHsKICAgICAgICAgICAgICByZXR1cm4gYTMuYS5qYihiLm9wdGlvbnMsIGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gYTQuc2VsZWN0ZWQ7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZihhNCwgYjIsIGMyKSB7CiAgICAgICAgICAgICAgdmFyIGQyID0gdHlwZW9mIGIyOwogICAgICAgICAgICAgIHJldHVybiAiZnVuY3Rpb24iID09IGQyID8gYjIoYTQpIDogInN0cmluZyIgPT0gZDIgPyBhNFtiMl0gOiBjMjsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBnKGMyLCBkMikgewogICAgICAgICAgICAgIGlmICh4ICYmIGwpCiAgICAgICAgICAgICAgICBhMy5pLm1hKGIsIGEzLmkuSCk7CiAgICAgICAgICAgICAgZWxzZSBpZiAodC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhciBlMiA9IDAgPD0gYTMuYS5BKHQsIGEzLncuTShkMlswXSkpOwogICAgICAgICAgICAgICAgYTMuYS5aYyhkMlswXSwgZTIpOwogICAgICAgICAgICAgICAgeCAmJiAhZTIgJiYgYTMudS5HKGEzLmEuRmIsIG51bGwsIFtiLCAiY2hhbmdlIl0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgaCA9IGIubXVsdGlwbGUsIG0gPSAwICE9IGIubGVuZ3RoICYmIGggPyBiLnNjcm9sbFRvcCA6IG51bGwsIGsgPSBhMy5hLmYoYygpKSwgbCA9IGQuZ2V0KCJ2YWx1ZUFsbG93VW5zZXQiKSAmJiBkLmhhcygidmFsdWUiKSwgcCA9IGQuZ2V0KCJvcHRpb25zSW5jbHVkZURlc3Ryb3llZCIpOwogICAgICAgICAgICBjID0ge307CiAgICAgICAgICAgIHZhciBxLCB0ID0gW107CiAgICAgICAgICAgIGwgfHwgKGggPyB0ID0gYTMuYS5NYihlKCksIGEzLncuTSkgOiAwIDw9IGIuc2VsZWN0ZWRJbmRleCAmJiB0LnB1c2goYTMudy5NKGIub3B0aW9uc1tiLnNlbGVjdGVkSW5kZXhdKSkpOwogICAgICAgICAgICBrICYmICgidW5kZWZpbmVkIiA9PSB0eXBlb2Ygay5sZW5ndGggJiYgKGsgPSBba10pLCBxID0gYTMuYS5qYihrLCBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIHJldHVybiBwIHx8IGIyID09PSBuIHx8IG51bGwgPT09IGIyIHx8ICFhMy5hLmYoYjIuX2Rlc3Ryb3kpOwogICAgICAgICAgICB9KSwgZC5oYXMoIm9wdGlvbnNDYXB0aW9uIikgJiYgKGsgPSBhMy5hLmYoZC5nZXQoIm9wdGlvbnNDYXB0aW9uIikpLCBudWxsICE9PSBrICYmIGsgIT09IG4gJiYgcS51bnNoaWZ0KFEpKSk7CiAgICAgICAgICAgIHZhciB4ID0gZmFsc2U7CiAgICAgICAgICAgIGMuYmVmb3JlUmVtb3ZlID0gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICBiLnJlbW92ZUNoaWxkKGE0KTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgayA9IGc7CiAgICAgICAgICAgIGQuaGFzKCJvcHRpb25zQWZ0ZXJSZW5kZXIiKSAmJiAiZnVuY3Rpb24iID09IHR5cGVvZiBkLmdldCgib3B0aW9uc0FmdGVyUmVuZGVyIikgJiYgKGsgPSBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICBnKDAsIGMyKTsKICAgICAgICAgICAgICBhMy51LkcoZC5nZXQoIm9wdGlvbnNBZnRlclJlbmRlciIpLCBudWxsLCBbYzJbMF0sIGIyICE9PSBRID8gYjIgOiBuXSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBhMy5hLmVjKGIsIHEsIGZ1bmN0aW9uKGMyLCBlMiwgZzIpIHsKICAgICAgICAgICAgICBnMi5sZW5ndGggJiYgKHQgPSAhbCAmJiBnMlswXS5zZWxlY3RlZCA/IFthMy53Lk0oZzJbMF0pXSA6IFtdLCB4ID0gdHJ1ZSk7CiAgICAgICAgICAgICAgZTIgPSBiLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7CiAgICAgICAgICAgICAgYzIgPT09IFEgPyAoYTMuYS5CYihlMiwgZC5nZXQoIm9wdGlvbnNDYXB0aW9uIikpLCBhMy53LmNiKGUyLCBuKSkgOiAoZzIgPSBmKGMyLCBkLmdldCgib3B0aW9uc1ZhbHVlIiksIGMyKSwgYTMudy5jYihlMiwgYTMuYS5mKGcyKSksIGMyID0gZihjMiwgZC5nZXQoIm9wdGlvbnNUZXh0IiksIGcyKSwgYTMuYS5CYihlMiwgYzIpKTsKICAgICAgICAgICAgICByZXR1cm4gW2UyXTsKICAgICAgICAgICAgfSwgYywgayk7CiAgICAgICAgICAgIGlmICghbCkgewogICAgICAgICAgICAgIHZhciBCOwogICAgICAgICAgICAgIGggPyBCID0gdC5sZW5ndGggJiYgZSgpLmxlbmd0aCA8IHQubGVuZ3RoIDogQiA9IHQubGVuZ3RoICYmIDAgPD0gYi5zZWxlY3RlZEluZGV4ID8gYTMudy5NKGIub3B0aW9uc1tiLnNlbGVjdGVkSW5kZXhdKSAhPT0gdFswXSA6IHQubGVuZ3RoIHx8IDAgPD0gYi5zZWxlY3RlZEluZGV4OwogICAgICAgICAgICAgIEIgJiYgYTMudS5HKGEzLmEuRmIsIG51bGwsIFtiLCAiY2hhbmdlIl0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIChsIHx8IGEzLlMuWWEoKSkgJiYgYTMuaS5tYShiLCBhMy5pLkgpOwogICAgICAgICAgICBhMy5hLndkKGIpOwogICAgICAgICAgICBtICYmIDIwIDwgTWF0aC5hYnMobSAtIGIuc2Nyb2xsVG9wKSAmJiAoYi5zY3JvbGxUb3AgPSBtKTsKICAgICAgICAgIH0gfTsKICAgICAgICAgIGEzLmMub3B0aW9ucy4kYiA9IGEzLmEuZy5aKCk7CiAgICAgICAgICBhMy5jLnNlbGVjdGVkT3B0aW9ucyA9IHsgaW5pdDogZnVuY3Rpb24oYiwgYywgZCkgewogICAgICAgICAgICBmdW5jdGlvbiBlKCkgewogICAgICAgICAgICAgIHZhciBlMiA9IGMoKSwgZjIgPSBbXTsKICAgICAgICAgICAgICBhMy5hLkQoYi5nZXRFbGVtZW50c0J5VGFnTmFtZSgib3B0aW9uIiksIGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgICBiMi5zZWxlY3RlZCAmJiBmMi5wdXNoKGEzLncuTShiMikpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGEzLm0uZWIoCiAgICAgICAgICAgICAgICBlMiwKICAgICAgICAgICAgICAgIGQsCiAgICAgICAgICAgICAgICAic2VsZWN0ZWRPcHRpb25zIiwKICAgICAgICAgICAgICAgIGYyCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBmKCkgewogICAgICAgICAgICAgIHZhciBkMiA9IGEzLmEuZihjKCkpLCBlMiA9IGIuc2Nyb2xsVG9wOwogICAgICAgICAgICAgIGQyICYmICJudW1iZXIiID09IHR5cGVvZiBkMi5sZW5ndGggJiYgYTMuYS5EKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIm9wdGlvbiIpLCBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgICAgdmFyIGMyID0gMCA8PSBhMy5hLkEoZDIsIGEzLncuTShiMikpOwogICAgICAgICAgICAgICAgYjIuc2VsZWN0ZWQgIT0gYzIgJiYgYTMuYS5aYyhiMiwgYzIpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGIuc2Nyb2xsVG9wID0gZTI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCJzZWxlY3QiICE9IGEzLmEuUihiKSkKICAgICAgICAgICAgICB0aHJvdyBFcnJvcigic2VsZWN0ZWRPcHRpb25zIGJpbmRpbmcgYXBwbGllcyBvbmx5IHRvIFNFTEVDVCBlbGVtZW50cyIpOwogICAgICAgICAgICB2YXIgZzsKICAgICAgICAgICAgYTMuaS5zdWJzY3JpYmUoYiwgYTMuaS5ILCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICBnID8gZSgpIDogKGEzLmEuQihiLCAiY2hhbmdlIiwgZSksIGcgPSBhMy5vKGYsIG51bGwsIHsgbDogYiB9KSk7CiAgICAgICAgICAgIH0sIG51bGwsIHsgbm90aWZ5SW1tZWRpYXRlbHk6IHRydWUgfSk7CiAgICAgICAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgfSB9OwogICAgICAgICAgYTMubS53YS5zZWxlY3RlZE9wdGlvbnMgPSB0cnVlOwogICAgICAgICAgYTMuYy5zdHlsZSA9IHsgdXBkYXRlOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgIHZhciBkID0gYTMuYS5mKGMoKSB8fCB7fSk7CiAgICAgICAgICAgIGEzLmEuUChkLCBmdW5jdGlvbihjMiwgZDIpIHsKICAgICAgICAgICAgICBkMiA9IGEzLmEuZihkMik7CiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGQyIHx8IGQyID09PSBuIHx8IGZhbHNlID09PSBkMikKICAgICAgICAgICAgICAgIGQyID0gIiI7CiAgICAgICAgICAgICAgaWYgKHYyKQogICAgICAgICAgICAgICAgdjIoYikuY3NzKGMyLCBkMik7CiAgICAgICAgICAgICAgZWxzZSBpZiAoL14tLS8udGVzdChjMikpCiAgICAgICAgICAgICAgICBiLnN0eWxlLnNldFByb3BlcnR5KGMyLCBkMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBjMiA9IGMyLnJlcGxhY2UoLy0oXHcpL2csIGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgICAgICByZXR1cm4gYjIudG9VcHBlckNhc2UoKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgdmFyIGcgPSBiLnN0eWxlW2MyXTsKICAgICAgICAgICAgICAgIGIuc3R5bGVbYzJdID0gZDI7CiAgICAgICAgICAgICAgICBkMiA9PT0gZyB8fCBiLnN0eWxlW2MyXSAhPSBnIHx8IGlzTmFOKGQyKSB8fCAoYi5zdHlsZVtjMl0gPSBkMiArICJweCIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IH07CiAgICAgICAgICBhMy5jLnN1Ym1pdCA9IHsgaW5pdDogZnVuY3Rpb24oYiwgYywgZCwgZSwgZikgewogICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgYygpKQogICAgICAgICAgICAgIHRocm93IEVycm9yKCJUaGUgdmFsdWUgZm9yIGEgc3VibWl0IGJpbmRpbmcgbXVzdCBiZSBhIGZ1bmN0aW9uIik7CiAgICAgICAgICAgIGEzLmEuQihiLCAic3VibWl0IiwgZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICB2YXIgZDIsIGUyID0gYygpOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBkMiA9IGUyLmNhbGwoZi4kZGF0YSwgYik7CiAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIHRydWUgIT09IGQyICYmIChhNC5wcmV2ZW50RGVmYXVsdCA/IGE0LnByZXZlbnREZWZhdWx0KCkgOiBhNC5yZXR1cm5WYWx1ZSA9IGZhbHNlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSB9OwogICAgICAgICAgYTMuYy50ZXh0ID0geyBpbml0OiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIHsgY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWUgfTsKICAgICAgICAgIH0sIHVwZGF0ZTogZnVuY3Rpb24oYiwgYykgewogICAgICAgICAgICBhMy5hLkJiKGIsIGMoKSk7CiAgICAgICAgICB9IH07CiAgICAgICAgICBhMy5oLmVhLnRleHQgPSB0cnVlOwogICAgICAgICAgKGZ1bmN0aW9uKCkgewogICAgICAgICAgICBpZiAoQSAmJiBBLm5hdmlnYXRvcikgewogICAgICAgICAgICAgIHZhciBiID0gZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIGlmIChhNCkKICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYTRbMV0pOwogICAgICAgICAgICAgIH0sIGMgPSBBLm5hdmlnYXRvci51c2VyQWdlbnQsIGQsIGUsIGYsIGcsIGg7CiAgICAgICAgICAgICAgKGQgPSBBLm9wZXJhICYmIEEub3BlcmEudmVyc2lvbiAmJiBwYXJzZUludChBLm9wZXJhLnZlcnNpb24oKSkpIHx8IChoID0gYihjLm1hdGNoKC9FZGdlXC8oW14gXSspJC8pKSkgfHwgYihjLm1hdGNoKC9DaHJvbWVcLyhbXiBdKykvKSkgfHwgKGUgPSBiKGMubWF0Y2goL1ZlcnNpb25cLyhbXiBdKykgU2FmYXJpLykpKSB8fCAoZiA9IGIoYy5tYXRjaCgvRmlyZWZveFwvKFteIF0rKS8pKSkgfHwgKGcgPSBhMy5hLlcgfHwgYihjLm1hdGNoKC9NU0lFIChbXiBdKykvKSkpIHx8IChnID0gYihjLm1hdGNoKC9ydjooW14gKV0rKS8pKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKDggPD0gZyAmJiAxMCA+IGcpCiAgICAgICAgICAgICAgdmFyIG0gPSBhMy5hLmcuWigpLCBrID0gYTMuYS5nLlooKSwgbCA9IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgICB2YXIgYzIgPSB0aGlzLmFjdGl2ZUVsZW1lbnQ7CiAgICAgICAgICAgICAgICAoYzIgPSBjMiAmJiBhMy5hLmcuZ2V0KGMyLCBrKSkgJiYgYzIoYjIpOwogICAgICAgICAgICAgIH0sIHAgPSBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICAgIHZhciBkMiA9IGIyLm93bmVyRG9jdW1lbnQ7CiAgICAgICAgICAgICAgICBhMy5hLmcuZ2V0KGQyLCBtKSB8fCAoYTMuYS5nLnNldChkMiwgbSwgdHJ1ZSksIGEzLmEuQihkMiwgInNlbGVjdGlvbmNoYW5nZSIsIGwpKTsKICAgICAgICAgICAgICAgIGEzLmEuZy5zZXQoYjIsIGssIGMyKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5jLnRleHRJbnB1dCA9IHsgaW5pdDogZnVuY3Rpb24oYjIsIGMyLCBrMikgewogICAgICAgICAgICAgIGZ1bmN0aW9uIGwyKGMzLCBkMikgewogICAgICAgICAgICAgICAgYTMuYS5CKGIyLCBjMywgZDIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmdW5jdGlvbiBtMigpIHsKICAgICAgICAgICAgICAgIHZhciBkMiA9IGEzLmEuZihjMigpKTsKICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBkMiB8fCBkMiA9PT0gbikKICAgICAgICAgICAgICAgICAgZDIgPSAiIjsKICAgICAgICAgICAgICAgIEwgIT09IG4gJiYgZDIgPT09IEwgPyBhMy5hLnNldFRpbWVvdXQobTIsIDQpIDogYjIudmFsdWUgIT09IGQyICYmICh5ID0gdHJ1ZSwgYjIudmFsdWUgPSBkMiwgeSA9IGZhbHNlLCB2MyA9IGIyLnZhbHVlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZnVuY3Rpb24gcjIoKSB7CiAgICAgICAgICAgICAgICB3MiB8fCAoTCA9IGIyLnZhbHVlLCB3MiA9IGEzLmEuc2V0VGltZW91dCgKICAgICAgICAgICAgICAgICAgeiwKICAgICAgICAgICAgICAgICAgNAogICAgICAgICAgICAgICAgKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGZ1bmN0aW9uIHooKSB7CiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodzIpOwogICAgICAgICAgICAgICAgTCA9IHcyID0gbjsKICAgICAgICAgICAgICAgIHZhciBkMiA9IGIyLnZhbHVlOwogICAgICAgICAgICAgICAgdjMgIT09IGQyICYmICh2MyA9IGQyLCBhMy5tLmViKGMyKCksIGsyLCAidGV4dElucHV0IiwgZDIpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHYzID0gYjIudmFsdWUsIHcyLCBMLCBBMiA9IDkgPT0gYTMuYS5XID8gcjIgOiB6LCB5ID0gZmFsc2U7CiAgICAgICAgICAgICAgZyAmJiBsMigia2V5cHJlc3MiLCB6KTsKICAgICAgICAgICAgICAxMSA+IGcgJiYgbDIoInByb3BlcnR5Y2hhbmdlIiwgZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIHkgfHwgInZhbHVlIiAhPT0gYTQucHJvcGVydHlOYW1lIHx8IEEyKGE0KTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICA4ID09IGcgJiYgKGwyKCJrZXl1cCIsIHopLCBsMigia2V5ZG93biIsIHopKTsKICAgICAgICAgICAgICBwICYmIChwKGIyLCBBMiksIGwyKCJkcmFnZW5kIiwgcjIpKTsKICAgICAgICAgICAgICAoIWcgfHwgOSA8PSBnKSAmJiBsMigiaW5wdXQiLCBBMik7CiAgICAgICAgICAgICAgNSA+IGUgJiYgInRleHRhcmVhIiA9PT0gYTMuYS5SKGIyKSA/IChsMigia2V5ZG93biIsIHIyKSwgbDIoInBhc3RlIiwgcjIpLCBsMigiY3V0IiwgcjIpKSA6IDExID4gZCA/IGwyKCJrZXlkb3duIiwgcjIpIDogNCA+IGYgPyAobDIoIkRPTUF1dG9Db21wbGV0ZSIsIHopLCBsMigiZHJhZ2Ryb3AiLCB6KSwgbDIoImRyb3AiLCB6KSkgOiBoICYmICJudW1iZXIiID09PSBiMi50eXBlICYmIGwyKCJrZXlkb3duIiwgcjIpOwogICAgICAgICAgICAgIGwyKAogICAgICAgICAgICAgICAgImNoYW5nZSIsCiAgICAgICAgICAgICAgICB6CiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICBsMigiYmx1ciIsIHopOwogICAgICAgICAgICAgIGEzLm8obTIsIG51bGwsIHsgbDogYjIgfSk7CiAgICAgICAgICAgIH0gfTsKICAgICAgICAgICAgYTMubS53YS50ZXh0SW5wdXQgPSB0cnVlOwogICAgICAgICAgICBhMy5jLnRleHRpbnB1dCA9IHsgcHJlcHJvY2VzczogZnVuY3Rpb24oYTQsIGIyLCBjMikgewogICAgICAgICAgICAgIGMyKCJ0ZXh0SW5wdXQiLCBhNCk7CiAgICAgICAgICAgIH0gfTsKICAgICAgICAgIH0pKCk7CiAgICAgICAgICBhMy5jLnVuaXF1ZU5hbWUgPSB7IGluaXQ6IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgaWYgKGMoKSkgewogICAgICAgICAgICAgIHZhciBkID0gImtvX3VuaXF1ZV8iICsgKythMy5jLnVuaXF1ZU5hbWUucmQ7CiAgICAgICAgICAgICAgYTMuYS5ZYyhiLCBkKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSB9OwogICAgICAgICAgYTMuYy51bmlxdWVOYW1lLnJkID0gMDsKICAgICAgICAgIGEzLmMudXNpbmcgPSB7IGluaXQ6IGZ1bmN0aW9uKGIsIGMsIGQsIGUsIGYpIHsKICAgICAgICAgICAgdmFyIGc7CiAgICAgICAgICAgIGQuaGFzKCJhcyIpICYmIChnID0geyBhczogZC5nZXQoImFzIiksIG5vQ2hpbGRDb250ZXh0OiBkLmdldCgibm9DaGlsZENvbnRleHQiKSB9KTsKICAgICAgICAgICAgYyA9IGYuY3JlYXRlQ2hpbGRDb250ZXh0KGMsIGcpOwogICAgICAgICAgICBhMy5PYShjLCBiKTsKICAgICAgICAgICAgcmV0dXJuIHsgY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWUgfTsKICAgICAgICAgIH0gfTsKICAgICAgICAgIGEzLmguZWEudXNpbmcgPSB0cnVlOwogICAgICAgICAgYTMuYy52YWx1ZSA9IHsgaW5pdDogZnVuY3Rpb24oYiwgYywgZCkgewogICAgICAgICAgICB2YXIgZSA9IGEzLmEuUihiKSwgZiA9ICJpbnB1dCIgPT0gZTsKICAgICAgICAgICAgaWYgKCFmIHx8ICJjaGVja2JveCIgIT0gYi50eXBlICYmICJyYWRpbyIgIT0gYi50eXBlKSB7CiAgICAgICAgICAgICAgdmFyIGcgPSBbXSwgaCA9IGQuZ2V0KCJ2YWx1ZVVwZGF0ZSIpLCBtID0gZmFsc2UsIGsgPSBudWxsOwogICAgICAgICAgICAgIGggJiYgKCJzdHJpbmciID09IHR5cGVvZiBoID8gZyA9IFtoXSA6IGcgPSBhMy5hLndjKGgpLCBhMy5hLlBhKGcsICJjaGFuZ2UiKSk7CiAgICAgICAgICAgICAgdmFyIGwgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGsgPSBudWxsOwogICAgICAgICAgICAgICAgbSA9IGZhbHNlOwogICAgICAgICAgICAgICAgdmFyIGUyID0gYygpLCBmMiA9IGEzLncuTShiKTsKICAgICAgICAgICAgICAgIGEzLm0uZWIoZTIsIGQsICJ2YWx1ZSIsIGYyKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICFhMy5hLlcgfHwgIWYgfHwgInRleHQiICE9IGIudHlwZSB8fCAib2ZmIiA9PSBiLmF1dG9jb21wbGV0ZSB8fCBiLmZvcm0gJiYgIm9mZiIgPT0gYi5mb3JtLmF1dG9jb21wbGV0ZSB8fCAtMSAhPSBhMy5hLkEoZywgInByb3BlcnR5Y2hhbmdlIikgfHwgKGEzLmEuQihiLCAicHJvcGVydHljaGFuZ2UiLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIG0gPSB0cnVlOwogICAgICAgICAgICAgIH0pLCBhMy5hLkIoYiwgImZvY3VzIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBtID0gZmFsc2U7CiAgICAgICAgICAgICAgfSksIGEzLmEuQihiLCAiYmx1ciIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgbSAmJiBsKCk7CiAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgIGEzLmEuRChnLCBmdW5jdGlvbihjMikgewogICAgICAgICAgICAgICAgdmFyIGQyID0gbDsKICAgICAgICAgICAgICAgIGEzLmEuVWQoYzIsICJhZnRlciIpICYmIChkMiA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICBrID0gYTMudy5NKGIpOwogICAgICAgICAgICAgICAgICBhMy5hLnNldFRpbWVvdXQobCwgMCk7CiAgICAgICAgICAgICAgICB9LCBjMiA9IGMyLnN1YnN0cmluZyg1KSk7CiAgICAgICAgICAgICAgICBhMy5hLkIoYiwgYzIsIGQyKTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB2YXIgcDsKICAgICAgICAgICAgICBwID0gZiAmJiAiZmlsZSIgPT0gYi50eXBlID8gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICB2YXIgZDIgPSBhMy5hLmYoYygpKTsKICAgICAgICAgICAgICAgIG51bGwgPT09IGQyIHx8IGQyID09PSBuIHx8ICIiID09PSBkMiA/IGIudmFsdWUgPSAiIiA6IGEzLnUuRyhsKTsKICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICB2YXIgZjIgPSBhMy5hLmYoYygpKSwgZzIgPSBhMy53Lk0oYik7CiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gayAmJiBmMiA9PT0gaykKICAgICAgICAgICAgICAgICAgYTMuYS5zZXRUaW1lb3V0KHAsIDApOwogICAgICAgICAgICAgICAgZWxzZSBpZiAoZjIgIT09IGcyIHx8IGcyID09PSBuKQogICAgICAgICAgICAgICAgICAic2VsZWN0IiA9PT0gZSA/IChnMiA9IGQuZ2V0KCJ2YWx1ZUFsbG93VW5zZXQiKSwgYTMudy5jYihiLCBmMiwgZzIpLCBnMiB8fCBmMiA9PT0gYTMudy5NKGIpIHx8IGEzLnUuRyhsKSkgOiBhMy53LmNiKGIsIGYyKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIGlmICgic2VsZWN0IiA9PT0gZSkgewogICAgICAgICAgICAgICAgdmFyIHE7CiAgICAgICAgICAgICAgICBhMy5pLnN1YnNjcmliZSgKICAgICAgICAgICAgICAgICAgYiwKICAgICAgICAgICAgICAgICAgYTMuaS5ILAogICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICBxID8gZC5nZXQoInZhbHVlQWxsb3dVbnNldCIpID8gcCgpIDogbCgpIDogKGEzLmEuQihiLCAiY2hhbmdlIiwgbCksIHEgPSBhMy5vKHAsIG51bGwsIHsgbDogYiB9KSk7CiAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgIG51bGwsCiAgICAgICAgICAgICAgICAgIHsgbm90aWZ5SW1tZWRpYXRlbHk6IHRydWUgfQogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgIGEzLmEuQihiLCAiY2hhbmdlIiwgbCksIGEzLm8ocCwgbnVsbCwgeyBsOiBiIH0pOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBhMy5pYihiLCB7IGNoZWNrZWRWYWx1ZTogYyB9KTsKICAgICAgICAgIH0sIHVwZGF0ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICB9IH07CiAgICAgICAgICBhMy5tLndhLnZhbHVlID0gdHJ1ZTsKICAgICAgICAgIGEzLmMudmlzaWJsZSA9IHsgdXBkYXRlOiBmdW5jdGlvbihiLCBjKSB7CiAgICAgICAgICAgIHZhciBkID0gYTMuYS5mKGMoKSksIGUgPSAibm9uZSIgIT0gYi5zdHlsZS5kaXNwbGF5OwogICAgICAgICAgICBkICYmICFlID8gYi5zdHlsZS5kaXNwbGF5ID0gIiIgOiAhZCAmJiBlICYmIChiLnN0eWxlLmRpc3BsYXkgPSAibm9uZSIpOwogICAgICAgICAgfSB9OwogICAgICAgICAgYTMuYy5oaWRkZW4gPSB7IHVwZGF0ZTogZnVuY3Rpb24oYiwgYykgewogICAgICAgICAgICBhMy5jLnZpc2libGUudXBkYXRlKGIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiAhYTMuYS5mKGMoKSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSB9OwogICAgICAgICAgKGZ1bmN0aW9uKGIpIHsKICAgICAgICAgICAgYTMuY1tiXSA9IHsgaW5pdDogZnVuY3Rpb24oYywgZCwgZSwgZiwgZykgewogICAgICAgICAgICAgIHJldHVybiBhMy5jLmV2ZW50LmluaXQuY2FsbCh0aGlzLCBjLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHZhciBhNCA9IHt9OwogICAgICAgICAgICAgICAgYTRbYl0gPSBkKCk7CiAgICAgICAgICAgICAgICByZXR1cm4gYTQ7CiAgICAgICAgICAgICAgfSwgZSwgZiwgZyk7CiAgICAgICAgICAgIH0gfTsKICAgICAgICAgIH0pKCJjbGljayIpOwogICAgICAgICAgYTMuY2EgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIH07CiAgICAgICAgICBhMy5jYS5wcm90b3R5cGUucmVuZGVyVGVtcGxhdGVTb3VyY2UgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdGhyb3cgRXJyb3IoIk92ZXJyaWRlIHJlbmRlclRlbXBsYXRlU291cmNlIik7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuY2EucHJvdG90eXBlLmNyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jayA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0aHJvdyBFcnJvcigiT3ZlcnJpZGUgY3JlYXRlSmF2YVNjcmlwdEV2YWx1YXRvckJsb2NrIik7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuY2EucHJvdG90eXBlLm1ha2VUZW1wbGF0ZVNvdXJjZSA9IGZ1bmN0aW9uKGIsIGMpIHsKICAgICAgICAgICAgaWYgKCJzdHJpbmciID09IHR5cGVvZiBiKSB7CiAgICAgICAgICAgICAgYyA9IGMgfHwgdzsKICAgICAgICAgICAgICB2YXIgZCA9IGMuZ2V0RWxlbWVudEJ5SWQoYik7CiAgICAgICAgICAgICAgaWYgKCFkKQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIkNhbm5vdCBmaW5kIHRlbXBsYXRlIHdpdGggSUQgIiArIGIpOwogICAgICAgICAgICAgIHJldHVybiBuZXcgYTMuQy5GKGQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgxID09IGIubm9kZVR5cGUgfHwgOCA9PSBiLm5vZGVUeXBlKQogICAgICAgICAgICAgIHJldHVybiBuZXcgYTMuQy5pYShiKTsKICAgICAgICAgICAgdGhyb3cgRXJyb3IoIlVua25vd24gdGVtcGxhdGUgdHlwZTogIiArIGIpOwogICAgICAgICAgfTsKICAgICAgICAgIGEzLmNhLnByb3RvdHlwZS5yZW5kZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uKGE0LCBjLCBkLCBlKSB7CiAgICAgICAgICAgIGE0ID0gdGhpcy5tYWtlVGVtcGxhdGVTb3VyY2UoYTQsIGUpOwogICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJUZW1wbGF0ZVNvdXJjZShhNCwgYywgZCwgZSk7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuY2EucHJvdG90eXBlLmlzVGVtcGxhdGVSZXdyaXR0ZW4gPSBmdW5jdGlvbihhNCwgYykgewogICAgICAgICAgICByZXR1cm4gZmFsc2UgPT09IHRoaXMuYWxsb3dUZW1wbGF0ZVJld3JpdGluZyA/IHRydWUgOiB0aGlzLm1ha2VUZW1wbGF0ZVNvdXJjZShhNCwgYykuZGF0YSgiaXNSZXdyaXR0ZW4iKTsKICAgICAgICAgIH07CiAgICAgICAgICBhMy5jYS5wcm90b3R5cGUucmV3cml0ZVRlbXBsYXRlID0gZnVuY3Rpb24oYTQsIGMsIGQpIHsKICAgICAgICAgICAgYTQgPSB0aGlzLm1ha2VUZW1wbGF0ZVNvdXJjZShhNCwgZCk7CiAgICAgICAgICAgIGMgPSBjKGE0LnRleHQoKSk7CiAgICAgICAgICAgIGE0LnRleHQoYyk7CiAgICAgICAgICAgIGE0LmRhdGEoImlzUmV3cml0dGVuIiwgdHJ1ZSk7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuYigidGVtcGxhdGVFbmdpbmUiLCBhMy5jYSk7CiAgICAgICAgICBhMy5rYyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICBmdW5jdGlvbiBiKGIyLCBjMiwgZDIsIGgpIHsKICAgICAgICAgICAgICBiMiA9IGEzLm0uYWMoYjIpOwogICAgICAgICAgICAgIGZvciAodmFyIG0gPSBhMy5tLlJhLCBrID0gMDsgayA8IGIyLmxlbmd0aDsgaysrKSB7CiAgICAgICAgICAgICAgICB2YXIgbCA9IGIyW2tdLmtleTsKICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoCiAgICAgICAgICAgICAgICAgIG0sCiAgICAgICAgICAgICAgICAgIGwKICAgICAgICAgICAgICAgICkpIHsKICAgICAgICAgICAgICAgICAgdmFyIHAgPSBtW2xdOwogICAgICAgICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiA9PT0gdHlwZW9mIHApIHsKICAgICAgICAgICAgICAgICAgICBpZiAobCA9IHAoYjJba10udmFsdWUpKQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IobCk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXApCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIlRoaXMgdGVtcGxhdGUgZW5naW5lIGRvZXMgbm90IHN1cHBvcnQgdGhlICciICsgbCArICInIGJpbmRpbmcgd2l0aGluIGl0cyB0ZW1wbGF0ZXMiKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZDIgPSAia28uX190cl9hbWJ0bnMoZnVuY3Rpb24oJGNvbnRleHQsJGVsZW1lbnQpe3JldHVybihmdW5jdGlvbigpe3JldHVybnsgIiArIGEzLm0udmIoYjIsIHsgdmFsdWVBY2Nlc3NvcnM6IHRydWUgfSkgKyAiIH0gfSkoKX0sJyIgKyBkMi50b0xvd2VyQ2FzZSgpICsgIicpIjsKICAgICAgICAgICAgICByZXR1cm4gaC5jcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2soZDIpICsgYzI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGMgPSAvKDwoW2Etel0rXGQqKSg/OlxzKyg/IWRhdGEtYmluZFxzKj1ccyopW2EtejAtOVwtXSsoPzo9KD86XCJbXlwiXSpcInxcJ1teXCddKlwnfFtePl0qKSk/KSpccyspZGF0YS1iaW5kXHMqPVxzKihbIiddKShbXHNcU10qPylcMy9naSwgZCA9IC9ceDNjIS0tXHMqa29cYlxzKihbXHNcU10qPylccyotLVx4M2UvZzsKICAgICAgICAgICAgcmV0dXJuIHsgeGQ6IGZ1bmN0aW9uKGIyLCBjMiwgZDIpIHsKICAgICAgICAgICAgICBjMi5pc1RlbXBsYXRlUmV3cml0dGVuKGIyLCBkMikgfHwgYzIucmV3cml0ZVRlbXBsYXRlKGIyLCBmdW5jdGlvbihiMykgewogICAgICAgICAgICAgICAgcmV0dXJuIGEzLmtjLkxkKGIzLCBjMik7CiAgICAgICAgICAgICAgfSwgZDIpOwogICAgICAgICAgICB9LCBMZDogZnVuY3Rpb24oYTQsIGYpIHsKICAgICAgICAgICAgICByZXR1cm4gYTQucmVwbGFjZShjLCBmdW5jdGlvbihhNSwgYzIsIGQyLCBlLCBsKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gYihsLCBjMiwgZDIsIGYpOwogICAgICAgICAgICAgIH0pLnJlcGxhY2UoZCwgZnVuY3Rpb24oYTUsIGMyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gYihjMiwgIjwhLS0ga28gLS0+IiwgIiNjb21tZW50IiwgZik7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0sIG1kOiBmdW5jdGlvbihiMiwgYzIpIHsKICAgICAgICAgICAgICByZXR1cm4gYTMuYWEuWGIoZnVuY3Rpb24oZDIsIGgpIHsKICAgICAgICAgICAgICAgIHZhciBtID0gZDIubmV4dFNpYmxpbmc7CiAgICAgICAgICAgICAgICBtICYmIG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYzIgJiYgYTMuaWIobSwgYjIsIGgpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9IH07CiAgICAgICAgICB9KCk7CiAgICAgICAgICBhMy5iKCJfX3RyX2FtYnRucyIsIGEzLmtjLm1kKTsKICAgICAgICAgIChmdW5jdGlvbigpIHsKICAgICAgICAgICAgYTMuQyA9IHt9OwogICAgICAgICAgICBhMy5DLkYgPSBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgIGlmICh0aGlzLkYgPSBiMikgewogICAgICAgICAgICAgICAgdmFyIGMyID0gYTMuYS5SKGIyKTsKICAgICAgICAgICAgICAgIHRoaXMuYWIgPSAic2NyaXB0IiA9PT0gYzIgPyAxIDogInRleHRhcmVhIiA9PT0gYzIgPyAyIDogInRlbXBsYXRlIiA9PSBjMiAmJiBiMi5jb250ZW50ICYmIDExID09PSBiMi5jb250ZW50Lm5vZGVUeXBlID8gMyA6IDQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5DLkYucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB2YXIgYjIgPSAxID09PSB0aGlzLmFiID8gInRleHQiIDogMiA9PT0gdGhpcy5hYiA/ICJ2YWx1ZSIgOiAiaW5uZXJIVE1MIjsKICAgICAgICAgICAgICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRltiMl07CiAgICAgICAgICAgICAgdmFyIGMyID0gYXJndW1lbnRzWzBdOwogICAgICAgICAgICAgICJpbm5lckhUTUwiID09PSBiMiA/IGEzLmEuZmModGhpcy5GLCBjMikgOiB0aGlzLkZbYjJdID0gYzI7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHZhciBiID0gYTMuYS5nLlooKSArICJfIjsKICAgICAgICAgICAgYTMuQy5GLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oYzIpIHsKICAgICAgICAgICAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkKICAgICAgICAgICAgICAgIHJldHVybiBhMy5hLmcuZ2V0KHRoaXMuRiwgYiArIGMyKTsKICAgICAgICAgICAgICBhMy5hLmcuc2V0KHRoaXMuRiwgYiArIGMyLCBhcmd1bWVudHNbMV0pOwogICAgICAgICAgICB9OwogICAgICAgICAgICB2YXIgYyA9IGEzLmEuZy5aKCk7CiAgICAgICAgICAgIGEzLkMuRi5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB2YXIgYjIgPSB0aGlzLkY7CiAgICAgICAgICAgICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFyIGUgPSBhMy5hLmcuZ2V0KGIyLCBjKSB8fCB7fSwgZiA9IGUubGIgfHwgKDMgPT09IHRoaXMuYWIgPyBiMi5jb250ZW50IDogNCA9PT0gdGhpcy5hYiA/IGIyIDogbik7CiAgICAgICAgICAgICAgICBpZiAoIWYgfHwgZS5qZCkgewogICAgICAgICAgICAgICAgICB2YXIgZyA9IHRoaXMudGV4dCgpOwogICAgICAgICAgICAgICAgICBnICYmIGcgIT09IGUuYmIgJiYgKGYgPSBhMy5hLk1kKGcsIGIyLm93bmVyRG9jdW1lbnQpLCBhMy5hLmcuc2V0KGIyLCBjLCB7IGxiOiBmLCBiYjogZywgamQ6IHRydWUgfSkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGY7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGUgPSBhcmd1bWVudHNbMF07CiAgICAgICAgICAgICAgdGhpcy5hYiAhPT0gbiAmJiB0aGlzLnRleHQoIiIpOwogICAgICAgICAgICAgIGEzLmEuZy5zZXQoYjIsIGMsIHsgbGI6IGUgfSk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLkMuaWEgPSBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgIHRoaXMuRiA9IGE0OwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5DLmlhLnByb3RvdHlwZSA9IG5ldyBhMy5DLkYoKTsKICAgICAgICAgICAgYTMuQy5pYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhMy5DLmlhOwogICAgICAgICAgICBhMy5DLmlhLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFyIGIyID0gYTMuYS5nLmdldCh0aGlzLkYsIGMpIHx8IHt9OwogICAgICAgICAgICAgICAgYjIuYmIgPT09IG4gJiYgYjIubGIgJiYgKGIyLmJiID0gYjIubGIuaW5uZXJIVE1MKTsKICAgICAgICAgICAgICAgIHJldHVybiBiMi5iYjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYTMuYS5nLnNldCgKICAgICAgICAgICAgICAgIHRoaXMuRiwKICAgICAgICAgICAgICAgIGMsCiAgICAgICAgICAgICAgICB7IGJiOiBhcmd1bWVudHNbMF0gfQogICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGEzLmIoInRlbXBsYXRlU291cmNlcyIsIGEzLkMpOwogICAgICAgICAgICBhMy5iKCJ0ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCIsIGEzLkMuRik7CiAgICAgICAgICAgIGEzLmIoInRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZSIsIGEzLkMuaWEpOwogICAgICAgICAgfSkoKTsKICAgICAgICAgIChmdW5jdGlvbigpIHsKICAgICAgICAgICAgZnVuY3Rpb24gYihiMiwgYzIsIGQyKSB7CiAgICAgICAgICAgICAgdmFyIGUyOwogICAgICAgICAgICAgIGZvciAoYzIgPSBhMy5oLm5leHRTaWJsaW5nKGMyKTsgYjIgJiYgKGUyID0gYjIpICE9PSBjMjsgKQogICAgICAgICAgICAgICAgYjIgPSBhMy5oLm5leHRTaWJsaW5nKGUyKSwgZDIoZTIsIGIyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBjKGMyLCBkMikgewogICAgICAgICAgICAgIGlmIChjMi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhciBlMiA9IGMyWzBdLCBmMiA9IGMyW2MyLmxlbmd0aCAtIDFdLCBnMiA9IGUyLnBhcmVudE5vZGUsIGgyID0gYTMuZ2EuaW5zdGFuY2UsIG0yID0gaDIucHJlcHJvY2Vzc05vZGU7CiAgICAgICAgICAgICAgICBpZiAobTIpIHsKICAgICAgICAgICAgICAgICAgYihlMiwgZjIsIGZ1bmN0aW9uKGE0LCBiMikgewogICAgICAgICAgICAgICAgICAgIHZhciBjMyA9IGE0LnByZXZpb3VzU2libGluZywgZDMgPSBtMi5jYWxsKGgyLCBhNCk7CiAgICAgICAgICAgICAgICAgICAgZDMgJiYgKGE0ID09PSBlMiAmJiAoZTIgPSBkM1swXSB8fCBiMiksIGE0ID09PSBmMiAmJiAoZjIgPSBkM1tkMy5sZW5ndGggLSAxXSB8fCBjMykpOwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgYzIubGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgICAgaWYgKCFlMikKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICAgIGUyID09PSBmMiA/IGMyLnB1c2goZTIpIDogKGMyLnB1c2goZTIsIGYyKSwgYTMuYS5VYShjMiwgZzIpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGIoZTIsIGYyLCBmdW5jdGlvbihiMikgewogICAgICAgICAgICAgICAgICAxICE9PSBiMi5ub2RlVHlwZSAmJiA4ICE9PSBiMi5ub2RlVHlwZSB8fCBhMy52YyhkMiwgYjIpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBiKGUyLCBmMiwgZnVuY3Rpb24oYjIpIHsKICAgICAgICAgICAgICAgICAgMSAhPT0gYjIubm9kZVR5cGUgJiYgOCAhPT0gYjIubm9kZVR5cGUgfHwgYTMuYWEuY2QoYjIsIFtkMl0pOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBhMy5hLlVhKGMyLCBnMik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGQoYTQpIHsKICAgICAgICAgICAgICByZXR1cm4gYTQubm9kZVR5cGUgPyBhNCA6IDAgPCBhNC5sZW5ndGggPyBhNFswXSA6IG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZShiMiwgZTIsIGYyLCBoMiwgbTIpIHsKICAgICAgICAgICAgICBtMiA9IG0yIHx8IHt9OwogICAgICAgICAgICAgIHZhciBuMiA9IChiMiAmJiBkKGIyKSB8fCBmMiB8fCB7fSkub3duZXJEb2N1bWVudCwgQiA9IG0yLnRlbXBsYXRlRW5naW5lIHx8IGc7CiAgICAgICAgICAgICAgYTMua2MueGQoZjIsIEIsIG4yKTsKICAgICAgICAgICAgICBmMiA9IEIucmVuZGVyVGVtcGxhdGUoZjIsIGgyLCBtMiwgbjIpOwogICAgICAgICAgICAgIGlmICgibnVtYmVyIiAhPSB0eXBlb2YgZjIubGVuZ3RoIHx8IDAgPCBmMi5sZW5ndGggJiYgIm51bWJlciIgIT0gdHlwZW9mIGYyWzBdLm5vZGVUeXBlKQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIlRlbXBsYXRlIGVuZ2luZSBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBET00gbm9kZXMiKTsKICAgICAgICAgICAgICBuMiA9IGZhbHNlOwogICAgICAgICAgICAgIHN3aXRjaCAoZTIpIHsKICAgICAgICAgICAgICAgIGNhc2UgInJlcGxhY2VDaGlsZHJlbiI6CiAgICAgICAgICAgICAgICAgIGEzLmgudmEoCiAgICAgICAgICAgICAgICAgICAgYjIsCiAgICAgICAgICAgICAgICAgICAgZjIKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgbjIgPSB0cnVlOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgInJlcGxhY2VOb2RlIjoKICAgICAgICAgICAgICAgICAgYTMuYS5YYyhiMiwgZjIpOwogICAgICAgICAgICAgICAgICBuMiA9IHRydWU7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAiaWdub3JlVGFyZ2V0Tm9kZSI6CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIlVua25vd24gcmVuZGVyTW9kZTogIiArIGUyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgbjIgJiYgKGMoZjIsIGgyKSwgbTIuYWZ0ZXJSZW5kZXIgJiYgYTMudS5HKG0yLmFmdGVyUmVuZGVyLCBudWxsLCBbZjIsIGgyW20yLmFzIHx8ICIkZGF0YSJdXSksICJyZXBsYWNlQ2hpbGRyZW4iID09IGUyICYmIGEzLmkubWEoYjIsIGEzLmkuSCkpOwogICAgICAgICAgICAgIHJldHVybiBmMjsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBmKGIyLCBjMiwgZDIpIHsKICAgICAgICAgICAgICByZXR1cm4gYTMuTyhiMikgPyBiMigpIDogImZ1bmN0aW9uIiA9PT0gdHlwZW9mIGIyID8gYjIoYzIsIGQyKSA6IGIyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBnOwogICAgICAgICAgICBhMy5nYyA9IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgaWYgKGIyICE9IG4gJiYgIShiMiBpbnN0YW5jZW9mIGEzLmNhKSkKICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCJ0ZW1wbGF0ZUVuZ2luZSBtdXN0IGluaGVyaXQgZnJvbSBrby50ZW1wbGF0ZUVuZ2luZSIpOwogICAgICAgICAgICAgIGcgPSBiMjsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgYTMuZGMgPSBmdW5jdGlvbihiMiwgYzIsIGgyLCBtMiwgdCkgewogICAgICAgICAgICAgIGgyID0gaDIgfHwge307CiAgICAgICAgICAgICAgaWYgKChoMi50ZW1wbGF0ZUVuZ2luZSB8fCBnKSA9PSBuKQogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIlNldCBhIHRlbXBsYXRlIGVuZ2luZSBiZWZvcmUgY2FsbGluZyByZW5kZXJUZW1wbGF0ZSIpOwogICAgICAgICAgICAgIHQgPSB0IHx8ICJyZXBsYWNlQ2hpbGRyZW4iOwogICAgICAgICAgICAgIGlmIChtMikgewogICAgICAgICAgICAgICAgdmFyIHggPSBkKG0yKTsKICAgICAgICAgICAgICAgIHJldHVybiBhMy4kKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB2YXIgZzIgPSBjMiAmJiBjMiBpbnN0YW5jZW9mIGEzLmZhID8gYzIgOiBuZXcgYTMuZmEoYzIsIG51bGwsIG51bGwsIG51bGwsIHsgZXhwb3J0RGVwZW5kZW5jaWVzOiB0cnVlIH0pLCBuMiA9IGYoYjIsIGcyLiRkYXRhLCBnMiksIGcyID0gZShtMiwgdCwgbjIsIGcyLCBoMik7CiAgICAgICAgICAgICAgICAgICJyZXBsYWNlTm9kZSIgPT0gdCAmJiAobTIgPSBnMiwgeCA9IGQobTIpKTsKICAgICAgICAgICAgICAgIH0sIG51bGwsIHsgU2E6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gIXggfHwgIWEzLmEuU2IoeCk7CiAgICAgICAgICAgICAgICB9LCBsOiB4ICYmICJyZXBsYWNlTm9kZSIgPT0gdCA/IHgucGFyZW50Tm9kZSA6IHggfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBhMy5hYS5YYihmdW5jdGlvbihkMikgewogICAgICAgICAgICAgICAgYTMuZGMoYjIsIGMyLCBoMiwgZDIsICJyZXBsYWNlTm9kZSIpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9OwogICAgICAgICAgICBhMy5RZCA9IGZ1bmN0aW9uKGIyLCBkMiwgZzIsIGgyLCBtMikgewogICAgICAgICAgICAgIGZ1bmN0aW9uIHgoYjMsIGMyKSB7CiAgICAgICAgICAgICAgICBhMy51LkcoYTMuYS5lYywgbnVsbCwgW2gyLCBiMywgdTIsIGcyLCByMiwgYzJdKTsKICAgICAgICAgICAgICAgIGEzLmkubWEoaDIsIGEzLmkuSCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGZ1bmN0aW9uIHIyKGE0LCBiMykgewogICAgICAgICAgICAgICAgYyhiMywgdjMpOwogICAgICAgICAgICAgICAgZzIuYWZ0ZXJSZW5kZXIgJiYgZzIuYWZ0ZXJSZW5kZXIoYjMsIGE0KTsKICAgICAgICAgICAgICAgIHYzID0gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZnVuY3Rpb24gdTIoYTQsIGMyKSB7CiAgICAgICAgICAgICAgICB2MyA9IG0yLmNyZWF0ZUNoaWxkQ29udGV4dChhNCwgeyBhczogeiwgbm9DaGlsZENvbnRleHQ6IGcyLm5vQ2hpbGRDb250ZXh0LCBleHRlbmQ6IGZ1bmN0aW9uKGE1KSB7CiAgICAgICAgICAgICAgICAgIGE1LiRpbmRleCA9IGMyOwogICAgICAgICAgICAgICAgICB6ICYmIChhNVt6ICsgIkluZGV4Il0gPSBjMik7CiAgICAgICAgICAgICAgICB9IH0pOwogICAgICAgICAgICAgICAgdmFyIGQzID0gZihiMiwgYTQsIHYzKTsKICAgICAgICAgICAgICAgIHJldHVybiBlKGgyLCAiaWdub3JlVGFyZ2V0Tm9kZSIsIGQzLCB2MywgZzIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgdjMsIHogPSBnMi5hcywgdzIgPSBmYWxzZSA9PT0gZzIuaW5jbHVkZURlc3Ryb3llZCB8fCBhMy5vcHRpb25zLmZvcmVhY2hIaWRlc0Rlc3Ryb3llZCAmJiAhZzIuaW5jbHVkZURlc3Ryb3llZDsKICAgICAgICAgICAgICBpZiAodzIgfHwgZzIuYmVmb3JlUmVtb3ZlIHx8ICFhMy5QYyhkMikpCiAgICAgICAgICAgICAgICByZXR1cm4gYTMuJChmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgdmFyIGIzID0gYTMuYS5mKGQyKSB8fCBbXTsKICAgICAgICAgICAgICAgICAgInVuZGVmaW5lZCIgPT0gdHlwZW9mIGIzLmxlbmd0aCAmJiAoYjMgPSBbYjNdKTsKICAgICAgICAgICAgICAgICAgdzIgJiYgKGIzID0gYTMuYS5qYihiMywgZnVuY3Rpb24oYjQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYjQgPT09IG4gfHwgbnVsbCA9PT0gYjQgfHwgIWEzLmEuZihiNC5fZGVzdHJveSk7CiAgICAgICAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgICAgICAgeChiMyk7CiAgICAgICAgICAgICAgICB9LCBudWxsLCB7IGw6IGgyIH0pOwogICAgICAgICAgICAgIHgoZDIudigpKTsKICAgICAgICAgICAgICB2YXIgQTIgPSBkMi5zdWJzY3JpYmUoZnVuY3Rpb24oYTQpIHsKICAgICAgICAgICAgICAgIHgoZDIoKSwgYTQpOwogICAgICAgICAgICAgIH0sIG51bGwsICJhcnJheUNoYW5nZSIpOwogICAgICAgICAgICAgIEEyLmwoaDIpOwogICAgICAgICAgICAgIHJldHVybiBBMjsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgdmFyIGggPSBhMy5hLmcuWigpLCBtID0gYTMuYS5nLlooKTsKICAgICAgICAgICAgYTMuYy50ZW1wbGF0ZSA9IHsgaW5pdDogZnVuY3Rpb24oYjIsIGMyKSB7CiAgICAgICAgICAgICAgdmFyIGQyID0gYTMuYS5mKGMyKCkpOwogICAgICAgICAgICAgIGlmICgic3RyaW5nIiA9PSB0eXBlb2YgZDIgfHwgIm5hbWUiIGluIGQyKQogICAgICAgICAgICAgICAgYTMuaC5FYShiMik7CiAgICAgICAgICAgICAgZWxzZSBpZiAoIm5vZGVzIiBpbiBkMikgewogICAgICAgICAgICAgICAgZDIgPSBkMi5ub2RlcyB8fCBbXTsKICAgICAgICAgICAgICAgIGlmIChhMy5PKGQyKSkKICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSAibm9kZXMiIG9wdGlvbiBtdXN0IGJlIGEgcGxhaW4sIG5vbi1vYnNlcnZhYmxlIGFycmF5LicpOwogICAgICAgICAgICAgICAgdmFyIGUyID0gZDJbMF0gJiYgZDJbMF0ucGFyZW50Tm9kZTsKICAgICAgICAgICAgICAgIGUyICYmIGEzLmEuZy5nZXQoZTIsIG0pIHx8IChlMiA9IGEzLmEuWWIoZDIpLCBhMy5hLmcuc2V0KGUyLCBtLCB0cnVlKSk7CiAgICAgICAgICAgICAgICBuZXcgYTMuQy5pYShiMikubm9kZXMoZTIpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPSBhMy5oLmNoaWxkTm9kZXMoYjIpLCAwIDwgZDIubGVuZ3RoKQogICAgICAgICAgICAgICAgZTIgPSBhMy5hLlliKGQyKSwgbmV3IGEzLkMuaWEoYjIpLm5vZGVzKGUyKTsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiQW5vbnltb3VzIHRlbXBsYXRlIGRlZmluZWQsIGJ1dCBubyB0ZW1wbGF0ZSBjb250ZW50IHdhcyBwcm92aWRlZCIpOwogICAgICAgICAgICAgIHJldHVybiB7IGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlIH07CiAgICAgICAgICAgIH0sIHVwZGF0ZTogZnVuY3Rpb24oYjIsIGMyLCBkMiwgZTIsIGYyKSB7CiAgICAgICAgICAgICAgdmFyIGcyID0gYzIoKTsKICAgICAgICAgICAgICBjMiA9IGEzLmEuZihnMik7CiAgICAgICAgICAgICAgZDIgPSB0cnVlOwogICAgICAgICAgICAgIGUyID0gbnVsbDsKICAgICAgICAgICAgICAic3RyaW5nIiA9PSB0eXBlb2YgYzIgPyBjMiA9IHt9IDogKGcyID0gIm5hbWUiIGluIGMyID8gYzIubmFtZSA6IGIyLCAiaWYiIGluIGMyICYmIChkMiA9IGEzLmEuZihjMlsiaWYiXSkpLCBkMiAmJiAiaWZub3QiIGluIGMyICYmIChkMiA9ICFhMy5hLmYoYzIuaWZub3QpKSwgZDIgJiYgIWcyICYmIChkMiA9IGZhbHNlKSk7CiAgICAgICAgICAgICAgImZvcmVhY2giIGluIGMyID8gZTIgPSBhMy5RZChnMiwgZDIgJiYgYzIuZm9yZWFjaCB8fCBbXSwgYzIsIGIyLCBmMikgOiBkMiA/IChkMiA9IGYyLCAiZGF0YSIgaW4gYzIgJiYgKGQyID0gZjIuY3JlYXRlQ2hpbGRDb250ZXh0KGMyLmRhdGEsIHsgYXM6IGMyLmFzLCBub0NoaWxkQ29udGV4dDogYzIubm9DaGlsZENvbnRleHQsIGV4cG9ydERlcGVuZGVuY2llczogdHJ1ZSB9KSksIGUyID0gYTMuZGMoZzIsIGQyLCBjMiwgYjIpKSA6IGEzLmguRWEoYjIpOwogICAgICAgICAgICAgIGYyID0gZTI7CiAgICAgICAgICAgICAgKGMyID0gYTMuYS5nLmdldChiMiwgaCkpICYmICJmdW5jdGlvbiIgPT0gdHlwZW9mIGMyLnMgJiYgYzIucygpOwogICAgICAgICAgICAgIGEzLmEuZy5zZXQoYjIsIGgsICFmMiB8fCBmMi5qYSAmJiAhZjIuamEoKSA/IG4gOiBmMik7CiAgICAgICAgICAgIH0gfTsKICAgICAgICAgICAgYTMubS5SYS50ZW1wbGF0ZSA9IGZ1bmN0aW9uKGIyKSB7CiAgICAgICAgICAgICAgYjIgPSBhMy5tLmFjKGIyKTsKICAgICAgICAgICAgICByZXR1cm4gMSA9PSBiMi5sZW5ndGggJiYgYjJbMF0udW5rbm93biB8fCBhMy5tLklkKGIyLCAibmFtZSIpID8gbnVsbCA6ICJUaGlzIHRlbXBsYXRlIGVuZ2luZSBkb2VzIG5vdCBzdXBwb3J0IGFub255bW91cyB0ZW1wbGF0ZXMgbmVzdGVkIHdpdGhpbiBpdHMgdGVtcGxhdGVzIjsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgYTMuaC5lYS50ZW1wbGF0ZSA9IHRydWU7CiAgICAgICAgICB9KSgpOwogICAgICAgICAgYTMuYigic2V0VGVtcGxhdGVFbmdpbmUiLCBhMy5nYyk7CiAgICAgICAgICBhMy5iKCJyZW5kZXJUZW1wbGF0ZSIsIGEzLmRjKTsKICAgICAgICAgIGEzLmEuS2MgPSBmdW5jdGlvbihhNCwgYywgZCkgewogICAgICAgICAgICBpZiAoYTQubGVuZ3RoICYmIGMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgdmFyIGUsIGYsIGcsIGgsIG07CiAgICAgICAgICAgICAgZm9yIChlID0gZiA9IDA7ICghZCB8fCBlIDwgZCkgJiYgKGggPSBhNFtmXSk7ICsrZikgewogICAgICAgICAgICAgICAgZm9yIChnID0gMDsgbSA9IGNbZ107ICsrZykKICAgICAgICAgICAgICAgICAgaWYgKGgudmFsdWUgPT09IG0udmFsdWUpIHsKICAgICAgICAgICAgICAgICAgICBoLm1vdmVkID0gbS5pbmRleDsKICAgICAgICAgICAgICAgICAgICBtLm1vdmVkID0gaC5pbmRleDsKICAgICAgICAgICAgICAgICAgICBjLnNwbGljZShnLCAxKTsKICAgICAgICAgICAgICAgICAgICBlID0gZyA9IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGUgKz0gZzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBhMy5hLlBiID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYjIsIGQsIGUsIGYsIGcpIHsKICAgICAgICAgICAgICB2YXIgaCA9IE1hdGgubWluLCBtID0gTWF0aC5tYXgsIGsgPSBbXSwgbCwgcCA9IGIyLmxlbmd0aCwgcSwgbjIgPSBkLmxlbmd0aCwgcjIgPSBuMiAtIHAgfHwgMSwgdjMgPSBwICsgbjIgKyAxLCB1MiwgdzIsIHo7CiAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8PSBwOyBsKyspCiAgICAgICAgICAgICAgICBmb3IgKHcyID0gdTIsIGsucHVzaCh1MiA9IFtdKSwgeiA9IGgobjIsIGwgKyByMiksIHEgPSBtKDAsIGwgLSAxKTsgcSA8PSB6OyBxKyspCiAgICAgICAgICAgICAgICAgIHUyW3FdID0gcSA/IGwgPyBiMltsIC0gMV0gPT09IGRbcSAtIDFdID8gdzJbcSAtIDFdIDogaCh3MltxXSB8fCB2MywgdTJbcSAtIDFdIHx8IHYzKSArIDEgOiBxICsgMSA6IGwgKyAxOwogICAgICAgICAgICAgIGggPSBbXTsKICAgICAgICAgICAgICBtID0gW107CiAgICAgICAgICAgICAgcjIgPSBbXTsKICAgICAgICAgICAgICBsID0gcDsKICAgICAgICAgICAgICBmb3IgKHEgPSBuMjsgbCB8fCBxOyApCiAgICAgICAgICAgICAgICBuMiA9IGtbbF1bcV0gLSAxLCBxICYmIG4yID09PSBrW2xdW3EgLSAxXSA/IG0ucHVzaChoW2gubGVuZ3RoXSA9IHsgc3RhdHVzOiBlLCB2YWx1ZTogZFstLXFdLCBpbmRleDogcSB9KSA6IGwgJiYgbjIgPT09IGtbbCAtIDFdW3FdID8gcjIucHVzaChoW2gubGVuZ3RoXSA9IHsgc3RhdHVzOiBmLCB2YWx1ZTogYjJbLS1sXSwgaW5kZXg6IGwgfSkgOiAoLS1xLCAtLWwsIGcuc3BhcnNlIHx8IGgucHVzaCh7IHN0YXR1czogInJldGFpbmVkIiwgdmFsdWU6IGRbcV0gfSkpOwogICAgICAgICAgICAgIGEzLmEuS2MocjIsIG0sICFnLmRvbnRMaW1pdE1vdmVzICYmIDEwICogcCk7CiAgICAgICAgICAgICAgcmV0dXJuIGgucmV2ZXJzZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhNCwgZCwgZSkgewogICAgICAgICAgICAgIGUgPSAiYm9vbGVhbiIgPT09IHR5cGVvZiBlID8geyBkb250TGltaXRNb3ZlczogZSB9IDogZSB8fCB7fTsKICAgICAgICAgICAgICBhNCA9IGE0IHx8IFtdOwogICAgICAgICAgICAgIGQgPSBkIHx8IFtdOwogICAgICAgICAgICAgIHJldHVybiBhNC5sZW5ndGggPCBkLmxlbmd0aCA/IGIoYTQsIGQsICJhZGRlZCIsICJkZWxldGVkIiwgZSkgOiBiKGQsIGE0LCAiZGVsZXRlZCIsICJhZGRlZCIsIGUpOwogICAgICAgICAgICB9OwogICAgICAgICAgfSgpOwogICAgICAgICAgYTMuYigidXRpbHMuY29tcGFyZUFycmF5cyIsIGEzLmEuUGIpOwogICAgICAgICAgKGZ1bmN0aW9uKCkgewogICAgICAgICAgICBmdW5jdGlvbiBiKGIyLCBjMiwgZDIsIGgsIG0pIHsKICAgICAgICAgICAgICB2YXIgayA9IFtdLCBsID0gYTMuJChmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHZhciBsMiA9IGMyKGQyLCBtLCBhMy5hLlVhKGssIGIyKSkgfHwgW107CiAgICAgICAgICAgICAgICAwIDwgay5sZW5ndGggJiYgKGEzLmEuWGMoaywgbDIpLCBoICYmIGEzLnUuRyhoLCBudWxsLCBbZDIsIGwyLCBtXSkpOwogICAgICAgICAgICAgICAgay5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgYTMuYS5OYihrLCBsMik7CiAgICAgICAgICAgICAgfSwgbnVsbCwgeyBsOiBiMiwgU2E6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuICFhMy5hLmtkKGspOwogICAgICAgICAgICAgIH0gfSk7CiAgICAgICAgICAgICAgcmV0dXJuIHsgWTogaywgJDogbC5qYSgpID8gbCA6IG4gfTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgYyA9IGEzLmEuZy5aKCksIGQgPSBhMy5hLmcuWigpOwogICAgICAgICAgICBhMy5hLmVjID0gZnVuY3Rpb24oZSwgZiwgZywgaCwgbSwgaykgewogICAgICAgICAgICAgIGZ1bmN0aW9uIGwoYjIpIHsKICAgICAgICAgICAgICAgIHkgPSB7IEFhOiBiMiwgcGI6IGEzLnRhKHcyKyspIH07CiAgICAgICAgICAgICAgICB2My5wdXNoKHkpOwogICAgICAgICAgICAgICAgcjIgfHwgRjIucHVzaCh5KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZnVuY3Rpb24gcChiMikgewogICAgICAgICAgICAgICAgeSA9IHRbYjJdOwogICAgICAgICAgICAgICAgdzIgIT09IHkucGIudigpICYmIEQyLnB1c2goeSk7CiAgICAgICAgICAgICAgICB5LnBiKHcyKyspOwogICAgICAgICAgICAgICAgYTMuYS5VYSh5LlksIGUpOwogICAgICAgICAgICAgICAgdjMucHVzaCh5KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZnVuY3Rpb24gcShiMiwgYzIpIHsKICAgICAgICAgICAgICAgIGlmIChiMikKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwLCBlMiA9IGMyLmxlbmd0aDsgZDIgPCBlMjsgZDIrKykKICAgICAgICAgICAgICAgICAgICBhMy5hLkQoYzJbZDJdLlksIGZ1bmN0aW9uKGE0KSB7CiAgICAgICAgICAgICAgICAgICAgICBiMihhNCwgZDIsIGMyW2QyXS5BYSk7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGYgPSBmIHx8IFtdOwogICAgICAgICAgICAgICJ1bmRlZmluZWQiID09IHR5cGVvZiBmLmxlbmd0aCAmJiAoZiA9IFtmXSk7CiAgICAgICAgICAgICAgaCA9IGggfHwge307CiAgICAgICAgICAgICAgdmFyIHQgPSBhMy5hLmcuZ2V0KGUsIGMpLCByMiA9ICF0LCB2MyA9IFtdLCB1MiA9IDAsIHcyID0gMCwgeiA9IFtdLCBBMiA9IFtdLCBDMiA9IFtdLCBEMiA9IFtdLCBGMiA9IFtdLCB5LCBJMiA9IDA7CiAgICAgICAgICAgICAgaWYgKHIyKQogICAgICAgICAgICAgICAgYTMuYS5EKGYsIGwpOwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgaWYgKCFrIHx8IHQgJiYgdC5fY291bnRXYWl0aW5nRm9yUmVtb3ZlKSB7CiAgICAgICAgICAgICAgICAgIHZhciBFID0gYTMuYS5NYih0LCBmdW5jdGlvbihhNCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBhNC5BYTsKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIGsgPSBhMy5hLlBiKEUsIGYsIHsgZG9udExpbWl0TW92ZXM6IGguZG9udExpbWl0TW92ZXMsIHNwYXJzZTogdHJ1ZSB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZvciAodmFyIEUgPSAwLCBHMiwgSDIsIEsyOyBHMiA9IGtbRV07IEUrKykKICAgICAgICAgICAgICAgICAgc3dpdGNoIChIMiA9IEcyLm1vdmVkLCBLMiA9IEcyLmluZGV4LCBHMi5zdGF0dXMpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlICJkZWxldGVkIjoKICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyB1MiA8IEsyOyApCiAgICAgICAgICAgICAgICAgICAgICAgIHAodTIrKyk7CiAgICAgICAgICAgICAgICAgICAgICBIMiA9PT0gbiAmJiAoeSA9IHRbdTJdLCB5LiQgJiYgKHkuJC5zKCksIHkuJCA9IG4pLCBhMy5hLlVhKHkuWSwgZSkubGVuZ3RoICYmIChoLmJlZm9yZVJlbW92ZSAmJiAodjMucHVzaCh5KSwgSTIrKywgeS5BYSA9PT0gZCA/IHkgPSBudWxsIDogQzIucHVzaCh5KSksIHkgJiYgei5wdXNoLmFwcGx5KHosIHkuWSkpKTsKICAgICAgICAgICAgICAgICAgICAgIHUyKys7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlICJhZGRlZCI6CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdzIgPCBLMjsgKQogICAgICAgICAgICAgICAgICAgICAgICBwKHUyKyspOwogICAgICAgICAgICAgICAgICAgICAgSDIgIT09IG4gPyAoQTIucHVzaCh2My5sZW5ndGgpLCBwKEgyKSkgOiBsKEcyLnZhbHVlKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZm9yICg7IHcyIDwgZi5sZW5ndGg7ICkKICAgICAgICAgICAgICAgICAgcCh1MisrKTsKICAgICAgICAgICAgICAgIHYzLl9jb3VudFdhaXRpbmdGb3JSZW1vdmUgPSBJMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYTMuYS5nLnNldChlLCBjLCB2Myk7CiAgICAgICAgICAgICAgcShoLmJlZm9yZU1vdmUsIEQyKTsKICAgICAgICAgICAgICBhMy5hLkQoCiAgICAgICAgICAgICAgICB6LAogICAgICAgICAgICAgICAgaC5iZWZvcmVSZW1vdmUgPyBhMy5vYSA6IGEzLnJlbW92ZU5vZGUKICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIHZhciBNLCBPLCBQOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBQID0gZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7CiAgICAgICAgICAgICAgfSBjYXRjaCAoTjIpIHsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKEEyLmxlbmd0aCkKICAgICAgICAgICAgICAgIGZvciAoOyAoRSA9IEEyLnNoaWZ0KCkpICE9IG47ICkgewogICAgICAgICAgICAgICAgICB5ID0gdjNbRV07CiAgICAgICAgICAgICAgICAgIGZvciAoTSA9IG47IEU7ICkKICAgICAgICAgICAgICAgICAgICBpZiAoKE8gPSB2M1stLUVdLlkpICYmIE8ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICBNID0gT1tPLmxlbmd0aCAtIDFdOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBmb3IgKGYgPSAwOyB1MiA9IHkuWVtmXTsgTSA9IHUyLCBmKyspCiAgICAgICAgICAgICAgICAgICAgYTMuaC5XYihlLCB1MiwgTSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZm9yIChFID0gMDsgeSA9IHYzW0VdOyBFKyspIHsKICAgICAgICAgICAgICAgIHkuWSB8fCBhMy5hLmV4dGVuZCh5LCBiKGUsIGcsIHkuQWEsIG0sIHkucGIpKTsKICAgICAgICAgICAgICAgIGZvciAoZiA9IDA7IHUyID0geS5ZW2ZdOyBNID0gdTIsIGYrKykKICAgICAgICAgICAgICAgICAgYTMuaC5XYihlLCB1MiwgTSk7CiAgICAgICAgICAgICAgICAheS5FZCAmJiBtICYmIChtKHkuQWEsIHkuWSwgeS5wYiksIHkuRWQgPSB0cnVlLCBNID0geS5ZW3kuWS5sZW5ndGggLSAxXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIFAgJiYgZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gUCAmJiBQLmZvY3VzKCk7CiAgICAgICAgICAgICAgcShoLmJlZm9yZVJlbW92ZSwgQzIpOwogICAgICAgICAgICAgIGZvciAoRSA9IDA7IEUgPCBDMi5sZW5ndGg7ICsrRSkKICAgICAgICAgICAgICAgIEMyW0VdLkFhID0gZDsKICAgICAgICAgICAgICBxKGguYWZ0ZXJNb3ZlLCBEMik7CiAgICAgICAgICAgICAgcShoLmFmdGVyQWRkLCBGMik7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9KSgpOwogICAgICAgICAgYTMuYigidXRpbHMuc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyIsIGEzLmEuZWMpOwogICAgICAgICAgYTMuYmEgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdGhpcy5hbGxvd1RlbXBsYXRlUmV3cml0aW5nID0gZmFsc2U7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuYmEucHJvdG90eXBlID0gbmV3IGEzLmNhKCk7CiAgICAgICAgICBhMy5iYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhMy5iYTsKICAgICAgICAgIGEzLmJhLnByb3RvdHlwZS5yZW5kZXJUZW1wbGF0ZVNvdXJjZSA9IGZ1bmN0aW9uKGIsIGMsIGQsIGUpIHsKICAgICAgICAgICAgaWYgKGMgPSAoOSA+IGEzLmEuVyA/IDAgOiBiLm5vZGVzKSA/IGIubm9kZXMoKSA6IG51bGwpCiAgICAgICAgICAgICAgcmV0dXJuIGEzLmEubGEoYy5jbG9uZU5vZGUodHJ1ZSkuY2hpbGROb2Rlcyk7CiAgICAgICAgICAgIGIgPSBiLnRleHQoKTsKICAgICAgICAgICAgcmV0dXJuIGEzLmEudWEoYiwgZSk7CiAgICAgICAgICB9OwogICAgICAgICAgYTMuYmEuTWEgPSBuZXcgYTMuYmEoKTsKICAgICAgICAgIGEzLmdjKGEzLmJhLk1hKTsKICAgICAgICAgIGEzLmIoIm5hdGl2ZVRlbXBsYXRlRW5naW5lIiwgYTMuYmEpOwogICAgICAgICAgKGZ1bmN0aW9uKCkgewogICAgICAgICAgICBhMy4kYSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHZhciBhNCA9IHRoaXMuSGQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGlmICghdjIgfHwgIXYyLnRtcGwpCiAgICAgICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gdjIudG1wbC50YWcudG1wbC5vcGVuLnRvU3RyaW5nKCkuaW5kZXhPZigiX18iKSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGE1KSB7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgICAgICB9KCk7CiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUZW1wbGF0ZVNvdXJjZSA9IGZ1bmN0aW9uKGIyLCBlLCBmLCBnKSB7CiAgICAgICAgICAgICAgICBnID0gZyB8fCB3OwogICAgICAgICAgICAgICAgZiA9IGYgfHwge307CiAgICAgICAgICAgICAgICBpZiAoMiA+IGE0KQogICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigiWW91ciB2ZXJzaW9uIG9mIGpRdWVyeS50bXBsIGlzIHRvbyBvbGQuIFBsZWFzZSB1cGdyYWRlIHRvIGpRdWVyeS50bXBsIDEuMC4wcHJlIG9yIGxhdGVyLiIpOwogICAgICAgICAgICAgICAgdmFyIGggPSBiMi5kYXRhKCJwcmVjb21waWxlZCIpOwogICAgICAgICAgICAgICAgaCB8fCAoaCA9IGIyLnRleHQoKSB8fCAiIiwgaCA9IHYyLnRlbXBsYXRlKG51bGwsICJ7e2tvX3dpdGggJGl0ZW0ua29CaW5kaW5nQ29udGV4dH19IiArIGggKyAie3sva29fd2l0aH19IiksIGIyLmRhdGEoInByZWNvbXBpbGVkIiwgaCkpOwogICAgICAgICAgICAgICAgYjIgPSBbZS4kZGF0YV07CiAgICAgICAgICAgICAgICBlID0gdjIuZXh0ZW5kKHsga29CaW5kaW5nQ29udGV4dDogZSB9LCBmLnRlbXBsYXRlT3B0aW9ucyk7CiAgICAgICAgICAgICAgICBlID0gdjIudG1wbChoLCBiMiwgZSk7CiAgICAgICAgICAgICAgICBlLmFwcGVuZFRvKGcuY3JlYXRlRWxlbWVudCgiZGl2IikpOwogICAgICAgICAgICAgICAgdjIuZnJhZ21lbnRzID0ge307CiAgICAgICAgICAgICAgICByZXR1cm4gZTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHRoaXMuY3JlYXRlSmF2YVNjcmlwdEV2YWx1YXRvckJsb2NrID0gZnVuY3Rpb24oYTUpIHsKICAgICAgICAgICAgICAgIHJldHVybiAie3trb19jb2RlICgoZnVuY3Rpb24oKSB7IHJldHVybiAiICsgYTUgKyAiIH0pKCkpIH19IjsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHRoaXMuYWRkVGVtcGxhdGUgPSBmdW5jdGlvbihhNSwgYjIpIHsKICAgICAgICAgICAgICAgIHcud3JpdGUoIjxzY3JpcHQgdHlwZT0ndGV4dC9odG1sJyBpZD0nIiArIGE1ICsgIic+IiArIGIyICsgIjxcL3NjcmlwdD4iKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIDAgPCBhNCAmJiAodjIudG1wbC50YWcua29fY29kZSA9IHsgb3BlbjogIl9fLnB1c2goJDEgfHwgJycpOyIgfSwgdjIudG1wbC50YWcua29fd2l0aCA9IHsgb3BlbjogIndpdGgoJDEpIHsiLCBjbG9zZTogIn0gIiB9KTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgYTMuJGEucHJvdG90eXBlID0gbmV3IGEzLmNhKCk7CiAgICAgICAgICAgIGEzLiRhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGEzLiRhOwogICAgICAgICAgICB2YXIgYiA9IG5ldyBhMy4kYSgpOwogICAgICAgICAgICAwIDwgYi5IZCAmJiBhMy5nYyhiKTsKICAgICAgICAgICAgYTMuYigianF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lIiwgYTMuJGEpOwogICAgICAgICAgfSkoKTsKICAgICAgICB9KTsKICAgICAgfSkoKTsKICAgIH0pKCk7CiAgfSkoKTsKICB2YXIga25vY2tvdXQgPSBrbzsKICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIpIHsKICAgIGtvID0gd2luZG93LmtvOwogICAgaWYgKHR5cGVvZiBvbGRWYWx1ZSAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgd2luZG93LmtvID0gb2xkVmFsdWU7CiAgICB9IGVsc2UgewogICAgICBkZWxldGUgd2luZG93LmtvOwogICAgfQogIH0gZWxzZSB7CiAgICBrbyA9IGdsb2JhbC5rbzsKICAgIGlmICh0eXBlb2Ygb2xkVmFsdWUgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgIGdsb2JhbC5rbyA9IG9sZFZhbHVlOwogICAgfSBlbHNlIHsKICAgICAgZGVsZXRlIGdsb2JhbC5rbzsKICAgIH0KICB9CiAgdmFyIGtub2Nrb3V0XzNfNV8xX2RlZmF1bHQgPSBrbm9ja291dDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2lzdHJ5Lm5wbW1pcnJvci5jb20rY2VzaXVtQDEuOTkuMC9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9UaGlyZFBhcnR5L2tub2Nrb3V0LWVzNS5qcwogIHZhciBPQlNFUlZBQkxFU19QUk9QRVJUWSA9ICJfX2tub2Nrb3V0T2JzZXJ2YWJsZXMiOwogIHZhciBTVUJTQ1JJQkFCTEVfUFJPUEVSVFkgPSAiX19rbm9ja291dFN1YnNjcmliYWJsZSI7CiAgZnVuY3Rpb24gdHJhY2sob2JqLCBwcm9wZXJ0eU5hbWVzKSB7CiAgICBpZiAoIW9iaikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIldoZW4gY2FsbGluZyBrby50cmFjaywgeW91IG11c3QgcGFzcyBhbiBvYmplY3QgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4iKTsKICAgIH0KICAgIHZhciBrbzIgPSB0aGlzLCBhbGxPYnNlcnZhYmxlc0Zvck9iamVjdCA9IGdldEFsbE9ic2VydmFibGVzRm9yT2JqZWN0KG9iaiwgdHJ1ZSk7CiAgICBwcm9wZXJ0eU5hbWVzID0gcHJvcGVydHlOYW1lcyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopOwogICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5TmFtZSkgewogICAgICBpZiAocHJvcGVydHlOYW1lID09PSBPQlNFUlZBQkxFU19QUk9QRVJUWSB8fCBwcm9wZXJ0eU5hbWUgPT09IFNVQlNDUklCQUJMRV9QUk9QRVJUWSkgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBpZiAocHJvcGVydHlOYW1lIGluIGFsbE9ic2VydmFibGVzRm9yT2JqZWN0KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIHZhciBvcmlnVmFsdWUgPSBvYmpbcHJvcGVydHlOYW1lXSwgaXNBcnJheSA9IG9yaWdWYWx1ZSBpbnN0YW5jZW9mIEFycmF5LCBvYnNlcnZhYmxlID0ga28yLmlzT2JzZXJ2YWJsZShvcmlnVmFsdWUpID8gb3JpZ1ZhbHVlIDogaXNBcnJheSA/IGtvMi5vYnNlcnZhYmxlQXJyYXkob3JpZ1ZhbHVlKSA6IGtvMi5vYnNlcnZhYmxlKG9yaWdWYWx1ZSk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSwgewogICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogb2JzZXJ2YWJsZSwKICAgICAgICBzZXQ6IGtvMi5pc1dyaXRlYWJsZU9ic2VydmFibGUob2JzZXJ2YWJsZSkgPyBvYnNlcnZhYmxlIDogdm9pZCAwCiAgICAgIH0pOwogICAgICBhbGxPYnNlcnZhYmxlc0Zvck9iamVjdFtwcm9wZXJ0eU5hbWVdID0gb2JzZXJ2YWJsZTsKICAgICAgaWYgKGlzQXJyYXkpIHsKICAgICAgICBub3RpZnlXaGVuUHJlc2VudE9yRnV0dXJlQXJyYXlWYWx1ZXNNdXRhdGUoa28yLCBvYnNlcnZhYmxlKTsKICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gb2JqOwogIH0KICBmdW5jdGlvbiBnZXRBbGxPYnNlcnZhYmxlc0Zvck9iamVjdChvYmosIGNyZWF0ZUlmTm90RGVmaW5lZCkgewogICAgdmFyIHJlc3VsdCA9IG9ialtPQlNFUlZBQkxFU19QUk9QRVJUWV07CiAgICBpZiAoIXJlc3VsdCAmJiBjcmVhdGVJZk5vdERlZmluZWQpIHsKICAgICAgcmVzdWx0ID0ge307CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIE9CU0VSVkFCTEVTX1BST1BFUlRZLCB7CiAgICAgICAgdmFsdWU6IHJlc3VsdAogICAgICB9KTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIGZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUsIGV2YWx1YXRvck9yT3B0aW9ucykgewogICAgdmFyIGtvMiA9IHRoaXMsIGNvbXB1dGVkT3B0aW9ucyA9IHsgb3duZXI6IG9iaiwgZGVmZXJFdmFsdWF0aW9uOiB0cnVlIH07CiAgICBpZiAodHlwZW9mIGV2YWx1YXRvck9yT3B0aW9ucyA9PT0gImZ1bmN0aW9uIikgewogICAgICBjb21wdXRlZE9wdGlvbnMucmVhZCA9IGV2YWx1YXRvck9yT3B0aW9uczsKICAgIH0gZWxzZSB7CiAgICAgIGlmICgidmFsdWUiIGluIGV2YWx1YXRvck9yT3B0aW9ucykgewogICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGtvLmRlZmluZVByb3BlcnR5LCB5b3UgbXVzdCBub3Qgc3BlY2lmeSBhICJ2YWx1ZSIgZm9yIHRoZSBwcm9wZXJ0eS4gWW91IG11c3QgcHJvdmlkZSBhICJnZXQiIGZ1bmN0aW9uLicpOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgZXZhbHVhdG9yT3JPcHRpb25zLmdldCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGtvLmRlZmluZVByb3BlcnR5LCB0aGUgdGhpcmQgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIGFuIGV2YWx1YXRvciBmdW5jdGlvbiwgb3IgYW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBhIGZ1bmN0aW9uIGNhbGxlZCAiZ2V0Ii4nKTsKICAgICAgfQogICAgICBjb21wdXRlZE9wdGlvbnMucmVhZCA9IGV2YWx1YXRvck9yT3B0aW9ucy5nZXQ7CiAgICAgIGNvbXB1dGVkT3B0aW9ucy53cml0ZSA9IGV2YWx1YXRvck9yT3B0aW9ucy5zZXQ7CiAgICB9CiAgICBvYmpbcHJvcGVydHlOYW1lXSA9IGtvMi5jb21wdXRlZChjb21wdXRlZE9wdGlvbnMpOwogICAgdHJhY2suY2FsbChrbzIsIG9iaiwgW3Byb3BlcnR5TmFtZV0pOwogICAgcmV0dXJuIG9iajsKICB9CiAgZnVuY3Rpb24gbm90aWZ5V2hlblByZXNlbnRPckZ1dHVyZUFycmF5VmFsdWVzTXV0YXRlKGtvMiwgb2JzZXJ2YWJsZSkgewogICAgdmFyIHdhdGNoaW5nQXJyYXlTdWJzY3JpcHRpb24gPSBudWxsOwogICAga28yLmNvbXB1dGVkKGZ1bmN0aW9uKCkgewogICAgICBpZiAod2F0Y2hpbmdBcnJheVN1YnNjcmlwdGlvbikgewogICAgICAgIHdhdGNoaW5nQXJyYXlTdWJzY3JpcHRpb24uZGlzcG9zZSgpOwogICAgICAgIHdhdGNoaW5nQXJyYXlTdWJzY3JpcHRpb24gPSBudWxsOwogICAgICB9CiAgICAgIHZhciBuZXdBcnJheUluc3RhbmNlID0gb2JzZXJ2YWJsZSgpOwogICAgICBpZiAobmV3QXJyYXlJbnN0YW5jZSBpbnN0YW5jZW9mIEFycmF5KSB7CiAgICAgICAgd2F0Y2hpbmdBcnJheVN1YnNjcmlwdGlvbiA9IHN0YXJ0V2F0Y2hpbmdBcnJheUluc3RhbmNlKGtvMiwgb2JzZXJ2YWJsZSwgbmV3QXJyYXlJbnN0YW5jZSk7CiAgICAgIH0KICAgIH0pOwogIH0KICBmdW5jdGlvbiBzdGFydFdhdGNoaW5nQXJyYXlJbnN0YW5jZShrbzIsIG9ic2VydmFibGUsIGFycmF5SW5zdGFuY2UpIHsKICAgIHZhciBzdWJzY3JpYmFibGUgPSBnZXRTdWJzY3JpYmFibGVGb3JBcnJheShrbzIsIGFycmF5SW5zdGFuY2UpOwogICAgcmV0dXJuIHN1YnNjcmliYWJsZS5zdWJzY3JpYmUob2JzZXJ2YWJsZSk7CiAgfQogIGZ1bmN0aW9uIGdldFN1YnNjcmliYWJsZUZvckFycmF5KGtvMiwgYXJyYXlJbnN0YW5jZSkgewogICAgdmFyIHN1YnNjcmliYWJsZSA9IGFycmF5SW5zdGFuY2VbU1VCU0NSSUJBQkxFX1BST1BFUlRZXTsKICAgIGlmICghc3Vic2NyaWJhYmxlKSB7CiAgICAgIHN1YnNjcmliYWJsZSA9IG5ldyBrbzIuc3Vic2NyaWJhYmxlKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheUluc3RhbmNlLCBTVUJTQ1JJQkFCTEVfUFJPUEVSVFksIHsKICAgICAgICB2YWx1ZTogc3Vic2NyaWJhYmxlCiAgICAgIH0pOwogICAgICB2YXIgbm90aWZpY2F0aW9uUGF1c2VTaWduYWwgPSB7fTsKICAgICAgd3JhcFN0YW5kYXJkQXJyYXlNdXRhdG9ycyhhcnJheUluc3RhbmNlLCBzdWJzY3JpYmFibGUsIG5vdGlmaWNhdGlvblBhdXNlU2lnbmFsKTsKICAgICAgYWRkS25vY2tvdXRBcnJheU11dGF0b3JzKGtvMiwgYXJyYXlJbnN0YW5jZSwgc3Vic2NyaWJhYmxlLCBub3RpZmljYXRpb25QYXVzZVNpZ25hbCk7CiAgICB9CiAgICByZXR1cm4gc3Vic2NyaWJhYmxlOwogIH0KICBmdW5jdGlvbiB3cmFwU3RhbmRhcmRBcnJheU11dGF0b3JzKGFycmF5SW5zdGFuY2UsIHN1YnNjcmliYWJsZSwgbm90aWZpY2F0aW9uUGF1c2VTaWduYWwpIHsKICAgIFsicG9wIiwgInB1c2giLCAicmV2ZXJzZSIsICJzaGlmdCIsICJzb3J0IiwgInNwbGljZSIsICJ1bnNoaWZ0Il0uZm9yRWFjaChmdW5jdGlvbihmbk5hbWUpIHsKICAgICAgdmFyIG9yaWdNdXRhdG9yID0gYXJyYXlJbnN0YW5jZVtmbk5hbWVdOwogICAgICBhcnJheUluc3RhbmNlW2ZuTmFtZV0gPSBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ011dGF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICBpZiAobm90aWZpY2F0aW9uUGF1c2VTaWduYWwucGF1c2UgIT09IHRydWUpIHsKICAgICAgICAgIHN1YnNjcmliYWJsZS5ub3RpZnlTdWJzY3JpYmVycyh0aGlzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfTsKICAgIH0pOwogIH0KICBmdW5jdGlvbiBhZGRLbm9ja291dEFycmF5TXV0YXRvcnMoa28yLCBhcnJheUluc3RhbmNlLCBzdWJzY3JpYmFibGUsIG5vdGlmaWNhdGlvblBhdXNlU2lnbmFsKSB7CiAgICBbInJlbW92ZSIsICJyZW1vdmVBbGwiLCAiZGVzdHJveSIsICJkZXN0cm95QWxsIiwgInJlcGxhY2UiXS5mb3JFYWNoKGZ1bmN0aW9uKGZuTmFtZSkgewogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXlJbnN0YW5jZSwgZm5OYW1lLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIHJlc3VsdDsKICAgICAgICAgIG5vdGlmaWNhdGlvblBhdXNlU2lnbmFsLnBhdXNlID0gdHJ1ZTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJlc3VsdCA9IGtvMi5vYnNlcnZhYmxlQXJyYXkuZm5bZm5OYW1lXS5hcHBseShrbzIub2JzZXJ2YWJsZUFycmF5KGFycmF5SW5zdGFuY2UpLCBhcmd1bWVudHMpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgbm90aWZpY2F0aW9uUGF1c2VTaWduYWwucGF1c2UgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHN1YnNjcmliYWJsZS5ub3RpZnlTdWJzY3JpYmVycyhhcnJheUluc3RhbmNlKTsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0pOwogIH0KICBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlKG9iaiwgcHJvcGVydHlOYW1lKSB7CiAgICBpZiAoIW9iaikgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIHZhciBhbGxPYnNlcnZhYmxlc0Zvck9iamVjdCA9IGdldEFsbE9ic2VydmFibGVzRm9yT2JqZWN0KG9iaiwgZmFsc2UpOwogICAgcmV0dXJuIGFsbE9ic2VydmFibGVzRm9yT2JqZWN0ICYmIGFsbE9ic2VydmFibGVzRm9yT2JqZWN0W3Byb3BlcnR5TmFtZV0gfHwgbnVsbDsKICB9CiAgZnVuY3Rpb24gdmFsdWVIYXNNdXRhdGVkKG9iaiwgcHJvcGVydHlOYW1lKSB7CiAgICB2YXIgb2JzZXJ2YWJsZSA9IGdldE9ic2VydmFibGUob2JqLCBwcm9wZXJ0eU5hbWUpOwogICAgaWYgKG9ic2VydmFibGUpIHsKICAgICAgb2JzZXJ2YWJsZS52YWx1ZUhhc011dGF0ZWQoKTsKICAgIH0KICB9CiAgZnVuY3Rpb24gYXR0YWNoVG9LbyhrbzIpIHsKICAgIGtvMi50cmFjayA9IHRyYWNrOwogICAga28yLmdldE9ic2VydmFibGUgPSBnZXRPYnNlcnZhYmxlOwogICAga28yLnZhbHVlSGFzTXV0YXRlZCA9IHZhbHVlSGFzTXV0YXRlZDsKICAgIGtvMi5kZWZpbmVQcm9wZXJ0eSA9IGRlZmluZUNvbXB1dGVkUHJvcGVydHk7CiAgfQogIHZhciBrbm9ja291dF9lczVfZGVmYXVsdCA9IHsKICAgIGF0dGFjaFRvS28KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVnaXN0cnkubnBtbWlycm9yLmNvbStjZXNpdW1AMS45OS4wL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1dpZGdldHMvU3ZnUGF0aEJpbmRpbmdIYW5kbGVyLmpzCiAgdmFyIHN2Z05TID0gImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIjsKICB2YXIgc3ZnQ2xhc3NOYW1lID0gImNlc2l1bS1zdmdQYXRoLXN2ZyI7CiAgdmFyIFN2Z1BhdGhCaW5kaW5nSGFuZGxlciA9IHsKICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihrbm9ja291dDIpIHsKICAgICAga25vY2tvdXQyLmJpbmRpbmdIYW5kbGVycy5jZXNpdW1TdmdQYXRoID0gewogICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHsKICAgICAgICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgInN2ZzpzdmciKTsKICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgc3ZnQ2xhc3NOYW1lKTsKICAgICAgICAgIGNvbnN0IHBhdGhFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCAicGF0aCIpOwogICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHBhdGhFbGVtZW50KTsKICAgICAgICAgIGtub2Nrb3V0Mi52aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuKGVsZW1lbnQsIFtzdmddKTsKICAgICAgICAgIGtub2Nrb3V0Mi5jb21wdXRlZCh7CiAgICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ga25vY2tvdXQyLnVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpOwogICAgICAgICAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgiZCIsIGtub2Nrb3V0Mi51bndyYXAodmFsdWUucGF0aCkpOwogICAgICAgICAgICAgIGNvbnN0IHBhdGhXaWR0aCA9IGtub2Nrb3V0Mi51bndyYXAodmFsdWUud2lkdGgpOwogICAgICAgICAgICAgIGNvbnN0IHBhdGhIZWlnaHQgPSBrbm9ja291dDIudW53cmFwKHZhbHVlLmhlaWdodCk7CiAgICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgid2lkdGgiLCBwYXRoV2lkdGgpOwogICAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIHBhdGhIZWlnaHQpOwogICAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLCBgMCAwICR7cGF0aFdpZHRofSAke3BhdGhIZWlnaHR9YCk7CiAgICAgICAgICAgICAgaWYgKHZhbHVlLmNzcykgewogICAgICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgKICAgICAgICAgICAgICAgICAgImNsYXNzIiwKICAgICAgICAgICAgICAgICAgYCR7c3ZnQ2xhc3NOYW1lfSAke2tub2Nrb3V0Mi51bndyYXAodmFsdWUuY3NzKX1gCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgfTsKICAgICAga25vY2tvdXQyLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3MuY2VzaXVtU3ZnUGF0aCA9IHRydWU7CiAgICB9CiAgfTsKICB2YXIgU3ZnUGF0aEJpbmRpbmdIYW5kbGVyX2RlZmF1bHQgPSBTdmdQYXRoQmluZGluZ0hhbmRsZXI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWdpc3RyeS5ucG1taXJyb3IuY29tK2Nlc2l1bUAxLjk5LjAvbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvVGhpcmRQYXJ0eS9rbm9ja291dC5qcwogIGtub2Nrb3V0X2VzNV9kZWZhdWx0LmF0dGFjaFRvS28oa25vY2tvdXRfM181XzFfZGVmYXVsdCk7CiAgU3ZnUGF0aEJpbmRpbmdIYW5kbGVyX2RlZmF1bHQucmVnaXN0ZXIoa25vY2tvdXRfM181XzFfZGVmYXVsdCk7CgogIC8vIHBhY2thZ2VzL3V0aWxzL21hdGgudHMKICBmdW5jdGlvbiBjb21wdXRlVHJpYW5nbGVBcmVhKC4uLnBvc2l0aW9ucykgewogICAgY29uc3QgW3AxLCBwMiwgcDNdID0gcG9zaXRpb25zOwogICAgY29uc3QgYTMgPSBjb21wdXRlRGlzdGFuY2UoW3AxLCBwMl0pOwogICAgY29uc3QgYiA9IGNvbXB1dGVEaXN0YW5jZShbcDIsIHAzXSk7CiAgICBjb25zdCBjID0gY29tcHV0ZURpc3RhbmNlKFtwMywgcDFdKTsKICAgIGNvbnN0IHAgPSAoYTMgKyBiICsgYykgLyAyOwogICAgcmV0dXJuIE1hdGguc3FydChwICogKHAgLSBhMykgKiAocCAtIGIpICogKHAgLSBjKSk7CiAgfQogIGZ1bmN0aW9uIGdldENhcnRlc2lhbjNDZW50ZXIoLi4ucG9zaXRpb25zKSB7CiAgICBjb25zdCB7IHgsIHksIHogfSA9IHBvc2l0aW9ucy5yZWR1Y2UoKHIsIGMpID0+ICh7IHg6IHIueCArIGMueCwgeTogci55ICsgYy55LCB6OiByLnogKyBjLnogfSksIHsgeDogMCwgeTogMCwgejogMCB9KTsKICAgIHJldHVybiB7IHg6IHggLyBwb3NpdGlvbnMubGVuZ3RoLCB5OiB5IC8gcG9zaXRpb25zLmxlbmd0aCwgejogeiAvIHBvc2l0aW9ucy5sZW5ndGggfTsKICB9CiAgZnVuY3Rpb24gY29tcHV0ZURpc3RhbmNlKHBvc2l0aW9ucykgewogICAgbGV0IGRpc3RhbmNlID0gMDsKICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IHAxID0gcG9zaXRpb25zW2kgLSAxXTsKICAgICAgY29uc3QgcDIgPSBwb3NpdGlvbnNbaV07CiAgICAgIGRpc3RhbmNlICs9IE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikgKyBNYXRoLnBvdyhwMS56IC0gcDIueiwgMikpOwogICAgfQogICAgcmV0dXJuIGRpc3RhbmNlOwogIH0KCiAgLy8gcGFja2FnZXMvd29ya2Vycy90cmlhbmdsZS1zcGxpdC50cwogIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHsKICAgIHN3aXRjaCAoZS5kYXRhLnR5cGUpIHsKICAgICAgY2FzZSAic3RhcnQiOgogICAgICAgIGNvbnNvbGUubG9nKCJlLmRhdGEiLCBlLmRhdGEsIGNyZWF0ZVdvcmxkVGVycmFpbl9kZWZhdWx0KCkpOwogICAgICAgIF9zcGxpdChlLmRhdGEucG9zaXRpb25zLCBlLmRhdGEub3B0aW9ucykudGhlbigoYXJlYSkgPT4gewogICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiAic3VjY2VzcyIsIGRhdGE6IGFyZWEgfSk7CiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4gY29uc29sZS50cmFjZShlcnIpKTsKICAgICAgICBicmVhazsKICAgIH0KICB9OwogIGZ1bmN0aW9uIF9zcGxpdChfMCkgewogICAgcmV0dXJuIF9fYXN5bmModGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKHBvc2l0aW9ucywgb3B0aW9ucyA9IHsKICAgICAgbWF4VHJpYW5nbGVBcmVhOiAxMCwKICAgICAgdGVycmFpblByb3ZpZGVyOiB2b2lkIDAKICAgIH0pIHsKICAgICAgbGV0IHRvdGFsQXJlYSA9IDA7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYXJlYSA9IGNvbXB1dGVUcmlhbmdsZUFyZWEoLi4ucG9zaXRpb25zW2ldKTsKICAgICAgICBpZiAoYXJlYSA8PSBvcHRpb25zLm1heFRyaWFuZ2xlQXJlYSkgewogICAgICAgICAgdG90YWxBcmVhICs9IGFyZWE7CiAgICAgICAgICBwb3NpdGlvbnMuc3BsaWNlKGktLSwgMSk7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgcG9zaXRpb25zLnB1c2goLi4uX3NwbGl0VHJpYW5nbGUocG9zaXRpb25zW2ldKSk7CiAgICAgICAgcG9zaXRpb25zLnNwbGljZShpLS0sIDEpOwogICAgICB9CiAgICAgIHJldHVybiB0b3RhbEFyZWE7CiAgICB9KTsKICB9CiAgZnVuY3Rpb24gX3NwbGl0VHJpYW5nbGUocG9zaXRpb25zKSB7CiAgICBjb25zdCBzcGxpdENlbnRlciA9IGdldENhcnRlc2lhbjNDZW50ZXIocG9zaXRpb25zWzFdLCBwb3NpdGlvbnNbMl0pOwogICAgcmV0dXJuIFsKICAgICAgW3NwbGl0Q2VudGVyLCBwb3NpdGlvbnNbMV0sIHBvc2l0aW9uc1swXV0sCiAgICAgIFtzcGxpdENlbnRlciwgcG9zaXRpb25zWzJdLCBwb3NpdGlvbnNbMF1dCiAgICBdOwogIH0KfSkoKTsKLyohCiAqIEtub2Nrb3V0IEphdmFTY3JpcHQgbGlicmFyeSB2My41LjEKICogKGMpIFRoZSBLbm9ja291dC5qcyB0ZWFtIC0gaHR0cDovL2tub2Nrb3V0anMuY29tLwogKiBMaWNlbnNlOiBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKQogKi8KLyohCiAqIFVSSS5qcyAtIE11dGF0aW5nIFVSTHMKICoKICogVmVyc2lvbjogMS4xOS4xMQogKgogKiBBdXRob3I6IFJvZG5leSBSZWhtCiAqIFdlYjogaHR0cDovL21lZGlhbGl6ZS5naXRodWIuaW8vVVJJLmpzLwogKgogKiBMaWNlbnNlZCB1bmRlcgogKiAgIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UKICoKICovCi8qIQogKiBVUkkuanMgLSBNdXRhdGluZyBVUkxzCiAqIElQdjYgU3VwcG9ydAogKgogKiBWZXJzaW9uOiAxLjE5LjExCiAqCiAqIEF1dGhvcjogUm9kbmV5IFJlaG0KICogV2ViOiBodHRwOi8vbWVkaWFsaXplLmdpdGh1Yi5pby9VUkkuanMvCiAqCiAqIExpY2Vuc2VkIHVuZGVyCiAqICAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZQogKgogKi8KLyohCiAqIFVSSS5qcyAtIE11dGF0aW5nIFVSTHMKICogU2Vjb25kIExldmVsIERvbWFpbiAoU0xEKSBTdXBwb3J0CiAqCiAqIFZlcnNpb246IDEuMTkuMTEKICoKICogQXV0aG9yOiBSb2RuZXkgUmVobQogKiBXZWI6IGh0dHA6Ly9tZWRpYWxpemUuZ2l0aHViLmlvL1VSSS5qcy8KICoKICogTGljZW5zZWQgdW5kZXIKICogICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCiAqCiAqLwovKiEgQGxpY2Vuc2UgRE9NUHVyaWZ5IDIuNC4xIHwgKGMpIEN1cmU1MyBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBsaWNlbnNlIDIuMCBhbmQgTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjAgfCBnaXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi8yLjQuMS9MSUNFTlNFICovCi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovCi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4wIGJ5IEBtYXRoaWFzICovCi8qKgogKiBAbGljZW5zZQogKiBLbm9ja291dCBFUzUgcGx1Z2luIC0gaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0LWVzNQogKiBDb3B5cmlnaHQgKGMpIFN0ZXZlIFNhbmRlcnNvbgogKiBNSVQgbGljZW5zZQogKi8K";

// packages/utils/geometry-split.ts
function splitTriangle2(positions, options) {
  return __async(this, null, function* () {
    const db = new Dexie$1("tmp_measure");
    db.version(1).stores({ split_triangles: "++id" });
    const a3 = Cartesian3_default.ZERO;
    console.log(a3);
    return yield new Promise((resolve, reject) => {
      const worker = new Worker(triangle_split_default);
      worker.postMessage({ type: "start", positions: simpleSplitTriangle(positions), options });
      worker.onmessage = function(e) {
        console.log("primary process", e);
      };
    });
  });
}
function simpleSplitTriangle(positions) {
  const triangles = [];
  for (let i = 0; i <= positions.length - 3; i++) {
    triangles.push([positions[0], positions[i + 1], positions[i + 2]]);
  }
  return triangles;
}
function _splitTriangle(positions) {
  const splitCenter = getCartesian3Center(positions[1], positions[2]);
  return [
    [splitCenter, positions[1], positions[0]],
    [splitCenter, positions[2], positions[0]]
  ];
}
export {
  geometry_split_exports as GeometrySplit,
  polygon_exports as PolygonDraw,
  math_exports as Util,
  volume_exports as VolumeMeasure
};
/*!
 * Knockout JavaScript library v3.5.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
/*! https://mths.be/punycode v1.3.2 by @mathias */
/*! https://mths.be/punycode v1.4.0 by @mathias */
/**
 * @license
 * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5
 * Copyright (c) Steve Sanderson
 * MIT license
 */
